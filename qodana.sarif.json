{
  "$schema": "https://raw.githubusercontent.com/schemastore/schemastore/master/src/schemas/json/sarif-2.1.0-rtm.5.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "IC",
          "fullName": "Qodana",
          "version": "243.26053.27",
          "rules": [],
          "taxa": [
            {
              "id": "言語インジェクション",
              "name": "言語インジェクション"
            },
            {
              "id": "Maven",
              "name": "Maven"
            },
            {
              "id": "Kotlin",
              "name": "Kotlin"
            },
            {
              "id": "Kotlin/スタイルの問題",
              "name": "スタイルの問題",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 2,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JVM 言語",
              "name": "JVM 言語"
            },
            {
              "id": "Kotlin/冗長なコンストラクト",
              "name": "冗長なコンストラクト",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 2,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java",
              "name": "Java"
            },
            {
              "id": "Java/ポータビリティ",
              "name": "ポータビリティ",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/スレッド関連の問題",
              "name": "スレッド関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/国際化",
              "name": "国際化",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/パフォーマンス",
              "name": "パフォーマンス",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/コードスタイル問題",
              "name": "コードスタイル問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/クラス構造",
              "name": "クラス構造",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/潜在的なバグ",
              "name": "潜在的なバグ",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/エラー処理",
              "name": "エラー処理",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/宣言の冗長性",
              "name": "宣言の冗長性",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/移行",
              "name": "移行",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 2,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "シェルスクリプト",
              "name": "シェルスクリプト"
            },
            {
              "id": "パターン検証",
              "name": "パターン検証"
            },
            {
              "id": "Java/シリアライズ関連の問題",
              "name": "シリアライズ関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/パフォーマンス/組み込み",
              "name": "組み込み",
              "relationships": [
                {
                  "target": {
                    "id": "Java/パフォーマンス",
                    "index": 10,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy",
              "name": "Groovy"
            },
            {
              "id": "Groovy/GPath",
              "name": "GPath",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/インポート",
              "name": "インポート",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/データフロー",
              "name": "データフロー",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/潜在的なバグ",
              "name": "潜在的なバグ",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 2,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/継承関連の問題",
              "name": "継承関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/数値関連の問題",
              "name": "数値関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/制御フロー問題",
              "name": "制御フロー問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/初期化",
              "name": "初期化",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "HTML",
              "name": "HTML"
            },
            {
              "id": "Java/セキュリティ",
              "name": "セキュリティ",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "プロパティファイル",
              "name": "プロパティファイル"
            },
            {
              "id": "EditorConfig",
              "name": "EditorConfig"
            },
            {
              "id": "Java/JavaBeans 関連の問題",
              "name": "JavaBeans 関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/代入関連の問題",
              "name": "代入関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/命名規則",
              "name": "命名規則",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/パッケージ関連の問題",
              "name": "パッケージ関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/冗長または不要なコード構成",
              "name": "冗長または不要なコード構成",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/スレッド関連の問題",
              "name": "スレッド関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Gradle",
              "name": "Gradle"
            },
            {
              "id": "Gradle/潜在的なバグ",
              "name": "潜在的なバグ",
              "relationships": [
                {
                  "target": {
                    "id": "Gradle",
                    "index": 40,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/エラー処理",
              "name": "エラー処理",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "HTML/アクセシビリティ",
              "name": "アクセシビリティ",
              "relationships": [
                {
                  "target": {
                    "id": "HTML",
                    "index": 30,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "一般",
              "name": "一般"
            },
            {
              "id": "JVM 言語/ログ関連",
              "name": "ログ関連",
              "relationships": [
                {
                  "target": {
                    "id": "JVM 言語",
                    "index": 4,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Javadoc",
              "name": "Javadoc",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/リソース管理",
              "name": "リソース管理",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Gradle/妥当性の問題",
              "name": "妥当性の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Gradle",
                    "index": 40,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/命名規約",
              "name": "命名規約",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 2,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/コード成熟度",
              "name": "コード成熟度",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/命名規約",
              "name": "命名規約",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 言語レベルの移行支援",
              "name": "Java 言語レベルの移行支援",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 言語レベルの移行支援/Java 5",
              "name": "Java 5",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 言語レベルの移行支援",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/他の問題",
              "name": "他の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 2,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/潜在的なバグ",
              "name": "潜在的なバグ",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/可視性",
              "name": "可視性",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/カプセル化",
              "name": "カプセル化",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/並行処理に関するアノテーションの問題",
              "name": "並行処理に関するアノテーションの問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "YAML",
              "name": "YAML"
            },
            {
              "id": "Java/Java 言語レベルの移行支援/Java 8",
              "name": "Java 8",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 言語レベルの移行支援",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java の言語レベル関連の問題",
              "name": "Java の言語レベル関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "XML",
              "name": "XML"
            },
            {
              "id": "Java/ファイナライズ",
              "name": "ファイナライズ",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/代入関連の問題",
              "name": "代入関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/モジュール化関連の問題",
              "name": "モジュール化関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/Java 相互運用性の問題",
              "name": "Java 相互運用性の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 2,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/命名規則",
              "name": "命名規則",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/命名規則/クラス",
              "name": "クラス",
              "relationships": [
                {
                  "target": {
                    "id": "Java/命名規則",
                    "index": 67,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/制御フロー問題",
              "name": "制御フロー問題",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/メモリ",
              "name": "メモリ",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/混乱を招く可能性があるコード箇所",
              "name": "混乱を招く可能性があるコード箇所",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/TestNG",
              "name": "TestNG",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JUnit",
              "name": "JUnit"
            },
            {
              "id": "Java/抽象化関連の問題",
              "name": "抽象化関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 言語レベルの移行支援/Java 21",
              "name": "Java 21",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 言語レベルの移行支援",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 言語レベルの移行支援/Java 9",
              "name": "Java 9",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 言語レベルの移行支援",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/JUnit",
              "name": "JUnit",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/その他",
              "name": "その他",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/クローン関連の問題",
              "name": "クローン関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "正規表現",
              "name": "正規表現"
            },
            {
              "id": "Groovy/スタイル",
              "name": "スタイル",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaFX",
              "name": "JavaFX"
            },
            {
              "id": "Java/クラスメトリクス",
              "name": "クラスメトリクス",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/命名規則/メソッド",
              "name": "メソッド",
              "relationships": [
                {
                  "target": {
                    "id": "Java/命名規則",
                    "index": 67,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/コードの移行",
              "name": "コードの移行",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 2,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/依存関係の問題",
              "name": "依存関係の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/コンパイラー関連の問題",
              "name": "コンパイラー関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/注釈",
              "name": "注釈",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "校正",
              "name": "校正"
            },
            {
              "id": "マニフェスト",
              "name": "マニフェスト"
            },
            {
              "id": "Java/ログ関連",
              "name": "ログ関連",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Markdown",
              "name": "Markdown"
            },
            {
              "id": "JVM 言語/テストフレームワーク",
              "name": "テストフレームワーク",
              "relationships": [
                {
                  "target": {
                    "id": "JVM 言語",
                    "index": 4,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/メソッドメトリクス",
              "name": "メソッドメトリクス",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "セキュリティ",
              "name": "セキュリティ"
            },
            {
              "id": "Java/テストフレームワーク",
              "name": "テストフレームワーク",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/ビット演算関連の問題",
              "name": "ビット演算関連の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/リフレクションアクセス",
              "name": "リフレクションアクセス",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "コードカバレッジ",
              "name": "コードカバレッジ"
            },
            {
              "id": "Java/Java 言語レベルの移行支援/Java 15",
              "name": "Java 15",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 言語レベルの移行支援",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 言語レベルの移行支援/Java 14",
              "name": "Java 14",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 言語レベルの移行支援",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/妥当性の問題",
              "name": "妥当性の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/数値の問題",
              "name": "数値の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/数値の問題/キャスト",
              "name": "キャスト",
              "relationships": [
                {
                  "target": {
                    "id": "Java/数値の問題",
                    "index": 103,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 言語レベルの移行支援/Java 23",
              "name": "Java 23",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 言語レベルの移行支援",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JSON および JSON5",
              "name": "JSON および JSON5"
            },
            {
              "id": "Groovy/データフロー",
              "name": "データフロー",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/メソッドメトリクス",
              "name": "メソッドメトリクス",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin、移行",
              "name": "Kotlin、移行"
            },
            {
              "id": "Kotlin、移行/Maven",
              "name": "Maven",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin、移行",
                    "index": 109,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "国際化",
              "name": "国際化"
            },
            {
              "id": "Java/Java 言語レベルの移行支援/Java 10",
              "name": "Java 10",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 言語レベルの移行支援",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 言語レベルの移行支援/Java 16",
              "name": "Java 16",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 言語レベルの移行支援",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 言語レベルの移行支援/Java 7",
              "name": "Java 7",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 言語レベルの移行支援",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "TOML",
              "name": "TOML"
            },
            {
              "id": "バージョン管理",
              "name": "バージョン管理"
            },
            {
              "id": "Kotlin、移行/Gradle",
              "name": "Gradle",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin、移行",
                    "index": 109,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/プロパティファイル",
              "name": "プロパティファイル",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/潜在的なバグ/null 許容性の問題",
              "name": "null 許容性の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java/潜在的なバグ",
                    "index": 13,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/ログ関連",
              "name": "ログ関連",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 2,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "構造検索",
              "name": "構造検索"
            },
            {
              "id": "Gradle/スタイル",
              "name": "スタイル",
              "relationships": [
                {
                  "target": {
                    "id": "Gradle",
                    "index": 40,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/toString() の問題",
              "name": "toString() の問題",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 6,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "RELAX NG",
              "name": "RELAX NG"
            },
            {
              "id": "Java/Java 言語レベルの移行支援/Java 11",
              "name": "Java 11",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 言語レベルの移行支援",
                    "index": 52,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Qodana",
              "name": "Qodana"
            },
            {
              "id": "コードメトリクス",
              "name": "コードメトリクス"
            },
            {
              "id": "Kotlin/React",
              "name": "React",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 2,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kotlin/React/潜在的なバグ",
              "name": "潜在的なバグ",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin/React",
                    "index": 128,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Gradle/ベストプラクティス",
              "name": "ベストプラクティス",
              "relationships": [
                {
                  "target": {
                    "id": "Gradle",
                    "index": 40,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Declarative Gradle",
              "name": "Declarative Gradle"
            },
            {
              "id": "Kotlin/コルーチンのインスペクション",
              "name": "コルーチンのインスペクション",
              "relationships": [
                {
                  "target": {
                    "id": "Kotlin",
                    "index": 2,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Groovy/宣言の冗長性",
              "name": "宣言の冗長性",
              "relationships": [
                {
                  "target": {
                    "id": "Groovy",
                    "index": 21,
                    "toolComponent": {
                      "name": "IC"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        },
        "extensions": [
          {
            "name": "org.intellij.intelliLang",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "InjectionNotApplicable",
                "shortDescription": {
                  "text": "インジェクションアノテーションは適用できません"
                },
                "fullDescription": {
                  "text": "'@Language'アノテーションが 'String' または 'String[]' 以外の型の要素に適用されている場合に報告します。 例: '@Language(\"HTML\") int i;' クイックフィックス適用後: 'int i;'",
                  "markdown": "`@Language`アノテーションが `String` または `String[]` 以外の型の要素に適用されている場合に報告します。\n\n**例:**\n\n\n      @Language(\"HTML\") int i;\n\nクイックフィックス適用後:\n\n\n      int i;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "InjectionNotApplicable",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "言語インジェクション",
                      "index": 0,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternNotApplicable",
                "shortDescription": {
                  "text": "パターンアノテーションは適用できません"
                },
                "fullDescription": {
                  "text": "'@Pattern'アノテーションが 'String' 以外の型の要素に適用されている場合に報告します。 例: '@Pattern(\"\\\\d\\\\d\") int i;'",
                  "markdown": "`@Pattern`アノテーションが `String` 以外の型の要素に適用されている場合に報告します。\n\n**例:**\n\n\n      @Pattern(\"\\\\d\\\\d\") int i;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PatternNotApplicable",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "パターン検証",
                      "index": 18,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnknownLanguage",
                "shortDescription": {
                  "text": "不明な言語 ID"
                },
                "fullDescription": {
                  "text": "'@Language' アノテーションで使用されている言語の ID が不明な場合に報告します。 例: '@Language(\"HMTL\") String html;'",
                  "markdown": "`@Language` アノテーションで使用されている言語の ID が不明な場合に報告します。\n\n**例:**\n\n\n      @Language(\"HMTL\") String html;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "UnknownLanguage",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "言語インジェクション",
                      "index": 0,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternOverriddenByNonAnnotatedMethod",
                "shortDescription": {
                  "text": "注釈が付けられていないメソッドは @Pattern メソッドをオーバーライドします"
                },
                "fullDescription": {
                  "text": "'@Pattern' アノテーションのないメソッドが '@Pattern' アノテーションが付いたメソッドをオーバーライドしている場合に報告します。 このような場合にエディタ内でエラーがハイライトされなくなることはありませんが、オーバーライドしているメソッドは実行時にチェックされません。 スーパークラスメソッドのアノテーションと一致する '@Pattern' アノテーションを追加するクイックフィックスが提供されています。 このクイックフィックスは、ランタイムチェックのインストルメンテーションが正しく機能するようにします。 例: 'abstract class Parent {\n    abstract @Pattern(\"\\\\d\\\\d-\\\\d\\\\d\\\\d\") String getId();\n  }\n  class Child extends Parent {\n    @Override String getId() { // ここで警告が出ます\n      return \"12-345\";\n    }\n  }'",
                  "markdown": "`@Pattern` アノテーションのないメソッドが `@Pattern` アノテーションが付いたメソッドをオーバーライドしている場合に報告します。 このような場合にエディタ内でエラーがハイライトされなくなることはありませんが、オーバーライドしているメソッドは実行時にチェックされません。\n\n\nスーパークラスメソッドのアノテーションと一致する `@Pattern` アノテーションを追加するクイックフィックスが提供されています。 このクイックフィックスは、ランタイムチェックのインストルメンテーションが正しく機能するようにします。\n\n**例:**\n\n\n      abstract class Parent {\n        abstract @Pattern(\"\\\\d\\\\d-\\\\d\\\\d\\\\d\") String getId();\n      }\n      class Child extends Parent {\n        @Override String getId() { // ここで警告が出ます\n          return \"12-345\";\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PatternOverriddenByNonAnnotatedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "パターン検証",
                      "index": 18,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InjectedReferences",
                "shortDescription": {
                  "text": "注入された参照"
                },
                "fullDescription": {
                  "text": "言語インジェクションによって挿入された未解決の参照を報告します。 例: '@Language(\"file-reference\")\n    String fileName = \"/home/user/nonexistent.file\"; // ファイルが存在しない場合はハイライトされます'",
                  "markdown": "[言語インジェクション](https://www.jetbrains.com/help/idea/using-language-injections.html)によって挿入された未解決の参照を報告します。\n\n例:\n\n\n        @Language(\"file-reference\")\n        String fileName = \"/home/user/nonexistent.file\"; // ファイルが存在しない場合はハイライトされます\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "InjectedReferences",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "一般",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternValidation",
                "shortDescription": {
                  "text": "アノテーション付きパターンを検証"
                },
                "fullDescription": {
                  "text": "'@Pattern' パラメーターの引数として渡され、指定したパターンと一致していない '@Pattern' アノテーション付きのメソッドから返されている式を報告します。 例: '@Pattern(\"\\\\d\\\\d-\\\\d\\\\d\\\\d\") String getId() {\n    return \"1\";\n  }' インスペクションが不明な値を持つ式を報告し、置換 ('@Subst') アノテーションの追加を提案するようにするには、「非コンパイル時定数式にフラグを設定」オプションを使用します。",
                  "markdown": "`@Pattern` パラメーターの引数として渡され、指定したパターンと一致していない `@Pattern` アノテーション付きのメソッドから返されている式を報告します。\n\n**例:**\n\n\n      @Pattern(\"\\\\d\\\\d-\\\\d\\\\d\\\\d\") String getId() {\n        return \"1\";\n      }\n\n\nインスペクションが不明な値を持つ式を報告し、置換 (`@Subst`) アノテーションの追加を提案するようにするには、「**非コンパイル時定数式にフラグを設定**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PatternValidation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "パターン検証",
                      "index": 18,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LanguageMismatch",
                "shortDescription": {
                  "text": "言語の不一致"
                },
                "fullDescription": {
                  "text": "参照の言語が使用箇所で期待される言語と一致していない場合に報告します。 例: '@Language(\"JavaScript\")\n  String JS_CODE = \"var x;\";\n\n  @Language(\"XPath\")\n  String XPATH_CODE = JS_CODE; // ここで警告が表示されます'",
                  "markdown": "参照の言語が使用箇所で期待される言語と一致していない場合に報告します。\n\n例:\n\n\n      @Language(\"JavaScript\")\n      String JS_CODE = \"var x;\";\n\n      @Language(\"XPath\")\n      String XPATH_CODE = JS_CODE; // ここで警告が表示されます\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LanguageMismatch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "言語インジェクション",
                      "index": 0,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.idea.maven",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "MavenRedundantGroupId",
                "shortDescription": {
                  "text": "冗長なグループ ID"
                },
                "fullDescription": {
                  "text": "親 pom.xml ファイルで定義済みであるために不要である <groupId> の定義を報告します。",
                  "markdown": "親 pom.xml ファイルで定義済みであるために不要である \\<groupId\\> の定義を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MavenRedundantGroupId",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Maven",
                      "index": 1,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MavenDuplicatePluginInspection",
                "shortDescription": {
                  "text": "重複したプラグイン宣言"
                },
                "fullDescription": {
                  "text": "pom.xml でプラグイン宣言が重複していることを報告します。",
                  "markdown": "pom.xml でプラグイン宣言が重複していることを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MavenDuplicatePluginInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Maven",
                      "index": 1,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MavenPropertyInParent",
                "shortDescription": {
                  "text": "親記述内のプロパティの使用"
                },
                "fullDescription": {
                  "text": "モジュールの親定義でプロパティの使用が禁止されていることを報告します。",
                  "markdown": "モジュールの親定義でプロパティの使用が禁止されていることを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MavenPropertyInParent",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Maven",
                      "index": 1,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MavenDuplicateDependenciesInspection",
                "shortDescription": {
                  "text": "重複した依存関係"
                },
                "fullDescription": {
                  "text": "重複した依存関係を報告します。",
                  "markdown": "重複した依存関係を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MavenDuplicateDependenciesInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Maven",
                      "index": 1,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MavenModelInspection",
                "shortDescription": {
                  "text": "Maven モデルインスペクション"
                },
                "fullDescription": {
                  "text": "Maven モデルの解決に関する問題を報告します。",
                  "markdown": "Maven モデルの解決に関する問題を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MavenModelInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Maven",
                      "index": 1,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MavenParentMissedVersionInspection",
                "shortDescription": {
                  "text": "親バージョンがありません"
                },
                "fullDescription": {
                  "text": "コンシューマー POM 機能をサポートしないバージョンに親バージョン要素が欠落していることを報告します。",
                  "markdown": "コンシューマー POM 機能をサポートしないバージョンに親バージョン要素が欠落していることを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MavenParentMissedVersionInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Maven",
                      "index": 1,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.kotlin",
            "version": "243.26053.27-IJ",
            "rules": [
              {
                "id": "RedundantRunCatching",
                "shortDescription": {
                  "text": "冗長な 'runCatching' の呼び出し"
                },
                "fullDescription": {
                  "text": "'getOrThrow' が直後に続いている 'runCatching' の呼び出しを報告します。 このような呼び出しは、単純に 'run' に置換できます。 例: 'fun foo() = runCatching { doSomething() }.getOrThrow()' クイックフィックス適用後: 'fun foo() = run { doSomething() }'",
                  "markdown": "`getOrThrow` が直後に続いている `runCatching` の呼び出しを報告します。 このような呼び出しは、単純に `run` に置換できます。\n\n**例:**\n\n\n      fun foo() = runCatching { doSomething() }.getOrThrow()\n\nクイックフィックス適用後:\n\n\n      fun foo() = run { doSomething() }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantRunCatching",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimpleRedundantLet",
                "shortDescription": {
                  "text": "冗長なレシーバーベースの 'let' の呼び出し"
                },
                "fullDescription": {
                  "text": "冗長なレシーバーベースの 'let' 呼び出しを報告します。 クイックフィックスを使用すると、冗長な 'let' 呼び出しが除去されます。 例: 'fun test(s: String?): Int? = s?.let { it.length }' クイックフィックス適用後: 'fun test(s: String?): Int? = s?.length'",
                  "markdown": "冗長なレシーバーベースの `let` 呼び出しを報告します。\n\nクイックフィックスを使用すると、冗長な `let` 呼び出しが除去されます。\n\n**例:**\n\n\n      fun test(s: String?): Int? = s?.let { it.length }\n\nクイックフィックス適用後:\n\n\n      fun test(s: String?): Int? = s?.length\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimpleRedundantLet",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveSingleExpressionStringTemplate",
                "shortDescription": {
                  "text": "冗長な文字列テンプレート"
                },
                "fullDescription": {
                  "text": "式が 1 つしかない文字列テンプレートで、安全に除去できるものを報告します。 例: 'val x = \"Hello\"\n  val y = \"$x\"' クイックフィックス適用後: 'val x = \"Hello\"\n  val y = x // <== 更新後'",
                  "markdown": "式が 1 つしかない文字列テンプレートで、安全に除去できるものを報告します。\n\n**例:**\n\n      val x = \"Hello\"\n      val y = \"$x\"\n\nクイックフィックス適用後:\n\n      val x = \"Hello\"\n      val y = x // <== 更新後\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RemoveSingleExpressionStringTemplate",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonExhaustiveWhenStatementMigration",
                "shortDescription": {
                  "text": "一部の 'when' ステートメントは 1.7 以降禁止されます"
                },
                "fullDescription": {
                  "text": "1.7 以降ではコンパイルエラーを引き起こす網羅的ではない 'when' ステートメントを報告します。 動機のタイプ: 抑止/ブロックする必要がある問題がある/無意味な使用パターン (例: 直感的ではない動作) コードにエラーが発生しやすい 一貫性のないデザイン (コンテキストによって動作が異なる) 影響のタイプ: コンパイル。 コンパイルできていたコードがコンパイルできなくなる そのようなコードが例外が発生することなく動作した場合があった そのようなコードには警告なしでコンパイルできたものがあった 詳細: KT-47709: 列挙型、sealed、ブール値の主体を含む when ステートメントをデフォルトで網羅的にする クイックフィックスを使用すると、欠落している 'else -> {}' 分岐が追加されます。 例: 'sealed class Base {\n      class A : Base()\n      class B : Base()\n  }\n\n  fun test(base: Base) {\n      when (base) {\n          is Base.A -> \"\"\n      }\n  }' クイックフィックス適用後: 'sealed class Base {\n      class A : Base()\n      class B : Base()\n  }\n\n  fun test(base: Base) {\n      when (base) {\n          is Base.A -> \"\"\n          else -> {}\n      }\n  }' このインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.6 以上の場合にのみ報告します。",
                  "markdown": "1.7 以降ではコンパイルエラーを引き起こす網羅的ではない `when` ステートメントを報告します。\n\n動機のタイプ:\n\n* 抑止/ブロックする必要がある問題がある/無意味な使用パターン (例: 直感的ではない動作)\n  * コードにエラーが発生しやすい\n* 一貫性のないデザイン (コンテキストによって動作が異なる)\n\n影響のタイプ:\n\n* コンパイル。 コンパイルできていたコードがコンパイルできなくなる\n  * そのようなコードが例外が発生することなく動作した場合があった\n    * そのようなコードには警告なしでコンパイルできたものがあった\n\n**詳細:** [KT-47709: 列挙型、sealed、ブール値の主体を含む when ステートメントをデフォルトで網羅的にする](https://youtrack.jetbrains.com/issue/KT-47709)\n\nクイックフィックスを使用すると、欠落している `else -> {}` 分岐が追加されます。\n\n**例:**\n\n\n      sealed class Base {\n          class A : Base()\n          class B : Base()\n      }\n\n      fun test(base: Base) {\n          when (base) {\n              is Base.A -> \"\"\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      sealed class Base {\n          class A : Base()\n          class B : Base()\n      }\n\n      fun test(base: Base) {\n          when (base) {\n              is Base.A -> \"\"\n              else -> {}\n          }\n      }\n\nこのインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.6 以上の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonExhaustiveWhenStatementMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertLambdaToReference",
                "shortDescription": {
                  "text": "関数参照に置換できます"
                },
                "fullDescription": {
                  "text": "関数リテラル式で、関数参照に置換できるものを報告します。 ラムダを関数参照に置換すると、多くの場合はコードが簡潔になり、理解しやすくなります。 例: 'fun Int.isEven() = this % 2 == 0\n\n  fun example() {\n      val numbers = listOf(1, 2, 4, 7, 9, 10)\n      val evenNumbers = numbers.filter { it.isEven() }\n  }' クイックフィックス適用後: 'fun Int.isEven() = this % 2 == 0\n\n  fun example() {\n      val numbers = listOf(1, 2, 4, 7, 9, 10)\n      val evenNumbers = numbers.filter(Int::isEven)\n  }'",
                  "markdown": "関数リテラル式で、関数参照に置換できるものを報告します。\n\nラムダを関数参照に置換すると、多くの場合はコードが簡潔になり、理解しやすくなります。\n\n**例:**\n\n\n      fun Int.isEven() = this % 2 == 0\n\n      fun example() {\n          val numbers = listOf(1, 2, 4, 7, 9, 10)\n          val evenNumbers = numbers.filter { it.isEven() }\n      }\n\nクイックフィックス適用後:\n\n\n      fun Int.isEven() = this % 2 == 0\n\n      fun example() {\n          val numbers = listOf(1, 2, 4, 7, 9, 10)\n          val evenNumbers = numbers.filter(Int::isEven)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertLambdaToReference",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantSetter",
                "shortDescription": {
                  "text": "冗長なプロパティ setter"
                },
                "fullDescription": {
                  "text": "冗長なプロパティの setter を報告します。 以下のいずれかに該当する場合、setter は冗長とみなされます。 setter に本体がない。 アクセサーの可視性が変更されていない、宣言が 'external' でない、およびアノテーションがない。 'var myPropWithRedundantSetter: Int = 0\n      set // 冗長\n  var myPropA: Int = 0\n      private set // OK - プロパティの可視性が private に変更されている\n\n  var myPropB: Int = 0\n      external set // OK - Kotlin で実装されていない (external)\n\n  var myPropC: Int = 0\n      @Inject set // OK - アクセサーにアノテーションが付いている' setter の本体が、バッキングフィールドにパラメーターを代入するステートメントを 1 つだけ持つブロックになっている。 'var prop: Int = 0\n      set(value) { // 冗長\n          field = value\n      }'",
                  "markdown": "冗長なプロパティの setter を報告します。\n\n\n以下のいずれかに該当する場合、setter は冗長とみなされます。\n\n1. setter に本体がない。 アクセサーの可視性が変更されていない、宣言が `external` でない、およびアノテーションがない。\n\n\n         var myPropWithRedundantSetter: Int = 0\n             set // 冗長\n         var myPropA: Int = 0\n             private set // OK - プロパティの可視性が private に変更されている\n\n         var myPropB: Int = 0\n             external set // OK - Kotlin で実装されていない (external)\n\n         var myPropC: Int = 0\n             @Inject set // OK - アクセサーにアノテーションが付いている\n               \n2. setter の本体が、バッキングフィールドにパラメーターを代入するステートメントを 1 つだけ持つブロックになっている。\n\n\n         var prop: Int = 0\n             set(value) { // 冗長\n                 field = value\n             }\n              \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantSetter",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncompleteDestructuring",
                "shortDescription": {
                  "text": "不完全な分解宣言"
                },
                "fullDescription": {
                  "text": "不完全な分解宣言を報告します。 例: 'data class Person(val name: String, val age: Int)\n  val person = Person(\"\", 0)\n  val (name) = person' クイックフィックスを使用すると、新しい変数を使用して分解宣言が補完されます。 'data class Person(val name: String, val age: Int)\n  val person = Person(\"\", 0)\n  val (name, age) = person'",
                  "markdown": "不完全な分解宣言を報告します。\n\n**例:**\n\n\n      data class Person(val name: String, val age: Int)\n      val person = Person(\"\", 0)\n      val (name) = person\n\nクイックフィックスを使用すると、新しい変数を使用して分解宣言が補完されます。\n\n\n      data class Person(val name: String, val age: Int)\n      val person = Person(\"\", 0)\n      val (name, age) = person\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IncompleteDestructuring",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ScopeFunctionConversion",
                "shortDescription": {
                  "text": "スコープ関数は別の関数に変換できます"
                },
                "fullDescription": {
                  "text": "相互に変換できるスコープ関数 ('let'、'run'、'apply'、'also') を報告します。 対応する関数を使用すると、コードを単純化できます。 クイックフィックスを使用すると、スコープ関数が別の関数に置換されます。 例: 'val x = \"\".let {\n      it.length\n  }' クイックフィックス適用後: 'val x = \"\".run {\n      length\n  }'",
                  "markdown": "相互に変換できるスコープ関数 (`let`、`run`、`apply`、`also`) を報告します。\n\n対応する関数を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、スコープ関数が別の関数に置換されます。\n\n**例:**\n\n\n      val x = \"\".let {\n          it.length\n      }\n\nクイックフィックス適用後:\n\n\n      val x = \"\".run {\n          length\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ScopeFunctionConversion",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrailingComma",
                "shortDescription": {
                  "text": "末尾のコンマを推奨"
                },
                "fullDescription": {
                  "text": "推奨されるスタイルガイドに従っていない末尾のカンマを報告します。",
                  "markdown": "推奨される[スタイルガイド](https://kotlinlang.org/docs/coding-conventions.html#trailing-commas)に従っていない末尾のカンマを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TrailingComma",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FoldInitializerAndIfToElvis",
                "shortDescription": {
                  "text": "'?:' に折りたたみ可能な If-Null return/break/..."
                },
                "fullDescription": {
                  "text": "イニシャライザー内で初期化直後の変数に対して null チェックを行っている 'if' 式で、エルビス演算子に変換できるものを報告します。 例: 'fun test(foo: Int?, bar: Int): Int {\n      var i = foo\n      if (i == null) {\n          return bar\n      }\n      return i\n  }' クイックフィックスを使用すると、イニシャライザーの 'if' 式がエルビス式に変換されます。 'fun test(foo: Int?, bar: Int): Int {\n      var i = foo ?: return bar\n      return i\n  }'",
                  "markdown": "イニシャライザー内で初期化直後の変数に対して null チェックを行っている `if` 式で、エルビス演算子に変換できるものを報告します。\n\n**例:**\n\n\n      fun test(foo: Int?, bar: Int): Int {\n          var i = foo\n          if (i == null) {\n              return bar\n          }\n          return i\n      }\n\nクイックフィックスを使用すると、イニシャライザーの `if` 式がエルビス式に変換されます。\n\n\n      fun test(foo: Int?, bar: Int): Int {\n          var i = foo ?: return bar\n          return i\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FoldInitializerAndIfToElvis",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CanSealedSubClassBeObject",
                "shortDescription": {
                  "text": "状態とオーバーライドされた equals がない sealed サブクラス"
                },
                "fullDescription": {
                  "text": "'sealed' クラスの直接継承で、状態もオーバーライドされた 'equals()' メソッドもないものを報告します。 'equals()' をオーバーライドして比較を安定させるか、'class' を 'object' に変換して同じ効果を得ることが強く推奨されています。 例: 'sealed class Receiver {\n      class Everyone : Receiver()\n      class User(val id: Int) : Receiver()\n  }' クイックフィックスを使用すると、'class' が 'object' に変換されます。 'sealed class Receiver {\n      object Everyone : Receiver()\n      class User(val id: Int) : Receiver()\n  }'",
                  "markdown": "`sealed` クラスの直接継承で、状態もオーバーライドされた `equals()` メソッドもないものを報告します。\n\n`equals()` をオーバーライドして比較を安定させるか、`class` を `object` に変換して同じ効果を得ることが強く推奨されています。\n\n**例:**\n\n\n      sealed class Receiver {\n          class Everyone : Receiver()\n          class User(val id: Int) : Receiver()\n      }\n\nクイックフィックスを使用すると、`class` が `object` に変換されます。\n\n\n      sealed class Receiver {\n          object Everyone : Receiver()\n          class User(val id: Int) : Receiver()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CanSealedSubClassBeObject",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PropertyName",
                "shortDescription": {
                  "text": "プロパティの命名規則"
                },
                "fullDescription": {
                  "text": "推奨されている命名規則に従っていないプロパティ名を報告します。 命名方法に一貫性を持たせると、コードが読みやすく、理解しやすくなります。 Kotlin 公式スタイルガイドによると、プロパティ名には小文字で始まるキャメルケースを使用する必要があります。 正規表現の \"パターン\" を変更することで、他の命名規則を導入できます。 例: 'val My_Cool_Property = \"\"' クイックフィックスを使用すると、クラス名が Kotlin の命名規則に従って変更されます。 'val myCoolProperty = \"\"'",
                  "markdown": "推奨されている命名規則に従っていないプロパティ名を報告します。\n\n\n命名方法に一貫性を持たせると、コードが読みやすく、理解しやすくなります。\n[Kotlin 公式スタイルガイド](https://kotlinlang.org/docs/coding-conventions.html#naming-rules)によると、プロパティ名には小文字で始まるキャメルケースを使用する必要があります。\n\n正規表現の \"パターン\" を変更することで、他の命名規則を導入できます。\n\n**例:**\n\n\n      val My_Cool_Property = \"\"\n\nクイックフィックスを使用すると、クラス名が Kotlin の命名規則に従って変更されます。\n\n\n      val myCoolProperty = \"\"\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PropertyName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名規約",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InlineClassDeprecatedMigration",
                "shortDescription": {
                  "text": "1.5 以降はインラインクラスは非推奨です"
                },
                "fullDescription": {
                  "text": "Kotlin 1.5 以降ではコンパイラーの警告を引き起こす非推奨のインラインクラスを報告します。 Kotlin 1.5.0 の新機能を参照してください 例: 'inline class Password(val s: String)' クイックフィックス適用後: '@JvmInline\n  value class Password(val s: String)' このインスペクションは Kotlin の言語レベルが 1.5 以降の場合に使用できます。",
                  "markdown": "Kotlin 1.5 以降ではコンパイラーの警告を引き起こす非推奨のインラインクラスを報告します。\n[Kotlin 1.5.0 の新機能](https://kotlinlang.org/docs/whatsnew15.html#inline-classes)を参照してください\n\n例:\n\n\n      inline class Password(val s: String)\n\nクイックフィックス適用後:\n\n\n      @JvmInline\n      value class Password(val s: String)\n\nこのインスペクションは Kotlin の言語レベルが 1.5 以降の場合に使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InlineClassDeprecatedMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinMavenPluginPhase",
                "shortDescription": {
                  "text": "Kotlin Maven Plugin の構成が不正です"
                },
                "fullDescription": {
                  "text": "kotlin-maven プラグインの構成に関する問題を報告します",
                  "markdown": "kotlin-maven プラグインの構成に関する問題を報告します"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KotlinMavenPluginPhase",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AmbiguousNonLocalJump",
                "shortDescription": {
                  "text": "あいまいな非ローカル 'break' または 'continue'"
                },
                "fullDescription": {
                  "text": "ループのような関数のラムダ式内にある 'break' または 'continue' の使用箇所を報告します。 'break' および 'continue' キーワードは常に実際のループ ('for'、'while'、'do-while') に適用されます。 'break' および 'continue' が関数に適用されることはありません。たとえば、'break' および 'continue' は 'forEach'、'filter'、'map' に適用されません。 ループのような関数 (例: 'forEach') 内で 'break' または 'continue' を使用すると分かりにくくなる場合があります。 このインスペクションはラベルを追加し、どのステートメントに 'break' または 'continue' が適用されるのかを明確にすることを提案します。 Kotlin にはループのような関数の概念がないため、このインスペクションはヒューリスティックを使用します。 'callsInPlace(EXACTLY_ONCE)' または 'callsInPlace(AT_LEAST_ONCE)' のいずれかの契約をもたない関数はループのような関数であると見なされます。 例: 'for (file in files) {\n        file.readLines().forEach { line ->\n            if (line == commentMarkerLine) continue\n            println(line)\n        }\n    }' クイックフィックスを使用すると、明確にするラベルが追加されます。 'loop@ for (file in files) {\n        file.readLines().forEach { line ->\n            if (line == commentMarkerLine) continue@loop\n            println(line)\n        }\n    }'",
                  "markdown": "ループのような関数のラムダ式内にある `break` または `continue` の使用箇所を報告します。\n\n\n`break` および `continue` キーワードは常に実際のループ (`for`、`while`、`do-while`) に適用されます。 `break` および `continue` が関数に適用されることはありません。たとえば、`break` および `continue` は `forEach`、`filter`、`map` に適用されません。\n\n\nループのような関数 (例: `forEach`) 内で `break` または `continue` を使用すると分かりにくくなる場合があります。\nこのインスペクションはラベルを追加し、どのステートメントに `break` または `continue` が適用されるのかを明確にすることを提案します。\n\n\nKotlin にはループのような関数の概念がないため、このインスペクションはヒューリスティックを使用します。 `callsInPlace(EXACTLY_ONCE)` または `callsInPlace(AT_LEAST_ONCE)` のいずれかの契約をもたない関数はループのような関数であると見なされます。\n\n**例:**\n\n\n        for (file in files) {\n            file.readLines().forEach { line ->\n                if (line == commentMarkerLine) continue\n                println(line)\n            }\n        }\n\nクイックフィックスを使用すると、明確にするラベルが追加されます。\n\n\n        loop@ for (file in files) {\n            file.readLines().forEach { line ->\n                if (line == commentMarkerLine) continue@loop\n                println(line)\n            }\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AmbiguousNonLocalJump",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceWithStringBuilderAppendRange",
                "shortDescription": {
                  "text": "JVM での 'StringBuilder.append(CharArray, offset, len)' の呼び出し"
                },
                "fullDescription": {
                  "text": "JVM プラットフォームでの 'StringBuilder.append(CharArray, offset, len)' 関数呼び出しのうち、'StringBuilder.appendRange(CharArray, startIndex, endIndex)' 関数呼び出しに置換すべきものを報告します。 'append' 関数は JVM、JS、および Native プラットフォームで動作が異なるため、'appendRange' 関数の使用をお勧めします。 例: 'fun f(charArray: CharArray, offset: Int, len: Int): String {\n      return buildString {\n          append(charArray, offset, len)\n      }\n  }' クイックフィックス適用後: 'fun f(charArray: CharArray, offset: Int, len: Int): String {\n      return buildString {\n          appendRange(charArray, offset, offset + len)\n      }\n  }'",
                  "markdown": "JVM プラットフォームでの `StringBuilder.append(CharArray, offset, len)` 関数呼び出しのうち、`StringBuilder.appendRange(CharArray, startIndex, endIndex)` 関数呼び出しに置換すべきものを報告します。\n\n`append` 関数は JVM、JS、および Native プラットフォームで動作が異なるため、`appendRange` 関数の使用をお勧めします。\n\n**例:**\n\n\n      fun f(charArray: CharArray, offset: Int, len: Int): String {\n          return buildString {\n              append(charArray, offset, len)\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun f(charArray: CharArray, offset: Int, len: Int): String {\n          return buildString {\n              appendRange(charArray, offset, offset + len)\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceWithStringBuilderAppendRange",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/他の問題",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertToStringTemplate",
                "shortDescription": {
                  "text": "文字列テンプレートに変換できる文字列連結"
                },
                "fullDescription": {
                  "text": "文字列テンプレートに変換できる文字列連結を報告します。 文字列テンプレートを使用することは推奨されています。以下のようにコードが読みやすくなるためです。 例: 'fun example() {\n      val capitals = mapOf(\"France\" to \"Paris\", \"Spain\" to \"Madrid\")\n      for ((country, capital) in capitals) {\n          print(capital + \" is a capital of \" + country)\n      }\n  }' クイックフィックス適用後: 'fun example() {\n      val capitals = mapOf(\"France\" to \"Paris\", \"Spain\" to \"Madrid\")\n      for ((country, capital) in capitals) {\n          print(\"$capital is a capital of $country\")\n      }\n  }'",
                  "markdown": "文字列テンプレートに変換できる文字列連結を報告します。\n\n文字列テンプレートを使用することは推奨されています。以下のようにコードが読みやすくなるためです。\n\n**例:**\n\n\n      fun example() {\n          val capitals = mapOf(\"France\" to \"Paris\", \"Spain\" to \"Madrid\")\n          for ((country, capital) in capitals) {\n              print(capital + \" is a capital of \" + country)\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun example() {\n          val capitals = mapOf(\"France\" to \"Paris\", \"Spain\" to \"Madrid\")\n          for ((country, capital) in capitals) {\n              print(\"$capital is a capital of $country\")\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertToStringTemplate",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinInvalidBundleOrProperty",
                "shortDescription": {
                  "text": "無効なプロパティキー"
                },
                "fullDescription": {
                  "text": "Kotlin ファイル内に '.properties' ファイルのキーとリソースバンドルへの未解決の参照があることを報告します。",
                  "markdown": "Kotlin ファイル内に `.properties` ファイルのキーとリソースバンドルへの未解決の参照があることを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "InvalidBundleOrProperty",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UselessCallOnCollection",
                "shortDescription": {
                  "text": "コレクション型での不要な呼び出し"
                },
                "fullDescription": {
                  "text": "すでにフィルターされているコレクションに対して標準ライブラリの 'filter...' が呼び出されていることを報告します。 'filterNotNull()' や 'filterIsInstance' のようないくつかの標準ライブラリ関数は、結果の型とは異なる型のレシーバーに対して呼び出された場合にのみ意味を持ちます。 それ以外の場合は同じ結果になるため、このような呼び出しは省略できます。 「冗長な呼び出しの除去」クイックフィックスを使用すると、コードを自動的に修正できます。 例: 'fun test(list: List<String>) {\n      val x = list.filterNotNull() // クイックフィックスで 'list' に単純化できます\n      val y = list.filterIsInstance<String>() // クイックフィックスで 'list' に単純化できます\n  }'",
                  "markdown": "すでにフィルターされているコレクションに対して標準ライブラリの `filter...` が呼び出されていることを報告します。\n\n`filterNotNull()` や `filterIsInstance` のようないくつかの標準ライブラリ関数は、結果の型とは異なる型のレシーバーに対して呼び出された場合にのみ意味を持ちます。 それ以外の場合は同じ結果になるため、このような呼び出しは省略できます。\n\n「**冗長な呼び出しの除去**」クイックフィックスを使用すると、コードを自動的に修正できます。\n\n例:\n\n\n      fun test(list: List<String>) {\n          val x = list.filterNotNull() // クイックフィックスで 'list' に単純化できます\n          val y = list.filterIsInstance<String>() // クイックフィックスで 'list' に単純化できます\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UselessCallOnCollection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableCall",
                "shortDescription": {
                  "text": "ライブラリ関数の呼び出しは単純化できます"
                },
                "fullDescription": {
                  "text": "より単純な呼び出しに置換できるライブラリ関数の呼び出しを報告します。 対応する関数を使用すると、コードを単純化できます。 クイックフィックスを使用すると、このような関数呼び出しが別の関数呼び出しに置換されます。 例: 'fun test(list: List<Any>) {\n      list.filter { it is String }\n  }' クイックフィックス適用後: 'fun test(list: List<Any>) {\n      list.filterIsInstance<String>()\n  }'",
                  "markdown": "より単純な呼び出しに置換できるライブラリ関数の呼び出しを報告します。\n\n対応する関数を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、このような関数呼び出しが別の関数呼び出しに置換されます。\n\n**例:**\n\n\n      fun test(list: List<Any>) {\n          list.filter { it is String }\n      }\n\nクイックフィックス適用後:\n\n\n      fun test(list: List<Any>) {\n          list.filterIsInstance<String>()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifiableCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectLiteralToLambda",
                "shortDescription": {
                  "text": "オブジェクトリテラルはラムダに変換できます"
                },
                "fullDescription": {
                  "text": "単一の abstract メソッドを持つ Java インターフェースを実装している匿名のオブジェクトリテラルで、ラムダ式での呼び出しに変換できるものを報告します。 例: 'class SomeService {\n  val threadPool = Executors.newCachedThreadPool()\n    \n  fun foo() {\n    threadPool.submit(object : Runnable {\n      override fun run() {\n        println(\"hello\")\n      }\n    })\n  }\n}' クイックフィックス適用後: 'fun foo() {\n    threadPool.submit { println(\"hello\") }\n  }'",
                  "markdown": "単一の abstract メソッドを持つ Java インターフェースを実装している匿名のオブジェクトリテラルで、ラムダ式での呼び出しに変換できるものを報告します。\n\n**例:**\n\n\n    class SomeService {\n      val threadPool = Executors.newCachedThreadPool()\n        \n      fun foo() {\n        threadPool.submit(object : Runnable {\n          override fun run() {\n            println(\"hello\")\n          }\n        })\n      }\n    }\n\nクイックフィックス適用後:\n\n\n      fun foo() {\n        threadPool.submit { println(\"hello\") }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectLiteralToLambda",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLambdaOrAnonymousFunction",
                "shortDescription": {
                  "text": "冗長なラムダまたは匿名関数の作成"
                },
                "fullDescription": {
                  "text": "作成されると同時に使用されるラムダまたは匿名関数を報告します。 'fun test() {\n      ({ println() })() // 冗長\n      (fun() { println() })() // 冗長\n  }'",
                  "markdown": "作成されると同時に使用されるラムダまたは匿名関数を報告します。\n\n\n      fun test() {\n          ({ println() })() // 冗長\n          (fun() { println() })() // 冗長\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantLambdaOrAnonymousFunction",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantRequireNotNullCall",
                "shortDescription": {
                  "text": "冗長な 'requireNotNull' または 'checkNotNull' の呼び出し"
                },
                "fullDescription": {
                  "text": "非 nullable の式に対する不要な 'requireNotNull' または 'checkNotNull' の呼び出しを報告します。 例: 'fun foo(i: Int) {\n      requireNotNull(i) // この 'i' は常に非 null であるため、この 'requireNotNull' の呼び出しは冗長です。\n      ...\n  }' クイックフィックス適用後: 'fun foo(i: Int) {\n      ...\n  }'",
                  "markdown": "非 nullable の式に対する不要な `requireNotNull` または `checkNotNull` の呼び出しを報告します。\n\n**例:**\n\n\n      fun foo(i: Int) {\n          requireNotNull(i) // この 'i' は常に非 null であるため、この 'requireNotNull' の呼び出しは冗長です。\n          ...\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(i: Int) {\n          ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantRequireNotNullCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectPropertyName",
                "shortDescription": {
                  "text": "object プロパティの命名規則"
                },
                "fullDescription": {
                  "text": "命名規則に従っていないプロパティを報告します。 以下のプロパティが報告されます。 トップレベルプロパティ オブジェクトおよびコンパニオンオブジェクトのプロパティ 必要なパターンは、インスペクションのオプションで指定できます。 推奨される命名規則: 大文字で始まるキャメルケースを使用する。アンダースコアは使用しない。 例: '// トップレベルプロパティ\n  val USER_NAME_FIELD = \"UserName\"\n  // シングルトンオブジェクトの参照を保持しているトップレベルプロパティ\n  val PersonComparator: Comparator<Person> = /*...*/\n\n  class Person {\n    companion object {\n      // コンパニオンオブジェクトのプロパティ\n      val NO_NAME = Person()\n    }\n  }'",
                  "markdown": "命名規則に従っていないプロパティを報告します。\n\n以下のプロパティが報告されます。\n\n* トップレベルプロパティ\n* オブジェクトおよびコンパニオンオブジェクトのプロパティ\n\n必要なパターンは、インスペクションのオプションで指定できます。\n\n[推奨される命名規則](https://kotlinlang.org/docs/coding-conventions.html#naming-rules): 大文字で始まるキャメルケースを使用する。アンダースコアは使用しない。\n\n**例:**\n\n\n      // トップレベルプロパティ\n      val USER_NAME_FIELD = \"UserName\"\n      // シングルトンオブジェクトの参照を保持しているトップレベルプロパティ\n      val PersonComparator: Comparator<Person> = /*...*/\n\n      class Person {\n        companion object {\n          // コンパニオンオブジェクトのプロパティ\n          val NO_NAME = Person()\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectPropertyName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名規約",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageDirectoryMismatch",
                "shortDescription": {
                  "text": "パッケージ名がそれを含むディレクトリと一致しません"
                },
                "fullDescription": {
                  "text": "ファイルの場所と一致していない 'package' ディレクティブを報告します。 修正を適用すると、「移動リファクタリング」のデフォルトが変更された宣言の使用箇所を更新するために使用されます。具体的には以下のとおりです。 \"コメントと文字列内を検索\" \"テキスト出現箇所の検索\"",
                  "markdown": "ファイルの場所と一致していない `package` ディレクティブを報告します。\n\n\n修正を適用すると、「移動リファクタリング」のデフォルトが変更された宣言の使用箇所を更新するために使用されます。具体的には以下のとおりです。\n\n* \"コメントと文字列内を検索\"\n* \"テキスト出現箇所の検索\""
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PackageDirectoryMismatch",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 相互運用性の問題",
                      "index": 66,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertObjectToDataObject",
                "shortDescription": {
                  "text": "'object' を 'data object' に変換"
                },
                "fullDescription": {
                  "text": "'data object' に変換できる 'object' を報告します 'data object' は 'toString'、'equals' および 'hashCode' を自動生成します このインスペクションは次の 2 つの場合に 'object' を 'data object' に変換するよう提案します。 カスタムの 'toString' がクラスの名前を返している場合 'object' が sealed 'class'/'interface' を継承している場合 例: 'object Foo {\n        override fun toString(): String = \"Foo\"\n    }' クイックフィックス適用後: 'data object Foo' このインスペクションはプロジェクトまたはモジュールの Kotlin 言語レベルが 1.9 以降の場合にのみ報告します",
                  "markdown": "`data object` に変換できる `object` を報告します\n\n`data object` は `toString`、`equals` および `hashCode` を自動生成します\n\nこのインスペクションは次の 2 つの場合に `object` を `data object` に変換するよう提案します。\n\n* カスタムの `toString` がクラスの名前を返している場合\n* `object` が sealed `class`/`interface` を継承している場合\n\n**例:**\n\n\n        object Foo {\n            override fun toString(): String = \"Foo\"\n        }\n\nクイックフィックス適用後:\n\n\n        data object Foo\n\nこのインスペクションはプロジェクトまたはモジュールの Kotlin 言語レベルが 1.9 以降の場合にのみ報告します"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertObjectToDataObject",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanLiteralArgument",
                "shortDescription": {
                  "text": "パラメーター名のないブールリテラル引数"
                },
                "fullDescription": {
                  "text": "引数に 'Boolean' 型が使用されており、明示的なパラメーター名が指定されていない呼び出しを報告します。 複数のブールリテラルが連続で渡されている場合はパラメーターの順序を忘れやすくなり、ミスを犯す可能性があります。 明示的なパラメーター名を使うと、読みやすく、理解しやすいコードを記述できます。 例: 'fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}\n\n  fun usage() {\n      check(true, false, true) // 意味が分かりにくい\n  }' クイックフィックスを使用すると、欠落しているパラメーター名が追加されます。 'fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}\n\n  fun usage() {\n      check(checkName = true, checkAddress = false, checkPhone = true)\n  }'",
                  "markdown": "引数に `Boolean` 型が使用されており、明示的なパラメーター名が指定されていない呼び出しを報告します。\n\n\n複数のブールリテラルが連続で渡されている場合はパラメーターの順序を忘れやすくなり、ミスを犯す可能性があります。\n明示的なパラメーター名を使うと、読みやすく、理解しやすいコードを記述できます。\n\n**例:**\n\n\n      fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}\n\n      fun usage() {\n          check(true, false, true) // 意味が分かりにくい\n      }\n\nクイックフィックスを使用すると、欠落しているパラメーター名が追加されます。\n\n\n      fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}\n\n      fun usage() {\n          check(checkName = true, checkAddress = false, checkPhone = true)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "BooleanLiteralArgument",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertArgumentToSet",
                "shortDescription": {
                  "text": "'Set' に変換してパフォーマンスを改善可能な引数"
                },
                "fullDescription": {
                  "text": "引数を 'Set' に変換すると動作が高速化する可能性がある関数呼び出しを検出します。 'minus' や 'intersect' のような演算は、引数をセットにしたほうが効率が良くなります。 'Iterable<T>' または 'Array<T>' を 'Set<T>' に明示的に変換すると、多くの場合はコードの効率が良くなる可能性があります。 クイックフィックスを使用すると、関数呼び出しに明示的な変換が追加されます。 例: 'fun <T> f(a: Iterable<T>, b: Iterable<T>): Int =\n      a.intersect(b).size' クイックフィックス適用後: 'fun <T> f(a: Iterable<T>, b: Iterable<T>): Int =\n      a.intersect(b.toSet()).size'",
                  "markdown": "引数を `Set` に変換すると動作が高速化する可能性がある関数呼び出しを検出します。\n\n\n'minus' や 'intersect' のような演算は、引数をセットにしたほうが効率が良くなります。\n`Iterable<T>` または `Array<T>` を `Set<T>` に明示的に変換すると、多くの場合はコードの効率が良くなる可能性があります。\n\n\nクイックフィックスを使用すると、関数呼び出しに明示的な変換が追加されます。\n\n**例:**\n\n\n      fun <T> f(a: Iterable<T>, b: Iterable<T>): Int =\n          a.intersect(b).size\n\nクイックフィックス適用後:\n\n\n      fun <T> f(a: Iterable<T>, b: Iterable<T>): Int =\n          a.intersect(b.toSet()).size\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertArgumentToSet",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/他の問題",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinCovariantEquals",
                "shortDescription": {
                  "text": "共変の 'equals()'"
                },
                "fullDescription": {
                  "text": "'Any?' 以外の引数の型を取る 'equals()' があり、そのクラスに 'Any?' を引数の型として取る 'equals()' が他にない場合に報告します。 例: 'class Foo {\n      fun equals(other: Foo?): Boolean {\n          return true\n      }\n  }' この問題を修正するには、'Any?' 型の引数を取る 'equals()' メソッドを作成してください。",
                  "markdown": "`Any?` 以外の引数の型を取る `equals()` があり、そのクラスに `Any?` を引数の型として取る `equals()` が他にない場合に報告します。\n\n**例:**\n\n\n      class Foo {\n          fun equals(other: Foo?): Boolean {\n              return true\n          }\n      }\n\nこの問題を修正するには、`Any?` 型の引数を取る `equals()` メソッドを作成してください。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CovariantEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceSizeZeroCheckWithIsEmpty",
                "shortDescription": {
                  "text": "'isEmpty()' に置換可能なサイズゼロチェック"
                },
                "fullDescription": {
                  "text": "'isEmpty()' に置換すべき 'Collections/Array/String' の 'size == 0' チェックを報告します。 'isEmpty()' を使用すると、コードを単純化できます。 クイックフィックスを使用すると、サイズチェックが 'isEmpty()' に置換されます。 例: 'fun foo() {\n      val arrayOf = arrayOf(1, 2, 3)\n      arrayOf.size == 0\n  }' クイックフィックス適用後: 'fun foo() {\n      val arrayOf = arrayOf(1, 2, 3)\n      arrayOf.isEmpty()\n  }'",
                  "markdown": "`isEmpty()` に置換すべき `Collections/Array/String` の `size == 0` チェックを報告します。\n\n`isEmpty()` を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、サイズチェックが `isEmpty()` に置換されます。\n\n**例:**\n\n\n      fun foo() {\n          val arrayOf = arrayOf(1, 2, 3)\n          arrayOf.size == 0\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo() {\n          val arrayOf = arrayOf(1, 2, 3)\n          arrayOf.isEmpty()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceSizeZeroCheckWithIsEmpty",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceGuardClauseWithFunctionCall",
                "shortDescription": {
                  "text": "Kotlin の関数呼び出しに置換可能なガード節"
                },
                "fullDescription": {
                  "text": "関数呼び出しに置換できるガード節を報告します。 例: 'fun test(foo: Int?) {\n      if (foo == null) throw IllegalArgumentException(\"foo\") // 置換できる節\n  }' クイックフィックス適用後: 'fun test(foo: Int?) {\n      checkNotNull(foo)\n  }'",
                  "markdown": "関数呼び出しに置換できるガード節を報告します。\n\n**例:**\n\n      fun test(foo: Int?) {\n          if (foo == null) throw IllegalArgumentException(\"foo\") // 置換できる節\n      }\n\nクイックフィックス適用後:\n\n      fun test(foo: Int?) {\n          checkNotNull(foo)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceGuardClauseWithFunctionCall",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AmbiguousExpressionInWhenBranchMigration",
                "shortDescription": {
                  "text": "1.7 以降の 'when' 分岐のあいまいな論理式"
                },
                "fullDescription": {
                  "text": "Kotlin 1.8 以降でコンパイルエラーを引き起こす 'when' 分岐内のあいまいな論理式を報告します。 'fun Int.matches(strict: Boolean): Boolean = when (strict) {\n      true -> this == 6\n      this in (4..7) -> true // あいまいです\n      else -> false\n  }' クイックフィックス適用後: 'fun Int.matches(strict: Boolean): Boolean = when (strict) {\n      true -> this == 6\n      (this in (4..7)) -> true // 丸括弧で囲まれました\n      else -> false\n  }' このインスペクションは Kotlin の言語レベルが 1.7 以降の場合に使用できます。",
                  "markdown": "Kotlin 1.8 以降でコンパイルエラーを引き起こす `when` 分岐内のあいまいな論理式を報告します。\n\n\n      fun Int.matches(strict: Boolean): Boolean = when (strict) {\n          true -> this == 6\n          this in (4..7) -> true // あいまいです\n          else -> false\n      }\n\nクイックフィックス適用後:\n\n\n      fun Int.matches(strict: Boolean): Boolean = when (strict) {\n          true -> this == 6\n          (this in (4..7)) -> true // 丸括弧で囲まれました\n          else -> false\n      }\n\nこのインスペクションは Kotlin の言語レベルが 1.7 以降の場合に使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AmbiguousExpressionInWhenBranchMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantEnumConstructorInvocation",
                "shortDescription": {
                  "text": "冗長な列挙型コンストラクターの呼び出し"
                },
                "fullDescription": {
                  "text": "列挙型エントリに対する冗長なコンストラクター呼び出しを報告します。 例: 'enum class Baz(i: Int = 0) {\n      A(1),\n      B(),\n      C(),\n  }' クイックフィックス適用後: 'enum class Baz(i: Int = 0) {\n      A(1),\n      B,\n      C,\n  }'",
                  "markdown": "列挙型エントリに対する冗長なコンストラクター呼び出しを報告します。\n\n**例:**\n\n\n      enum class Baz(i: Int = 0) {\n          A(1),\n          B(),\n          C(),\n      }\n\nクイックフィックス適用後:\n\n\n      enum class Baz(i: Int = 0) {\n          A(1),\n          B,\n          C,\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantEnumConstructorInvocation",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceToStringWithStringTemplate",
                "shortDescription": {
                  "text": "'toString' の呼び出しは文字列テンプレートに置換できます"
                },
                "fullDescription": {
                  "text": "文字列テンプレートに置換できる 'toString' 関数の呼び出しを報告します。 文字列テンプレートを使用すると、コードを単純化できます。 文字列テンプレートに置換できる 'toString' 関数の呼び出しを報告します。 例: 'fun test(): String {\n      val x = 1\n      return x.toString()\n  }' クイックフィックス適用後: 'fun test(): String {\n      val x = 1\n      return \"$x\"\n  }'",
                  "markdown": "文字列テンプレートに置換できる `toString` 関数の呼び出しを報告します。\n\n文字列テンプレートを使用すると、コードを単純化できます。\n\n文字列テンプレートに置換できる `toString` 関数の呼び出しを報告します。\n\n**例:**\n\n\n      fun test(): String {\n          val x = 1\n          return x.toString()\n      }\n\nクイックフィックス適用後:\n\n\n      fun test(): String {\n          val x = 1\n          return \"$x\"\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceToStringWithStringTemplate",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FakeJvmFieldConstant",
                "shortDescription": {
                  "text": "Kotlin の非 const プロパティが Java 定数として使用されています"
                },
                "fullDescription": {
                  "text": "'const' ではなく、Java アノテーションの引数として使用されている Kotlin プロパティを報告します。 たとえば、'@JvmField' アノテーション付きのプロパティにコンパイル時に評価できるイニシャライザーがあり、プリミティブ型または 'String' 型を持っている場合が挙げられます。 Kotlin 1.1-1.2 のバイトコードでは、このようなプロパティは 'ConstantValue' 属性を持っています。 この属性があれば、javac を使って対応するフィールドの使用箇所を折りたたみ、そのフィールドをアノテーション内で使用することができます。 これにより、Java と Kotlin が混在するコードでは、個別のコンパイルやインクリメンタルコンパイルの際に不正な動作が発生する可能性があります。 この動作は、Kotlin 1.3 で変更される予定です ('ConstantValue' 属性は廃止される予定です)。 例: foo.kt ファイルの Kotlin コード: 'annotation class Ann(val s: String)\n  @JvmField val importantString = \"important\"' Java コード: 'public class JavaUser {\n      // これは危険です\n      @Ann(s = FooKt.importantString)\n      public void foo() {}\n  }' この問題を修正するには、関連する Kotlin プロパティの '@JvmField' アノテーションを 'const' 修飾子に置換するか、インライン化してください。",
                  "markdown": "`const` ではなく、Java アノテーションの引数として使用されている Kotlin プロパティを報告します。\n\n\nたとえば、`@JvmField` アノテーション付きのプロパティにコンパイル時に評価できるイニシャライザーがあり、プリミティブ型または `String` 型を持っている場合が挙げられます。\n\n\nKotlin 1.1-1.2 のバイトコードでは、このようなプロパティは `ConstantValue` 属性を持っています。\nこの属性があれば、javac を使って対応するフィールドの使用箇所を折りたたみ、そのフィールドをアノテーション内で使用することができます。\nこれにより、Java と Kotlin が混在するコードでは、個別のコンパイルやインクリメンタルコンパイルの際に不正な動作が発生する可能性があります。\nこの動作は、Kotlin 1.3 で変更される予定です (`ConstantValue` 属性は廃止される予定です)。\n\n**例:**\n\nfoo.kt ファイルの Kotlin コード:\n\n\n      annotation class Ann(val s: String)\n      @JvmField val importantString = \"important\"\n\nJava コード:\n\n\n      public class JavaUser {\n          // これは危険です\n          @Ann(s = FooKt.importantString)\n          public void foo() {}\n      }\n\nこの問題を修正するには、関連する Kotlin プロパティの `@JvmField` アノテーションを `const` 修飾子に置換するか、インライン化してください。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FakeJvmFieldConstant",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 相互運用性の問題",
                      "index": 66,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProtectedInFinal",
                "shortDescription": {
                  "text": "'protected' の可視性は実質的に final クラス内の 'private' と同じです"
                },
                "fullDescription": {
                  "text": "'final' クラス内で使用されている 'protected' 可視性を報告します。 このような場合、'protected' メンバーはそのクラスの中でしかアクセスできないため、実質的には 'private' と同じです。 例: 'class FinalClass {\n      protected fun foo() {}\n  }' クイックフィックス適用後: 'class FinalClass {\n      private fun foo() {}\n  }'",
                  "markdown": "`final` クラス内で使用されている `protected` 可視性を報告します。 このような場合、`protected` メンバーはそのクラスの中でしかアクセスできないため、実質的には `private` と同じです。\n\n**例:**\n\n\n      class FinalClass {\n          protected fun foo() {}\n      }\n\nクイックフィックス適用後:\n\n\n      class FinalClass {\n          private fun foo() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ProtectedInFinal",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WhenWithOnlyElse",
                "shortDescription": {
                  "text": "'when' は 'else' 分岐しか持たないため単純化できます"
                },
                "fullDescription": {
                  "text": "単純化できる 'else' 分岐のみを持つ 'when' 式を報告します。 「式の単純化」クイックフィックスを使用すると、コードを自動的に修正できます。 例: 'fun redundant() {\n      val x = when { // <== 冗長。クイックフィックスで when 式を \"val x = 1\" に単純化できます\n          else -> 1\n      }\n  }'",
                  "markdown": "単純化できる `else` 分岐のみを持つ `when` 式を報告します。\n\n「**式の単純化**」クイックフィックスを使用すると、コードを自動的に修正できます。\n\n例:\n\n\n      fun redundant() {\n          val x = when { // <== 冗長。クイックフィックスで when 式を \"val x = 1\" に単純化できます\n              else -> 1\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "WhenWithOnlyElse",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceRangeStartEndInclusiveWithFirstLast",
                "shortDescription": {
                  "text": "ボクシングされたプロパティはアンボクシングされたものに置換する必要があります"
                },
                "fullDescription": {
                  "text": "ボクシングされている 'Range.start' および 'Range.endInclusive' プロパティを報告します。 これらのプロパティを アンボクシングされた 'first' および 'last' プロパティに置換すると、冗長な呼び出しを回避することができます。 クイックフィックスを使用すると、'start' および 'endInclusive' のプロパティが対応する 'first' と 'last' に置換されます。 例: 'fun foo(range: CharRange) {\n      val lastElement = range.endInclusive\n  }' クイックフィックス適用後: 'fun foo(range: CharRange) {\n      val lastElement = range.last\n  }'",
                  "markdown": "**ボクシングされている** `Range.start` および `Range.endInclusive` プロパティを報告します。\n\nこれらのプロパティを **アンボクシングされた** `first` および `last` プロパティに置換すると、冗長な呼び出しを回避することができます。\n\nクイックフィックスを使用すると、`start` および `endInclusive` のプロパティが対応する `first` と `last` に置換されます。\n\n**例:**\n\n\n      fun foo(range: CharRange) {\n          val lastElement = range.endInclusive\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(range: CharRange) {\n          val lastElement = range.last\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceRangeStartEndInclusiveWithFirstLast",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceSizeCheckWithIsNotEmpty",
                "shortDescription": {
                  "text": "'isNotEmpty()' に置換可能なサイズチェック"
                },
                "fullDescription": {
                  "text": "'isNotEmpty()' に置換すべき 'Collections/Array/String' のサイズチェックを報告します。 'isNotEmpty()' を使用すると、コードを単純化できます。 クイックフィックスを使用すると、サイズチェックが 'isNotEmpty()' に置換されます。 例: 'fun foo() {\n      val arrayOf = arrayOf(1, 2, 3)\n      arrayOf.size > 0\n  }' クイックフィックス適用後: 'fun foo() {\n      val arrayOf = arrayOf(1, 2, 3)\n      arrayOf.isNotEmpty()\n  }'",
                  "markdown": "`isNotEmpty()` に置換すべき `Collections/Array/String` のサイズチェックを報告します。\n\n`isNotEmpty()` を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、サイズチェックが `isNotEmpty()` に置換されます。\n\n**例:**\n\n\n      fun foo() {\n          val arrayOf = arrayOf(1, 2, 3)\n          arrayOf.size > 0\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo() {\n          val arrayOf = arrayOf(1, 2, 3)\n          arrayOf.isNotEmpty()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceSizeCheckWithIsNotEmpty",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantSemicolon",
                "shortDescription": {
                  "text": "冗長なセミコロン"
                },
                "fullDescription": {
                  "text": "安全に除去できる不要なセミコロン (';') を報告します。 Kotlin では、各ステートメントまたは式の最後にセミコロンを使用する必要がありません。 不要なセミコロンを除去するクイックフィックスが提案されます。 例: 'val myMap = mapOf(\"one\" to 1, \"two\" to 2);\n  myMap.forEach { (key, value) ->  print(\"$key -> $value\")};' クイックフィックス適用後: 'val myMap = mapOf(\"one\" to 1, \"two\" to 2)\n  myMap.forEach { (key, value) ->  print(\"$key -> $value\")}' ただし、以下の 2 つの場合にはセミコロンが必要です。 複数のステートメントを 1 行に記述している場合は、セミコロンで区切る必要があります。 'map.forEach { val (key, value) = it; println(\"$key -> $value\") }' プロパティまたは関数も宣言する 'enum' クラスでは、列挙型定数の後にセミコロンを記述する必要があります。 'enum class Mode {\n      SILENT, VERBOSE;\n\n      fun isSilent(): Boolean = this == SILENT\n  }'",
                  "markdown": "安全に除去できる不要なセミコロン (`;`) を報告します。\n\n\nKotlin では、各ステートメントまたは式の最後にセミコロンを使用する必要がありません。\n不要なセミコロンを除去するクイックフィックスが提案されます。\n\n**例:**\n\n\n      val myMap = mapOf(\"one\" to 1, \"two\" to 2);\n      myMap.forEach { (key, value) ->  print(\"$key -> $value\")};\n\nクイックフィックス適用後:\n\n\n      val myMap = mapOf(\"one\" to 1, \"two\" to 2)\n      myMap.forEach { (key, value) ->  print(\"$key -> $value\")}\n\nただし、以下の 2 つの場合にはセミコロンが必要です。\n\n1. 複数のステートメントを 1 行に記述している場合は、セミコロンで区切る必要があります。\n\n\n         map.forEach { val (key, value) = it; println(\"$key -> $value\") }\n\n2. プロパティまたは関数も宣言する `enum` クラスでは、列挙型定数の後にセミコロンを記述する必要があります。\n\n\n         enum class Mode {\n             SILENT, VERBOSE;\n\n             fun isSilent(): Boolean = this == SILENT\n         }\n               \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantSemicolon",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InfixCallToOrdinary",
                "shortDescription": {
                  "text": "中置呼び出しはドット呼び出しにできます"
                },
                "fullDescription": {
                  "text": "ドットで修飾された関数の呼び出しに置換できる中置関数の呼び出しを報告します。 例: '1 xor 2' '1.xor(2)'",
                  "markdown": "ドットで修飾された関数の呼び出しに置換できる中置関数の呼び出しを報告します。\n\n例:\n\n\n        1 xor 2\n\n\n        1.xor(2)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "InfixCallToOrdinary",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/コードの移行",
                      "index": 85,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IntroduceWhenSubject",
                "shortDescription": {
                  "text": "引数の導入で単純化できる 'when'"
                },
                "fullDescription": {
                  "text": "対象の引数を導入して単純化できる 'when' 式を報告します。 例: 'fun test(obj: Any): String {\n      return when {\n          obj is String -> \"string\"\n          obj is Int -> \"int\"\n          else -> \"unknown\"\n      }\n  }' クイックフィックスを使用すると、対象の引数が導入されます。 'fun test(obj: Any): String {\n      return when (obj) {\n          is String -> \"string\"\n          is Int -> \"int\"\n          else -> \"unknown\"\n      }\n  }'",
                  "markdown": "対象の引数を導入して単純化できる `when` 式を報告します。\n\n**例:**\n\n\n      fun test(obj: Any): String {\n          return when {\n              obj is String -> \"string\"\n              obj is Int -> \"int\"\n              else -> \"unknown\"\n          }\n      }\n\nクイックフィックスを使用すると、対象の引数が導入されます。\n\n\n      fun test(obj: Any): String {\n          return when (obj) {\n              is String -> \"string\"\n              is Int -> \"int\"\n              else -> \"unknown\"\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IntroduceWhenSubject",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinTestJUnit",
                "shortDescription": {
                  "text": "kotlin-test-junit を使用できます"
                },
                "fullDescription": {
                  "text": "'kotlin-test' と 'junit' の依存関係の使用箇所で、'kotlin-test-junit' がないものを報告します。 Kotlin と JUnit の組み合わせでは、'kotlin-test-junit' を依存関係に含めることをお勧めします。",
                  "markdown": "`kotlin-test` と `junit` の依存関係の使用箇所で、`kotlin-test-junit` がないものを報告します。\n\nKotlin と JUnit の組み合わせでは、`kotlin-test-junit` を依存関係に含めることをお勧めします。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KotlinTestJUnit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SafeCastWithReturn",
                "shortDescription": {
                  "text": "'return' を含む安全なキャストは 'if' の型チェックに置換する必要があります"
                },
                "fullDescription": {
                  "text": "'if' の型チェックに置換できる、'return' を使用した安全なキャストを報告します。 対応する関数を使用すると、コードを単純化できます。 クイックフィックスを使用すると、安全なキャストが 'if' の型チェックに置換されます。 例: 'fun test(x: Any) {\n      x as? String ?: return\n  }' クイックフィックス適用後: 'fun test(x: Any) {\n      if (x !is String) return\n  }'",
                  "markdown": "`if` の型チェックに置換できる、`return` を使用した安全なキャストを報告します。\n\n対応する関数を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、安全なキャストが `if` の型チェックに置換されます。\n\n**例:**\n\n\n      fun test(x: Any) {\n          x as? String ?: return\n      }\n\nクイックフィックス適用後:\n\n\n      fun test(x: Any) {\n          if (x !is String) return\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SafeCastWithReturn",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedCallableAddReplaceWith",
                "shortDescription": {
                  "text": "'replaceWith' 引数のない @Deprecated アノテーション"
                },
                "fullDescription": {
                  "text": "'kotlin.deprecated' アノテーションに 'kotlin.ReplaceWith' 引数が無い非推奨の関数とプロパティを報告し、その本体に基づいて該当の引数を 1 つ追加することを提案します。 Kotlin では、非推奨の宣言を自動的に置換する 'ReplaceWith' 引数が提供されています。 コード内の非推奨要素に関する問題は、この引数を使用して修正することをお勧めします。 例: '@Deprecated(\"Use refined() instead.\")\n  fun deprecated() = refined()\n\n  fun refined() = 42' クイックフィックスを使用すると、'ReplaceWith()' 引数が追加されます。 '@Deprecated(\"Use refined() instead.\", ReplaceWith(\"refined()\"))\n  fun deprecated() = refined()\n\n  fun refined() = 42'",
                  "markdown": "`kotlin.deprecated` アノテーションに `kotlin.ReplaceWith` 引数が無い非推奨の関数とプロパティを報告し、その本体に基づいて該当の引数を 1 つ追加することを提案します。\n\n\nKotlin では、非推奨の宣言を自動的に置換する `ReplaceWith` 引数が提供されています。\nコード内の非推奨要素に関する問題は、この引数を使用して修正することをお勧めします。\n\n**例:**\n\n\n      @Deprecated(\"Use refined() instead.\")\n      fun deprecated() = refined()\n\n      fun refined() = 42\n\nクイックフィックスを使用すると、`ReplaceWith()` 引数が追加されます。\n\n\n      @Deprecated(\"Use refined() instead.\", ReplaceWith(\"refined()\"))\n      fun deprecated() = refined()\n\n      fun refined() = 42\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DeprecatedCallableAddReplaceWith",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/他の問題",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceAssertBooleanWithAssertEquality",
                "shortDescription": {
                  "text": "等価比較のアサーションに置換可能なブール値のアサーション"
                },
                "fullDescription": {
                  "text": "assert の等価比較関数に置換できる 'assertTrue()' と 'assertFalse()' の呼び出しを報告します。 'assertEquals()'、'assertSame()'、およびこれらに対応する否定関数 (-Not-) を使用すると、失敗時により詳細なメッセージが表示されます。 例: 'assertTrue(a == b)' クイックフィックス適用後: 'assertEquals(a, b)'",
                  "markdown": "assert の等価比較関数に置換できる `assertTrue()` と `assertFalse()` の呼び出しを報告します。\n\n\n`assertEquals()`、`assertSame()`、およびこれらに対応する否定関数 (-Not-) を使用すると、失敗時により詳細なメッセージが表示されます。\n\n**例:**\n\n      assertTrue(a == b)\n\nクイックフィックス適用後:\n\n      assertEquals(a, b)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceAssertBooleanWithAssertEquality",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryOptInAnnotation",
                "shortDescription": {
                  "text": "不要な '@OptIn' アノテーション"
                },
                "fullDescription": {
                  "text": "安全に除去できる不要な OptIn アノテーションを報告します。 '@OptIn' アノテーションは、将来的にどこかの時点で変更される可能性がある実験的な API を使用するコードに必要です。 このような API が使用されていない場合、このアノテーションは無駄であり、誤解を招く可能性があります (例: 実験的な API が安定し、その使用箇所をオプトインする必要がなくなった場合)。 「アノテーションの除去」クイックフィックスを使用すると、不要な '@OptIn' アノテーションを除去できます。 例: '@OptIn(ExperimentalApi::class)\n  fun foo(x: Bar) {\n      x.baz()\n  }' クイックフィックス適用後: 'fun foo(x: Bar) {\n      x.baz()\n  }'",
                  "markdown": "安全に除去できる不要な OptIn アノテーションを報告します。\n\n`@OptIn` アノテーションは、将来的にどこかの時点で変更される可能性がある実験的な API を使用するコードに必要です。 このような API が使用されていない場合、このアノテーションは無駄であり、誤解を招く可能性があります (例: 実験的な API が安定し、その使用箇所をオプトインする必要がなくなった場合)。\n\n\n「**アノテーションの除去** 」クイックフィックスを使用すると、不要な `@OptIn` アノテーションを除去できます。\n\n例:\n\n\n      @OptIn(ExperimentalApi::class)\n      fun foo(x: Bar) {\n          x.baz()\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(x: Bar) {\n          x.baz()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessaryOptInAnnotation",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComplexRedundantLet",
                "shortDescription": {
                  "text": "冗長な引数ベースの 'let' の呼び出し"
                },
                "fullDescription": {
                  "text": "不要な引数ベースの 'let' の呼び出しを報告します。 ラムダパラメーターが呼び出し式の中で修飾子としてのみ使用されている場合、'let' は冗長です。 修飾する式に名前を付ける必要がある場合は、ローカル変数を宣言してください。 例: 'fun splitNumbers() {\n      \"1,2,3\".let { it.split(',') }\n  }' クイックフィックスを使用すると、不要な 'let()' の呼び出しが除去されます。 'fun example() {\n      \"1,2,3\".split(',')\n  }' もしくは 'fun splitNumbers() {\n      val numbers = \"1,2,3\"\n      numbers.split(',')\n  }'",
                  "markdown": "不要な引数ベースの `let` の呼び出しを報告します。\n\nラムダパラメーターが呼び出し式の中で修飾子としてのみ使用されている場合、`let` は冗長です。\n\n修飾する式に名前を付ける必要がある場合は、ローカル変数を宣言してください。\n\n**例:**\n\n\n      fun splitNumbers() {\n          \"1,2,3\".let { it.split(',') }\n      }\n\nクイックフィックスを使用すると、不要な `let()` の呼び出しが除去されます。\n\n\n      fun example() {\n          \"1,2,3\".split(',')\n      }\n\nもしくは\n\n\n      fun splitNumbers() {\n          val numbers = \"1,2,3\"\n          numbers.split(',')\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ComplexRedundantLet",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveRedundantSpreadOperator",
                "shortDescription": {
                  "text": "冗長なスプレッド演算子"
                },
                "fullDescription": {
                  "text": "'arrayOf' 関数ファミリーの呼び出しに使用されている冗長なスプレッド演算子を報告します。 コードをクリーンアップするには、'冗長なスプレッド演算子を除去' クイックフィックスを使用します。 例: 'fun foo(vararg s: String) { }\n\n  fun bar(ss: Array<String>) {\n      foo(*arrayOf(\"abc\"))       // 両方の 'foo' の呼び出しで配列が作成されており\n      foo(*arrayOf(*ss, \"zzz\"))  // 後続の \"スプレッド\" は冗長です\n  }' クイックフィックス適用後: 'fun foo(vararg s: String) { }\n\n  fun bar(ss: Array<String>) {\n      foo(\"abc\")\n      foo(*ss, \"zzz\")\n  }'",
                  "markdown": "`arrayOf` 関数ファミリーの呼び出しに使用されている冗長なスプレッド演算子を報告します。\n\nコードをクリーンアップするには、'冗長なスプレッド演算子を除去' クイックフィックスを使用します。\n\n**例:**\n\n\n      fun foo(vararg s: String) { }\n\n      fun bar(ss: Array<String>) {\n          foo(*arrayOf(\"abc\"))       // 両方の 'foo' の呼び出しで配列が作成されており\n          foo(*arrayOf(*ss, \"zzz\"))  // 後続の \"スプレッド\" は冗長です\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(vararg s: String) { }\n\n      fun bar(ss: Array<String>) {\n          foo(\"abc\")\n          foo(*ss, \"zzz\")\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RemoveRedundantSpreadOperator",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonVarPropertyInExternalInterface",
                "shortDescription": {
                  "text": "external インターフェースには val プロパティが含まれます"
                },
                "fullDescription": {
                  "text": "外部インターフェースの var でないプロパティを報告します。 詳細は、移行ガイドを参照してください。",
                  "markdown": "外部インターフェースの var でないプロパティを報告します。 詳細は、[移行ガイド](https://kotlinlang.org/docs/js-ir-migration.html#convert-properties-of-external-interfaces-to-var)を参照してください。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonVarPropertyInExternalInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProhibitJvmOverloadsOnConstructorsOfAnnotationClassesMigration",
                "shortDescription": {
                  "text": "1.4 以降は '@JvmOverloads' アノテーションをアノテーションクラスのコンストラクターで使用できません"
                },
                "fullDescription": {
                  "text": "アノテーションクラスのコンストラクターに対する無意味な '@JvmOverloads' を報告します。 生成されるバイトコードと Kotlin のメタデータには '@JvmOverloads' の占有領域が無いため、'@JvmOverloads' は生成されるバイトコードおよびコードの動作に影響しません。 Kotlin 1.4 以降はアノテーションクラスのコンストラクターに対して '@JvmOverloads' を使用すると、コンパイルエラーになります。 例: 'annotation class A @JvmOverloads constructor(val x: Int = 1)' クイックフィックス適用後: 'annotation class A constructor(val x: Int = 1)'",
                  "markdown": "アノテーションクラスのコンストラクターに対する無意味な `@JvmOverloads` を報告します。\n\n\n生成されるバイトコードと Kotlin のメタデータには `@JvmOverloads` の占有領域が無いため、`@JvmOverloads` は生成されるバイトコードおよびコードの動作に影響しません。\n\nKotlin 1.4 以降はアノテーションクラスのコンストラクターに対して `@JvmOverloads` を使用すると、コンパイルエラーになります。\n\n**例:**\n\n\n      annotation class A @JvmOverloads constructor(val x: Int = 1)\n\nクイックフィックス適用後:\n\n\n      annotation class A constructor(val x: Int = 1)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ProhibitJvmOverloadsOnConstructorsOfAnnotationClassesMigration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveSetterParameterType",
                "shortDescription": {
                  "text": "冗長な setter パラメーターの型"
                },
                "fullDescription": {
                  "text": "プロパティの setter に明示的に指定されているパラメーターの型を報告します。 setter のパラメーターの型は常にプロパティの型と一致するため、明示的に指定する必要はありません。 '明示的な型指定の除去' クイックフィックスを使用すると、コードが修正されます。 例: 'fun process(x: Int) {}\n\n  var x: Int = 0\n      set(value: Int) = process(value) // <== 'Int' の指定は安全に省略できます' クイックフィックス適用後: 'fun process(x: Int) {}\n\n  var x: Int = 0\n      set(value) = process(value)'",
                  "markdown": "プロパティの setter に明示的に指定されているパラメーターの型を報告します。\n\n\nsetter のパラメーターの型は常にプロパティの型と一致するため、明示的に指定する必要はありません。\n'明示的な型指定の除去' クイックフィックスを使用すると、コードが修正されます。\n\n**例:**\n\n\n      fun process(x: Int) {}\n\n      var x: Int = 0\n          set(value: Int) = process(value) // <== 'Int' の指定は安全に省略できます\n\nクイックフィックス適用後:\n\n\n      fun process(x: Int) {}\n\n      var x: Int = 0\n          set(value) = process(value)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RemoveSetterParameterType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfThenToElvis",
                "shortDescription": {
                  "text": "'?:' に折りたたみ可能な If-Then"
                },
                "fullDescription": {
                  "text": "エルビス ('?:') 式に変換できる 'if-then' 式を報告します。 例: 'fun maybeFoo(): String? = \"foo\"\n\n  var foo = maybeFoo()\n  val bar = if (foo == null) \"hello\" else foo' クイックフィックスを使用すると、'if-then' 式がエルビス ('?:') 式に変換されます。 'fun maybeFoo(): String? = \"foo\"\n\n  var foo = maybeFoo()\n  val bar = foo ?: \"hello\"'",
                  "markdown": "エルビス (`?:`) 式に変換できる `if-then` 式を報告します。\n\n**例:**\n\n\n      fun maybeFoo(): String? = \"foo\"\n\n      var foo = maybeFoo()\n      val bar = if (foo == null) \"hello\" else foo\n\nクイックフィックスを使用すると、`if-then` 式がエルビス (`?:`) 式に変換されます。\n\n\n      fun maybeFoo(): String? = \"foo\"\n\n      var foo = maybeFoo()\n      val bar = foo ?: \"hello\"\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IfThenToElvis",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectPrivatePropertyName",
                "shortDescription": {
                  "text": "オブジェクト private プロパティの命名規則"
                },
                "fullDescription": {
                  "text": "命名規則に従っていないプロパティを報告します。 以下のプロパティが報告されます。 オブジェクトとコンパニオンオブジェクト内の private プロパティ 必要なパターンは、インスペクションのオプションで指定できます。 推奨される命名規則: アンダースコアまたは大文字で始まるキャメルケースを使用する。 例: 'class Person {\n    companion object {\n      // コンパニオンオブジェクト内のプロパティ\n      private val NO_NAME = Person()\n    }\n  }'",
                  "markdown": "命名規則に従っていないプロパティを報告します。\n\n以下のプロパティが報告されます。\n\n* オブジェクトとコンパニオンオブジェクト内の private プロパティ\n\n必要なパターンは、インスペクションのオプションで指定できます。\n\n[推奨される命名規則](https://kotlinlang.org/docs/coding-conventions.html#naming-rules): アンダースコアまたは大文字で始まるキャメルケースを使用する。\n\n**例:**\n\n\n      class Person {\n        companion object {\n          // コンパニオンオブジェクト内のプロパティ\n          private val NO_NAME = Person()\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectPrivatePropertyName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名規約",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WrapUnaryOperator",
                "shortDescription": {
                  "text": "数値定数を含むあいまいな単項演算子の使用"
                },
                "fullDescription": {
                  "text": "'-1.inc()' のように、ドット修飾子が後に続いている単項演算子を報告します。 '-' の優先順位は '.inc()' よりも低いため、'-1.inc()' のようなコードは誤解を招く可能性があります。 '-1.inc()' は結果的に '-2' と評価され、期待値だと思われる '-0' にはなりません。 「単項演算子と値を () で囲む」クイックフィックスを使用すると、コードを自動的に修正できます。",
                  "markdown": "`-1.inc()` のように、ドット修飾子が後に続いている単項演算子を報告します。\n\n`-` の優先順位は `.inc()` よりも低いため、`-1.inc()` のようなコードは誤解を招く可能性があります。\n`-1.inc()` は結果的に `-2` と評価され、期待値だと思われる `-0` にはなりません。\n\n「**単項演算子と値を () で囲む**」クイックフィックスを使用すると、コードを自動的に修正できます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "WrapUnaryOperator",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConflictingExtensionProperty",
                "shortDescription": {
                  "text": "合成プロパティと競合する拡張プロパティ"
                },
                "fullDescription": {
                  "text": "Java の 'get' メソッドまたは 'set' メソッドから自動的に作成された合成プロパティと競合している拡張プロパティを報告します。 将来的にコンパイラーに加えられる変更が原因でコードが破損するのを防ぐため、このようなプロパティは除去するか名前を変更しておく必要があります。 クイックフィックスを使用すると、拡張プロパティが削除されます。 例: 'val File.name: String\n      get() = getName()' クイックフィックスを使用すると、'@Deprecated' アノテーションが追加されます。 '@Deprecated(\"Is replaced with automatic synthetic extension\", ReplaceWith(\"name\"), level = DeprecationLevel.HIDDEN)\n  val File.name: String\n      get() = getName()'",
                  "markdown": "Java の `get` メソッドまたは `set` メソッドから自動的に作成された合成プロパティと競合している拡張プロパティを報告します。\n\n将来的にコンパイラーに加えられる変更が原因でコードが破損するのを防ぐため、このようなプロパティは除去するか名前を変更しておく必要があります。\n\nクイックフィックスを使用すると、拡張プロパティが削除されます。\n\n**例:**\n\n\n      val File.name: String\n          get() = getName()\n\nクイックフィックスを使用すると、`@Deprecated` アノテーションが追加されます。\n\n\n      @Deprecated(\"Is replaced with automatic synthetic extension\", ReplaceWith(\"name\"), level = DeprecationLevel.HIDDEN)\n      val File.name: String\n          get() = getName()\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConflictingExtensionProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceNotNullAssertionWithElvisReturn",
                "shortDescription": {
                  "text": "非 null アサーションは 'return' に置換できます"
                },
                "fullDescription": {
                  "text": "非 null アサーション ('!!') の呼び出しで、エルビス演算子 ('?: return') に置換できるものを報告します。 非 null アサーションを使用すると、想定外の NPE (NullPointerException) が発生する可能性があります。 '!!' の使用を避けることをお勧めします。 クイックフィックスを使用すると、非 null アサーションが 'return' または 'return null' に置換されます。 例: 'fun test(number: Int?) {\n      val x = number!!\n  }' クイックフィックス適用後: 'fun test(number: Int?) {\n      val x = number ?: return\n  }'",
                  "markdown": "非 null アサーション (`!!`) の呼び出しで、エルビス演算子 (`?: return`) に置換できるものを報告します。\n\n非 null アサーションを使用すると、想定外の NPE (NullPointerException) が発生する可能性があります。 `!!` の使用を避けることをお勧めします。\n\nクイックフィックスを使用すると、非 null アサーションが `return` または `return null` に置換されます。\n\n**例:**\n\n\n      fun test(number: Int?) {\n          val x = number!!\n      }\n\nクイックフィックス適用後:\n\n\n      fun test(number: Int?) {\n          val x = number ?: return\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceNotNullAssertionWithElvisReturn",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceStringFormatWithLiteral",
                "shortDescription": {
                  "text": "文字列テンプレートに置換可能な 'String.format' の呼び出し"
                },
                "fullDescription": {
                  "text": "文字列テンプレートに置換できる 'String.format' の呼び出しを報告します。 文字列テンプレートを使用すると、コードを単純化できます。 クイックフィックスを使用すると、呼び出しが文字列テンプレートに置換されます。 例: 'fun main() {\n      val id = \"abc\"\n      val date = \"123\"\n      val s = String.format(\"%s_%s_%s\", id, date, id)\n  }' クイックフィックス適用後: 'fun main() {\n      val id = \"abc\"\n      val date = \"123\"\n      val s = \"${id}_${date}_$id\"\n  }'",
                  "markdown": "文字列テンプレートに置換できる `String.format` の呼び出しを報告します。\n\n文字列テンプレートを使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、呼び出しが文字列テンプレートに置換されます。\n\n**例:**\n\n\n      fun main() {\n          val id = \"abc\"\n          val date = \"123\"\n          val s = String.format(\"%s_%s_%s\", id, date, id)\n      }\n\nクイックフィックス適用後:\n\n\n      fun main() {\n          val id = \"abc\"\n          val date = \"123\"\n          val s = \"${id}_${date}_$id\"\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceStringFormatWithLiteral",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceSubstringWithSubstringBefore",
                "shortDescription": {
                  "text": "'substringBefore' に置換すべき 'substring' の呼び出し"
                },
                "fullDescription": {
                  "text": "'s.substring(0, s.indexOf(x))' から 's.substringBefore(x)' のように置換できる呼び出しを報告します。 'substringBefore()' を使用すると、コードを単純化できます。 クイックフィックスを使用すると、'substring' の呼び出しが 'substringBefore' に置換されます。 例: 'fun foo(s: String) {\n      s.substring(0, s.indexOf('x'))\n  }' クイックフィックス適用後: 'fun foo(s: String) {\n      s.substringBefore('x')\n  }'",
                  "markdown": "`s.substring(0, s.indexOf(x))` から `s.substringBefore(x)` のように置換できる呼び出しを報告します。\n\n`substringBefore()` を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、`substring` の呼び出しが `substringBefore` に置換されます。\n\n**例:**\n\n\n      fun foo(s: String) {\n          s.substring(0, s.indexOf('x'))\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(s: String) {\n          s.substringBefore('x')\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceSubstringWithSubstringBefore",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceJavaStaticMethodWithKotlinAnalog",
                "shortDescription": {
                  "text": "Java メソッドは Kotlin 関数に置換する必要があります"
                },
                "fullDescription": {
                  "text": "'System.out.println()' など、Kotlin 関数に置換できる Java メソッドの呼び出しを報告します。 このようなコードを置換すると Java への依存性がなくなり、Kotlin らしいコードになります。 クイックフィックスを使用すると、同じ Kotlin の呼び出しで Java メソッドの呼び出しが置換されます。 例: 'import java.util.Arrays\n\n  fun main() {\n      val a = Arrays.asList(1, 3, null)\n  }' クイックフィックス適用後: 'fun main() {\n      val a = listOf(1, 3, null)\n  }'",
                  "markdown": "`System.out.println()` など、Kotlin 関数に置換できる Java メソッドの呼び出しを報告します。\n\nこのようなコードを置換すると Java への依存性がなくなり、Kotlin らしいコードになります。\n\nクイックフィックスを使用すると、同じ Kotlin の呼び出しで Java メソッドの呼び出しが置換されます。\n\n**例:**\n\n\n      import java.util.Arrays\n\n      fun main() {\n          val a = Arrays.asList(1, 3, null)\n      }\n\nクイックフィックス適用後:\n\n\n      fun main() {\n          val a = listOf(1, 3, null)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceJavaStaticMethodWithKotlinAnalog",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveEmptyParenthesesFromLambdaCall",
                "shortDescription": {
                  "text": "ラムダを含む関数呼び出しの不要な丸括弧"
                },
                "fullDescription": {
                  "text": "空の丸括弧を使用した関数呼び出しがあり、その丸括弧の外にあるラムダが唯一のパラメーターになっている場合に、その丸括弧を冗長であると報告します。 コードをクリーンアップするには、'ラムダ関数呼び出しから不要な丸括弧を除去' クイックフィックスを使用します。 例: 'fun foo() {\n      listOf(1).forEach() {  }\n  }' クイックフィックス適用後: 'fun foo() {\n      listOf(1).forEach {  }\n  }'",
                  "markdown": "空の丸括弧を使用した関数呼び出しがあり、その丸括弧の外にあるラムダが唯一のパラメーターになっている場合に、その丸括弧を冗長であると報告します。\n\nコードをクリーンアップするには、'ラムダ関数呼び出しから不要な丸括弧を除去' クイックフィックスを使用します。\n\n**例:**\n\n\n      fun foo() {\n          listOf(1).forEach() {  }\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo() {\n          listOf(1).forEach {  }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveEmptyParenthesesFromLambdaCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceWithOperatorAssignment",
                "shortDescription": {
                  "text": "演算子代入に置換可能な代入"
                },
                "fullDescription": {
                  "text": "単純な代入 ('y = y + x' など) を使用した変数の変更で、演算子代入に置換できるものを報告します。 クイックフィックスを使用すると、このような代入が代入演算子に置換されます。 例: 'fun foo() {\n      val list = mutableListOf(1, 2, 3)\n      list = list + 4\n  }' クイックフィックス適用後: 'fun foo() {\n      val list = mutableListOf(1, 2, 3)\n      list += 4\n  }'",
                  "markdown": "単純な代入 (`y = y + x` など) を使用した変数の変更で、演算子代入に置換できるものを報告します。\n\nクイックフィックスを使用すると、このような代入が代入演算子に置換されます。\n\n**例:**\n\n\n      fun foo() {\n          val list = mutableListOf(1, 2, 3)\n          list = list + 4\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo() {\n          val list = mutableListOf(1, 2, 3)\n          list += 4\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceWithOperatorAssignment",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveExplicitSuperQualifier",
                "shortDescription": {
                  "text": "不要なスーパータイプ修飾子"
                },
                "fullDescription": {
                  "text": "冗長なスーパータイプ修飾子が使用された 'super' メンバーの呼び出しを報告します。 派生クラス内のコードで 'super' キーワードを使用すると、そのスーパークラスの関数とプロパティアクセサーの実装を呼び出すことができます。 実装の継承元であるスーパータイプを指定するため、スーパータイプの名前を山括弧で囲み、'super' を修飾することができます (例: 'super<Base>')。 この修飾が冗長であり、省略できる場合があります。 コードをクリーンアップするには、'明示的なスーパータイプ修飾子の除去' クイックフィックスを使用します。 例: 'open class B {\n      open fun foo(){}\n  }\n\n  class A : B() {\n      override fun foo() {\n         super<B>.foo() // <== 'B' が唯一のスーパータイプであるため冗長です\n      }\n  }\n\n  interface I {\n      fun foo() {}\n  }\n\n  class C : B(), I {\n      override fun foo() {\n          super<B>.foo() // <== here <B> 'B.foo()' を 'I.foo()' と区別するには修飾子が必要です\n      }\n  }' クイックフィックス適用後: 'open class B {\n      open fun foo(){}\n  }\n\n  class A : B() {\n      override fun foo() {\n         super.foo() // <== 更新後\n      }\n  }\n\n  interface I {\n      fun foo() {}\n  }\n\n  class C : B(), I {\n      override fun foo() {\n          super<B>.foo()\n      }\n  }'",
                  "markdown": "冗長なスーパータイプ修飾子が使用された `super` メンバーの呼び出しを報告します。\n\n\n派生クラス内のコードで `super` キーワードを使用すると、そのスーパークラスの関数とプロパティアクセサーの実装を呼び出すことができます。\n実装の継承元であるスーパータイプを指定するため、スーパータイプの名前を山括弧で囲み、`super` を修飾することができます (例: `super<Base>`)。 この修飾が冗長であり、省略できる場合があります。\nコードをクリーンアップするには、'明示的なスーパータイプ修飾子の除去' クイックフィックスを使用します。\n\n**例:**\n\n\n      open class B {\n          open fun foo(){}\n      }\n\n      class A : B() {\n          override fun foo() {\n             super<B>.foo() // <== 'B' が唯一のスーパータイプであるため冗長です\n          }\n      }\n\n      interface I {\n          fun foo() {}\n      }\n\n      class C : B(), I {\n          override fun foo() {\n              super<B>.foo() // <== here <B> 'B.foo()' を 'I.foo()' と区別するには修飾子が必要です\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      open class B {\n          open fun foo(){}\n      }\n\n      class A : B() {\n          override fun foo() {\n             super.foo() // <== 更新後\n          }\n      }\n\n      interface I {\n          fun foo() {}\n      }\n\n      class C : B(), I {\n          override fun foo() {\n              super<B>.foo()\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveExplicitSuperQualifier",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantExplicitType",
                "shortDescription": {
                  "text": "明らかに明示的な型"
                },
                "fullDescription": {
                  "text": "ローカル変数の明示的に指定されている型で、'val f: Foo = Foo()' のように明らかに冗長なものを報告します。 例: 'class Point(val x: Int, val y: Int)\n\n  fun foo() {\n      val t: Boolean = true\n      val p: Point = Point(1, 2)\n      val i: Int = 42\n  }' クイックフィックス適用後: 'class Point(val x: Int, val y: Int)\n\n  fun foo() {\n      val t = true\n      val p = Point(1, 2)\n      val i = 42\n  }'",
                  "markdown": "ローカル変数の明示的に指定されている型で、`val f: Foo = Foo()` のように明らかに冗長なものを報告します。\n\n**例:**\n\n\n      class Point(val x: Int, val y: Int)\n\n      fun foo() {\n          val t: Boolean = true\n          val p: Point = Point(1, 2)\n          val i: Int = 42\n      }\n\nクイックフィックス適用後:\n\n\n      class Point(val x: Int, val y: Int)\n\n      fun foo() {\n          val t = true\n          val p = Point(1, 2)\n          val i = 42\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantExplicitType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedSymbol",
                "shortDescription": {
                  "text": "未使用のシンボル"
                },
                "fullDescription": {
                  "text": "使用されていない、またはエントリポイントから到達できないシンボルを報告します。",
                  "markdown": "使用されていない、またはエントリポイントから到達できないシンボルを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "unused",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousVarProperty",
                "shortDescription": {
                  "text": "疑わしい 'var' プロパティ: setter は getter 結果に影響を与えません"
                },
                "fullDescription": {
                  "text": "バッキングフィールドを参照しないデフォルトの setter と getter を持つ 'var' プロパティを報告します。 このようなプロパティは setter の呼び出しには影響しません。したがって、このようなプロパティを 'val' に変更し、イニシャライザーを削除した方が分かりやすくなります。 「val に変更してイニシャライザーを削除」クイックフィックスを使用すると、コードを自動的に修正できます。 例: '// このプロパティは常に '1' を返すため、プロパティが 'var' であることは重要ではありません\n  var foo: Int = 0\n      get() = 1'",
                  "markdown": "バッキングフィールドを参照しないデフォルトの setter と getter を持つ `var` プロパティを報告します。\n\n\nこのようなプロパティは setter の呼び出しには影響しません。したがって、このようなプロパティを `val` に変更し、イニシャライザーを削除した方が分かりやすくなります。\n\n「**val に変更してイニシャライザーを削除**」クイックフィックスを使用すると、コードを自動的に修正できます。\n\n例:\n\n\n      // このプロパティは常に '1' を返すため、プロパティが 'var' であることは重要ではありません\n      var foo: Int = 0\n          get() = 1\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousVarProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceCollectionCountWithSize",
                "shortDescription": {
                  "text": "コレクションのカウントはサイズに変換できます"
                },
                "fullDescription": {
                  "text": "'Collection<T>.count()' の呼び出しを報告します。 この関数呼び出しは '.size' に置換できます。 '.size' 形式を使用すると確実に演算を O(1) にして別オブジェクトの割り当てを防ぐことができますが、'count()' は O(n) であり、かつオブジェクトを割り当てる 'Iterable<T>.count()' と混同される可能性があります。 例: 'fun foo() {\n      var list = listOf(1,2,3)\n      list.count() // 置換可能な 'count()'\n  }' クイックフィックス適用後: 'fun foo() {\n      var list = listOf(1,2,3)\n      list.size\n  }'",
                  "markdown": "`Collection<T>.count()` の呼び出しを報告します。\n\n\nこの関数呼び出しは `.size` に置換できます。\n\n\n`.size` 形式を使用すると確実に演算を O(1) にして別オブジェクトの割り当てを防ぐことができますが、`count()` は O(n) であり、かつオブジェクトを割り当てる `Iterable<T>.count()` と混同される可能性があります。\n\n\n**例:**\n\n      fun foo() {\n          var list = listOf(1,2,3)\n          list.count() // 置換可能な 'count()'\n      }\n\nクイックフィックス適用後:\n\n      fun foo() {\n          var list = listOf(1,2,3)\n          list.size\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceCollectionCountWithSize",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceArrayEqualityOpWithArraysEquals",
                "shortDescription": {
                  "text": "'==' と '!=' による配列の比較"
                },
                "fullDescription": {
                  "text": "配列に対して使用されている演算子 '==' または '!=' で、'contentEquals()' に置換するべきであるものを報告します。 演算子 '==' と '!=' は配列の中身ではなく、参照先を比較します。 例: 'fun test() {\n      val a = arrayOf(1, 2, 3)\n      val b = arrayOf(1, 2, 3)\n      println(a == b) // 参照の比較  }' クイックフィックス適用後: 'fun test() {\n      val a = arrayOf(1, 2, 3)\n      val b = arrayOf(1, 2, 3)\n      println(a.contentEquals(b))\n  }'",
                  "markdown": "配列に対して使用されている演算子 `==` または `!=` で、`contentEquals()` に置換するべきであるものを報告します。\n\n\n演算子 `==` と `!=` は配列の中身ではなく、参照先を比較します。\n\n**例:**\n\n      fun test() {\n          val a = arrayOf(1, 2, 3)\n          val b = arrayOf(1, 2, 3)\n          println(a == b) // 参照の比較  }\n\nクイックフィックス適用後:\n\n      fun test() {\n          val a = arrayOf(1, 2, 3)\n          val b = arrayOf(1, 2, 3)\n          println(a.contentEquals(b))\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceArrayEqualityOpWithArraysEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaCollectionsStaticMethod",
                "shortDescription": {
                  "text": "Java コレクションの static メソッドの呼び出しは Kotlin stdlib に置換できます"
                },
                "fullDescription": {
                  "text": "Java 'Collections' の static メソッドの呼び出しで、Kotlin stdlib に置換できるものを報告します。 例: 'import java.util.Collections\n\n  fun test() {\n      val mutableList = mutableListOf(1, 2)\n      Collections.fill(mutableList, 3)\n  }' クイックフィックスを使用すると、Java 'Collections' の static メソッドの呼び出しが対応する Kotlin stdlib メソッドの呼び出しに置換されます。 'import java.util.Collections\n\n  fun test() {\n      val mutableList = mutableListOf(1, 2)\n      mutableList.fill(3)\n  }'",
                  "markdown": "Java `Collections` の static メソッドの呼び出しで、Kotlin stdlib に置換できるものを報告します。\n\n**例:**\n\n\n      import java.util.Collections\n\n      fun test() {\n          val mutableList = mutableListOf(1, 2)\n          Collections.fill(mutableList, 3)\n      }\n\nクイックフィックスを使用すると、Java `Collections` の static メソッドの呼び出しが対応する Kotlin stdlib メソッドの呼び出しに置換されます。\n\n\n      import java.util.Collections\n\n      fun test() {\n          val mutableList = mutableListOf(1, 2)\n          mutableList.fill(3)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JavaCollectionsStaticMethod",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MoveVariableDeclarationIntoWhen",
                "shortDescription": {
                  "text": "変数宣言は 'when' の内部に移動できます"
                },
                "fullDescription": {
                  "text": "'when' 式内に移動できる変数宣言を報告します。 例: 'fun someCalc(x: Int) = x * 42\n\nfun foo(x: Int): Int {\n  val a = someCalc(x)\n  return when (a) {\n    1 -> a\n    2 -> 2 * a\n    else -> 24\n  }\n}' クイックフィックス適用後: 'fun foo(x: Int): Int {\n  return when (val a = someCalc(x)) {\n    1 -> a\n    2 -> 2 * a\n    else -> 24\n  }\n}'",
                  "markdown": "`when` 式内に移動できる変数宣言を報告します。\n\n**例:**\n\n\n    fun someCalc(x: Int) = x * 42\n\n    fun foo(x: Int): Int {\n      val a = someCalc(x)\n      return when (a) {\n        1 -> a\n        2 -> 2 * a\n        else -> 24\n      }\n    }\n\nクイックフィックス適用後:\n\n\n    fun foo(x: Int): Int {\n      return when (val a = someCalc(x)) {\n        1 -> a\n        2 -> 2 * a\n        else -> 24\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MoveVariableDeclarationIntoWhen",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedGradleDependency",
                "shortDescription": {
                  "text": "Gradle での非推奨ライブラリの使用"
                },
                "fullDescription": {
                  "text": "Gradle のビルドスクリプトに記載されている非推奨の依存関係を報告します。 例: 'dependencies {\n      compile \"org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.0\"\n  }' クイックフィックス適用後: 'dependencies {\n      compile \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.2.0\"\n  }'",
                  "markdown": "Gradle のビルドスクリプトに記載されている非推奨の依存関係を報告します。\n\n**例:**\n\n\n      dependencies {\n          compile \"org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.0\"\n      }\n\nクイックフィックス適用後:\n\n\n      dependencies {\n          compile \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.2.0\"\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeprecatedGradleDependency",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastDueToProgressionResolutionChangeMigration",
                "shortDescription": {
                  "text": "1.9 以降のプログレッションの解像度の変更"
                },
                "fullDescription": {
                  "text": "オーバーロードされた関数の呼び出しで、引数を明示的にキャストして適切な宣言に解決する必要があるものを報告します。 現在のコンパイラー警告 (Kotlin 1.6.20 から提供) は、Kotlin 1.8 ではエラーになります。 等差数列と範囲型 ('kotlin.ranges') は、Kotlin 1.9 以降では 'Collection' インターフェースの実装を開始します。 この更新により、オーバーロードされた関数の解決に変更が生じます。 たとえば、以下の例では 'test(1..5)' の呼び出しは Kotlin 1.8 以前では 'test(t: Any)' に、Kotlin 1.9 以降では 'test(t: Collection<*>)' に解決されます。 'fun test(t: Any) { }\n  fun test(t: Collection<*>) { }\n  fun invoke() {\n    test(1..5) // 1.9 では IntRange はコレクションになります\n  }' 提供されるクイックフィックスは、バージョン 1.8 以前のコンパイラー固有の動作を捕捉します。 'fun test(t: Any) { }\n  fun test(t: Collection<*>) { }\n\n  fun invoke() {\n    test(1..5) // Kotlin 1.9 より前では 'test(t: T)' に解決されます\n  }' クイックフィックス適用後: 'fun test(t: Any) { }\n  fun test(t: Collection<*>) { }\n\n  fun invoke() {\n    test((1..5) as Iterable<Int>) // Kotlin 1.9 では 'test(t: T)' に解決されます\n  }' このインスペクションは Kotlin の言語レベルが 1.6 以降の場合に使用できます。",
                  "markdown": "オーバーロードされた関数の呼び出しで、引数を明示的にキャストして適切な宣言に解決する必要があるものを報告します。\n現在のコンパイラー警告 (Kotlin 1.6.20 から提供) は、Kotlin 1.8 ではエラーになります。\n\n\n等差数列と範囲型 (`kotlin.ranges`) は、Kotlin 1.9 以降では `Collection` インターフェースの実装を開始します。 この更新により、オーバーロードされた関数の解決に変更が生じます。 たとえば、以下の例では `test(1..5)` の呼び出しは Kotlin 1.8 以前では `test(t: Any)` に、Kotlin 1.9 以降では `test(t: Collection<*>)` に解決されます。\n\n\n      fun test(t: Any) { }\n      fun test(t: Collection<*>) { }\n      fun invoke() {\n        test(1..5) // 1.9 では IntRange はコレクションになります\n      }\n\n提供されるクイックフィックスは、バージョン 1.8 以前のコンパイラー固有の動作を捕捉します。\n\n\n      fun test(t: Any) { }\n      fun test(t: Collection<*>) { }\n\n      fun invoke() {\n        test(1..5) // Kotlin 1.9 より前では 'test(t: T)' に解決されます\n      }\n\nクイックフィックス適用後:\n\n\n      fun test(t: Any) { }\n      fun test(t: Collection<*>) { }\n\n      fun invoke() {\n        test((1..5) as Iterable<Int>) // Kotlin 1.9 では 'test(t: T)' に解決されます\n      }\n\nこのインスペクションは Kotlin の言語レベルが 1.6 以降の場合に使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CastDueToProgressionResolutionChangeMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveEmptyParenthesesFromAnnotationEntry",
                "shortDescription": {
                  "text": "不要な丸括弧の除去"
                },
                "fullDescription": {
                  "text": "アノテーションエントリに使用されている冗長な空の丸括弧を報告します。 コードをクリーンアップするには、'不要な丸括弧の除去' クイックフィックスを使用します。 例: 'annotation class MyAnnotationA\n  annotation class MyAnnotationB(val x: Int)\n  annotation class MyAnnotationC(val x: Int = 10) // デフォルト値が存在している\n\n  @MyAnnotationA() // <== 丸括弧は冗長\n  fun testA() {\n  }\n\n  @MyAnnotationB() // <== 引数がない、丸括弧が必要\n  fun testB() {\n  }\n\n  @MyAnnotationC() // <== 丸括弧は冗長\n  fun testC() {\n  }'",
                  "markdown": "アノテーションエントリに使用されている冗長な空の丸括弧を報告します。\n\nコードをクリーンアップするには、'不要な丸括弧の除去' クイックフィックスを使用します。\n\n**例:**\n\n\n      annotation class MyAnnotationA\n      annotation class MyAnnotationB(val x: Int)\n      annotation class MyAnnotationC(val x: Int = 10) // デフォルト値が存在している\n\n      @MyAnnotationA() // <== 丸括弧は冗長\n      fun testA() {\n      }\n\n      @MyAnnotationB() // <== 引数がない、丸括弧が必要\n      fun testB() {\n      }\n\n      @MyAnnotationC() // <== 丸括弧は冗長\n      fun testC() {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveEmptyParenthesesFromAnnotationEntry",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableCallChain",
                "shortDescription": {
                  "text": "コレクション型に対する呼び出しチェーンは単純化できます"
                },
                "fullDescription": {
                  "text": "1 回の呼び出しに置換できる 2 回の連鎖する呼び出しを報告します。 そのような置換を行うと、冗長なコードの実行を避けることができます。 クイックフィックスを使用すると、連鎖する呼び出しが単一の呼び出しに置換されます。 例: 'fun main() {\n      listOf(1, 2, 3).filter { it > 1 }.count()\n  }' クイックフィックス適用後: 'fun main() {\n      listOf(1, 2, 3).count { it > 1 }\n  }'",
                  "markdown": "1 回の呼び出しに置換できる 2 回の連鎖する呼び出しを報告します。\n\nそのような置換を行うと、冗長なコードの実行を避けることができます。\n\nクイックフィックスを使用すると、連鎖する呼び出しが単一の呼び出しに置換されます。\n\n**例:**\n\n\n      fun main() {\n          listOf(1, 2, 3).filter { it > 1 }.count()\n      }\n\nクイックフィックス適用後:\n\n\n      fun main() {\n          listOf(1, 2, 3).count { it > 1 }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifiableCallChain",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertReferenceToLambda",
                "shortDescription": {
                  "text": "ラムダに置換できます"
                },
                "fullDescription": {
                  "text": "関数リテラル (ラムダ) に置換できる関数参照式を報告します。 ラムダを渡すことでコードが理解しやすくなり、コード全体の一貫性が向上する場合があります。 また、単純な呼び出しを複雑な呼び出しに置換する必要がある場合は、クイックフィックスが重宝するかもしれません。 例: 'fun Int.isEven() = this % 2 == 0\n\n  fun example() {\n      val numbers = listOf(1, 2, 4, 7, 9, 10)\n      val evenNumbers = numbers.filter(Int::isEven)\n  }' クイックフィックス適用後: 'fun Int.isEven() = this % 2 == 0\n\n  fun example() {\n      val numbers = listOf(1, 2, 4, 7, 9, 10)\n      val evenNumbers = numbers.filter { it.isEven() }\n  }'",
                  "markdown": "関数リテラル (ラムダ) に置換できる関数参照式を報告します。\n\n\nラムダを渡すことでコードが理解しやすくなり、コード全体の一貫性が向上する場合があります。\nまた、単純な呼び出しを複雑な呼び出しに置換する必要がある場合は、クイックフィックスが重宝するかもしれません。\n\n**例:**\n\n\n      fun Int.isEven() = this % 2 == 0\n\n      fun example() {\n          val numbers = listOf(1, 2, 4, 7, 9, 10)\n          val evenNumbers = numbers.filter(Int::isEven)\n      }\n\nクイックフィックス適用後:\n\n\n      fun Int.isEven() = this % 2 == 0\n\n      fun example() {\n          val numbers = listOf(1, 2, 4, 7, 9, 10)\n          val evenNumbers = numbers.filter { it.isEven() }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertReferenceToLambda",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceCallWithBinaryOperator",
                "shortDescription": {
                  "text": "二項演算子に置換できます"
                },
                "fullDescription": {
                  "text": "二項演算子に置換できる関数 (特に比較関連の関数) の呼び出しを報告します。 例: 'fun test(): Boolean {\n      return 2.compareTo(1) > 0 // 置換可能な 'compareTo()'\n  }' クイックフィックス適用後: 'fun test(): Boolean {\n      return 2 > 1\n  }'",
                  "markdown": "二項演算子に置換できる関数 (特に比較関連の関数) の呼び出しを報告します。\n\n**例:**\n\n      fun test(): Boolean {\n          return 2.compareTo(1) > 0 // 置換可能な 'compareTo()'\n      }\n\nクイックフィックス適用後:\n\n      fun test(): Boolean {\n          return 2 > 1\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceCallWithBinaryOperator",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplacePrintlnWithLogging",
                "shortDescription": {
                  "text": "'print()' または 'println()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'print' または 'println' の使用箇所を報告します。 このようなステートメントは一時的なデバッグによく使用されるため、プロダクションコードから除去するか、より堅牢なログ機能に置換する必要があります。",
                  "markdown": "`print` または `println` の使用箇所を報告します。\n\nこのようなステートメントは一時的なデバッグによく使用されるため、プロダクションコードから除去するか、より堅牢なログ機能に置換する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplacePrintlnWithLogging",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/他の問題",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnlabeledReturnInsideLambda",
                "shortDescription": {
                  "text": "ラムダ内のラベルのない return"
                },
                "fullDescription": {
                  "text": "インラインラムダの中にあるラベルのない 'return' 式を報告します。 このような式は 'return' に属しているスコープが不明確な場合があり、混乱を招く可能性があります。 「return@ に変更…」クイックフィックスを使用すると、コードを自動的に修正できます。 例: 'fun test(list: List<Int>) {\n      list.forEach {\n          // この return 式は関数 test から返却します\n          // スコープを変更するため return@forEach に変更できます\n          if (it == 10) return\n      }\n  }' クイックフィックス適用後: 'fun test(list: List<Int>) {\n      list.forEach {\n          if (it == 10) return@test\n      }\n  }'",
                  "markdown": "インラインラムダの中にあるラベルのない `return` 式を報告します。\n\nこのような式は `return` に属しているスコープが不明確な場合があり、混乱を招く可能性があります。\n\n「**return@ に変更...**」クイックフィックスを使用すると、コードを自動的に修正できます。\n\n例:\n\n\n      fun test(list: List<Int>) {\n          list.forEach {\n              // この return 式は関数 test から返却します\n              // スコープを変更するため return@forEach に変更できます\n              if (it == 10) return\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun test(list: List<Int>) {\n          list.forEach {\n              if (it == 10) return@test\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnlabeledReturnInsideLambda",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedUnaryOperator",
                "shortDescription": {
                  "text": "未使用の単項演算子"
                },
                "fullDescription": {
                  "text": "式にある使用されていない数値型の単項演算子を報告します。 単項演算子を波括弧なしで使用すると、先行する式が壊れます。 そのため、複数行に渡る数式は誤解を招く可能性があります。 例: 'fun main() {\n      val result = 1 + 2 * 3\n                  + 3              // <== '+ 3' は 'result' 変数のものではないため使用されません\n      println(\"Result = $result\")  // この結果は期待値だと思われる '10' ではなく '7' になります\n  }'",
                  "markdown": "式にある使用されていない数値型の単項演算子を報告します。\n\n単項演算子を波括弧なしで使用すると、先行する式が壊れます。\nそのため、複数行に渡る数式は誤解を招く可能性があります。\n\n例:\n\n\n      fun main() {\n          val result = 1 + 2 * 3\n                      + 3              // <== '+ 3' は 'result' 変数のものではないため使用されません\n          println(\"Result = $result\")  // この結果は期待値だと思われる '10' ではなく '7' になります\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedUnaryOperator",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AddConversionCallMigration",
                "shortDescription": {
                  "text": "1.9 以降に必要な `Int` からの明示的な変換"
                },
                "fullDescription": {
                  "text": "型が 'Int' になるため、Kotlin 1.9 以降でコンパイルエラーを引き起こす式を報告します。 例: 'fun takeByte(x: Byte) {}\n\n  fun foo() {\n      takeByte(1 + 1) // 1.9 では Int に解決されます\n  }' クイックフィックス適用後: 'fun takeByte(x: Byte) {}\n\n  fun foo() {\n      takeByte((1 + 1).toByte()) // 1.9 では Int に解決されます\n  }' このインスペクションは Kotlin の言語レベルが 1.7 以降の場合に使用できます。",
                  "markdown": "型が `Int` になるため、Kotlin 1.9 以降でコンパイルエラーを引き起こす式を報告します。\n\n例:\n\n\n      fun takeByte(x: Byte) {}\n\n      fun foo() {\n          takeByte(1 + 1) // 1.9 では Int に解決されます\n      }\n\nクイックフィックス適用後:\n\n\n      fun takeByte(x: Byte) {}\n\n      fun foo() {\n          takeByte((1 + 1).toByte()) // 1.9 では Int に解決されます\n      }\n\nこのインスペクションは Kotlin の言語レベルが 1.7 以降の場合に使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AddConversionCallMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LateinitVarOverridesLateinitVar",
                "shortDescription": {
                  "text": "'lateinit var' プロパティが 'lateinit var' プロパティをオーバーライドしています"
                },
                "fullDescription": {
                  "text": "他の 'lateinit var' プロパティをオーバーライドしている 'lateinit var' プロパティを報告します。 サブクラスのインスタンスは 1 つのプロパティに対してフィールドを 2 つ持ち、スーパークラスのフィールドは実質的に未使用のままとなります。 例: 'open class BaseClass {\n      open lateinit var name: String\n    }\n\n    class RealClass : BaseClass() {\n      override lateinit var name: String\n    }'",
                  "markdown": "他の `lateinit var` プロパティをオーバーライドしている `lateinit var` プロパティを報告します。\n\nサブクラスのインスタンスは 1 つのプロパティに対してフィールドを 2 つ持ち、スーパークラスのフィールドは実質的に未使用のままとなります。\n\n**例:**\n\n\n        open class BaseClass {\n          open lateinit var name: String\n        }\n\n        class RealClass : BaseClass() {\n          override lateinit var name: String\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LateinitVarOverridesLateinitVar",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VerboseNullabilityAndEmptiness",
                "shortDescription": {
                  "text": "詳細な null 許容性と空かどうかのチェック"
                },
                "fullDescription": {
                  "text": "単一のチェックに単純化できる 'null' チェックと空チェックの組み合わせを報告します。 クイックフィックスを使用すると、ハイライトされたチェックが 'isNullOrEmpty()' のような複合チェックの呼び出しに置換されます。 例: 'fun test(list: List<Int>?) {\n      if (list == null || list.isEmpty()) {\n          println(\"List is empty!\")\n      } else {\n          println(list.joinToString())\n      }\n  }' クイックフィックス適用後: 'fun test(list: List<Int>?) {\n      if (list.isNullOrEmpty()) {\n          println(\"List is empty!\")\n      } else {\n          println(list.joinToString())\n      }\n  }'",
                  "markdown": "単一のチェックに単純化できる `null` チェックと空チェックの組み合わせを報告します。\n\nクイックフィックスを使用すると、ハイライトされたチェックが `isNullOrEmpty()` のような複合チェックの呼び出しに置換されます。\n\n**例:**\n\n\n      fun test(list: List<Int>?) {\n          if (list == null || list.isEmpty()) {\n              println(\"List is empty!\")\n          } else {\n              println(list.joinToString())\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun test(list: List<Int>?) {\n          if (list.isNullOrEmpty()) {\n              println(\"List is empty!\")\n          } else {\n              println(list.joinToString())\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "VerboseNullabilityAndEmptiness",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassName",
                "shortDescription": {
                  "text": "クラスの命名規則"
                },
                "fullDescription": {
                  "text": "推奨されている命名規則に従っていないクラス名を報告します。 命名方法に一貫性を持たせると、コードが読みやすく、理解しやすくなります。 Kotlin 公式スタイルガイドによると、クラス名には大文字から始まるキャメルケースを使用する必要があります。 正規表現の \"パターン\" を変更することで、他の命名規則を導入できます。 例: 'class user(val name: String)' クイックフィックスを使用すると、クラス名が Kotlin の命名規則に従って変更されます。 'class User(val name: String)'",
                  "markdown": "推奨されている命名規則に従っていないクラス名を報告します。\n\n\n命名方法に一貫性を持たせると、コードが読みやすく、理解しやすくなります。\n[Kotlin 公式スタイルガイド](https://kotlinlang.org/docs/coding-conventions.html#naming-rules)によると、クラス名には大文字から始まるキャメルケースを使用する必要があります。\n\n正規表現の \"パターン\" を変更することで、他の命名規則を導入できます。\n\n**例:**\n\n\n      class user(val name: String)\n\nクイックフィックスを使用すると、クラス名が Kotlin の命名規則に従って変更されます。\n\n\n      class User(val name: String)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ClassName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名規約",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveEmptyPrimaryConstructor",
                "shortDescription": {
                  "text": "冗長な空のプライマリコンストラクター"
                },
                "fullDescription": {
                  "text": "空のプライマリコンストラクターで、宣言しなくてもデフォルトで使用できるものを報告します。 アノテーションも可視性修飾子もないプライマリコンストラクターは冗長であるため、省略しても問題はありません。 コードをクリーンアップするには、'空のプライマリコンストラクターを除去' クイックフィックスを使用します。 例: 'class MyClassA constructor() //  冗長、'class MyClassA' に置換できます\n\n  annotation class MyAnnotation\n  class MyClassB @MyAnnotation constructor() //  アノテーションがあるため必要\n\n  class MyClassC private constructor() // 可視性修飾子があるため必要'",
                  "markdown": "空のプライマリコンストラクターで、宣言しなくてもデフォルトで使用できるものを報告します。\n\n\nアノテーションも可視性修飾子もないプライマリコンストラクターは冗長であるため、省略しても問題はありません。\nコードをクリーンアップするには、'空のプライマリコンストラクターを除去' クイックフィックスを使用します。\n\n**例:**\n\n\n      class MyClassA constructor() //  冗長、'class MyClassA' に置換できます\n\n      annotation class MyAnnotation\n      class MyClassB @MyAnnotation constructor() //  アノテーションがあるため必要\n\n      class MyClassC private constructor() // 可視性修飾子があるため必要\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveEmptyPrimaryConstructor",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveEmptySecondaryConstructorBody",
                "shortDescription": {
                  "text": "冗長なコンストラクターの本体"
                },
                "fullDescription": {
                  "text": "セカンダリコンストラクターの空の本体を報告します。",
                  "markdown": "セカンダリコンストラクターの空の本体を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveEmptySecondaryConstructorBody",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FloatingPointLiteralPrecision",
                "shortDescription": {
                  "text": "有効な精度を超えている浮動小数点リテラル"
                },
                "fullDescription": {
                  "text": "IEEE 754 の 'Float' 型と 'Double' 型を使用して、必要な精度で表すことができない浮動小数点リテラルを報告します。 たとえば '1.9999999999999999999' は有効な数値が多すぎるため、'Double' としての表記は '2.0' に丸められます。 過剰な数値を指定すると、誤解を招く可能性があります。計算時には丸められた値が代わりに使用されるという事実が分からなくなるためです。 クイックフィックスを使用すると、リテラルが定数の実際の表記に一致する丸められた値に置換されます。 例: 'val x: Float = 3.14159265359f' クイックフィックス適用後: 'val x: Float = 3.1415927f'",
                  "markdown": "[IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) の `Float` 型と `Double` 型を使用して、必要な精度で表すことができない浮動小数点リテラルを報告します。\n\n\nたとえば `1.9999999999999999999` は有効な数値が多すぎるため、`Double` としての表記は `2.0` に丸められます。\n過剰な数値を指定すると、誤解を招く可能性があります。計算時には丸められた値が代わりに使用されるという事実が分からなくなるためです。\n\n\nクイックフィックスを使用すると、リテラルが定数の実際の表記に一致する丸められた値に置換されます。\n\n**例:**\n\n\n      val x: Float = 3.14159265359f\n\nクイックフィックス適用後:\n\n\n      val x: Float = 3.1415927f\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FloatingPointLiteralPrecision",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/他の問題",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DifferentKotlinGradleVersion",
                "shortDescription": {
                  "text": "Kotlin Gradle と IDE プラグインのバージョンが異なります"
                },
                "fullDescription": {
                  "text": "Gradle プラグインのバージョンが現在の IDE プラグインで適切にサポートされていないことを報告します。 バージョンが違うと、IDE と Gradle のビルド間でエラー報告やコードの動作が矛盾する場合があります。 例: 'dependencies {\n    classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:0.0.1\"\n  }' この問題を修正するには、IDE プラグインにバンドルされている Kotlin のバージョンに合うように Kotlin Gradle プラグインのバージョンを変更してください。",
                  "markdown": "Gradle プラグインのバージョンが現在の IDE プラグインで適切にサポートされていないことを報告します。\n\nバージョンが違うと、IDE と Gradle のビルド間でエラー報告やコードの動作が矛盾する場合があります。\n\n**例:**\n\n\n      dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:0.0.1\"\n      }\n\nこの問題を修正するには、IDE プラグインにバンドルされている Kotlin のバージョンに合うように Kotlin Gradle プラグインのバージョンを変更してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DifferentKotlinGradleVersion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertPairConstructorToToFunction",
                "shortDescription": {
                  "text": "Pair コンストラクターを 'to' 関数に変換"
                },
                "fullDescription": {
                  "text": "'to()' 中置関数の呼び出しに置換できる 'Pair' コンストラクターの呼び出しを報告します。 コンストラクターを明示的に呼び出すと、(複数回に渡って使用される場合は特に) コードの冗長性が増す可能性があります。 コンストラクターの呼び出しを 'to()' に置換すると、コードの可読性とメンテナンス性が向上します。 例: 'val countries = mapOf(\n      Pair(\"France\", \"Paris\"),\n      Pair(\"Spain\", \"Madrid\"),\n      Pair(\"Germany\", \"Berlin\")\n  )' クイックフィックス適用後: 'val countries = mapOf(\n      \"France\" to \"Paris\",\n      \"Spain\" to \"Madrid\",\n      \"Germany\" to \"Berlin\"\n  )'",
                  "markdown": "`to()` 中置関数の呼び出しに置換できる `Pair` コンストラクターの呼び出しを報告します。\n\n\nコンストラクターを明示的に呼び出すと、(複数回に渡って使用される場合は特に) コードの冗長性が増す可能性があります。\nコンストラクターの呼び出しを `to()` に置換すると、コードの可読性とメンテナンス性が向上します。\n\n**例:**\n\n\n      val countries = mapOf(\n          Pair(\"France\", \"Paris\"),\n          Pair(\"Spain\", \"Madrid\"),\n          Pair(\"Germany\", \"Berlin\")\n      )\n\nクイックフィックス適用後:\n\n\n      val countries = mapOf(\n          \"France\" to \"Paris\",\n          \"Spain\" to \"Madrid\",\n          \"Germany\" to \"Berlin\"\n      )\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertPairConstructorToToFunction",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantGetter",
                "shortDescription": {
                  "text": "冗長なプロパティ getter"
                },
                "fullDescription": {
                  "text": "プロパティの冗長な getter を報告します。 例: 'class Test {\n      val a = 1\n          get\n      val b = 1\n          get() = field\n  }' クイックフィックス適用後: 'class Test {\n      val a = 1\n      val b = 1\n  }'",
                  "markdown": "プロパティの冗長な getter を報告します。\n\n**例:**\n\n\n      class Test {\n          val a = 1\n              get\n          val b = 1\n              get() = field\n      }\n\nクイックフィックス適用後:\n\n\n      class Test {\n          val a = 1\n          val b = 1\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantGetter",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantIf",
                "shortDescription": {
                  "text": "冗長な 'if' ステートメント"
                },
                "fullDescription": {
                  "text": "単一のステートメントに単純化できる 'if' ステートメントを報告します。 例: 'fun test(): Boolean {\n      if (foo()) {\n         return true\n      } else {\n         return false\n      }\n  }' クイックフィックス適用後: 'fun test(): Boolean {\n      return foo()\n  }'",
                  "markdown": "単一のステートメントに単純化できる `if` ステートメントを報告します。\n\n**例:**\n\n\n      fun test(): Boolean {\n          if (foo()) {\n             return true\n          } else {\n             return false\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun test(): Boolean {\n          return foo()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantIf",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KDocMissingDocumentation",
                "shortDescription": {
                  "text": "public 宣言の KDoc コメントがありません"
                },
                "fullDescription": {
                  "text": "KDoc コメントがない public 宣言を報告します。 例: 'class A' クイックフィックスを使用すると、宣言の上にコメントブロックが生成されます。 '/**\n   *\n   */\n  class A'",
                  "markdown": "KDoc コメントがない public 宣言を報告します。\n\n**例:**\n\n\n      class A\n\nクイックフィックスを使用すると、宣言の上にコメントブロックが生成されます。\n\n\n      /**\n       *\n       */\n      class A\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KDocMissingDocumentation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/他の問題",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinEqualsBetweenInconvertibleTypes",
                "shortDescription": {
                  "text": "互換性のない型のオブジェクト間の 'equals()'"
                },
                "fullDescription": {
                  "text": "レシーバーと引数が互換性の無いプリミティブ型、列挙型または文字列型である 'equals()' の呼び出しを報告します。 このような呼び出しは理屈の上では役に立つ場合もありますが、バグの可能性が高いです。 例: '5.equals(\"\");'",
                  "markdown": "レシーバーと引数が互換性の無いプリミティブ型、列挙型または文字列型である `equals()` の呼び出しを報告します。\n\nこのような呼び出しは理屈の上では役に立つ場合もありますが、バグの可能性が高いです。\n\n**例:**\n\n      5.equals(\"\");\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsBetweenInconvertibleTypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JoinDeclarationAndAssignment",
                "shortDescription": {
                  "text": "宣言と代入の結合"
                },
                "fullDescription": {
                  "text": "後続の代入式と結合できるプロパティ宣言を報告します。 例: 'val x: String\n  x = System.getProperty(\"\")' クイックフィックスを使用すると、対象の宣言が代入式と結合されます。 'val x = System.getProperty(\"\")' インスペクションの構成: 「メンバープロパティの複雑な初期化を報告する」オプションを無効にすると、複雑な初期化を持つプロパティをスキップできます。 このオプションは以下の 2 つの状況に対応しています。 プロパティイニシャライザーが複雑である (複数行または複合/制御フロー式になっている) プロパティが最初に初期化された直後に後続のコードで使用されている (例: 追加の初期化メソッドを呼び出すために使用されている)",
                  "markdown": "後続の代入式と結合できるプロパティ宣言を報告します。\n\n**例:**\n\n\n      val x: String\n      x = System.getProperty(\"\")\n\nクイックフィックスを使用すると、対象の宣言が代入式と結合されます。\n\n\n      val x = System.getProperty(\"\")\n\nインスペクションの構成:\n\n「**メンバープロパティの複雑な初期化を報告する**」オプションを無効にすると、複雑な初期化を持つプロパティをスキップできます。 このオプションは以下の 2 つの状況に対応しています。\n\n1. プロパティイニシャライザーが複雑である (複数行または複合/制御フロー式になっている)\n2. プロパティが最初に初期化された直後に後続のコードで使用されている (例: 追加の初期化メソッドを呼び出すために使用されている)"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JoinDeclarationAndAssignment",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveExplicitTypeArguments",
                "shortDescription": {
                  "text": "不要な型引数"
                },
                "fullDescription": {
                  "text": "自動的に推論できる型引数を持つ関数呼び出しを報告します。 このような型引数は不要であるため、安全に除去できます。 コードをクリーンアップするには、'明示的な型引数の除去' クイックフィックスを使用します。 例: '// ここの 'String' 型は推論できる\n  fun foo(): MutableList<String> = mutableListOf<String>()\n\n  // ここの 'String' は推論できないため型引数が必要。\n  fun bar() = mutableListOf<String>()' クイックフィックス適用後: 'fun foo(): MutableList<String> = mutableListOf() <== 更新後\n\n  fun bar() = mutableListOf<String>()'",
                  "markdown": "自動的に推論できる型引数を持つ関数呼び出しを報告します。 このような型引数は不要であるため、安全に除去できます。\n\nコードをクリーンアップするには、'明示的な型引数の除去' クイックフィックスを使用します。\n\n**例:**\n\n\n      // ここの 'String' 型は推論できる\n      fun foo(): MutableList<String> = mutableListOf<String>()\n\n      // ここの 'String' は推論できないため型引数が必要。\n      fun bar() = mutableListOf<String>()\n\nクイックフィックス適用後:\n\n\n      fun foo(): MutableList<String> = mutableListOf() <== 更新後\n\n      fun bar() = mutableListOf<String>()\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveExplicitTypeArguments",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HasPlatformType",
                "shortDescription": {
                  "text": "関数またはプロパティにプラットフォーム型があります"
                },
                "fullDescription": {
                  "text": "プラットフォーム型を持つ関数とプロパティを報告します。 予期しないエラーを防ぐため、型は明示的に宣言する必要があります。 例: 'fun foo() = java.lang.String.valueOf(1)' クイックフィックスを使用すると、戻り値の型が指定されます。 'fun foo(): String = java.lang.String.valueOf(1)'",
                  "markdown": "プラットフォーム型を持つ関数とプロパティを報告します。\n\n予期しないエラーを防ぐため、型は明示的に宣言する必要があります。\n\n**例:**\n\n\n      fun foo() = java.lang.String.valueOf(1)\n\nクイックフィックスを使用すると、戻り値の型が指定されます。\n\n\n      fun foo(): String = java.lang.String.valueOf(1)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "HasPlatformType",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 相互運用性の問題",
                      "index": 66,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantVisibilityModifier",
                "shortDescription": {
                  "text": "冗長な可視性修飾子"
                },
                "fullDescription": {
                  "text": "要素のデフォルトの可視性 (ほとんどの要素は 'public'、protected メンバーをオーバーライドするメンバーは 'protected') と一致している可視性修飾子を報告します。",
                  "markdown": "要素のデフォルトの可視性 (ほとんどの要素は `public`、protected メンバーをオーバーライドするメンバーは `protected`) と一致している可視性修飾子を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantVisibilityModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumValuesSoftDeprecateInJava",
                "shortDescription": {
                  "text": "Kotlin 1.9 以降は 'Enum.values()' を 'Enum.getEntries()' で置換することをお勧めします"
                },
                "fullDescription": {
                  "text": "Java から Kotlin 列挙型クラスの 'values()' メソッドへの呼び出しのうち、'getEntries()' に置換できるものを報告します。 'Enum.getEntries()' を使用すると、コードのパフォーマンスが改善する場合があります。 詳細: KT-48872 Enum.values() に対応するモダンでパフォーマンスの高い置換の提供",
                  "markdown": "Java から Kotlin 列挙型クラスの `values()` メソッドへの呼び出しのうち、`getEntries()` に置換できるものを報告します。\n\n\n`Enum.getEntries()` を使用すると、コードのパフォーマンスが改善する場合があります。\n\n\n**詳細:** [KT-48872 Enum.values() に対応するモダンでパフォーマンスの高い置換の提供](https://youtrack.jetbrains.com/issue/KT-48872)"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EnumValuesSoftDeprecateInJava",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/他の問題",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UsePropertyAccessSyntax",
                "shortDescription": {
                  "text": "プロパティアクセス構文に置換できるアクセサーの呼び出し"
                },
                "fullDescription": {
                  "text": "Java の 'get' と 'set' メソッドの呼び出しで、Kotlin の合成プロパティに置換できるものを報告します。 「プロパティアクセス構文の使用」クイックフィックスを使用すると、コードを自動的に修正できます。 例: '// Java:\n  public class JavaClassWithGetter {\n      private final String expr = \"result\";\n\n      // ...\n\n      public String getExpr() {\n          return expr;\n      }\n  }' '// Kotlin:\n  fun test(j: JavaClassWithGetter) {\n      // ...\n      j.getExpr() // <== クイックフィックスで式を 'j.expr' に単純化できます\n  }'",
                  "markdown": "Java の `get` と `set` メソッドの呼び出しで、Kotlin の合成プロパティに置換できるものを報告します。\n\n「**プロパティアクセス構文の使用**」クイックフィックスを使用すると、コードを自動的に修正できます。\n\n例:\n\n\n      // Java:\n      public class JavaClassWithGetter {\n          private final String expr = \"result\";\n\n          // ...\n\n          public String getExpr() {\n              return expr;\n          }\n      }\n\n\n      // Kotlin:\n      fun test(j: JavaClassWithGetter) {\n          // ...\n          j.getExpr() // <== クイックフィックスで式を 'j.expr' に単純化できます\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UsePropertyAccessSyntax",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseExpressionBody",
                "shortDescription": {
                  "text": "ここでは式本体の構文が推奨されます"
                },
                "fullDescription": {
                  "text": "式本体構文に置換できる 'return' 式 (ワンライナーまたは 'when') を報告します。 式本体構文の使用は、スタイルガイドで推奨されています。 「式本体に変換」クイックフィックスを使用すると、コードを自動的に修正できます。 例: 'fun sign(x: Int): Int {\n      return when { // <== 単純化できます\n          x < 0 -> -1\n          x > 0 -> 1\n          else -> 0\n      }\n  }' クイックフィックス適用後: 'fun sign(x: Int): Int = when {\n      x < 0 -> -1\n      x > 0 -> 1\n      else -> 0\n  }'",
                  "markdown": "式本体構文に置換できる `return` 式 (ワンライナーまたは `when`) を報告します。\n\n式本体構文の使用は、[スタイルガイド](https://kotlinlang.org/docs/coding-conventions.html#functions)で推奨されています。\n\n「**式本体に変換**」クイックフィックスを使用すると、コードを自動的に修正できます。\n\n例:\n\n\n      fun sign(x: Int): Int {\n          return when { // <== 単純化できます\n              x < 0 -> -1\n              x > 0 -> 1\n              else -> 0\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun sign(x: Int): Int = when {\n          x < 0 -> -1\n          x > 0 -> 1\n          else -> 0\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UseExpressionBody",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DataClassPrivateConstructor",
                "shortDescription": {
                  "text": "private データクラスのコンストラクターが 'copy' メソッドにより公開されています"
                },
                "fullDescription": {
                  "text": "データクラスの 'private' プライマリコンストラクターを報告します。 'data' クラスには、コンストラクターと同様に使用できる 'copy()' ファクトリメソッドがあります。 コンストラクターは、十分な安全性を提供する目的で 'private' にしてはいけません。 例: 'data class User private constructor(val name: String)' クイックフィックスを使用すると、コンストラクターの可視性修飾子が 'public' に変更されます。 'data class User(val name: String)'",
                  "markdown": "データクラスの `private` プライマリコンストラクターを報告します。\n\n\n`data` クラスには、コンストラクターと同様に使用できる `copy()` ファクトリメソッドがあります。\nコンストラクターは、十分な安全性を提供する目的で `private` にしてはいけません。\n\n**例:**\n\n\n      data class User private constructor(val name: String)\n\nクイックフィックスを使用すると、コンストラクターの可視性修飾子が `public` に変更されます。\n\n\n      data class User(val name: String)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DataClassPrivateConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantInnerClassModifier",
                "shortDescription": {
                  "text": "冗長な 'inner' 修飾子"
                },
                "fullDescription": {
                  "text": "クラスの 'inner' 修飾子が外部クラスのメンバーを参照していない場合、それを冗長なものとして報告します。 例: 'class Foo {\n      inner class InnerClass { // 冗長な `inner` 修飾子\n          fun hello() {\n              println(\"Hi!\")\n          }\n      }\n  }\n\n  class List {\n      val objects = Array<Any>(42) { Any() }\n\n      inner class Iterator { // 冗長ではない `inner` 修飾子\n          fun next(): Any {\n              return objects[0]\n          }\n      }\n  }' クイックフィックス適用後: 'class Foo {\n      class InnerClass { // 冗長な `inner` 修飾子\n          fun hello() {\n              println(\"Hi!\")\n          }\n      }\n  }\n\n  class List {\n      val objects = Array<Any>(42) { Any() }\n\n      inner class Iterator { // 冗長ではない `inner` 修飾子\n          fun next(): Any {\n              return objects[0]\n          }\n      }\n  }'",
                  "markdown": "クラスの `inner` 修飾子が外部クラスのメンバーを参照していない場合、それを冗長なものとして報告します。\n\n**例:**\n\n\n      class Foo {\n          inner class InnerClass { // 冗長な `inner` 修飾子\n              fun hello() {\n                  println(\"Hi!\")\n              }\n          }\n      }\n\n      class List {\n          val objects = Array<Any>(42) { Any() }\n\n          inner class Iterator { // 冗長ではない `inner` 修飾子\n              fun next(): Any {\n                  return objects[0]\n              }\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n          class InnerClass { // 冗長な `inner` 修飾子\n              fun hello() {\n                  println(\"Hi!\")\n              }\n          }\n      }\n\n      class List {\n          val objects = Array<Any>(42) { Any() }\n\n          inner class Iterator { // 冗長ではない `inner` 修飾子\n              fun next(): Any {\n                  return objects[0]\n              }\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantInnerClassModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaCollectionsStaticMethodOnImmutableList",
                "shortDescription": {
                  "text": "不変な Kotlin コレクションに対する Java ミューテーターメソッドの呼び出し"
                },
                "fullDescription": {
                  "text": "Kotlin のイミュータブルなコレクションに対する Java のミューテーターメソッドの呼び出し ('fill'、'reverse'、'shuffle'、'sort' など) を報告します。 このような呼び出しがあると、実行時に 'UnsupportedOperationException' が発生する可能性があります。 例: 'import java.util.Collections\n\n  fun test() {\n      val immutableList = listOf(1, 2)\n      Collections.reverse(immutableList)\n  }' この問題を修正するには、リストをミュータブルにしてください。",
                  "markdown": "Kotlin のイミュータブルなコレクションに対する Java のミューテーターメソッドの呼び出し (`fill`、`reverse`、`shuffle`、`sort` など) を報告します。\n\nこのような呼び出しがあると、実行時に `UnsupportedOperationException` が発生する可能性があります。\n\n**例:**\n\n\n      import java.util.Collections\n\n      fun test() {\n          val immutableList = listOf(1, 2)\n          Collections.reverse(immutableList)\n      }\n\nこの問題を修正するには、リストをミュータブルにしてください。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaCollectionsStaticMethodOnImmutableList",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 相互運用性の問題",
                      "index": 66,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MapGetWithNotNullAssertionOperator",
                "shortDescription": {
                  "text": "非 null アサーション演算子 (!!) を含む 'map.get()'"
                },
                "fullDescription": {
                  "text": "'map.getValue()'、'map.getOrElse()' などに置換できる 'map.get()!!' を報告します。 例: 'fun test(map: Map<Int, String>): String = map.get(0)!!' クイックフィックス適用後: 'fun test(map: Map<Int, String>): String = map.getValue(0)'",
                  "markdown": "`map.getValue()`、`map.getOrElse()` などに置換できる `map.get()!!` を報告します。\n\n**例:**\n\n\n    fun test(map: Map<Int, String>): String = map.get(0)!!\n\nクイックフィックス適用後:\n\n\n    fun test(map: Map<Int, String>): String = map.getValue(0)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MapGetWithNotNullAssertionOperator",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SortModifiers",
                "shortDescription": {
                  "text": "非正規修飾子の順序"
                },
                "fullDescription": {
                  "text": "スタイルガイドで推奨されている順序に従っていない修飾子を報告します。 「修飾子の並べ替え」クイックフィックスを使用すると、コードを自動的に修正できます。 例: 'private inline fun correctOrder(f: () -> Unit) {} // <== Ok\n\n  infix private fun Int.wrongOrder(expr: Int) {} // <== 不正な順序。クイックフィックスを使用すると修飾子を \"private infix\" に修正できます'",
                  "markdown": "[スタイルガイド](https://kotlinlang.org/docs/coding-conventions.html#modifiers-order)で推奨されている順序に従っていない修飾子を報告します。\n\n「**修飾子の並べ替え**」クイックフィックスを使用すると、コードを自動的に修正できます。\n\n例:\n\n\n      private inline fun correctOrder(f: () -> Unit) {} // <== Ok\n\n      infix private fun Int.wrongOrder(expr: Int) {} // <== 不正な順序。クイックフィックスを使用すると修飾子を \"private infix\" に修正できます\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SortModifiers",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MavenCoroutinesDeprecation",
                "shortDescription": {
                  "text": "Maven で Kotlin 1.3 以上と互換性のない kotlinx.coroutines 依存関係が使用されています"
                },
                "fullDescription": {
                  "text": "Maven の kotlinx.coroutines ライブラリの依存関係で、Kotlin 1.3 以降のバージョンとの互換性を確保するために更新する必要があるものを報告します。",
                  "markdown": "Maven の **kotlinx.coroutines** ライブラリの依存関係で、Kotlin 1.3 以降のバージョンとの互換性を確保するために更新する必要があるものを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MavenCoroutinesDeprecation",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin、移行/Maven",
                      "index": 110,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NullableBooleanElvis",
                "shortDescription": {
                  "text": "nullable ブール値のチェックにはエルビスの代わりに等価チェックを使用できます"
                },
                "fullDescription": {
                  "text": "エルビス式の代わりに等価チェックを使用すべきケースを報告します。 例: 'fun check(a: Boolean? == null) {\n    if (a ?: false) throw IllegalStateException()\n}' クイックフィックス適用後: 'fun check(a: Boolean? == null) {\n    if (a == true) throw IllegalStateException()\n}'",
                  "markdown": "エルビス式の代わりに等価チェックを使用すべきケースを報告します。\n\n**例:**\n\n\n    fun check(a: Boolean? == null) {\n        if (a ?: false) throw IllegalStateException()\n    }\n\nクイックフィックス適用後:\n\n\n    fun check(a: Boolean? == null) {\n        if (a == true) throw IllegalStateException()\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "NullableBooleanElvis",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumEntryName",
                "shortDescription": {
                  "text": "列挙型エントリの命名規則"
                },
                "fullDescription": {
                  "text": "推奨されている命名規則に従っていない列挙型エントリ名を報告します。 例: 'enum class Foo {\n    _Foo,\n    foo\n  }' この問題を修正するには、推奨されている命名規則に一致するように列挙型エントリ名を変更してください。",
                  "markdown": "推奨されている命名規則に従っていない列挙型エントリ名を報告します。\n\n**例:**\n\n\n      enum class Foo {\n        _Foo,\n        foo\n      }\n\nこの問題を修正するには、推奨されている命名規則に一致するように列挙型エントリ名を変更してください。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EnumEntryName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名規約",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryVariable",
                "shortDescription": {
                  "text": "不要なローカル変数"
                },
                "fullDescription": {
                  "text": "次の 'return' ステートメントでのみ使用されるローカル変数、または他の変数の正確なコピーを報告します。 コードをより明確にするため、このような変数は安全にインライン化できます。 例: 'fun sum(a: Int, b: Int): Int {\n      val c = a + b\n      return c\n  }' クイックフィックス適用後: 'fun sum(a: Int, b: Int): Int {\n      return a + b\n  }' インスペクションの構成: 直ちに返される変数を報告するには、「直ちに返される変数を無視する」オプションを使用します。 内容をよく表す変数の名前を使用することでコードの可読性が向上する場合があるため、このオプションはデフォルトで無効になっています。",
                  "markdown": "次の `return` ステートメントでのみ使用されるローカル変数、または他の変数の正確なコピーを報告します。\n\nコードをより明確にするため、このような変数は安全にインライン化できます。\n\n**例:**\n\n\n      fun sum(a: Int, b: Int): Int {\n          val c = a + b\n          return c\n      }\n\nクイックフィックス適用後:\n\n\n      fun sum(a: Int, b: Int): Int {\n          return a + b\n      }\n\nインスペクションの構成:\n\n直ちに返される変数を報告するには、「**直ちに返される変数を無視する**」オプションを使用します。\n内容をよく表す変数の名前を使用することでコードの可読性が向上する場合があるため、このオプションはデフォルトで無効になっています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessaryVariable",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedMavenDependency",
                "shortDescription": {
                  "text": "Maven での非推奨ライブラリの使用"
                },
                "fullDescription": {
                  "text": "非推奨の maven 依存関係を報告します。 例: '<dependencies>\n    <dependency>\n        <groupId>org.jetbrains.kotlin</groupId>\n        <artifactId>kotlin-stdlib-jre7</artifactId>\n        <version>${kotlin.version}</version>\n    </dependency>\n  </dependencies>' クイックフィックスを使用すると、非推奨の依存関係がメンテナンス対象の依存関係に変更されます。 '<dependencies>\n    <dependency>\n        <groupId>org.jetbrains.kotlin</groupId>\n        <artifactId>kotlin-stdlib-jdk7</artifactId>\n        <version>${kotlin.version}</version>\n    </dependency>\n  </dependencies>'",
                  "markdown": "非推奨の maven 依存関係を報告します。\n\n**例:**\n\n\n      <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-stdlib-jre7</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n      </dependencies>\n\nクイックフィックスを使用すると、非推奨の依存関係がメンテナンス対象の依存関係に変更されます。\n\n\n       <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-stdlib-jdk7</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n      </dependencies>\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeprecatedMavenDependency",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceSubstringWithDropLast",
                "shortDescription": {
                  "text": "'dropLast' の呼び出しに置換すべき 'substring' の呼び出し"
                },
                "fullDescription": {
                  "text": "'s.substring(0, s.length - x)' から 's.dropLast(x)' のように置換できる呼び出しを報告します。 対応する関数を使用すると、コードを単純化できます。 クイックフィックスを使用すると、'substring' の呼び出しが 'dropLast' に置換されます。 例: 'fun foo(s: String) {\n      s.substring(0, s.length - 5)\n  }' クイックフィックス適用後: 'fun foo(s: String) {\n      s.dropLast(5)\n  }'",
                  "markdown": "`s.substring(0, s.length - x)` から `s.dropLast(x)` のように置換できる呼び出しを報告します。\n\n対応する関数を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、`substring` の呼び出しが `dropLast` に置換されます。\n\n**例:**\n\n\n      fun foo(s: String) {\n          s.substring(0, s.length - 5)\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(s: String) {\n          s.dropLast(5)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceSubstringWithDropLast",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SetterBackingFieldAssignment",
                "shortDescription": {
                  "text": "代入のない既存のバッキングフィールド"
                },
                "fullDescription": {
                  "text": "バッキングフィールドを更新しないプロパティの setter を報告します。 クイックフィックスを使用すると、バッキングフィールドへの代入が追加されます。 例: 'class Test {\n      var foo: Int = 1\n          set(value) {\n          }\n  }' クイックフィックス適用後: 'class Test {\n      var foo: Int = 1\n          set(value) {\n              field = value\n          }\n  }'",
                  "markdown": "バッキングフィールドを更新しないプロパティの setter を報告します。\n\nクイックフィックスを使用すると、バッキングフィールドへの代入が追加されます。\n\n**例:**\n\n\n      class Test {\n          var foo: Int = 1\n              set(value) {\n              }\n      }\n\nクイックフィックス適用後:\n\n\n      class Test {\n          var foo: Int = 1\n              set(value) {\n                  field = value\n              }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SetterBackingFieldAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CopyWithoutNamedArguments",
                "shortDescription": {
                  "text": "データクラスの 'copy' メソッドが名前付き引数なしで呼び出されています"
                },
                "fullDescription": {
                  "text": "名前付き引数を持たないデータクラスの 'copy()' メソッドの呼び出しを報告します。 'copy()' 関数の引数はすべて任意であるため、どのプロパティが修飾されているのか分かりにくい場合があります。 明示的にパラメーター名を指定すると、'data class' の宣言を確認しなくても、簡単にコードを理解できるようになります。 例: 'data class User(val name: String, val age: Int)\n\n  fun copyUser(user: User): User {\n      return user.copy(\"John\")\n  }' クイックフィックスを使用すると、'copy()' のすべての引数にパラメーター名が指定されます。 'data class User(val name: String, val age: Int)\n\n  fun copyUser(user: User): User {\n      return user.copy(name = \"John\")\n  }'",
                  "markdown": "名前付き引数を持たないデータクラスの `copy()` メソッドの呼び出しを報告します。\n\n\n`copy()` 関数の引数はすべて任意であるため、どのプロパティが修飾されているのか分かりにくい場合があります。\n明示的にパラメーター名を指定すると、`data class` の宣言を確認しなくても、簡単にコードを理解できるようになります。\n\n**例:**\n\n\n      data class User(val name: String, val age: Int)\n\n      fun copyUser(user: User): User {\n          return user.copy(\"John\")\n      }\n\nクイックフィックスを使用すると、`copy()` のすべての引数にパラメーター名が指定されます。\n\n\n      data class User(val name: String, val age: Int)\n\n      fun copyUser(user: User): User {\n          return user.copy(name = \"John\")\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CopyWithoutNamedArguments",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantConstructorKeyword",
                "shortDescription": {
                  "text": "冗長な 'constructor' キーワード"
                },
                "fullDescription": {
                  "text": "プライマリコンストラクターの冗長な 'constructor' キーワードを報告します。 例: 'class Foo constructor(x: Int, y: Int)' クイックフィックス適用後: 'class Foo(x: Int, y: Int)'",
                  "markdown": "プライマリコンストラクターの冗長な 'constructor' キーワードを報告します。\n\n**例:**\n\n\n      class Foo constructor(x: Int, y: Int)\n\nクイックフィックス適用後:\n\n\n      class Foo(x: Int, y: Int)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantConstructorKeyword",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinDeprecation",
                "shortDescription": {
                  "text": "冗長または非推奨な構文または非推奨なシンボルの使用箇所"
                },
                "fullDescription": {
                  "text": "コードのクリーンアップ (コード | コードのクリーンアップ) 中に廃止された言語機能と無駄に冗長なコード構文を報告します。 クイックフィックスを使用すると、廃止された言語機能や無駄に冗長なコード構文が自動的にコンパクトかつ最新の構文に置換されます。 また、非推奨のシンボルも提案された代替のシンボルに置換されます。",
                  "markdown": "コードのクリーンアップ (**コード \\| コードのクリーンアップ** ) 中に廃止された言語機能と無駄に冗長なコード構文を報告します。\n\n\nクイックフィックスを使用すると、廃止された言語機能や無駄に冗長なコード構文が自動的にコンパクトかつ最新の構文に置換されます。\n\n\nまた、非推奨のシンボルも提案された代替のシンボルに置換されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KotlinDeprecation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantEmptyInitializerBlock",
                "shortDescription": {
                  "text": "冗長な空のイニシャライザーブロック"
                },
                "fullDescription": {
                  "text": "冗長な空のイニシャライザーブロックを報告します。 例: 'class Foo {\n      init {\n          // 空の init ブロック\n      }\n  }' クイックフィックス適用後: 'class Foo {\n  }'",
                  "markdown": "冗長な空のイニシャライザーブロックを報告します。\n\n**例:**\n\n\n      class Foo {\n          init {\n              // 空の init ブロック\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantEmptyInitializerBlock",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/他の問題",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceSubstringWithTake",
                "shortDescription": {
                  "text": "'take' の呼び出しに置換すべき 'substring' の呼び出し"
                },
                "fullDescription": {
                  "text": "'s.substring(0, x)' から 's.take(x)' のように置換できる呼び出しを報告します。 'take()' を使用すると、コードを単純化できます。 クイックフィックスを使用すると、'substring' の呼び出しが 'take()' に置換されます。 例: 'fun foo(s: String) {\n      s.substring(0, 10)\n  }' クイックフィックス適用後: 'fun foo(s: String) {\n      s.take(10)\n  }'",
                  "markdown": "`s.substring(0, x)` から `s.take(x)` のように置換できる呼び出しを報告します。\n\n`take()` を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、`substring` の呼び出しが `take()` に置換されます。\n\n**例:**\n\n\n      fun foo(s: String) {\n          s.substring(0, 10)\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(s: String) {\n          s.take(10)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceSubstringWithTake",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceRangeToWithRangeUntil",
                "shortDescription": {
                  "text": "'rangeTo' または '..' の呼び出しは '..<' に置換する必要があります"
                },
                "fullDescription": {
                  "text": "'..' を呼び出す代わりに、'rangeTo' または '..' 演算子を呼び出していることを報告します。 対応する関数を使用すると、コードを単純化できます。 クイックフィックスを使用すると、'rangeTo' または '..' の呼び出しが '..' に置換されます。 例: 'fun foo(a: Int) {\n      for (i in 0..a - 1) {\n\n      }\n  }' クイックフィックス適用後: 'fun foo(a: Int) {\n      for (i in 0..<a) {\n\n      }\n  }'",
                  "markdown": "`..` を呼び出す代わりに、`rangeTo` または `..` 演算子を呼び出していることを報告します。\n\n対応する関数を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、`rangeTo` または `..` の呼び出しが `..` に置換されます。\n\n**例:**\n\n\n      fun foo(a: Int) {\n          for (i in 0..a - 1) {\n\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(a: Int) {\n          for (i in 0..<a) {\n\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceRangeToWithRangeUntil",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertCallChainIntoSequence",
                "shortDescription": {
                  "text": "コレクションの呼び出しチェーンは 'Sequence' に変換するとパフォーマンスを改善できます"
                },
                "fullDescription": {
                  "text": "'Collection' に対する呼び出しチェーンで、シーケンスに変換すべきものを報告します。 'Collection' を変換する関数 ('map()' や 'filter()' など) は、それぞれが内部で新しい 'Collection' (一般的には 'List' または 'Set') を作成します。 結果的に生じる呼び出しが複数個あり、かつ 'Collection' 内の項目数が多い場合、膨大なメモリトラフィックが発生する可能性があります。 このような場合は、'Sequence' を使用することをお勧めします。 例: 'class Entity(val key: String, val value: String)\n\n  fun getValues(lines: List<String>) = lines\n      .filter { it.isNotEmpty() }\n      .map { it.split(',', limit = 2) }\n      .filter { it.size == 2 }\n      .map { Entity(it[0], it[1]) }' クイックフィックスを使用すると、呼び出しチェーンが 'asSequence()' と 'toList()' にラップされます。 'class Entity(val key: String, val value: String)\n\n  fun getValues(lines: List<String>) = lines\n      .asSequence()\n      .filter { it.isNotEmpty() }\n      .map { it.split(',', limit = 2) }\n      .filter { it.size == 2 }\n      .map { Entity(it[0], it[1]) }\n      .toList()'",
                  "markdown": "`Collection` に対する呼び出しチェーンで、**シーケンス** に変換すべきものを報告します。\n\n`Collection` を変換する関数 (`map()` や `filter()` など) は、それぞれが内部で新しい `Collection` (一般的には `List` または `Set`) を作成します。\n結果的に生じる呼び出しが複数個あり、かつ `Collection` 内の項目数が多い場合、膨大なメモリトラフィックが発生する可能性があります。\nこのような場合は、`Sequence` を使用することをお勧めします。\n\n**例:**\n\n\n      class Entity(val key: String, val value: String)\n\n      fun getValues(lines: List<String>) = lines\n          .filter { it.isNotEmpty() }\n          .map { it.split(',', limit = 2) }\n          .filter { it.size == 2 }\n          .map { Entity(it[0], it[1]) }\n\nクイックフィックスを使用すると、呼び出しチェーンが `asSequence()` と `toList()` にラップされます。\n\n\n      class Entity(val key: String, val value: String)\n\n      fun getValues(lines: List<String>) = lines\n          .asSequence()\n          .filter { it.isNotEmpty() }\n          .map { it.split(',', limit = 2) }\n          .filter { it.size == 2 }\n          .map { Entity(it[0], it[1]) }\n          .toList()\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertCallChainIntoSequence",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AddOperatorModifier",
                "shortDescription": {
                  "text": "関数には 'operator' 修飾子を指定する必要があります"
                },
                "fullDescription": {
                  "text": "演算子の規則の 1 つと一致しているものの、'operator' キーワードがない関数を報告します。 'operator' 修飾子を追加すると、関数の利用者が Kotlin らしいコードを書けるようになります。 例: 'class Complex(val real: Double, val imaginary: Double) {\n      fun plus(other: Complex) =\n          Complex(real + other.real, imaginary + other.imaginary)\n  }\n\n  fun usage(a: Complex, b: Complex) {\n      a.plus(b)\n  }' クイックフィックスを使用すると、'operator' 修飾子キーワードが追加されます。 'class Complex(val real: Double, val imaginary: Double) {\n      operator fun plus(other: Complex) =\n          Complex(real + other.real, imaginary + other.imaginary)\n  }\n\n  fun usage(a: Complex, b: Complex) {\n      a + b\n  }'",
                  "markdown": "演算子の規則の 1 つと一致しているものの、`operator` キーワードがない関数を報告します。\n\n`operator` 修飾子を追加すると、関数の利用者が Kotlin らしいコードを書けるようになります。\n\n**例:**\n\n\n      class Complex(val real: Double, val imaginary: Double) {\n          fun plus(other: Complex) =\n              Complex(real + other.real, imaginary + other.imaginary)\n      }\n\n      fun usage(a: Complex, b: Complex) {\n          a.plus(b)\n      }\n\nクイックフィックスを使用すると、`operator` 修飾子キーワードが追加されます。\n\n\n      class Complex(val real: Double, val imaginary: Double) {\n          operator fun plus(other: Complex) =\n              Complex(real + other.real, imaginary + other.imaginary)\n      }\n\n      fun usage(a: Complex, b: Complex) {\n          a + b\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AddOperatorModifier",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLabeledReturnOnLastExpressionInLambda",
                "shortDescription": {
                  "text": "ラムダの最後の式に対する重複したラベル付きの return"
                },
                "fullDescription": {
                  "text": "ラムダ内の最後の式で使用されているラベル付きの return を報告します。 このような return は冗長であるため、安全に除去できます。 例: 'fun foo() {\n  listOf(1,2,3).find {\n    return@find true\n  }\n}' クイックフィックス適用後: 'fun foo() {\n  listOf(1,2,3).find {\n    true\n  }\n}'",
                  "markdown": "ラムダ内の最後の式で使用されているラベル付きの return を報告します。\n\nこのような return は冗長であるため、安全に除去できます。\n\n**例:**\n\n\n    fun foo() {\n      listOf(1,2,3).find {\n        return@find true\n      }\n    }\n\nクイックフィックス適用後:\n\n\n    fun foo() {\n      listOf(1,2,3).find {\n        true\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantLabeledReturnOnLastExpressionInLambda",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MayBeConstant",
                "shortDescription": {
                  "text": "'const' の可能性あり"
                },
                "fullDescription": {
                  "text": "オブジェクトのトップレベル 'val' プロパティで、パフォーマンスおよび Java との相互運用性を高める目的で 'const' と宣言されている可能性があるものを報告します。 例: 'object A {\n      val foo = 1\n  }' クイックフィックス適用後: 'object A {\n      const val foo = 1\n  }'",
                  "markdown": "オブジェクトのトップレベル `val` プロパティで、パフォーマンスおよび Java との相互運用性を高める目的で `const` と宣言されている可能性があるものを報告します。\n\n**例:**\n\n\n      object A {\n          val foo = 1\n      }\n\nクイックフィックス適用後:\n\n\n      object A {\n          const val foo = 1\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MayBeConstant",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GradleKotlinxCoroutinesDeprecation",
                "shortDescription": {
                  "text": "Gradle で Kotlin 1.3 以上と互換性のない kotlinx.coroutines 依存関係が使用されています"
                },
                "fullDescription": {
                  "text": "Gradle の 'kotlinx.coroutines' ライブラリの依存関係で、Kotlin 1.3 以降との互換性を確保するために更新する必要があるものを報告します。 例: 'dependencies {\n      implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.0.1'\n  }' クイックフィックスを使用すると、'kotlinx.coroutines' ライブラリのバージョンを Kotlin 1.3 と互換性があるバージョンに変更されます。 'dependencies {\n      implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.27.0-eap13'\n  }'",
                  "markdown": "Gradle の `kotlinx.coroutines` ライブラリの依存関係で、Kotlin 1.3 以降との互換性を確保するために更新する必要があるものを報告します。\n\n**例:**\n\n\n      dependencies {\n          implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.0.1'\n      }\n\nクイックフィックスを使用すると、`kotlinx.coroutines` ライブラリのバージョンを Kotlin 1.3 と互換性があるバージョンに変更されます。\n\n\n      dependencies {\n          implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.27.0-eap13'\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "GradleKotlinxCoroutinesDeprecation",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin、移行/Gradle",
                      "index": 117,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantWith",
                "shortDescription": {
                  "text": "冗長な 'with' の呼び出し"
                },
                "fullDescription": {
                  "text": "レシーバーの要素にアクセスしていない冗長な 'with' 関数の呼び出しを報告します。 例: 'class MyClass {\n      fun f(): String = \"\"\n  }\n\n  fun testRedundant() {\n      with(c) { // <== 'c' は使用されないため 'with' は冗長\n          println(\"1\")\n      }\n  }\n\n  fun testOk() {\n      val c = MyClass()\n      with(c) { // <== 'f()' は実質的に 'c.f()' であるため OK\n          println(f())\n      }\n  }'",
                  "markdown": "レシーバーの要素にアクセスしていない冗長な `with` 関数の呼び出しを報告します。\n\n**例:**\n\n\n      class MyClass {\n          fun f(): String = \"\"\n      }\n\n      fun testRedundant() {\n          with(c) { // <== 'c' は使用されないため 'with' は冗長\n              println(\"1\")\n          }\n      }\n\n      fun testOk() {\n          val c = MyClass()\n          with(c) { // <== 'f()' は実質的に 'c.f()' であるため OK\n              println(f())\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantWith",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WarningOnMainUnusedParameterMigration",
                "shortDescription": {
                  "text": "1.4 以降 'main' で未使用の 'args'"
                },
                "fullDescription": {
                  "text": "未使用の単一パラメーターを使用している 'main' 関数を報告します。 Kotlin 1.4 以降は、パラメーターのない 'main' 関数を Kotlin プログラムのエントリポイントとして使用できます。 'main' 関数に未使用のパラメーターがある場合、コンパイラーが警告を表示します。",
                  "markdown": "未使用の単一パラメーターを使用している `main` 関数を報告します。\n\nKotlin 1.4 以降は、パラメーターのない `main` 関数を Kotlin プログラムのエントリポイントとして使用できます。\n`main` 関数に未使用のパラメーターがある場合、コンパイラーが警告を表示します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "WarningOnMainUnusedParameterMigration",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceIsEmptyWithIfEmpty",
                "shortDescription": {
                  "text": "'if' 条件はラムダ呼び出しに置換できます"
                },
                "fullDescription": {
                  "text": "デフォルト値を代入するために 'if' ステートメントで呼び出されている 'isEmpty'、'isBlank'、'isNotEmpty'、または'isNotBlank' を報告します。 クイックフィックスを使用すると、'if' 条件が 'ifEmpty' または 'ifBlank' 呼び出しに置換されます。 例: 'fun test(list: List<Int>): List<Int> {\n      return if (list.isEmpty()) {\n          println()\n          foo()\n      } else {\n          list\n      }\n  }' クイックフィックス適用後: 'fun test(list: List<Int>): List<Int> {\n      return list.ifEmpty {\n          println()\n          foo()\n      }\n  }' このインスペクションは、プロジェクトまたはモジュールの Kotlin 言語バージョンが 1.3 以降の場合にのみ報告します。",
                  "markdown": "デフォルト値を代入するために `if` ステートメントで呼び出されている `isEmpty`、`isBlank`、`isNotEmpty`、または`isNotBlank` を報告します。\n\nクイックフィックスを使用すると、`if` 条件が `ifEmpty` または `ifBlank` 呼び出しに置換されます。\n\n**例:**\n\n\n      fun test(list: List<Int>): List<Int> {\n          return if (list.isEmpty()) {\n              println()\n              foo()\n          } else {\n              list\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun test(list: List<Int>): List<Int> {\n          return list.ifEmpty {\n              println()\n              foo()\n          }\n      }\n\nこのインスペクションは、プロジェクトまたはモジュールの Kotlin 言語バージョンが 1.3 以降の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceIsEmptyWithIfEmpty",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLabelMigration",
                "shortDescription": {
                  "text": "冗長なラベル"
                },
                "fullDescription": {
                  "text": "Kotlin 1.4 以降でコンパイルエラーを引き起こす不要なラベルを報告します。 Kotlin 1.0 以降は、どのステートメントにもラベルを付けられるようになりました。 'fun foo() {\n    L1@ val x = L2@bar()\n  }' しかし、このようなラベルは以下のように限られた方法でしか参照できません。 ループの break / continue インラインラムダまたはインライン匿名関数のローカルでない return このようなラベルは、Kotlin 1.4 以降では禁止されています。 このインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.4 以降の場合にのみ報告します。",
                  "markdown": "Kotlin 1.4 以降でコンパイルエラーを引き起こす不要なラベルを報告します。\n\nKotlin 1.0 以降は、どのステートメントにもラベルを付けられるようになりました。\n\n\n      fun foo() {\n        L1@ val x = L2@bar()\n      }\n\nしかし、このようなラベルは以下のように限られた方法でしか参照できません。\n\n* ループの break / continue\n* インラインラムダまたはインライン匿名関数のローカルでない return\n\nこのようなラベルは、Kotlin 1.4 以降では禁止されています。\n\nこのインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.4 以降の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantLabelMigration",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinRedundantDiagnosticSuppress",
                "shortDescription": {
                  "text": "冗長な診断の抑止"
                },
                "fullDescription": {
                  "text": "'@Suppress' アノテーションの使用箇所のうち、関係するコンパイラー診断が対象のコンテキストで適用されなくなったため、安全に除去できるものを報告します。 例: 'fun doSmth(@Suppress(\"UNUSED_PARAMETER\") used: Int) {\n    println(used)\n  }' クイックフィックス適用後: 'fun doSmth(used: Int) {\n    println(used)\n  }'",
                  "markdown": "`@Suppress` アノテーションの使用箇所のうち、関係するコンパイラー診断が対象のコンテキストで適用されなくなったため、安全に除去できるものを報告します。\n\n**例:**\n\n\n      fun doSmth(@Suppress(\"UNUSED_PARAMETER\") used: Int) {\n        println(used)\n      }\n\nクイックフィックス適用後:\n\n\n      fun doSmth(used: Int) {\n        println(used)\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KotlinRedundantDiagnosticSuppress",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceNegatedIsEmptyWithIsNotEmpty",
                "shortDescription": {
                  "text": "単純化できる否定呼び出し"
                },
                "fullDescription": {
                  "text": "コレクションと 'String' に対する 'isEmpty()' と 'isNotEmpty()' の否定、または 'String' に対する 'isBlank()' と 'isNotBlank()' の否定を報告します。 対応する関数を使用すると、コードを単純化できます。 クイックフィックスを使用すると、否定の呼び出しが対応する標準ライブラリの呼び出しに置換されます。 例: 'fun main() {\n      val list = listOf(1,2,3)\n      if (!list.isEmpty()) {\n          // 何か処理を書きます\n      }\n  }' クイックフィックス適用後: 'fun main() {\n      val list = listOf(1,2,3)\n      if (list.isNotEmpty()) {\n          // 何か処理を書きます\n      }\n  }'",
                  "markdown": "コレクションと `String` に対する `isEmpty()` と `isNotEmpty()` の否定、または `String` に対する `isBlank()` と `isNotBlank()` の否定を報告します。\n\n対応する関数を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、否定の呼び出しが対応する標準ライブラリの呼び出しに置換されます。\n\n**例:**\n\n\n      fun main() {\n          val list = listOf(1,2,3)\n          if (!list.isEmpty()) {\n              // 何か処理を書きます\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun main() {\n          val list = listOf(1,2,3)\n          if (list.isNotEmpty()) {\n              // 何か処理を書きます\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceNegatedIsEmptyWithIsNotEmpty",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceWithImportAlias",
                "shortDescription": {
                  "text": "完全修飾名は既存のインポートエイリアスに置換できます"
                },
                "fullDescription": {
                  "text": "既存のインポートエイリアスに置換できる完全修飾名を報告します。 例: 'import foo.Foo as Bar\nfun main() {\n    foo.Foo()\n}' クイックフィックス適用後: 'import foo.Foo as Bar\nfun main() {\n    Bar()\n}'",
                  "markdown": "既存のインポートエイリアスに置換できる完全修飾名を報告します。\n\n**例:**\n\n\n    import foo.Foo as Bar\n    fun main() {\n        foo.Foo()\n    }\n\nクイックフィックス適用後:\n\n\n    import foo.Foo as Bar\n    fun main() {\n        Bar()\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceWithImportAlias",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DelegationToVarProperty",
                "shortDescription": {
                  "text": "'var' プロパティへの委譲"
                },
                "fullDescription": {
                  "text": "'var' プロパティへのインターフェース委譲を報告します。 委譲にはプロパティの初期値のみが使用され、その後の代入の影響は受けません。 例: 'class Example(var text: CharSequence): CharSequence by text' クイックフィックスを使用すると、プロパティがイミュータブルなプロパティに置換されます。 'class Example(val text: CharSequence): CharSequence by text' また、可変性が必要な場合は、以下のコードを使用できます。 'class Example(text: CharSequence): CharSequence by text {\n      var text = text\n  }'",
                  "markdown": "`var` プロパティへのインターフェース委譲を報告します。\n\n委譲にはプロパティの初期値のみが使用され、その後の代入の影響は受けません。\n\n**例:**\n\n\n      class Example(var text: CharSequence): CharSequence by text\n\nクイックフィックスを使用すると、プロパティがイミュータブルなプロパティに置換されます。\n\n\n      class Example(val text: CharSequence): CharSequence by text\n\nまた、可変性が必要な場合は、以下のコードを使用できます。\n\n\n      class Example(text: CharSequence): CharSequence by text {\n          var text = text\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DelegationToVarProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantConditionIf",
                "shortDescription": {
                  "text": "'if' 式の条件は不変です"
                },
                "fullDescription": {
                  "text": "'true' または 'false' の定数リテラル条件があり、単純化できる 'if' 式を報告します。 このような構文は意図的な場合もありますが、混乱を招き、多くの場合はタイプミスによるものか、以前に実行されたリファクタリングによるものです。 例: 'fun example() {\n      if (true) {\n          throw IllegalStateException(\"Unexpected state\")\n      }\n  }' クイックフィックスを使用すると、'if' 条件が除去されます。 'fun example() {\n      throw IllegalStateException(\"Unexpected state\")\n  }'",
                  "markdown": "`true` または `false` の定数リテラル条件があり、単純化できる `if` 式を報告します。\n\nこのような構文は意図的な場合もありますが、混乱を招き、多くの場合はタイプミスによるものか、以前に実行されたリファクタリングによるものです。\n\n**例:**\n\n\n      fun example() {\n          if (true) {\n              throw IllegalStateException(\"Unexpected state\")\n          }\n      }\n\nクイックフィックスを使用すると、`if` 条件が除去されます。\n\n\n      fun example() {\n          throw IllegalStateException(\"Unexpected state\")\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConstantConditionIf",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLambdaArrow",
                "shortDescription": {
                  "text": "冗長なラムダアロー"
                },
                "fullDescription": {
                  "text": "パラメーターのないラムダ式にある不要な矢印を報告します。 例: 'fun foo(f: () -> Unit) = f()\n\n  fun bar() {\n      foo { -> println(\"Hi!\") }\n  }' クイックフィックス適用後: 'fun foo(f: () -> Unit) = f()\n\n  fun bar() {\n      foo { println(\"Hi!\") }\n  }'",
                  "markdown": "パラメーターのないラムダ式にある不要な矢印を報告します。\n\n**例:**\n\n\n      fun foo(f: () -> Unit) = f()\n\n      fun bar() {\n          foo { -> println(\"Hi!\") }\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(f: () -> Unit) = f()\n\n      fun bar() {\n          foo { println(\"Hi!\") }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantLambdaArrow",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinInternalInJava",
                "shortDescription": {
                  "text": "Java からの Kotlin 内部宣言の使用"
                },
                "fullDescription": {
                  "text": "別モジュール内の Java コードで Kotlin の 'internal' 宣言が使用されていることを報告します。 'internal' キーワードは、別のモジュールからクラス、関数、プロパティへのアクセスを制限するためのものです。 JVM における可視性の制限により、'internal' クラス、関数、プロパティは Kotlin の外からでもアクセスできてしまうため、後に互換性の問題を引き起こす可能性があります。",
                  "markdown": "別モジュール内の Java コードで Kotlin の `internal` 宣言が使用されていることを報告します。\n\n\n`internal` キーワードは、別のモジュールからクラス、関数、プロパティへのアクセスを制限するためのものです。\nJVM における可視性の制限により、`internal` クラス、関数、プロパティは Kotlin の外からでもアクセスできてしまうため、後に互換性の問題を引き起こす可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "KotlinInternalInJava",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 相互運用性の問題",
                      "index": 66,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyBooleanWithConstants",
                "shortDescription": {
                  "text": "ブール式は単純化できます"
                },
                "fullDescription": {
                  "text": "定数に変更できる部分があるブール式を報告します。 クイックフィックスを使用すると、条件が単純化されます。 例: 'fun use(arg: Boolean) {\n      if (false == arg) {\n\n      }\n  }' クイックフィックス適用後: 'fun use(arg: Boolean) {\n      if (!arg) {\n\n      }\n  }'",
                  "markdown": "定数に変更できる部分があるブール式を報告します。\n\nクイックフィックスを使用すると、条件が単純化されます。\n\n**例:**\n\n\n      fun use(arg: Boolean) {\n          if (false == arg) {\n\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun use(arg: Boolean) {\n          if (!arg) {\n\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifyBooleanWithConstants",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverrideDeprecatedMigration",
                "shortDescription": {
                  "text": "1.9 以降は、オーバーライドを通じてメソッドの使用停止を伝播しないでください"
                },
                "fullDescription": {
                  "text": "1.9 以降ではコンパイルエラーを引き起こす '@Deprecated' アノテーションにより伝播されている宣言を報告します。 動機のタイプ: 実装設計/アーキテクチャ上の理由により実装の変更が必要である 一貫性のないデザイン (コンテキストによって動作が異なる) 詳細: KT-47902: overrides を通じてメソッドの非推奨を伝播しない クイックフィックスを使用すると、親の宣言から '@Deprecated' アノテーションがコピーされます。 例: 'open class Base {\n      @Deprecated(\"Don't use\")\n      open fun foo() {}\n  }\n\n  class Derived : Base() {\n      override fun foo() {}\n  }' クイックフィックス適用後: 'open class Base {\n      @Deprecated(\"Don't use\")\n      open fun foo() {}\n  }\n\n  class Derived : Base() {\n      @Deprecated(\"Don't use\")\n      override fun foo() {}\n  }' このインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.6 以上の場合にのみ報告します。",
                  "markdown": "1.9 以降ではコンパイルエラーを引き起こす `@Deprecated` アノテーションにより伝播されている宣言を報告します。\n\n動機のタイプ:\n\n* 実装設計/アーキテクチャ上の理由により実装の変更が必要である\n* 一貫性のないデザイン (コンテキストによって動作が異なる)\n\n**詳細:** [KT-47902: overrides を通じてメソッドの非推奨を伝播しない](https://youtrack.jetbrains.com/issue/KT-47902)\n\nクイックフィックスを使用すると、親の宣言から `@Deprecated` アノテーションがコピーされます。\n\n**例:**\n\n\n      open class Base {\n          @Deprecated(\"Don't use\")\n          open fun foo() {}\n      }\n\n      class Derived : Base() {\n          override fun foo() {}\n      }\n\nクイックフィックス適用後:\n\n\n      open class Base {\n          @Deprecated(\"Don't use\")\n          open fun foo() {}\n      }\n\n      class Derived : Base() {\n          @Deprecated(\"Don't use\")\n          override fun foo() {}\n      }\n\nこのインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.6 以上の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "OverrideDeprecatedMigration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NoConstructorMigration",
                "shortDescription": {
                  "text": "禁止されているコンストラクターの呼び出し"
                },
                "fullDescription": {
                  "text": "1.9 以降ではコンパイルエラーを引き起こす関数のスーパータイプに対するコンストラクターの呼び出しを報告します。 動機のタイプ: 実装が公開されている仕様またはドキュメントに従っていない 詳細: KT-46344: スーパータイプリスト内の関数インターフェースに対するスーパークラスコンストラクターの呼び出しでエラーが発生しない クイックフィックスを使用すると、コンストラクターの呼び出しが除去されます。 例: 'abstract class A : () -> Int()' クイックフィックス適用後: 'abstract class A : () -> Int' このインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.7 以上の場合にのみ報告します。",
                  "markdown": "1.9 以降ではコンパイルエラーを引き起こす関数のスーパータイプに対するコンストラクターの呼び出しを報告します。\n\n動機のタイプ:\n\n* 実装が公開されている仕様またはドキュメントに従っていない\n\n**詳細:** [KT-46344: スーパータイプリスト内の関数インターフェースに対するスーパークラスコンストラクターの呼び出しでエラーが発生しない](https://youtrack.jetbrains.com/issue/KT-46344)\n\nクイックフィックスを使用すると、コンストラクターの呼び出しが除去されます。\n\n**例:**\n\n\n      abstract class A : () -> Int()\n\nクイックフィックス適用後:\n\n\n      abstract class A : () -> Int\n\nこのインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.7 以上の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "NoConstructorMigration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantModalityModifier",
                "shortDescription": {
                  "text": "冗長なモダリティ修飾子"
                },
                "fullDescription": {
                  "text": "要素のデフォルトのモダリティ (ほとんどの要素は 'final'、'override' 付きのメンバーは 'open') と一致しているモダリティ修飾子を報告します。 例: 'final class Foo\n\n  open class Bar : Comparable<Bar> {\n      open override fun compareTo(other: Bar): Int = 0\n  }' クイックフィックス適用後: 'class Foo\n\n  open class Bar : Comparable<Bar> {\n      override fun compareTo(other: Bar): Int = 0\n  }'",
                  "markdown": "要素のデフォルトのモダリティ (ほとんどの要素は `final`、`override` 付きのメンバーは `open`) と一致しているモダリティ修飾子を報告します。\n\n**例:**\n\n\n      final class Foo\n\n      open class Bar : Comparable<Bar> {\n          open override fun compareTo(other: Bar): Int = 0\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo\n\n      open class Bar : Comparable<Bar> {\n          override fun compareTo(other: Bar): Int = 0\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantModalityModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantValueArgument",
                "shortDescription": {
                  "text": "冗長な値引数"
                },
                "fullDescription": {
                  "text": "対応するパラメーターのデフォルト値と等しい引数を報告します。 例: 'fun foo(x: Int, y: Int = 2) {}\n\nfun bar() {\n    foo(1, 2)\n}' クイックフィックス適用後: 'fun bar() {\n    foo(1)\n}'",
                  "markdown": "対応するパラメーターのデフォルト値と等しい引数を報告します。\n\n**例:**\n\n\n    fun foo(x: Int, y: Int = 2) {}\n\n    fun bar() {\n        foo(1, 2)\n    }\n\nクイックフィックス適用後:\n\n\n    fun bar() {\n        foo(1)\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantValueArgument",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseWithIndex",
                "shortDescription": {
                  "text": "手動でインクリメントされるインデックス変数は 'withIndex()' を使用して置換できます"
                },
                "fullDescription": {
                  "text": "手動でインクリメントされているインデックス変数がある 'for' ループを報告します。 手動でインクリメントされているインデックス変数がある 'for' ループは、'withIndex()' 関数で単純化できます。 「手動でインデックスをインクリメントする代わりに withIndex() を使用」クイックフィックスを使用すると、コードを自動的に修正できます。 例: 'fun foo(list: List<String>): Int? {\n      var index = 0\n      for (s in list) { <== は単純化できます\n          val x = s.length * index\n          index++\n          if (x > 0) return x\n      }\n      return null\n  }' クイックフィックス適用後: 'fun foo(list: List<String>): Int? {\n      for ((index, s) in list.withIndex()) {\n          val x = s.length * index\n          if (x > 0) return x\n      }\n      return null\n  }'",
                  "markdown": "手動でインクリメントされているインデックス変数がある `for` ループを報告します。\n\n手動でインクリメントされているインデックス変数がある `for` ループは、`withIndex()` 関数で単純化できます。\n\n「**手動でインデックスをインクリメントする代わりに withIndex() を使用**」クイックフィックスを使用すると、コードを自動的に修正できます。\n\n例:\n\n\n      fun foo(list: List<String>): Int? {\n          var index = 0\n          for (s in list) { <== は単純化できます\n              val x = s.length * index\n              index++\n              if (x > 0) return x\n          }\n          return null\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(list: List<String>): Int? {\n          for ((index, s) in list.withIndex()) {\n              val x = s.length * index\n              if (x > 0) return x\n          }\n          return null\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UseWithIndex",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyAssertNotNull",
                "shortDescription": {
                  "text": "'!!' または '?:' に置換可能な 'assert' の呼び出し"
                },
                "fullDescription": {
                  "text": "宣言された変数の値が null でないことをチェックしている 'assert' の呼び出しを報告します。 '!!' または '?:' を使用すると、コードを単純化できます。 クイックフィックスを使用すると、変数のイニシャライザーで 'assert' が '!!!' または '?:' 演算子に置換されます。 例: 'fun foo(p: Array<String?>) {\n      val v = p[0]\n      assert(v != null, { \"Should be not null\" })\n  }' クイックフィックス適用後: 'fun foo(p: Array<String?>) {\n      val v = p[0] ?: error(\"Should be not null\")\n  }'",
                  "markdown": "宣言された変数の値が null でないことをチェックしている `assert` の呼び出しを報告します。\n\n`!!` または `?:` を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、変数のイニシャライザーで `assert` が `!!!` または `?:` 演算子に置換されます。\n\n**例:**\n\n\n      fun foo(p: Array<String?>) {\n          val v = p[0]\n          assert(v != null, { \"Should be not null\" })\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(p: Array<String?>) {\n          val v = p[0] ?: error(\"Should be not null\")\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifyAssertNotNull",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertNaNEquality",
                "shortDescription": {
                  "text": "'NaN' による等価チェックを 'isNaN' の呼び出しに変換"
                },
                "fullDescription": {
                  "text": "'Float.NaN' または 'Double.NaN' を使った等価チェックで、'isNaN()' を使ったチェックに置換すべきものを報告します。 IEEE 754 によると、NaN に対する等価チェックは必ず 'false' を返します ('NaN == NaN' の場合も含む)。 したがって、このようなチェックはミスである可能性が高いです。 クイックフィックスを使用すると、このような比較を別の比較手法で 'NaN' の値を正しく処理する 'isNaN()' チェックに置換できます。 例: 'fun check(value: Double): Boolean {\n      return Double.NaN == value\n  }' クイックフィックス適用後: 'fun check(value: Double): Boolean {\n      return value.isNaN()\n  }'",
                  "markdown": "`Float.NaN` または `Double.NaN` を使った等価チェックで、`isNaN()` を使ったチェックに置換すべきものを報告します。\n\n\nIEEE 754 によると、NaN に対する等価チェックは必ず `false` を返します (`NaN == NaN` の場合も含む)。\nしたがって、このようなチェックはミスである可能性が高いです。\n\nクイックフィックスを使用すると、このような比較を別の比較手法で `NaN` の値を正しく処理する `isNaN()` チェックに置換できます。\n\n**例:**\n\n\n      fun check(value: Double): Boolean {\n          return Double.NaN == value\n      }\n\nクイックフィックス適用後:\n\n\n      fun check(value: Double): Boolean {\n          return value.isNaN()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConvertNaNEquality",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceManualRangeWithIndicesCalls",
                "shortDescription": {
                  "text": "範囲はインデックスまたは繰り返しに変換できます"
                },
                "fullDescription": {
                  "text": "'until' および 'rangeTo' 演算子で、'Collection.indices' または 'for' ループ内でのコレクションの反復処理に置換できるものを報告します。 糖衣構文を使用すると、コードを単純化できます。 クイックフィックスを使用すると、手入力の範囲が対応する構造に置換されます。 例: 'fun main(args: Array<String>) {\n      for (index in 0..args.size - 1) {\n          println(args[index])\n      }\n  }' クイックフィックス適用後: 'fun main(args: Array<String>) {\n      for (element in args) {\n          println(element)\n      }\n  }'",
                  "markdown": "`until` および `rangeTo` 演算子で、`Collection.indices` または `for` ループ内でのコレクションの反復処理に置換できるものを報告します。\n\n糖衣構文を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、手入力の範囲が対応する構造に置換されます。\n\n**例:**\n\n\n      fun main(args: Array<String>) {\n          for (index in 0..args.size - 1) {\n              println(args[index])\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun main(args: Array<String>) {\n          for (element in args) {\n              println(element)\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceManualRangeWithIndicesCalls",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinLoggerInitializedWithForeignClass",
                "shortDescription": {
                  "text": "ロガーが外部クラスで初期化されています"
                },
                "fullDescription": {
                  "text": "'Logger' が含まれているクラス以外のクラスリテラルを使用して初期化されている 'Logger' インスタンスを報告します。 このようなコードは、他のクラスからコピーペーストした場合に発生する可能性があります。 結果として、イベントが予想外のカテゴリでログに記録され、またフィルターも不適切に適用される可能性があります。 このインスペクションが認識するロガーファクトリクラスとロガーファクトリメソッドを指定するには、インスペクションのオプションを使用します。 例: 'class AnotherService\nclass MyService {\n    private val logger = LoggerFactory.getLogger(AnotherService::class.java)\n}' クイックフィックス適用後: 'class MyService {\n    private val logger = LoggerFactory.getLogger(MyService::class.java)\n}'",
                  "markdown": "`Logger` が含まれているクラス以外のクラスリテラルを使用して初期化されている `Logger` インスタンスを報告します。\n\n\nこのようなコードは、他のクラスからコピーペーストした場合に発生する可能性があります。\n結果として、イベントが予想外のカテゴリでログに記録され、またフィルターも不適切に適用される可能性があります。\n\n\nこのインスペクションが認識するロガーファクトリクラスとロガーファクトリメソッドを指定するには、インスペクションのオプションを使用します。\n\n**例:**\n\n\n    class AnotherService\n    class MyService {\n        private val logger = LoggerFactory.getLogger(AnotherService::class.java)\n    }\n\nクイックフィックス適用後:\n\n\n    class MyService {\n        private val logger = LoggerFactory.getLogger(MyService::class.java)\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KotlinLoggerInitializedWithForeignClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/ログ関連",
                      "index": 120,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitThis",
                "shortDescription": {
                  "text": "暗黙的な 'this'"
                },
                "fullDescription": {
                  "text": "暗黙的な this の使用箇所を報告します。 例: 'class Foo {\n      fun s() = \"\"\n\n      fun test() {\n          s()\n      }\n  }' クイックフィックスを使用すると、this が明示的に指定されます。 'class Foo {\n      fun s() = \"\"\n\n      fun test() {\n          this.s()\n      }\n  }'",
                  "markdown": "暗黙的な **this** の使用箇所を報告します。\n\n**例:**\n\n\n      class Foo {\n          fun s() = \"\"\n\n          fun test() {\n              s()\n          }\n      }\n\nクイックフィックスを使用すると、**this** が明示的に指定されます。\n\n\n      class Foo {\n          fun s() = \"\"\n\n          fun test() {\n              this.s()\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ImplicitThis",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveToStringInStringTemplate",
                "shortDescription": {
                  "text": "文字列テンプレート内の冗長な 'toString()' の呼び出し"
                },
                "fullDescription": {
                  "text": "文字列テンプレート内の 'toString()' の呼び出しで、安全に除去できるものを報告します。 例: 'fun foo(a: Int, b: Int) = a + b\n\n  fun test(): String {\n      return \"Foo: ${foo(0, 4).toString()}\" // 'toString()' は冗長\n  }' クイックフィックス適用後: 'fun foo(a: Int, b: Int) = a + b\n\n  fun test(): String {\n      return \"Foo: ${foo(0, 4)}\"\n  }'",
                  "markdown": "文字列テンプレート内の `toString()` の呼び出しで、安全に除去できるものを報告します。\n\n**例:**\n\n      fun foo(a: Int, b: Int) = a + b\n\n      fun test(): String {\n          return \"Foo: ${foo(0, 4).toString()}\" // 'toString()' は冗長\n      }\n\nクイックフィックス適用後:\n\n      fun foo(a: Int, b: Int) = a + b\n\n      fun test(): String {\n          return \"Foo: ${foo(0, 4)}\"\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveToStringInStringTemplate",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantAsSequence",
                "shortDescription": {
                  "text": "冗長な 'asSequence' の呼び出し"
                },
                "fullDescription": {
                  "text": "パフォーマンスに良い影響を及ぼすことのない 'asSequence()' の冗長な呼び出しを報告します。 'asSequence()' は操作を遅延実行して中間コレクションを作成しないため、複数の操作を伴うコレクションの処理を高速化します。 しかし、'asSequence()' の直後にターミナル操作 ('toList()' など) が使用されている場合、パフォーマンスに良い影響を及ぼしません。 例: 'fun test(list: List<String>) {\n      list.asSequence().last()\n  }' クイックフィックス適用後: 'fun test(list: List<String>) {\n      list.last()\n  }'",
                  "markdown": "パフォーマンスに良い影響を及ぼすことのない `asSequence()` の冗長な呼び出しを報告します。\n\n\n`asSequence()` は操作を遅延実行して中間コレクションを作成しないため、複数の操作を伴うコレクションの処理を高速化します。\n\n\nしかし、`asSequence()` の直後にターミナル操作 (`toList()` など) が使用されている場合、パフォーマンスに良い影響を及ぼしません。\n\n**例:**\n\n\n      fun test(list: List<String>) {\n          list.asSequence().last()\n      }\n\nクイックフィックス適用後:\n\n\n      fun test(list: List<String>) {\n          list.last()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantAsSequence",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinCatchMayIgnoreException",
                "shortDescription": {
                  "text": "例外を無視する可能性がある 'catch' ブロック"
                },
                "fullDescription": {
                  "text": "空であるか、例外を無視する可能性がある 'catch' ブロックを報告します。 このような空の 'catch' ブロックは意図的な場合もありますが、デバッグを困難にする可能性があります。 また、'catch' パラメーターを無視するのは不適切である可能性があります。 このインスペクションは、'ignore'、'ignored' または '_' という名前の 'catch' パラメーターを報告しません。 例外の名前を '_' に変更するクイックフィックスを使用できます。 例: 'try {\n    throwingMethod()\n  } catch (ex: IOException) {\n\n  }' クイックフィックス適用後: 'try {\n    throwingMethod()\n  } catch (_: IOException) {\n\n  }' コメント付きの 'catch' ブロックを無視するには、「'catch' ブロックにコメントがある場合は警告しない」オプションを使用します。",
                  "markdown": "空であるか、例外を無視する可能性がある `catch` ブロックを報告します。\n\nこのような空の `catch` ブロックは意図的な場合もありますが、デバッグを困難にする可能性があります。\nまた、`catch` パラメーターを無視するのは不適切である可能性があります。\n\n\nこのインスペクションは、`ignore`、`ignored` または `_` という名前の `catch` パラメーターを報告しません。\n\n\n例外の名前を `_` に変更するクイックフィックスを使用できます。\n\n**例:**\n\n\n      try {\n        throwingMethod()\n      } catch (ex: IOException) {\n\n      }\n\nクイックフィックス適用後:\n\n\n      try {\n        throwingMethod()\n      } catch (_: IOException) {\n\n      }\n\nコメント付きの `catch` ブロックを無視するには、「**'catch' ブロックにコメントがある場合は警告しない**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CatchMayIgnoreException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DifferentStdlibGradleVersion",
                "shortDescription": {
                  "text": "Kotlin ライブラリと Gradle プラグインのバージョンが異なります"
                },
                "fullDescription": {
                  "text": "Kotlin の stdlib とコンパイラーのバージョンが違っていることを報告します。 例: 'dependencies {\n    classpath \"org.jetbrains.kotlin:kotlin-stdlib:0.0.1\"\n  }' この問題を修正するには、Kotlin コンパイラーのバージョンに一致するように Kotlin stdlib バージョンを変更してください。",
                  "markdown": "Kotlin の stdlib とコンパイラーのバージョンが違っていることを報告します。\n\n**例:**\n\n\n      dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-stdlib:0.0.1\"\n      }\n\nこの問題を修正するには、Kotlin コンパイラーのバージョンに一致するように Kotlin stdlib バージョンを変更してください。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DifferentStdlibGradleVersion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinUnusedImport",
                "shortDescription": {
                  "text": "未使用の import ディレクティブ"
                },
                "fullDescription": {
                  "text": "冗長な 'import' ステートメントを報告します。 デフォルトおよび未使用の import は安全に除去できます。 例: 'import kotlin.*\n  import kotlin.collections.*\n  import kotlin.comparisons.*\n  import kotlin.io.*\n  import kotlin.ranges.*\n  import kotlin.sequences.*\n  import kotlin.text.*\n\n  // jvm specific\n  import java.lang.*\n  import kotlin.jvm.*\n\n  // js specific\n  import kotlin.js.*\n\n  import java.io.* // この import は未使用であり、除去できます\n  import java.util.*\n\n  fun foo(list: ArrayList<String>) {\n      list.add(\"\")\n  }'",
                  "markdown": "冗長な `import` ステートメントを報告します。\n\nデフォルトおよび未使用の import は安全に除去できます。\n\n**例:**\n\n\n      import kotlin.*\n      import kotlin.collections.*\n      import kotlin.comparisons.*\n      import kotlin.io.*\n      import kotlin.ranges.*\n      import kotlin.sequences.*\n      import kotlin.text.*\n\n      // jvm specific\n      import java.lang.*\n      import kotlin.jvm.*\n\n      // js specific\n      import kotlin.js.*\n\n      import java.io.* // この import は未使用であり、除去できます\n      import java.util.*\n\n      fun foo(list: ArrayList<String>) {\n          list.add(\"\")\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CanBePrimaryConstructorProperty",
                "shortDescription": {
                  "text": "プロパティがコンストラクターパラメーターに明示的に割り当てられています"
                },
                "fullDescription": {
                  "text": "プライマリコンストラクターのパラメーターに明示的に代入されているプロパティを報告します。 プロパティはプライマリコンストラクターの中で直接宣言することができるため、コードの量を減らして読みやすくすることができます。 例: 'class User(name: String) {\n      val name = name\n  }' クイックフィックスを使用すると、パラメーターとプロパティ宣言がプライマリコンストラクターのパラメーターとして結合されます。 'class User(val name: String) {\n  }'",
                  "markdown": "プライマリコンストラクターのパラメーターに明示的に代入されているプロパティを報告します。\n\nプロパティはプライマリコンストラクターの中で直接宣言することができるため、コードの量を減らして読みやすくすることができます。\n\n**例:**\n\n\n      class User(name: String) {\n          val name = name\n      }\n\nクイックフィックスを使用すると、パラメーターとプロパティ宣言がプライマリコンストラクターのパラメーターとして結合されます。\n\n\n      class User(val name: String) {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CanBePrimaryConstructorProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CanBeVal",
                "shortDescription": {
                  "text": "ローカルの 'var' は変更されることはなく 'val' として宣言できます"
                },
                "fullDescription": {
                  "text": "キーワード 'var' を使用して宣言されたローカル変数で、まったく修飾されていないものを報告します。 Kotlin では、実質的にイミュータブルな変数はキーワード 'val' を使用して宣言し、その変数の値が変更されないようにすることが推奨されています。 例: 'fun example() {\n      var primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)\n      var fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)\n      print(\"Same numbers: \" + primeNumbers.intersect(fibonacciNumbers))\n  }' クイックフィックスを使用すると、キーワード 'var' が 'val' に置換されます。 'fun example() {\n      val primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)\n      val fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)\n      print(\"Same numbers: \" + primeNumbers.intersect(fibonacciNumbers))\n  }'",
                  "markdown": "キーワード `var` を使用して宣言されたローカル変数で、まったく修飾されていないものを報告します。\n\nKotlin では、実質的にイミュータブルな変数はキーワード `val` を使用して宣言し、その変数の値が変更されないようにすることが推奨されています。\n\n**例:**\n\n\n      fun example() {\n          var primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)\n          var fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)\n          print(\"Same numbers: \" + primeNumbers.intersect(fibonacciNumbers))\n      }\n\nクイックフィックスを使用すると、キーワード `var` が `val` に置換されます。\n\n\n      fun example() {\n          val primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)\n          val fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)\n          print(\"Same numbers: \" + primeNumbers.intersect(fibonacciNumbers))\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CanBeVal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaMapForEach",
                "shortDescription": {
                  "text": "Java の Map.forEach メソッドの呼び出しは Kotlin の forEach に置換する必要があります"
                },
                "fullDescription": {
                  "text": "Kotlin の forEach に置換できる Java の Map.'forEach' メソッドの呼び出しを報告します。 例: 'fun test(map: HashMap<Int, String>) {\n      map.forEach { key, value ->\n          foo(key, value)\n      }\n  }\n\n  fun foo(i: Int, s: String) {}' クイックフィックスを使用すると、丸括弧が追加されます。 'fun test(map: HashMap<Int, String>) {\n      map.forEach { (key, value) ->\n          foo(key, value)\n      }\n  }\n\n  fun foo(i: Int, s: String) {}'",
                  "markdown": "Kotlin の **forEach** に置換できる Java の Map.`forEach` メソッドの呼び出しを報告します。\n\n**例:**\n\n\n      fun test(map: HashMap<Int, String>) {\n          map.forEach { key, value ->\n              foo(key, value)\n          }\n      }\n\n      fun foo(i: Int, s: String) {}\n\nクイックフィックスを使用すると、丸括弧が追加されます。\n\n\n      fun test(map: HashMap<Int, String>) {\n          map.forEach { (key, value) ->\n              foo(key, value)\n          }\n      }\n\n      fun foo(i: Int, s: String) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JavaMapForEach",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantObjectTypeCheck",
                "shortDescription": {
                  "text": "オブジェクトに対する慣用的でない 'is' 型チェック"
                },
                "fullDescription": {
                  "text": "オブジェクトに対する 'is' を使った慣用的でない型チェックを報告します。 このようなチェックは、参照の比較に置換することが推奨されています。 例: 'object Foo\n\n  fun foo(arg: Any) = when {\n      arg is Foo -> ...\n      arg !is Foo -> ...\n  }' クイックフィックス適用後: 'object Foo\n\n  fun foo(arg: Any) = when {\n      arg === Foo -> ...\n      arg !== Foo -> ...\n  }'",
                  "markdown": "オブジェクトに対する `is` を使った慣用的でない型チェックを報告します。\n\nこのようなチェックは、参照の比較に置換することが推奨されています。\n\n**例:**\n\n\n      object Foo\n\n      fun foo(arg: Any) = when {\n          arg is Foo -> ...\n          arg !is Foo -> ...\n      }\n\nクイックフィックス適用後:\n\n\n      object Foo\n\n      fun foo(arg: Any) = when {\n          arg === Foo -> ...\n          arg !== Foo -> ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantObjectTypeCheck",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspendFunctionOnCoroutineScope",
                "shortDescription": {
                  "text": "suspend 関数の CoroutineScope レシーバーに起因するあいまいな coroutineContext "
                },
                "fullDescription": {
                  "text": "'CoroutineScope' レシーバーを持つ suspend 関数内にある 'CoroutineScope' 拡張またはメンバーの呼び出しとアクセスを報告します。 関数が 'suspend' で 'CoroutineScope' レシーバーを持っている場合、'kotlin.coroutines.coroutineContext' と 'CoroutineScope.coroutineContext' を介した 'CoroutineContext' へのアクセスはあいまいになります。また、これらの 2 つのコンテキストは一般的に異なります。 この状況を改善するため、'coroutineScope { ... }' の中に疑わしい呼び出しをラップするか、'CoroutineScope' 関数のレシーバーを取り除くことができます。",
                  "markdown": "`CoroutineScope` レシーバーを持つ suspend 関数内にある `CoroutineScope` 拡張またはメンバーの呼び出しとアクセスを報告します。\n\n関数が `suspend` で `CoroutineScope` レシーバーを持っている場合、`kotlin.coroutines.coroutineContext` と `CoroutineScope.coroutineContext` を介した `CoroutineContext` へのアクセスはあいまいになります。また、これらの 2 つのコンテキストは一般的に異なります。\n\n\nこの状況を改善するため、`coroutineScope { ... }` の中に疑わしい呼び出しをラップするか、`CoroutineScope` 関数のレシーバーを取り除くことができます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspendFunctionOnCoroutineScope",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceWithIgnoreCaseEquals",
                "shortDescription": {
                  "text": "'equals(..., ignoreCase = true)' に置換が必要"
                },
                "fullDescription": {
                  "text": "'equals(..., ignoreCase = true)' に置換できる大文字小文字を区別しない比較を報告します。 'equals()' を使用すると、文字列を比較するために 'toLowerCase()' や 'toUpperCase()' を含む文字列を不必要に配置する必要がなくなります。 クイックフィックスを使用すると、'toLowerCase()' または 'toUpperCase()' を使用する大文字小文字を区別しない比較が 'equals(..., ignoreCase = true)' に置換されます。 注: 一部のロケールではセマンティクスが変更される可能性があります。 例: 'fun main() {\n      val a = \"KoTliN\"\n      val b = \"KOTLIN\"\n      println(a.toLowerCase() == b.toLowerCase())\n  }' クイックフィックス適用後: 'fun main() {\n      val a = \"KoTliN\"\n      val b = \"KOTLIN\"\n      println(a.equals(b, ignoreCase = true))\n  }'",
                  "markdown": "`equals(..., ignoreCase = true)` に置換できる大文字小文字を区別しない比較を報告します。\n\n`equals()` を使用すると、文字列を比較するために `toLowerCase()` や `toUpperCase()` を含む文字列を不必要に配置する必要がなくなります。\n\nクイックフィックスを使用すると、`toLowerCase()` または `toUpperCase()` を使用する大文字小文字を区別しない比較が `equals(..., ignoreCase = true)` に置換されます。\n\n**注:** 一部のロケールではセマンティクスが変更される可能性があります。\n\n**例:**\n\n\n      fun main() {\n          val a = \"KoTliN\"\n          val b = \"KOTLIN\"\n          println(a.toLowerCase() == b.toLowerCase())\n      }\n\nクイックフィックス適用後:\n\n\n      fun main() {\n          val a = \"KoTliN\"\n          val b = \"KOTLIN\"\n          println(a.equals(b, ignoreCase = true))\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceWithIgnoreCaseEquals",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DifferentMavenStdlibVersion",
                "shortDescription": {
                  "text": "ライブラリと Maven プラグインのバージョンが異なります"
                },
                "fullDescription": {
                  "text": "Kotlin の stdlib とコンパイラーのバージョンが違っていることを報告します。 異なるバージョンの Kotlin コンパイラーと標準ライブラリを使用すると、実行時に予期しない問題が発生する可能性があります。",
                  "markdown": "Kotlin の stdlib とコンパイラーのバージョンが違っていることを報告します。\n\n異なるバージョンの Kotlin コンパイラーと標準ライブラリを使用すると、実行時に予期しない問題が発生する可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DifferentMavenStdlibVersion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceSubstringWithSubstringAfter",
                "shortDescription": {
                  "text": "'substringAfter' に置換すべき 'substring' の呼び出し"
                },
                "fullDescription": {
                  "text": "'s.substring(s.indexOf(x))' から 's.substringAfter(x)' のように置換できる呼び出しを報告します。 's.substringAfter(x)' を使用すると、コードを単純化できます。 クイックフィックスを使用すると、'substring' の呼び出しが 'substringAfter' に置換されます。 例: 'fun foo(s: String) {\n      s.substring(s.indexOf('x'))\n  }' クイックフィックス適用後: 'fun foo(s: String) {\n      s.substringAfter('x')\n  }'",
                  "markdown": "`s.substring(s.indexOf(x))` から `s.substringAfter(x)` のように置換できる呼び出しを報告します。\n\n`s.substringAfter(x)` を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、`substring` の呼び出しが `substringAfter` に置換されます。\n\n**例:**\n\n\n      fun foo(s: String) {\n          s.substring(s.indexOf('x'))\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(s: String) {\n          s.substringAfter('x')\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceSubstringWithSubstringAfter",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitNullableNothingType",
                "shortDescription": {
                  "text": "暗黙的な 'Nothing?' 型"
                },
                "fullDescription": {
                  "text": "暗黙的な Nothing? 型を持つ変数と関数を報告します。 例: 'fun foo() = null' クイックフィックスを使用すると、戻り値の型が明示的に指定されます。 'fun foo(): Nothing? = null'",
                  "markdown": "暗黙的な **Nothing?** 型を持つ変数と関数を報告します。\n\n**例:**\n\n\n      fun foo() = null\n\nクイックフィックスを使用すると、戻り値の型が明示的に指定されます。\n\n\n      fun foo(): Nothing? = null\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ImplicitNullableNothingType",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantCompanionReference",
                "shortDescription": {
                  "text": "冗長な 'Companion' 参照"
                },
                "fullDescription": {
                  "text": "冗長な 'Companion' の参照を報告します。 例: 'class A {\n      companion object {\n          fun create() = A()\n      }\n  }\n  fun test() {\n      val s = A.Companion.create()\n  }' クイックフィックス適用後: 'class A {\n      companion object {\n          fun create() = A()\n      }\n  }\n  fun test() {\n      val s = A.create()\n  }'",
                  "markdown": "冗長な `Companion` の参照を報告します。\n\n**例:**\n\n\n      class A {\n          companion object {\n              fun create() = A()\n          }\n      }\n      fun test() {\n          val s = A.Companion.create()\n      }\n\nクイックフィックス適用後:\n\n\n      class A {\n          companion object {\n              fun create() = A()\n          }\n      }\n      fun test() {\n          val s = A.create()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantCompanionReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceAssociateFunction",
                "shortDescription": {
                  "text": "'associateBy' または 'associateWith' に置換可能な 'associate'"
                },
                "fullDescription": {
                  "text": "'associateBy()' または 'associateWith()' に置換できる 'associate()' および 'associateTo()' の呼び出しを報告します。 どちらの関数も、所定のシーケンスまたはコレクションの要素に (レシーバーとして) 適用される変換関数を受け付けます。 これらはその後、生成される 'Map' をビルドするために使用されます。 変換関数が 'it' を参照することを考慮すると、'associate[To]()' の呼び出しは、より高いパフォーマンスを提供する 'associateBy()' または 'associateWith()' に置換できます。 例: 'fun getKey(i: Int) = 1L\n  fun getValue(i: Int) = 1L\n\n  fun test() {\n      arrayOf(1).associate { getKey(it) to it }  // 置換可能な 'associate()'\n      listOf(1).associate { it to getValue(it) } // 置換可能な 'associate()'\n  }' クイックフィックス適用後: 'fun getKey(i: Int) = 1L\n  fun getValue(i: Int) = 1L\n\n  fun test() {\n      arrayOf(1).associateBy { getKey(it) }\n      listOf(1).associateWith { getValue(it) }\n  }'",
                  "markdown": "`associateBy()` または `associateWith()` に置換できる `associate()` および `associateTo()` の呼び出しを報告します。\n\n\nどちらの関数も、所定のシーケンスまたはコレクションの要素に (レシーバーとして) 適用される変換関数を受け付けます。\nこれらはその後、生成される `Map` をビルドするために使用されます。\n\n\n変換関数が `it` を参照することを考慮すると、`associate[To]()` の呼び出しは、より高いパフォーマンスを提供する `associateBy()` または `associateWith()` に置換できます。\n\n**例:**\n\n      fun getKey(i: Int) = 1L\n      fun getValue(i: Int) = 1L\n\n      fun test() {\n          arrayOf(1).associate { getKey(it) to it }  // 置換可能な 'associate()'\n          listOf(1).associate { it to getValue(it) } // 置換可能な 'associate()'\n      }\n\nクイックフィックス適用後:\n\n      fun getKey(i: Int) = 1L\n      fun getValue(i: Int) = 1L\n\n      fun test() {\n          arrayOf(1).associateBy { getKey(it) }\n          listOf(1).associateWith { getValue(it) }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceAssociateFunction",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KDocUnresolvedReference",
                "shortDescription": {
                  "text": "KDoc 内の未解決の参照"
                },
                "fullDescription": {
                  "text": "KDoc コメントに未解決の参照があることを報告します。 例: '/**\n   * [unresolvedLink]\n   */\n  fun foo() {}' この問題を修正するには、リンクを有効にしてください。",
                  "markdown": "KDoc コメントに未解決の参照があることを報告します。\n\n**例:**\n\n\n      /**\n       * [unresolvedLink]\n       */\n      fun foo() {}\n\nこの問題を修正するには、リンクを有効にしてください。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KDocUnresolvedReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObsoleteExperimentalCoroutines",
                "shortDescription": {
                  "text": "1.3 以降、実験的なコルーチンの使用は推奨されません"
                },
                "fullDescription": {
                  "text": "実験的なコルーチンが使用されているコードを報告します。 このような使用方法は Kotlin 1.3 以降との互換性がないため、更新する必要があります。",
                  "markdown": "実験的なコルーチンが使用されているコードを報告します。\n\nこのような使用方法は Kotlin 1.3 以降との互換性がないため、更新する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ObsoleteExperimentalCoroutines",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LiftReturnOrAssignment",
                "shortDescription": {
                  "text": "return または代入は取り出せます"
                },
                "fullDescription": {
                  "text": "'return' ステートメントまたは代入を取り出せば式に変換できる 'if'、'when'、および 'try' ステートメントを報告します。 例: 'fun foo(arg: Int): String {\n      when (arg) {\n          0 -> return \"Zero\"\n          1 -> return \"One\"\n          else -> return \"Multiple\"\n      }\n  }' クイックフィックス適用後: 'fun foo(arg: Int): String {\n      return when (arg) {\n          0 -> \"Zero\"\n          1 -> \"One\"\n          else -> \"Multiple\"\n      }\n  }' このインスペクションで複数ステートメントの分岐を使用したより複雑なコードをハイライトする場合は「各分岐が単一のステートメントの場合にのみ報告する」オプションのチェックを解除します。",
                  "markdown": "`return` ステートメントまたは代入を取り出せば式に変換できる `if`、`when`、および `try` ステートメントを報告します。\n\n**例:**\n\n\n      fun foo(arg: Int): String {\n          when (arg) {\n              0 -> return \"Zero\"\n              1 -> return \"One\"\n              else -> return \"Multiple\"\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(arg: Int): String {\n          return when (arg) {\n              0 -> \"Zero\"\n              1 -> \"One\"\n              else -> \"Multiple\"\n          }\n      }\n\nこのインスペクションで複数ステートメントの分岐を使用したより複雑なコードをハイライトする場合は「各分岐が単一のステートメントの場合にのみ報告する」オプションのチェックを解除します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LiftReturnOrAssignment",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedLambdaShadowedImplicitParameter",
                "shortDescription": {
                  "text": "ネストしたラムダにシャドーされた暗黙的なパラメーターがあります"
                },
                "fullDescription": {
                  "text": "ネストしたラムダで、シャドーイングされた暗黙的なパラメーターを持つものを報告します。 例: 'fun foo(listOfLists: List<List<String>>) {\n  listOfLists.forEach {\n    it.forEach {\n      println(it)\n    }\n  }\n}' クイックフィックス適用後: 'fun foo(listOfLists: List<List<String>>) {\n  listOfLists.forEach {\n    it.forEach { it1 ->\n      println(it1)\n    }\n  }\n}'",
                  "markdown": "ネストしたラムダで、シャドーイングされた暗黙的なパラメーターを持つものを報告します。\n\n**例:**\n\n\n    fun foo(listOfLists: List<List<String>>) {\n      listOfLists.forEach {\n        it.forEach {\n          println(it)\n        }\n      }\n    }\n\nクイックフィックス適用後:\n\n\n    fun foo(listOfLists: List<List<String>>) {\n      listOfLists.forEach {\n        it.forEach { it1 ->\n          println(it1)\n        }\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "NestedLambdaShadowedImplicitParameter",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyWhenWithBooleanConstantCondition",
                "shortDescription": {
                  "text": "単純化できる 'when'"
                },
                "fullDescription": {
                  "text": "定数 'true' または 'false' の分岐を持つ 'when' 式を報告します。 \"when\" の単純化 クイックフィックスを使用すると、コードを自動的に修正できます。 例: 'fun redundant() {\n      when { // <== 冗長。クイックフィックスを使用すると when 式を \"println(\"true\")\" に単純化できます\n          true -> println(\"true\")\n          else -> println(\"false\")\n      }\n  }'",
                  "markdown": "定数 `true` または `false` の分岐を持つ `when` 式を報告します。\n\n**\"when\" の単純化** クイックフィックスを使用すると、コードを自動的に修正できます。\n\n例:\n\n\n      fun redundant() {\n          when { // <== 冗長。クイックフィックスを使用すると when 式を \"println(\"true\")\" に単純化できます\n              true -> println(\"true\")\n              else -> println(\"false\")\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifyWhenWithBooleanConstantCondition",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantSamConstructor",
                "shortDescription": {
                  "text": "冗長な SAM コンストラクター"
                },
                "fullDescription": {
                  "text": "ラムダ式に置換できる SAM (単一抽象メソッド) コンストラクターが使用されていることを報告します。 例: 'fun main() {\n      foo(Runnable { println(\"Hi!\") })\n  }\n\n  fun foo(other: Runnable) {}' クイックフィックス適用後: 'fun main() {\n      foo( { println(\"Hi!\") })\n  }\n\n  fun foo(other: Runnable) {}'",
                  "markdown": "ラムダ式に置換できる SAM (単一抽象メソッド) コンストラクターが使用されていることを報告します。\n\n**例:**\n\n\n      fun main() {\n          foo(Runnable { println(\"Hi!\") })\n      }\n\n      fun foo(other: Runnable) {}\n\nクイックフィックス適用後:\n\n\n      fun main() {\n          foo( { println(\"Hi!\") })\n      }\n\n      fun foo(other: Runnable) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantSamConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinConstantConditions",
                "shortDescription": {
                  "text": "定数条件"
                },
                "fullDescription": {
                  "text": "非自明な条件と値で、常に true、false、null、またはゼロになることが静的に分かっているものを報告します。 これは意図的な場合もありますが、多くの場合はプログラムのロジックに問題があることを示唆しています。 また、常に到達不可能な 'when' 分岐と、常に失敗すると静的に分かっている一部の式を報告します。 例: 'fun process(x: Int?) {\n  val isNull = x == null\n  if (!isNull) {\n    if (x != null) {} // 条件は常に true です\n    require(x!! < 0 && x > 10) // 条件は常に false です\n  } else {\n    println(x!!) // !! 演算子は常に失敗します\n  }\n}\nfun process(v: Any) {\n  when(v) {\n    is CharSequence -> println(v as Int) // キャストは常に失敗します\n    is String -> println(v) // 分岐は到達不能です\n  }\n}' 条件にない定数値を持つ変数の報告を避けるには、「定数が変数に保管された場合に警告する」オプションのチェックを解除します。 2021.3 の新機能です",
                  "markdown": "非自明な条件と値で、常に true、false、null、またはゼロになることが静的に分かっているものを報告します。 これは意図的な場合もありますが、多くの場合はプログラムのロジックに問題があることを示唆しています。 また、常に到達不可能な `when` 分岐と、常に失敗すると静的に分かっている一部の式を報告します。\n\n例:\n\n\n    fun process(x: Int?) {\n      val isNull = x == null\n      if (!isNull) {\n        if (x != null) {} // 条件は常に true です\n        require(x!! < 0 && x > 10) // 条件は常に false です\n      } else {\n        println(x!!) // !! 演算子は常に失敗します\n      }\n    }\n    fun process(v: Any) {\n      when(v) {\n        is CharSequence -> println(v as Int) // キャストは常に失敗します\n        is String -> println(v) // 分岐は到達不能です\n      }\n    }\n\n\n条件にない定数値を持つ変数の報告を避けるには、「定数が変数に保管された場合に警告する」オプションのチェックを解除します。\n\n2021.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KotlinConstantConditions",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InconsistentCommentForJavaParameter",
                "shortDescription": {
                  "text": "Java パラメーターの一貫性のないコメント"
                },
                "fullDescription": {
                  "text": "コメントブロックで指定されている一貫性のない Java メソッド呼び出しのパラメーター名を報告します。 例: '// Java\n  public class JavaService {\n      public void invoke(String command) {}\n  }' '// Kotlin\n  fun main() {\n      JavaService().invoke(/* name = */ \"fix\")\n  }' クイックフィックスを使用すると、コメントブロックのパラメーター名が修正されます。 'fun main() {\n      JavaService().invoke(/* command = */ \"fix\")\n  }'",
                  "markdown": "コメントブロックで指定されている一貫性のない **Java** メソッド呼び出しのパラメーター名を報告します。\n\n**例:**\n\n\n      // Java\n      public class JavaService {\n          public void invoke(String command) {}\n      }\n\n\n      // Kotlin\n      fun main() {\n          JavaService().invoke(/* name = */ \"fix\")\n      }\n\nクイックフィックスを使用すると、コメントブロックのパラメーター名が修正されます。\n\n\n      fun main() {\n          JavaService().invoke(/* command = */ \"fix\")\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InconsistentCommentForJavaParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名規約",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForEachParameterNotUsed",
                "shortDescription": {
                  "text": "イテレートされた要素が forEach で使用されていません"
                },
                "fullDescription": {
                  "text": "iterable 値を使用していない 'forEach' ループを報告します。 例: 'listOf(1, 2, 3).forEach { }' クイックフィックスを使用すると、'forEach' セクションに匿名パラメーターが導入されます。 'listOf(1, 2, 3).forEach { _ -> }'",
                  "markdown": "iterable 値を使用していない `forEach` ループを報告します。\n\n**例:**\n\n\n      listOf(1, 2, 3).forEach { }\n\nクイックフィックスを使用すると、`forEach` セクションに匿名パラメーターが導入されます。\n\n\n      listOf(1, 2, 3).forEach { _ -> }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ForEachParameterNotUsed",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LeakingThis",
                "shortDescription": {
                  "text": "コンストラクターで 'this' がリークしています"
                },
                "fullDescription": {
                  "text": "次のようなオブジェクト構築中に行われている 'this' を使用した安全でない操作を報告します。 クラスを初期化する際にコンストラクターまたはプロパティの初期化ブロックから final でないプロパティにアクセスしている。 クラスを初期化する際に非 final の関数を呼び出している。 非 final クラスのコンストラクターで 'this' を関数の引数として使用している。 対象のクラスから継承するクラスが他にもある場合、その継承先クラスは安全でない操作が実行される時点では完全に初期化されていない可能性があります。 例: 'abstract class Base {\n      val code = calculate()\n      abstract fun calculate(): Int\n  }\n\n  class Derived(private val x: Int) : Base() {\n      override fun calculate() = x\n  }\n\n  fun testIt() {\n      println(Derived(42).code) // 期待: 42、実際: 0\n  }'",
                  "markdown": "次のようなオブジェクト構築中に行われている `this` を使用した安全でない操作を報告します。\n\n* クラスを初期化する際にコンストラクターまたはプロパティの初期化ブロックから final でないプロパティにアクセスしている。\n* クラスを初期化する際に非 final の関数を呼び出している。\n* 非 final クラスのコンストラクターで `this` を関数の引数として使用している。\n\n\n対象のクラスから継承するクラスが他にもある場合、その継承先クラスは安全でない操作が実行される時点では完全に初期化されていない可能性があります。\n\n**例:**\n\n\n      abstract class Base {\n          val code = calculate()\n          abstract fun calculate(): Int\n      }\n\n      class Derived(private val x: Int) : Base() {\n          override fun calculate() = x\n      }\n\n      fun testIt() {\n          println(Derived(42).code) // 期待: 42、実際: 0\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LeakingThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveRedundantCallsOfConversionMethods",
                "shortDescription": {
                  "text": "冗長な変換メソッドの呼び出し"
                },
                "fullDescription": {
                  "text": "冗長な変換メソッドの呼び出しを報告します ('String' に対する 'toString()' や 'Double' に対する 'toDouble()' など)。 コードをクリーンアップするには、'冗長な変換メソッドの呼び出しの除去' クイックフィックスを使用します。",
                  "markdown": "冗長な変換メソッドの呼び出しを報告します (`String` に対する `toString()` や `Double` に対する `toDouble()` など)。\n\nコードをクリーンアップするには、'冗長な変換メソッドの呼び出しの除去' クイックフィックスを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RemoveRedundantCallsOfConversionMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AddVarianceModifier",
                "shortDescription": {
                  "text": "型パラメーターは 'in' または 'out' の変性を持つことができます"
                },
                "fullDescription": {
                  "text": "'in' または 'out' の変性を持つことができるパラメーターを報告します。 'in' と 'out' の変性を使用すると、Kotlin の型推論がより的確に行われるほか、コードのセマンティクスも明確になります。 例: 'class Box<T>(val obj: T)\n\n  fun consumeString(box: Box<String>) {}\n  fun consumeCharSequence(box: Box<CharSequence>) {}\n\n  fun usage(box: Box<String>) {\n      consumeString(box)\n      consumeCharSequence(box) // コンパイルエラー\n  }' クイックフィックスを使用すると、マッチする変性修飾子が追加されます。 'class Box<out T>(val obj: T)\n\n  fun consumeString(box: Box<String>) {}\n  fun consumeCharSequence(box: Box<CharSequence>) {}\n\n  fun usage(box: Box<String>) ++{\n      consumeString(box)\n      consumeCharSequence(box) // OK\n  }'",
                  "markdown": "`in` または `out` の変性を持つことができるパラメーターを報告します。\n\n`in` と `out` の変性を使用すると、Kotlin の型推論がより的確に行われるほか、コードのセマンティクスも明確になります。\n\n**例:**\n\n\n      class Box<T>(val obj: T)\n\n      fun consumeString(box: Box<String>) {}\n      fun consumeCharSequence(box: Box<CharSequence>) {}\n\n      fun usage(box: Box<String>) {\n          consumeString(box)\n          consumeCharSequence(box) // コンパイルエラー\n      }\n\nクイックフィックスを使用すると、マッチする変性修飾子が追加されます。\n\n\n      class Box<out T>(val obj: T)\n\n      fun consumeString(box: Box<String>) {}\n      fun consumeCharSequence(box: Box<CharSequence>) {}\n\n      fun usage(box: Box<String>) ++{\n          consumeString(box)\n          consumeCharSequence(box) // OK\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AddVarianceModifier",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinThrowableNotThrown",
                "shortDescription": {
                  "text": "スローされていない Throwable"
                },
                "fullDescription": {
                  "text": "'Throwable' またはそのサブクラスのインスタンス化で、作成される 'Throwable' が実際にスローされていない場合に報告します。 これは、報告対象のコードにテストでは発見しにくいミスがあることを示しています。 また、このインスペクションは 'Throwable' またはそのサブクラスのインスタンスを返すメソッド呼び出しがあり、結果的に生成される 'Throwable' のインスタンスが実際にスローされない場合にも報告します。 例: 'fun check(condition: Boolean) {\n      if (!condition) /* ここにスローがない */ IllegalArgumentException(\"condition is not met\");\n  }\n\n  fun createError() = RuntimeException()\n\n  fun foo() {\n      /* ここにスローがない */ createError()\n  }'",
                  "markdown": "`Throwable` またはそのサブクラスのインスタンス化で、作成される `Throwable` が実際にスローされていない場合に報告します。\n\nこれは、報告対象のコードにテストでは発見しにくいミスがあることを示しています。\n\n\nまた、このインスペクションは `Throwable` またはそのサブクラスのインスタンスを返すメソッド呼び出しがあり、結果的に生成される `Throwable` のインスタンスが実際にスローされない場合にも報告します。\n\n**例:**\n\n\n      fun check(condition: Boolean) {\n          if (!condition) /* ここにスローがない */ IllegalArgumentException(\"condition is not met\");\n      }\n\n      fun createError() = RuntimeException()\n\n      fun foo() {\n          /* ここにスローがない */ createError()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowableNotThrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinSealedInheritorsInJava",
                "shortDescription": {
                  "text": "Java から Kotlin Sealed インターフェース/クラスを継承"
                },
                "fullDescription": {
                  "text": "Java コード の Kotlin sealed インターフェースまたはクラスから継承しようとしていることを報告します。 例: '// Kotlin ファイル: MathExpression.kt\n\nsealed class MathExpression\n\ndata class Const(val number: Double) : MathExpression()\ndata class Sum(val e1: MathExpression, val e2: MathExpression) : MathExpression()' '// Java ファイル: NotANumber.java\n\npublic class NotANumber extends MathExpression {\n}'",
                  "markdown": "Java コード の Kotlin sealed インターフェースまたはクラスから継承しようとしていることを報告します。\n\n**例:**\n\n\n    // Kotlin ファイル: MathExpression.kt\n\n    sealed class MathExpression\n\n    data class Const(val number: Double) : MathExpression()\n    data class Sum(val e1: MathExpression, val e2: MathExpression) : MathExpression()\n\n\n    // Java ファイル: NotANumber.java\n\n    public class NotANumber extends MathExpression {\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "KotlinSealedInheritorsInJava",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 相互運用性の問題",
                      "index": 66,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyNegatedBinaryExpression",
                "shortDescription": {
                  "text": "単純化できる否定ブール式"
                },
                "fullDescription": {
                  "text": "単純化できる否定されたブール式を報告します。 クイックフィックスを使用すると、ブール式が単純化されます。 例: 'fun test(n: Int) {\n        !(0 == 1)\n    }' クイックフィックス適用後: 'fun test(n: Int) {\n        0 != 1\n    }' IEEE-754 NaN 値がある場合、このアクションによりコードのセマンティクスが変更される可能性があることに注意してください。 'fun main() {\n        println(!(Double.NaN >= 0)) // true\n    }' クイックフィックス適用後: 'fun main() {\n        println(Double.NaN < 0) // false\n    }'",
                  "markdown": "単純化できる否定されたブール式を報告します。\n\nクイックフィックスを使用すると、ブール式が単純化されます。\n\n**例:**\n\n\n        fun test(n: Int) {\n            !(0 == 1)\n        }\n\nクイックフィックス適用後:\n\n\n        fun test(n: Int) {\n            0 != 1\n        }\n\nIEEE-754 NaN 値がある場合、このアクションによりコードのセマンティクスが変更される可能性があることに注意してください。\n\n\n        fun main() {\n            println(!(Double.NaN >= 0)) // true\n        }\n\nクイックフィックス適用後:\n\n\n        fun main() {\n            println(Double.NaN < 0) // false\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifyNegatedBinaryExpression",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MemberVisibilityCanBePrivate",
                "shortDescription": {
                  "text": "クラスメンバーには 'private' 可視性を指定できます"
                },
                "fullDescription": {
                  "text": "カプセル化の原則に従うために 'private' にできる宣言を報告します。 例: 'class Service(val url: String) {\n    fun connect(): URLConnection = URL(url).openConnection()\n}' クイックフィックス適用後 ('Service' クラス外で 'url' は使用されていないとみなしています): 'class Service(private val url: String) {\n    fun connect(): URLConnection = URL(url).openConnection()\n}'",
                  "markdown": "カプセル化の原則に従うために `private` にできる宣言を報告します。\n\n**例:**\n\n\n    class Service(val url: String) {\n        fun connect(): URLConnection = URL(url).openConnection()\n    }\n\nクイックフィックス適用後 (`Service` クラス外で `url` は使用されていないとみなしています):\n\n\n    class Service(private val url: String) {\n        fun connect(): URLConnection = URL(url).openConnection()\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MemberVisibilityCanBePrivate",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveForLoopIndices",
                "shortDescription": {
                  "text": "未使用のループインデックス"
                },
                "fullDescription": {
                  "text": "'withIndex()' 関数を使用しているものの、インデックス変数を使用せずにコレクションを反復処理している 'for' ループを報告します。 コードをクリーンアップするには、\"'for' ループのインデックスを除去\" クイックフィックスを使用します。 例: 'fun foo(bar: List<String>) {\n     for ((index : Int, value: String) in bar.withIndex()) { // <== 'index' は使用されない\n         println(value)\n     }\n  }' クイックフィックス適用後: 'fun foo(bar: List<String>) {\n      for (value: String in bar) { // <== '.withIndex()' と 'index' が除去されている\n          println(value)\n      }\n  }'",
                  "markdown": "`withIndex()` 関数を使用しているものの、インデックス変数を使用せずにコレクションを反復処理している `for` ループを報告します。\n\nコードをクリーンアップするには、\"'for' ループのインデックスを除去\" クイックフィックスを使用します。\n\n**例:**\n\n\n      fun foo(bar: List<String>) {\n         for ((index : Int, value: String) in bar.withIndex()) { // <== 'index' は使用されない\n             println(value)\n         }\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(bar: List<String>) {\n          for (value: String in bar) { // <== '.withIndex()' と 'index' が除去されている\n              println(value)\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RemoveForLoopIndices",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantSuspendModifier",
                "shortDescription": {
                  "text": "冗長な 'suspend' 修飾子"
                },
                "fullDescription": {
                  "text": "'suspend' 修飾子について、関数内で別の suspend 関数が呼ばれていないものを冗長とみなして報告します。",
                  "markdown": "`suspend` 修飾子について、関数内で別の suspend 関数が呼ばれていないものを冗長とみなして報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantSuspendModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousAsDynamic",
                "shortDescription": {
                  "text": "疑わしい 'asDynamic' の呼び出し"
                },
                "fullDescription": {
                  "text": "dynamic 型のレシーバーに対する 'asDynamic' 関数が使用されていることを報告します。 'asDynamic' 関数は dynamic 型の式に対しては無効です。 dynamic 型のレシーバーに対して 'asDynamic' 関数を使用すると、実行時に問題が発生する可能性があります。'asDynamic' は JavaScript 環境で実行されるため、実行時にはそのような関数が存在しない可能性があるためです。 この関数は、通常の Kotlin の型に使用することが想定されています。 「\"asDynamic\" の呼び出しを除去」クイックフィックスを使用すると、コードが自動的に修正されます。 例: 'fun wrongUsage(d: Dynamic) {\n     d.asDynamic().foo() // <== 冗長。クイックフィックスを使用すると、呼び出し式が \"d.foo()\" に単純化されます\n  }'",
                  "markdown": "dynamic 型のレシーバーに対する `asDynamic` 関数が使用されていることを報告します。\n\n`asDynamic` 関数は dynamic 型の式に対しては無効です。\n\ndynamic 型のレシーバーに対して `asDynamic` 関数を使用すると、実行時に問題が発生する可能性があります。`asDynamic` は JavaScript 環境で実行されるため、実行時にはそのような関数が存在しない可能性があるためです。\nこの関数は、通常の Kotlin の型に使用することが想定されています。\n\n「**\"asDynamic\" の呼び出しを除去**」クイックフィックスを使用すると、コードが自動的に修正されます。\n\n例:\n\n\n      fun wrongUsage(d: Dynamic) {\n         d.asDynamic().foo() // <== 冗長。クイックフィックスを使用すると、呼び出し式が \"d.foo()\" に単純化されます\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SuspiciousAsDynamic",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FilterIsInstanceCallWithClassLiteralArgument",
                "shortDescription": {
                  "text": "クラスリテラル引数を持つ 'filterIsInstance' の呼び出し"
                },
                "fullDescription": {
                  "text": "クラスリテラルの引数を持つ Kotlin 標準ライブラリ関数 'filterIsInstance' の呼び出しを報告します。 この関数の具象化された型パラメーターを持つバージョンを使用し、'::class.java' 構文を避ける方が慣用的です。 注意: このインスペクションはジェネリックなクラスリテラルに対しては報告されません。型引数リスト内の 'Class<*, *>' 構文は望ましくない場合があるためです。 例: 'fun foo(list: List<*>) {\n      list.filterIsInstance(Int::class.java)\n  }' クイックフィックス適用後: 'fun foo(list: List<*>) {\n      list.filterIsInstance<Int>()\n  }'",
                  "markdown": "クラスリテラルの引数を持つ Kotlin 標準ライブラリ関数 `filterIsInstance` の呼び出しを報告します。 この関数の具象化された型パラメーターを持つバージョンを使用し、`::class.java` 構文を避ける方が慣用的です。\n\n注意: このインスペクションはジェネリックなクラスリテラルに対しては報告されません。型引数リスト内の `Class<*, *>` 構文は望ましくない場合があるためです。\n\n例:\n\n\n      fun foo(list: List<*>) {\n          list.filterIsInstance(Int::class.java)\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(list: List<*>) {\n          list.filterIsInstance<Int>()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FilterIsInstanceCallWithClassLiteralArgument",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FromClosedRangeMigration",
                "shortDescription": {
                  "text": "1.3 以降の fromClosedRange() にある MIN_VALUE ステップ"
                },
                "fullDescription": {
                  "text": "間隔が 'MIN_VALUE' である 'IntProgression.fromClosedRange()' と 'LongProgression.fromClosedRange()' を報告します。 間隔が 'MIN_VALUE' である 'IntProgression.fromClosedRange()' と 'LongProgression.fromClosedRange()' の呼び出しは禁止されています。 Kotlin 1.3 以降に移行する際には、このような呼び出しをすべてチェックする必要があります。 例: 'IntProgression.fromClosedRange(12, 143, Int.MIN_VALUE)' この問題を修正するには、数列の間隔を変更してください。",
                  "markdown": "間隔が `MIN_VALUE` である `IntProgression.fromClosedRange()` と `LongProgression.fromClosedRange()` を報告します。\n\n\n間隔が `MIN_VALUE` である `IntProgression.fromClosedRange()` と `LongProgression.fromClosedRange()` の呼び出しは禁止されています。 Kotlin 1.3 以降に移行する際には、このような呼び出しをすべてチェックする必要があります。\n\n**例:**\n\n\n      IntProgression.fromClosedRange(12, 143, Int.MIN_VALUE)\n\nこの問題を修正するには、数列の間隔を変更してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FromClosedRangeMigration",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveRedundantBackticks",
                "shortDescription": {
                  "text": "冗長なバッククォート"
                },
                "fullDescription": {
                  "text": "参照にある冗長なバッククォートを報告します。 'in'、'object'、'is' など、Kotlin の一部のキーワードは Java では有効な識別子として使用されています。 Java ライブラリのメソッドに Kotlin のキーワードが使用されている場合でも、'foo.`is`(bar)' のようにバッククォート文字 ('`') を使用してエスケープすることで、そのメソッドを呼び出すことができます。 このエスケープが冗長で、安全に省略できる場合があります。 このインスペクションは、このようなケースを検出して報告します。また、'冗長なバッククォートの除去' クイックフィックスとペアになっており、ハイライトされたコードを修正できるようになっています。 例: 'fun `is`(x: String) {}\n  fun foo() {\n      `is`(\"bar\") // 'is' はキーワードであるためバッククォートが必要\n  }\n\n  fun `test that smth works as designed`() {} // 可読性を高めるための複雑な識別子であるため問題なし\n\n  val `a` = 1  // バッククォートは不要'",
                  "markdown": "参照にある冗長なバッククォートを報告します。\n\n\n`in`、`object`、`is` など、Kotlin の一部のキーワードは Java では有効な識別子として使用されています。\nJava ライブラリのメソッドに Kotlin のキーワードが使用されている場合でも、``foo.`is`(bar)`` のようにバッククォート文字 (`````) を使用してエスケープすることで、そのメソッドを呼び出すことができます。\nこのエスケープが冗長で、安全に省略できる場合があります。 このインスペクションは、このようなケースを検出して報告します。また、'冗長なバッククォートの除去' クイックフィックスとペアになっており、ハイライトされたコードを修正できるようになっています。\n\n**例:**\n\n\n      fun `is`(x: String) {}\n      fun foo() {\n          `is`(\"bar\") // 'is' はキーワードであるためバッククォートが必要\n      }\n\n      fun `test that smth works as designed`() {} // 可読性を高めるための複雑な識別子であるため問題なし\n\n      val `a` = 1  // バッククォートは不要\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RemoveRedundantBackticks",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceReadLineWithReadln",
                "shortDescription": {
                  "text": "'readLine' は 'readln' または 'readlnOrNull' に置換できます"
                },
                "fullDescription": {
                  "text": "'readln()' または 'readlnOrNull()' に置換できる 'readLine()' への呼び出しを報告します。 対応する関数を使用すると、コードを単純化できます。 クイックフィックスを使用すると、'readLine()!!' が 'readln()' に、'readLine()' が 'readlnOrNull()' に置換されます。 例: 'val x = readLine()!!\n    val y = readLine()?.length' クイックフィックス適用後: 'val x = readln()\n    val y = readlnOrNull()?.length'",
                  "markdown": "`readln()` または `readlnOrNull()` に置換できる `readLine()` への呼び出しを報告します。\n\n\n対応する関数を使用すると、コードを単純化できます。\n\n\nクイックフィックスを使用すると、`readLine()!!` が `readln()` に、`readLine()` が `readlnOrNull()` に置換されます。\n\n**例:**\n\n\n        val x = readLine()!!\n        val y = readLine()?.length\n\nクイックフィックス適用後:\n\n\n        val x = readln()\n        val y = readlnOrNull()?.length\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceReadLineWithReadln",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SelfAssignment",
                "shortDescription": {
                  "text": "冗長な代入"
                },
                "fullDescription": {
                  "text": "変数の自己代入を報告します。 クイックフィックスを使用すると、冗長な代入が除去されます。 例: 'fun test() {\n      var bar = 1\n      bar = bar\n  }' クイックフィックス適用後: 'fun test() {\n      var bar = 1\n  }'",
                  "markdown": "変数の自己代入を報告します。\n\nクイックフィックスを使用すると、冗長な代入が除去されます。\n\n**例:**\n\n\n      fun test() {\n          var bar = 1\n          bar = bar\n      }\n\nクイックフィックス適用後:\n\n\n      fun test() {\n          var bar = 1\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SelfAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RecursiveEqualsCall",
                "shortDescription": {
                  "text": "再帰的な equals の呼び出し"
                },
                "fullDescription": {
                  "text": "'equals'('==') の再帰呼び出しを報告します。 Kotlin の '==' は、'equals' メソッドを内部的に呼び出すことでオブジェクト値を比較しています。 その一方で、'===' はオブジェクトを参照で比較しています。 '===' は、一般的に 'equals' メソッドの実装で使用されます。 しかし、'===' が誤って '==' と混同され、無限再帰を引き起こす可能性があります。 例: 'class X {\n      override fun equals(other: Any?): Boolean {\n          if (this == other) return true\n          return false\n      }\n  }' クイックフィックス適用後: 'class X {\n      override fun equals(other: Any?): Boolean {\n          if (this === other) return true\n          return false\n      }\n  }'",
                  "markdown": "`equals`(`==`) の再帰呼び出しを報告します。\n\n\nKotlin の `==` は、`equals` メソッドを内部的に呼び出すことでオブジェクト値を比較しています。\nその一方で、`===` はオブジェクトを参照で比較しています。\n\n\n`===` は、一般的に `equals` メソッドの実装で使用されます。\nしかし、`===` が誤って `==` と混同され、無限再帰を引き起こす可能性があります。\n\n**例:**\n\n\n      class X {\n          override fun equals(other: Any?): Boolean {\n              if (this == other) return true\n              return false\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      class X {\n          override fun equals(other: Any?): Boolean {\n              if (this === other) return true\n              return false\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RecursiveEqualsCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyNestedEachInScopeFunction",
                "shortDescription": {
                  "text": "ネストした forEach のある Scope 関数は単純化できます"
                },
                "fullDescription": {
                  "text": "'also' や 'apply' のようなスコープ関数内にある 'forEach' 関数で、単純化できるものを報告します。 「forEach の呼び出しを onEach に変換」クイックフィックスを使用すると、コードを自動的に修正できます。 例: 'fun test(list: List<Int>) {\n      val x = list.also { it.forEach { it + 4 } }.toString()\n      val y = list.apply { forEach { println(it) } }\n  }' クイックフィックス適用後: 'fun test(list: List<Int>) {\n      val x = list.onEach { it + 4 }.toString()\n      val y = list.onEach { println(it) }\n  }'",
                  "markdown": "`also` や `apply` のようなスコープ関数内にある `forEach` 関数で、単純化できるものを報告します。\n\n「**forEach の呼び出しを onEach に変換**」クイックフィックスを使用すると、コードを自動的に修正できます。\n\n例:\n\n\n      fun test(list: List<Int>) {\n          val x = list.also { it.forEach { it + 4 } }.toString()\n          val y = list.apply { forEach { println(it) } }\n      }\n\nクイックフィックス適用後:\n\n\n      fun test(list: List<Int>) {\n          val x = list.onEach { it + 4 }.toString()\n          val y = list.onEach { println(it) }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifyNestedEachInScopeFunction",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnsafeCastFromDynamic",
                "shortDescription": {
                  "text": "dynamic 型からの暗黙的な (安全でない) キャスト"
                },
                "fullDescription": {
                  "text": "指定したインスペクション範囲内にある dynamic 型の式で、暗黙的に別の型にキャストされているものを報告します。",
                  "markdown": "指定したインスペクション範囲内にある dynamic 型の式で、暗黙的に別の型にキャストされているものを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnsafeCastFromDynamic",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicApiImplicitType",
                "shortDescription": {
                  "text": "暗黙的な戻り値の型を含む公開 API 宣言"
                },
                "fullDescription": {
                  "text": "暗黙的な戻り値の型を持つ 'public' または 'protected' の関数およびプロパティを報告します。 API の安定性を確保するため、このような型は明示的に指定することが推奨されています。 例: 'fun publicFunctionWhichAbusesTypeInference() =\n      otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()' クイックフィックス適用後: 'fun publicFunctionWhichAbusesTypeInference(): Api =\n      otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()'",
                  "markdown": "暗黙的な戻り値の型を持つ `public` または `protected` の関数およびプロパティを報告します。\nAPI の安定性を確保するため、このような型は明示的に指定することが推奨されています。\n\n**例:**\n\n\n      fun publicFunctionWhichAbusesTypeInference() =\n          otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()\n\nクイックフィックス適用後:\n\n\n      fun publicFunctionWhichAbusesTypeInference(): Api =\n          otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PublicApiImplicitType",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/他の問題",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeclaringClassMigration",
                "shortDescription": {
                  "text": "非推奨の 'Enum.declaringClass' プロパティ"
                },
                "fullDescription": {
                  "text": "1.9 以降ではコンパイルエラーを引き起こす列挙型に対する 'declaringClass' プロパティの呼び出しを報告します。 'Enum.getDeclaringClass' は、解決によって通常は表示されない \"非表示\" の Java 関数のうちの 1 つです。 しかし、合成プロパティ経由では表示可能であり、これはフロントエンドのバグです。 詳細: KT-49653 非推奨の Enum.declaringClass 合成プロパティを除去 クイックフィックスを使用すると、呼び出しが 'declaringJavaClass' に置換されます。 例: 'fun <E: Enum<E>> foo(values: Array<E>) {\n    EnumSet.noneOf(values.first().declaringClass)\n  }' クイックフィックス適用後: 'fun <E: Enum<E>> foo(values: Array<E>) {\n    EnumSet.noneOf(values.first().declaringJavaClass)\n  }' このインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.7 以上の場合にのみ報告します。",
                  "markdown": "1.9 以降ではコンパイルエラーを引き起こす列挙型に対する 'declaringClass' プロパティの呼び出しを報告します。\n\n'Enum.getDeclaringClass' は、解決によって通常は表示されない \"非表示\" の Java 関数のうちの 1 つです。 しかし、合成プロパティ経由では表示可能であり、これはフロントエンドのバグです。\n\n**詳細:** [KT-49653 非推奨の Enum.declaringClass 合成プロパティを除去](https://youtrack.jetbrains.com/issue/KT-49653)\n\nクイックフィックスを使用すると、呼び出しが 'declaringJavaClass' に置換されます。\n\n**例:**\n\n\n      fun <E: Enum<E>> foo(values: Array<E>) {\n        EnumSet.noneOf(values.first().declaringClass)\n      }\n\nクイックフィックス適用後:\n\n\n      fun <E: Enum<E>> foo(values: Array<E>) {\n        EnumSet.noneOf(values.first().declaringJavaClass)\n      }\n\nこのインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.7 以上の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeclaringClassMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceMapIndexedWithListGenerator",
                "shortDescription": {
                  "text": "'mapIndexed' を List ジェネレーターに置換"
                },
                "fullDescription": {
                  "text": "'List' ジェネレーターで置換できる 'mapIndexed' の呼び出しを報告します。 例: 'val a = listOf(1, 2, 3).mapIndexed { i, _ ->\n      i + 42\n  }' クイックフィックス適用後: 'val a = List(listOf(1, 2, 3).size) { i ->\n          i + 42\n  }'",
                  "markdown": "`List` ジェネレーターで置換できる `mapIndexed` の呼び出しを報告します。\n\n**例:**\n\n\n      val a = listOf(1, 2, 3).mapIndexed { i, _ ->\n          i + 42\n      }\n\nクイックフィックス適用後:\n\n\n      val a = List(listOf(1, 2, 3).size) { i ->\n              i + 42\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceMapIndexedWithListGenerator",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ControlFlowWithEmptyBody",
                "shortDescription": {
                  "text": "本体が空の制御フロー"
                },
                "fullDescription": {
                  "text": "本体が空の 'if'、'while'、'do'、または 'for' ステートメントを報告します。 このような構文は意図的な場合もありますが、混乱を招き、多くの場合はタイプミスによるものです。 クイックフィックスを使用すると、ステートメントが除去されます。 例: 'if (a > b) {}'",
                  "markdown": "本体が空の `if`、`while`、`do`、または `for` ステートメントを報告します。\n\nこのような構文は意図的な場合もありますが、混乱を招き、多くの場合はタイプミスによるものです。\n\nクイックフィックスを使用すると、ステートメントが除去されます。\n\n**例:**\n\n\n      if (a > b) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ControlFlowWithEmptyBody",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExplicitThis",
                "shortDescription": {
                  "text": "冗長で明示的な 'this'"
                },
                "fullDescription": {
                  "text": "省略できる明示的な 'this' を報告します。 例: 'class C {\n      private val i = 1\n      fun f() = this.i\n  }' クイックフィックスを使用すると、冗長な 'this' が除去されます。 'class C {\n      private val i = 1\n      fun f() = i\n  }'",
                  "markdown": "省略できる明示的な `this` を報告します。\n\n**例:**\n\n\n      class C {\n          private val i = 1\n          fun f() = this.i\n      }\n\nクイックフィックスを使用すると、冗長な `this` が除去されます。\n\n\n      class C {\n          private val i = 1\n          fun f() = i\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ExplicitThis",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NullChecksToSafeCall",
                "shortDescription": {
                  "text": "安全な呼び出しに置換可能な null チェック"
                },
                "fullDescription": {
                  "text": "安全な呼び出しに置換できる連鎖した null チェックを報告します。 例: 'fun test(my: My?) {\n      if (my != null && my.foo() != null) {}\n  }' クイックフィックス適用後: 'fun test(my: My?) {\n      if (my?.foo() != null) {}\n  }'",
                  "markdown": "安全な呼び出しに置換できる連鎖した null チェックを報告します。\n\n**例:**\n\n\n      fun test(my: My?) {\n          if (my != null && my.foo() != null) {}\n      }\n\nクイックフィックス適用後:\n\n\n      fun test(my: My?) {\n          if (my?.foo() != null) {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "NullChecksToSafeCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoopToCallChain",
                "shortDescription": {
                  "text": "ループは stdlib 演算に置換できます"
                },
                "fullDescription": {
                  "text": "一連の stdlib 操作 ('map'、'filter' など) に置換できる 'for' ループを報告します。 例: 'fun foo(list: List<String>): List<Int> {\n  val result = ArrayList<Int>()\n  for (s in list) {\n     if (s.length > 0)\n       result.add(s.hashCode())\n     }\n  return result\n}' クイックフィックス適用後: 'fun foo(list: List<String>): List<Int> {\n  val result = list\n    .filter { it.length > 0 }\n    .map { it.hashCode() }\n  return result\n}'",
                  "markdown": "一連の stdlib 操作 (`map`、`filter` など) に置換できる `for` ループを報告します。\n\n**例:**\n\n\n    fun foo(list: List<String>): List<Int> {\n      val result = ArrayList<Int>()\n      for (s in list) {\n         if (s.length > 0)\n           result.add(s.hashCode())\n         }\n      return result\n    }\n\nクイックフィックス適用後:\n\n\n    fun foo(list: List<String>): List<Int> {\n      val result = list\n        .filter { it.length > 0 }\n        .map { it.hashCode() }\n      return result\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LoopToCallChain",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveEmptyClassBody",
                "shortDescription": {
                  "text": "空のクラス本体を置換"
                },
                "fullDescription": {
                  "text": "本体が空のクラスとオブジェクトの宣言を報告します。 コードをクリーンアップするには、'冗長な空のクラス本文の除去' クイックフィックスを使用します。 例: 'class EmptyA() {} // <== 空の本体\n\n  class EmptyB {\n      companion object {} // <== 空の本体\n  }\n\n  fun emptyC() {\n     object {} // <== 匿名オブジェクトなので OK (報告されない)\n  }' クイックフィックス適用後: 'class EmptyA()\n\n  class EmptyB {\n      companion object\n  }\n\n  fun emptyC() {\n     object {}\n  }'",
                  "markdown": "本体が空のクラスとオブジェクトの宣言を報告します。\n\nコードをクリーンアップするには、'冗長な空のクラス本文の除去' クイックフィックスを使用します。\n\n**例:**\n\n\n      class EmptyA() {} // <== 空の本体\n\n      class EmptyB {\n          companion object {} // <== 空の本体\n      }\n\n      fun emptyC() {\n         object {} // <== 匿名オブジェクトなので OK (報告されない)\n      }\n\nクイックフィックス適用後:\n\n\n      class EmptyA()\n\n      class EmptyB {\n          companion object\n      }\n\n      fun emptyC() {\n         object {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveEmptyClassBody",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CanBeParameter",
                "shortDescription": {
                  "text": "コンストラクターのパラメーターはプロパティとして使用されません"
                },
                "fullDescription": {
                  "text": "プライマリコンストラクターのパラメーターで、'val' または 'var' を除去できるものを報告します。 コンストラクター内でクラスプロパティを宣言すると、メモリ消費量が増加します。 コンストラクター内でのみ使用されるパラメーター値は省略できます。 参照先のオブジェクトは、早い段階でガベージコレクトされる可能性があります。 例: 'class Task(val name: String) {\n      init {\n          print(\"Task created: $name\")\n      }\n  }' クイックフィックスを使用すると、不要な 'val' または 'var' キーワードが除去されます。 'class Task(name: String) {\n      init {\n          print(\"Task created: $name\")\n      }\n  }'",
                  "markdown": "プライマリコンストラクターのパラメーターで、`val` または `var` を除去できるものを報告します。\n\n\nコンストラクター内でクラスプロパティを宣言すると、メモリ消費量が増加します。\nコンストラクター内でのみ使用されるパラメーター値は省略できます。\n\n参照先のオブジェクトは、早い段階でガベージコレクトされる可能性があります。\n\n**例:**\n\n\n      class Task(val name: String) {\n          init {\n              print(\"Task created: $name\")\n          }\n      }\n\nクイックフィックスを使用すると、不要な `val` または `var` キーワードが除去されます。\n\n\n      class Task(name: String) {\n          init {\n              print(\"Task created: $name\")\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CanBeParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantReturnLabel",
                "shortDescription": {
                  "text": "冗長な 'return' ラベル"
                },
                "fullDescription": {
                  "text": "ラムダ式の外にある不要な return ラベルを報告します。 例: 'fun test() {\n      return@test\n  }' クイックフィックス適用後: 'fun test() {\n      return\n  }'",
                  "markdown": "ラムダ式の外にある不要な return ラベルを報告します。\n\n**例:**\n\n\n      fun test() {\n          return@test\n      }\n\nクイックフィックス適用後:\n\n\n      fun test() {\n          return\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantReturnLabel",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedMainParameter",
                "shortDescription": {
                  "text": "ｍain のパラメーターは不要です"
                },
                "fullDescription": {
                  "text": "未使用の単一パラメーターを使用している 'main' 関数を報告します。",
                  "markdown": "未使用の単一パラメーターを使用している `main` 関数を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnusedMainParameter",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FunctionWithLambdaExpressionBody",
                "shortDescription": {
                  "text": "'= { ... }' と推測された戻り型を持つ関数"
                },
                "fullDescription": {
                  "text": "'= { ... }' と 推論された戻り値の型が使用されている関数を報告します。 例: 'fun sum(a: Int, b: Int) = { a + b } // この関数の戻り値の型は '() -> Int' です。' クイックフィックスが波括弧を除去します。 'fun sum(a: Int, b: Int) = a + b'",
                  "markdown": "`= { ... }` と 推論された戻り値の型が使用されている関数を報告します。\n\n**例:**\n\n\n      fun sum(a: Int, b: Int) = { a + b } // この関数の戻り値の型は '() -> Int' です。\n\nクイックフィックスが波括弧を除去します。\n\n\n      fun sum(a: Int, b: Int) = a + b\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FunctionWithLambdaExpressionBody",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageName",
                "shortDescription": {
                  "text": "パッケージの命名規則"
                },
                "fullDescription": {
                  "text": "命名規則に従っていないパッケージ名を報告します。 必要なパターンは、インスペクションのオプションで指定できます。 推奨される命名規則: パッケージ名は常に小文字にする。アンダースコアは使用しない。 例: 'org.example.project' 名前に複数の単語を使用することは一般的に推奨されていませんが、必要な場合は連結するかキャメルケースを使用してください。 例: 'org.example.myProject'",
                  "markdown": "命名規則に従っていないパッケージ名を報告します。\n\n必要なパターンは、インスペクションのオプションで指定できます。\n\n[推奨される命名規則](https://kotlinlang.org/docs/coding-conventions.html#naming-rules): パッケージ名は常に小文字にする。アンダースコアは使用しない。\n\n**例:**\n`org.example.project`\n\n名前に複数の単語を使用することは一般的に推奨されていませんが、必要な場合は連結するかキャメルケースを使用してください。\n\n**例:**\n`org.example.myProject`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PackageName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名規約",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayInDataClass",
                "shortDescription": {
                  "text": "データクラス内の配列プロパティ"
                },
                "fullDescription": {
                  "text": "'data' クラスにある 'Array' 型のプロパティで、オーバーライドされた 'equals()' または 'hashCode()' がないものを報告します。 配列のパラメーターは参照の等価性によって比較されます。しかし、これは想定している動作ではないと思われます。 このような場合は、'equals()' と 'hashCode()' をオーバーライドすることを強くお勧めします。 例: 'data class Text(val lines: Array<String>)' クイックフィックスを使用すると、欠落している 'equals()' と'hashCode()' の実装が生成されます。 'data class Text(val lines: Array<String>) {\n      override fun equals(other: Any?): Boolean {\n          if (this === other) return true\n          if (javaClass != other?.javaClass) return false\n\n          other as Text\n\n          if (!lines.contentEquals(other.lines)) return false\n\n          return true\n      }\n\n      override fun hashCode(): Int {\n          return lines.contentHashCode()\n      }\n  }'",
                  "markdown": "`data` クラスにある `Array` 型のプロパティで、オーバーライドされた `equals()` または `hashCode()` がないものを報告します。\n\n\n配列のパラメーターは参照の等価性によって比較されます。しかし、これは想定している動作ではないと思われます。\nこのような場合は、`equals()` と `hashCode()` をオーバーライドすることを強くお勧めします。\n\n**例:**\n\n\n      data class Text(val lines: Array<String>)\n\nクイックフィックスを使用すると、欠落している `equals()` と`hashCode()` の実装が生成されます。\n\n\n      data class Text(val lines: Array<String>) {\n          override fun equals(other: Any?): Boolean {\n              if (this === other) return true\n              if (javaClass != other?.javaClass) return false\n\n              other as Text\n\n              if (!lines.contentEquals(other.lines)) return false\n\n              return true\n          }\n\n          override fun hashCode(): Int {\n              return lines.contentHashCode()\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ArrayInDataClass",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProhibitUseSiteTargetAnnotationsOnSuperTypesMigration",
                "shortDescription": {
                  "text": "スーパークラスの無意味なアノテーションターゲット"
                },
                "fullDescription": {
                  "text": "Kotlin 1.4 以降でスーパークラスに対して使用されている無意味なアノテーションターゲットを報告します。 '@get:' などのアノテーションターゲットをスーパークラスに対して使用することは無意味であるため、禁止されています。 例: 'interface Foo\n\n  annotation class Ann\n\n  class E : @field:Ann @get:Ann @set:Ann @setparam:Ann Foo' クイックフィックス適用後: 'interface Foo\n\n  annotation class Ann\n\n  class E : Foo' このインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.4 以降の場合にのみ報告します。",
                  "markdown": "Kotlin 1.4 以降でスーパークラスに対して使用されている無意味なアノテーションターゲットを報告します。\n\n`@get:` などのアノテーションターゲットをスーパークラスに対して使用することは無意味であるため、禁止されています。\n\n**例:**\n\n\n      interface Foo\n\n      annotation class Ann\n\n      class E : @field:Ann @get:Ann @set:Ann @setparam:Ann Foo\n\nクイックフィックス適用後:\n\n\n      interface Foo\n\n      annotation class Ann\n\n      class E : Foo\n\nこのインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.4 以降の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ProhibitUseSiteTargetAnnotationsOnSuperTypesMigration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertTwoComparisonsToRangeCheck",
                "shortDescription": {
                  "text": "2 つの比較は範囲チェックに変換する必要があります"
                },
                "fullDescription": {
                  "text": "範囲チェックに変換できる 2 つの連続する比較を報告します。 範囲チェックに変換するとテスト対象の重複が排除され、コードがより簡潔になります。 例: 'fun checkMonth(month: Int): Boolean {\n      return month >= 1 && month <= 12\n  }' クイックフィックスを使用すると、比較によるチェックが範囲チェックに置換されます。 'fun checkMonth(month: Int): Boolean {\n      return month in 1..12\n  }'",
                  "markdown": "範囲チェックに変換できる 2 つの連続する比較を報告します。\n\n範囲チェックに変換するとテスト対象の重複が排除され、コードがより簡潔になります。\n\n**例:**\n\n\n      fun checkMonth(month: Int): Boolean {\n          return month >= 1 && month <= 12\n      }\n\nクイックフィックスを使用すると、比較によるチェックが範囲チェックに置換されます。\n\n\n      fun checkMonth(month: Int): Boolean {\n          return month in 1..12\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertTwoComparisonsToRangeCheck",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceWithEnumMap",
                "shortDescription": {
                  "text": "'EnumMap' に置換可能な 'HashMap'"
                },
                "fullDescription": {
                  "text": "'hashMapOf' 関数または 'HashMap' コンストラクターの呼び出しで、'EnumMap' コンストラクターの呼び出しに置換できるものを報告します。 'EnumMap' コンストラクターを使用すると、コードを単純化できます。 クイックフィックスを使用すると、関数呼び出しが 'EnumMap' コンストラクターの呼び出しに置換されます。 例: 'enum class E {\n      A, B\n  }\n\n  fun getMap(): Map<E, String> = hashMapOf()' クイックフィックス適用後: 'enum class E {\n      A, B\n  }\n\n  fun getMap(): Map<E, String> = EnumMap(E::class.java)'",
                  "markdown": "`hashMapOf` 関数または `HashMap` コンストラクターの呼び出しで、`EnumMap` コンストラクターの呼び出しに置換できるものを報告します。\n\n`EnumMap` コンストラクターを使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、関数呼び出しが `EnumMap` コンストラクターの呼び出しに置換されます。\n\n**例:**\n\n\n      enum class E {\n          A, B\n      }\n\n      fun getMap(): Map<E, String> = hashMapOf()\n\nクイックフィックス適用後:\n\n\n      enum class E {\n          A, B\n      }\n\n      fun getMap(): Map<E, String> = EnumMap(E::class.java)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceWithEnumMap",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/他の問題",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LocalVariableName",
                "shortDescription": {
                  "text": "ローカル変数の命名規則"
                },
                "fullDescription": {
                  "text": "命名規則に従っていないローカル変数を報告します。 必要なパターンは、インスペクションのオプションで指定できます。 推奨される命名規則: 小文字で始まるキャメルケースを使用する。アンダースコアは使用しない。 例: 'fun fibonacciNumber(index: Int): Long = when(index) {\n      0 -> 0\n      else -> {\n          // 命名規則に従っていません: アンダースコアが含まれています (`_`)\n          var number_one: Long = 0\n          // 命名規則に従っていません: 大文字で始まっています\n          var NUMBER_TWO: Long = 1\n          // 命名規則に従っています: 小文字で始まるキャメルケースを使用する。アンダースコアは使用しない。\n          var numberThree: Long = number_one + NUMBER_TWO\n\n          for(currentIndex in 2..index) {\n              numberThree = number_one + NUMBER_TWO\n              number_one = NUMBER_TWO\n              NUMBER_TWO = numberThree\n          }\n          numberThree\n      }\n  }'",
                  "markdown": "命名規則に従っていないローカル変数を報告します。\n\n必要なパターンは、インスペクションのオプションで指定できます。\n\n[推奨される命名規則](https://kotlinlang.org/docs/coding-conventions.html#function-names): 小文字で始まるキャメルケースを使用する。アンダースコアは使用しない。\n\n**例:**\n\n\n      fun fibonacciNumber(index: Int): Long = when(index) {\n          0 -> 0\n          else -> {\n              // 命名規則に従っていません: アンダースコアが含まれています (`_`)\n              var number_one: Long = 0\n              // 命名規則に従っていません: 大文字で始まっています\n              var NUMBER_TWO: Long = 1\n              // 命名規則に従っています: 小文字で始まるキャメルケースを使用する。アンダースコアは使用しない。\n              var numberThree: Long = number_one + NUMBER_TWO\n\n              for(currentIndex in 2..index) {\n                  numberThree = number_one + NUMBER_TWO\n                  number_one = NUMBER_TWO\n                  NUMBER_TWO = numberThree\n              }\n              numberThree\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LocalVariableName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名規約",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceUntilWithRangeUntil",
                "shortDescription": {
                  "text": "'until' を '..<' 演算子に置換"
                },
                "fullDescription": {
                  "text": "'..<' 演算子に置換できる 'until' を報告します。 どの 'until' から '..<' への置換も、あらゆる点でセマンティクスを変更することはありません。 UX 調査により、開発者が '..<' を含んでいるコードを読む場合は 'until' を読む場合と比較してエラーの数が約 20 ～ 30% 減少することが分かっています。 例: 'fun main(args: Array<String>) {\n      for (index in 0 until args.size) {\n          println(index)\n      }\n  }' クイックフィックス適用後: 'fun main(args: Array<String>) {\n      for (index in 0..<args.size) {\n          println(index)\n      }\n  }' このインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.7 以上の場合にのみ報告します。",
                  "markdown": "`..<` 演算子に置換できる `until` を報告します。\n\nどの `until` から `..<` への置換も、あらゆる点でセマンティクスを変更することはありません。\n\nUX 調査により、開発者が `..<` を含んでいるコードを読む場合は `until` を読む場合と比較してエラーの数が約 20 ～ 30% 減少することが分かっています。\n\n**例:**\n\n\n      fun main(args: Array<String>) {\n          for (index in 0 until args.size) {\n              println(index)\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun main(args: Array<String>) {\n          for (index in 0..<args.size) {\n              println(index)\n          }\n      }\n\nこのインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.7 以上の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceUntilWithRangeUntil",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveRedundantQualifierName",
                "shortDescription": {
                  "text": "冗長な修飾子名"
                },
                "fullDescription": {
                  "text": "クラス名、関数、およびプロパティの冗長な修飾子 (またはその一部) を報告します。 完全修飾名は、呼び出しが参照するオブジェクト、関数、またはプロパティを指定する明確な識別子です。 このインスペクションは名前を短縮できる場合に通知を行います。また、関連する '冗長な修飾子名の除去' クイックフィックスを使用してコードを修正できます。 例: 'package my.simple.name\n  import kotlin.Int.Companion.MAX_VALUE\n\n  class Foo\n\n  fun main() {\n      val a = my.simple.name.Foo()    // 'Foo' は宣言された 'my.simple.name' パッケージ内にあるため修飾子は冗長です\n      val b = kotlin.Int.MAX_VALUE    // インポートされているため 'MAX_VALUE' に置換できます\n      val c = kotlin.Double.MAX_VALUE // ビルトイン型は自動的にインポートされるため 'Double.MAX_VALUE' に置換できます\n  }' クイックフィックス適用後: 'package my.simple.name\n  import kotlin.Int.Companion.MAX_VALUE\n\n  class Foo\n\n  fun main() {\n      val a = Foo()\n      val b = MAX_VALUE\n      val c = Double.MAX_VALUE\n  }'",
                  "markdown": "クラス名、関数、およびプロパティの冗長な修飾子 (またはその一部) を報告します。\n\n\n完全修飾名は、呼び出しが参照するオブジェクト、関数、またはプロパティを指定する明確な識別子です。\nこのインスペクションは名前を短縮できる場合に通知を行います。また、関連する '冗長な修飾子名の除去' クイックフィックスを使用してコードを修正できます。\n\n**例:**\n\n\n      package my.simple.name\n      import kotlin.Int.Companion.MAX_VALUE\n\n      class Foo\n\n      fun main() {\n          val a = my.simple.name.Foo()    // 'Foo' は宣言された 'my.simple.name' パッケージ内にあるため修飾子は冗長です\n          val b = kotlin.Int.MAX_VALUE    // インポートされているため 'MAX_VALUE' に置換できます\n          val c = kotlin.Double.MAX_VALUE // ビルトイン型は自動的にインポートされるため 'Double.MAX_VALUE' に置換できます\n      }\n\nクイックフィックス適用後:\n\n\n      package my.simple.name\n      import kotlin.Int.Companion.MAX_VALUE\n\n      class Foo\n\n      fun main() {\n          val a = Foo()\n          val b = MAX_VALUE\n          val c = Double.MAX_VALUE\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RemoveRedundantQualifierName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumValuesSoftDeprecate",
                "shortDescription": {
                  "text": "1.9 以降は 'Enum.values()' を 'Enum.entries' で置換することをお勧めします"
                },
                "fullDescription": {
                  "text": "Kotlin から列挙型クラスの 'values()' メソッドへの呼び出しのうち、'entries' プロパティの読み取りに置換できるものを報告します。 'Enum.entries' を使用すると、コードのパフォーマンスが向上する場合があります。 このクイックフィックスは 'values()' を 'entries' に置換します。 詳細: KT-48872 Enum.values() に対応するモダンでパフォーマンスの高い置換の提供 注意: 'entries' プロパティの型は 'values()' メソッドの戻り値の型と異なります ('Array<T>' ではなく 'List<T>' から継承している 'EnumEntries<T>')。 このため、場合によってはクイックフィックスによってコードを破壊しないように追加の '.toTypedArray()' 変換が挿入されますが、多くの場合はこの変換なしで置換が実行されます (例: 'for' ループ)。 例: 'enum class Version {\n        V1, V2\n    }\n\n    Version.values().forEach { /* .. */ }\n    val firstVersion = Version.values()[0]\n    functionExpectingArray(Version.values())' クイックフィックス適用後: 'enum class Version {\n        V1, V2\n    }\n\n    Version.entries.forEach { /* .. */ }\n    val firstVersion = Version.entries[0]\n    functionExpectingArray(Version.entries.toTypedArray())'",
                  "markdown": "Kotlin から列挙型クラスの `values()` メソッドへの呼び出しのうち、`entries` プロパティの読み取りに置換できるものを報告します。\n\n\n`Enum.entries` を使用すると、コードのパフォーマンスが向上する場合があります。\n\n\nこのクイックフィックスは `values()` を `entries` に置換します。\n\n\n**詳細:** [KT-48872 Enum.values() に対応するモダンでパフォーマンスの高い置換の提供](https://youtrack.jetbrains.com/issue/KT-48872)\n\n\n**注意:** `entries` プロパティの型は `values()` メソッドの戻り値の型と異なります\n(`Array<T>` ではなく `List<T>` から継承している `EnumEntries<T>`)。\nこのため、場合によってはクイックフィックスによってコードを破壊しないように追加の `.toTypedArray()` 変換が挿入されますが、多くの場合はこの変換なしで置換が実行されます (例: `for` ループ)。\n\n**例:**\n\n\n        enum class Version {\n            V1, V2\n        }\n\n        Version.values().forEach { /* .. */ }\n        val firstVersion = Version.values()[0]\n        functionExpectingArray(Version.values())\n\nクイックフィックス適用後:\n\n\n        enum class Version {\n            V1, V2\n        }\n\n        Version.entries.forEach { /* .. */ }\n        val firstVersion = Version.entries[0]\n        functionExpectingArray(Version.entries.toTypedArray())\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EnumValuesSoftDeprecate",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/他の問題",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveCurlyBracesFromTemplate",
                "shortDescription": {
                  "text": "文字列テンプレートの冗長な波括弧"
                },
                "fullDescription": {
                  "text": "文字列テンプレートで単純な識別子に使用されている波括弧を報告します。 冗長な波括弧を除去するには、'波括弧の除去' クイックフィックスを使用します。 例: 'fun redundant() {\n     val x = 4\n     val y = \"${x}\" // <== 不要\n  }\n\n  fun correctUsage() {\n      val x = \"x\"\n      val y = \"${x.length}\" // <== Ok\n  }' クイックフィックス適用後: 'fun redundant() {\n     val x = 4\n     val y = \"$x\"\n  }\n\n  fun correctUsage() {\n      val x = \"x\" <== 更新後\n      val y = \"${x.length}\"\n  }'",
                  "markdown": "文字列テンプレートで単純な識別子に使用されている波括弧を報告します。\n\n冗長な波括弧を除去するには、'波括弧の除去' クイックフィックスを使用します。\n\n**例:**\n\n\n      fun redundant() {\n         val x = 4\n         val y = \"${x}\" // <== 不要\n      }\n\n      fun correctUsage() {\n          val x = \"x\"\n          val y = \"${x.length}\" // <== Ok\n      }\n\nクイックフィックス適用後:\n\n\n      fun redundant() {\n         val x = 4\n         val y = \"$x\"\n      }\n\n      fun correctUsage() {\n          val x = \"x\" <== 更新後\n          val y = \"${x.length}\"\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveCurlyBracesFromTemplate",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceSubstringWithIndexingOperation",
                "shortDescription": {
                  "text": "インデックス演算子に置換すべき 'substring' の呼び出し"
                },
                "fullDescription": {
                  "text": "'\"abc\".substring(0, 1)' から '\"abc\"[0]' のように置換できる呼び出しを報告します。 インデックスを指定して要素を取得すると、コードを単純化できます。 クイックフィックスを使用すると、'substring' の呼び出しがインデックス演算子に置換されます。 例: 'fun foo() {\n      \"abc\".substring(0, 1)\n  }' クイックフィックス適用後: 'fun foo() {\n      \"abc\"[0]\n  }'",
                  "markdown": "`\"abc\".substring(0, 1)` から `\"abc\"[0]` のように置換できる呼び出しを報告します。\n\nインデックスを指定して要素を取得すると、コードを単純化できます。\n\nクイックフィックスを使用すると、`substring` の呼び出しがインデックス演算子に置換されます。\n\n**例:**\n\n\n      fun foo() {\n          \"abc\".substring(0, 1)\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo() {\n          \"abc\"[0]\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceSubstringWithIndexingOperation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousCollectionReassignment",
                "shortDescription": {
                  "text": "累計代入は内部的に新しいコレクションを作成します"
                },
                "fullDescription": {
                  "text": "読み取り専用の 'Collection' に対する累算代入 ('+=') 式を報告します。 読み取り専用の 'Collection' に対する累算代入 ('+=') 式は一時的に新規コレクションを割り当てるため、パフォーマンスに悪影響を及ぼす可能性があります。 「型をミュータブルに変更」クイックフィックスを使用すると、自動的にコードを修正することができます。 例: 'fun test() {\n      var list = listOf(0)\n      list += 42 // ここで新しいリストに代入されており、list = list + 42 と同等です\n  }' クイックフィックス適用後: 'fun test() {\n      val list = mutableListOf(0)\n      list += 42\n  }'",
                  "markdown": "読み取り専用の `Collection` に対する累算代入 (`+=`) 式を報告します。\n\n読み取り専用の `Collection` に対する累算代入 (`+=`) 式は一時的に新規コレクションを割り当てるため、パフォーマンスに悪影響を及ぼす可能性があります。\n\n「**型をミュータブルに変更**」クイックフィックスを使用すると、自動的にコードを修正することができます。\n\n例:\n\n\n      fun test() {\n          var list = listOf(0)\n          list += 42 // ここで新しいリストに代入されており、list = list + 42 と同等です\n      }\n\nクイックフィックス適用後:\n\n\n      fun test() {\n          val list = mutableListOf(0)\n          list += 42\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SuspiciousCollectionReassignment",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MoveLambdaOutsideParentheses",
                "shortDescription": {
                  "text": "丸括弧内のラムダ引数"
                },
                "fullDescription": {
                  "text": "丸括弧の外側に移動できるラムダ式を報告します。 例: 'fun square(a: Int, b: (Int) -> Int) {\n  b(a * a)\n}\n\nfun foo() {\n  square(2, { it })\n}' クイックフィックス適用後: 'fun foo() {\n  square(2){ it }\n}'",
                  "markdown": "丸括弧の外側に移動できるラムダ式を報告します。\n\n**例:**\n\n\n    fun square(a: Int, b: (Int) -> Int) {\n      b(a * a)\n    }\n\n    fun foo() {\n      square(2, { it })\n    }\n\nクイックフィックス適用後:\n\n\n    fun foo() {\n      square(2){ it }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MoveLambdaOutsideParentheses",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantNotNullExtensionReceiverOfInline",
                "shortDescription": {
                  "text": "Kotlin 1.2 以下で明示的な nullable にできる 'inline fun' 拡張レシーバー"
                },
                "fullDescription": {
                  "text": "非 nullable の拡張レシーバーを持つインライン関数で、拡張レシーバーが nullable でない事実を考慮していないものを報告します。 Kotlin 1.2 以前は、バイトコードでの柔軟な nullable 拡張レシーバー (null 許容性が不明なプラットフォーム型) を持つ 'inline fun' の呼び出しに null 許容性チェックが含まれていませんでした。 Kotlin 1.2 以降は、null 許容性チェックがバイトコードに含まれるようになりました (KT-12899 を参照してください)。 したがって、Kotlin 1.2 までのバージョンでは拡張レシーバーが nullable でない事実を考慮しない関数は危険とされており、そのような関数には nullable レシーバーを持たせることが推奨されています。 例: 'inline fun String.greet() {\n      println(\"Hello, $this!\")\n  }\n\n  fun main() {\n      // `System.getProperty` は表示できない `String!` 型を返します\n      val user = System.getProperty(\"user.name\")\n      user.greet()\n  }' クイックフィックス適用後: 'inline fun String.greet() {\n      println(\"Hello, $this!\")\n  }\n\n  fun main() {\n      // `System.getProperty` は表示できない `String!` 型を返します\n      val user = System.getProperty(\"user.name\")\n      user.greet()\n  }' このインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.2 未満の場合にのみ報告します。",
                  "markdown": "非 nullable の拡張レシーバーを持つインライン関数で、拡張レシーバーが nullable でない事実を考慮していないものを報告します。\n\n\nKotlin 1.2 以前は、バイトコードでの柔軟な nullable 拡張レシーバー (null 許容性が不明なプラットフォーム型) を持つ `inline fun` の呼び出しに null 許容性チェックが含まれていませんでした。 Kotlin 1.2 以降は、null 許容性チェックがバイトコードに含まれるようになりました ([KT-12899](https://youtrack.jetbrains.com/issue/KT-12899) を参照してください)。\n\n\nしたがって、Kotlin 1.2 までのバージョンでは拡張レシーバーが nullable でない事実を考慮しない関数は危険とされており、そのような関数には nullable レシーバーを持たせることが推奨されています。\n\n**例:**\n\n\n      inline fun String.greet() {\n          println(\"Hello, $this!\")\n      }\n\n      fun main() {\n          // `System.getProperty` は表示できない `String!` 型を返します\n          val user = System.getProperty(\"user.name\")\n          user.greet()\n      }\n\nクイックフィックス適用後:\n\n\n      inline fun String.greet() {\n          println(\"Hello, $this!\")\n      }\n\n      fun main() {\n          // `System.getProperty` は表示できない `String!` 型を返します\n          val user = System.getProperty(\"user.name\")\n          user.greet()\n      }\n\nこのインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.2 未満の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantNotNullExtensionReceiverOfInline",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 相互運用性の問題",
                      "index": 66,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantElvisReturnNull",
                "shortDescription": {
                  "text": "冗長な '?: return null'"
                },
                "fullDescription": {
                  "text": "冗長な '?: return null' を報告します。 例: 'fun foo(): Int? {\n      ...\n  }\n\n  fun test() : Int? {\n      return foo() ?: return null\n  }' クイックフィックス適用後: 'fun foo(): Int? {\n      ...\n  }\n\n  fun test() : Int? {\n      return foo()\n  }'",
                  "markdown": "冗長な `?: return null` を報告します。\n\n**例:**\n\n\n      fun foo(): Int? {\n          ...\n      }\n\n      fun test() : Int? {\n          return foo() ?: return null\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(): Int? {\n          ...\n      }\n\n      fun test() : Int? {\n          return foo()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantElvisReturnNull",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProhibitTypeParametersForLocalVariablesMigration",
                "shortDescription": {
                  "text": "型パラメーター付きのローカル変数"
                },
                "fullDescription": {
                  "text": "型パラメーターを持つローカル変数を報告します。 型パラメーターは特殊化できないため、ローカル変数に使用する意味がありません。 例: 'fun main() {\n      val <T> x = \"\"\n  }' クイックフィックス適用後: 'fun main() {\n      val x = \"\"\n  }' このインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.4 以降の場合にのみ報告します。",
                  "markdown": "型パラメーターを持つローカル変数を報告します。\n\n型パラメーターは特殊化できないため、ローカル変数に使用する意味がありません。\n\n**例:**\n\n\n      fun main() {\n          val <T> x = \"\"\n      }\n\nクイックフィックス適用後:\n\n\n      fun main() {\n          val x = \"\"\n      }\n\nこのインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.4 以降の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ProhibitTypeParametersForLocalVariablesMigration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PrivatePropertyName",
                "shortDescription": {
                  "text": "private プロパティの命名規則"
                },
                "fullDescription": {
                  "text": "推奨されている命名規則に従っていない private プロパティ名を報告します。 命名方法に一貫性を持たせると、コードが読みやすく、理解しやすくなります。 Kotlin 公式スタイルガイドによると、private プロパティ名には小文字で始まるキャメルケースを使用する必要があります。 必要に応じて、private プロパティにのみ例外的にアンダースコアを接頭辞として使用できます。 正規表現の \"パターン\" を変更することで、他の命名規則を導入できます。 例: 'val _My_Cool_Property = \"\"' クイックフィックスを使用すると、クラス名が Kotlin の命名規則に従って変更されます。 'val _myCoolProperty = \"\"'",
                  "markdown": "推奨されている命名規則に従っていない private プロパティ名を報告します。\n\n\n命名方法に一貫性を持たせると、コードが読みやすく、理解しやすくなります。\n[Kotlin 公式スタイルガイド](https://kotlinlang.org/docs/coding-conventions.html#naming-rules)によると、private プロパティ名には小文字で始まるキャメルケースを使用する必要があります。\n必要に応じて、**private** プロパティにのみ例外的にアンダースコアを接頭辞として使用できます。\n\n正規表現の \"パターン\" を変更することで、他の命名規則を導入できます。\n\n**例:**\n\n\n      val _My_Cool_Property = \"\"\n\nクイックフィックスを使用すると、クラス名が Kotlin の命名規則に従って変更されます。\n\n\n      val _myCoolProperty = \"\"\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PrivatePropertyName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名規約",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinJvmAnnotationInJava",
                "shortDescription": {
                  "text": "Java での Kotlin JVM アノテーション"
                },
                "fullDescription": {
                  "text": "Java コード内の不要な Kotlin JVM アノテーションを報告します。 例: 'import kotlin.jvm.Volatile;\n\n  public class Test {\n      @Volatile\n      public int i;\n  }'",
                  "markdown": "Java コード内の不要な Kotlin JVM アノテーションを報告します。\n\n**例:**\n\n\n      import kotlin.jvm.Volatile;\n\n      public class Test {\n          @Volatile\n          public int i;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KotlinJvmAnnotationInJava",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 相互運用性の問題",
                      "index": 66,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObsoleteKotlinJsPackages",
                "shortDescription": {
                  "text": "1.4 以降は 'kotlin.browser' および 'kotlin.dom' パッケージは非推奨です"
                },
                "fullDescription": {
                  "text": "'kotlin.dom' パッケージと 'kotlin.browser' パッケージが使用されていることを報告します。 これらのパッケージは、Kotlin 1.4 以降でそれぞれ 'kotlinx.dom' と 'kotlinx.browser' に移動されています。",
                  "markdown": "`kotlin.dom` パッケージと `kotlin.browser` パッケージが使用されていることを報告します。\n\nこれらのパッケージは、Kotlin 1.4 以降でそれぞれ `kotlinx.dom` と `kotlinx.browser` に移動されています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ObsoleteKotlinJsPackages",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CascadeIf",
                "shortDescription": {
                  "text": "カスケード 'if' は 'when' に置換できます'"
                },
                "fullDescription": {
                  "text": "3 つ以上の分岐を持つ 'if' ステートメントで、'when' 式に置換できるものを報告します。 例: 'fun checkIdentifier(id: String) {\n      fun Char.isIdentifierStart() = this in 'A'..'z'\n      fun Char.isIdentifierPart() = isIdentifierStart() || this in '0'..'9'\n\n      if (id.isEmpty()) {\n          print(\"Identifier is empty\")\n      } else if (!id.first().isIdentifierStart()) {\n          print(\"Identifier should start with a letter\")\n      } else if (!id.subSequence(1, id.length).all(Char::isIdentifierPart)) {\n          print(\"Identifier should contain only letters and numbers\")\n      }\n  }' クイックフィックスを使用すると、'if' 式が 'when' 式に変換されます。 'fun checkIdentifier(id: String) {\n      fun Char.isIdentifierStart() = this in 'A'..'z'\n      fun Char.isIdentifierPart() = isIdentifierStart() || this in '0'..'9'\n\n      when {\n          id.isEmpty() -> {\n              print(\"Identifier is empty\")\n          }\n          !id.first().isIdentifierStart() -> {\n              print(\"Identifier should start with a letter\")\n          }\n          !id.subSequence(1, id.length).all(Char::isIdentifierPart) -> {\n              print(\"Identifier should contain only letters and numbers\")\n          }\n      }\n  }'",
                  "markdown": "3 つ以上の分岐を持つ `if` ステートメントで、`when` 式に置換できるものを報告します。\n\n**例:**\n\n\n      fun checkIdentifier(id: String) {\n          fun Char.isIdentifierStart() = this in 'A'..'z'\n          fun Char.isIdentifierPart() = isIdentifierStart() || this in '0'..'9'\n\n          if (id.isEmpty()) {\n              print(\"Identifier is empty\")\n          } else if (!id.first().isIdentifierStart()) {\n              print(\"Identifier should start with a letter\")\n          } else if (!id.subSequence(1, id.length).all(Char::isIdentifierPart)) {\n              print(\"Identifier should contain only letters and numbers\")\n          }\n      }\n\nクイックフィックスを使用すると、`if` 式が `when` 式に変換されます。\n\n\n      fun checkIdentifier(id: String) {\n          fun Char.isIdentifierStart() = this in 'A'..'z'\n          fun Char.isIdentifierPart() = isIdentifierStart() || this in '0'..'9'\n\n          when {\n              id.isEmpty() -> {\n                  print(\"Identifier is empty\")\n              }\n              !id.first().isIdentifierStart() -> {\n                  print(\"Identifier should start with a letter\")\n              }\n              !id.subSequence(1, id.length).all(Char::isIdentifierPart) -> {\n                  print(\"Identifier should contain only letters and numbers\")\n              }\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CascadeIf",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyRange",
                "shortDescription": {
                  "text": "endInclusive よりも大きい start の範囲は空です"
                },
                "fullDescription": {
                  "text": "'start' 値が 'endInclusive' 値よりも大きいために空になっている範囲を報告します。 例: 'val range = 2..1' クイックフィックスを使用すると、'..' 演算子が 'downTo' に変更されます。 'val range = 2 downTo 1'",
                  "markdown": "`start` 値が `endInclusive` 値よりも大きいために空になっている範囲を報告します。\n\n**例:**\n\n\n      val range = 2..1\n\nクイックフィックスを使用すると、`..` 演算子が `downTo` に変更されます。\n\n\n      val range = 2 downTo 1\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyRange",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestFunctionName",
                "shortDescription": {
                  "text": "テスト関数の命名規則"
                },
                "fullDescription": {
                  "text": "推奨される命名規則に従っていないテスト関数名を報告します。",
                  "markdown": "[推奨される命名規則](https://kotlinlang.org/docs/coding-conventions.html#names-for-test-methods)に従っていないテスト関数名を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TestFunctionName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名規約",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RecursivePropertyAccessor",
                "shortDescription": {
                  "text": "再帰的なプロパティアクセサー"
                },
                "fullDescription": {
                  "text": "プロパティアクセサーの再帰呼び出しで、'StackOverflowError' となり得るものを報告します。 一般的に、このような呼び出しはバッキングフィールドへのアクセスと混同されています。 例: 'var counter: Int = 0\n      set(value) {\n          counter = if (value < 0) 0 else value\n      }' クイックフィックス適用後: 'var counter: Int = 0\n      set(value) {\n          field = if (value < 0) 0 else value\n      }'",
                  "markdown": "プロパティアクセサーの再帰呼び出しで、`StackOverflowError` となり得るものを報告します。\n一般的に、このような呼び出しはバッキングフィールドへのアクセスと混同されています。\n\n**例:**\n\n\n      var counter: Int = 0\n          set(value) {\n              counter = if (value < 0) 0 else value\n          }\n\nクイックフィックス適用後:\n\n\n      var counter: Int = 0\n          set(value) {\n              field = if (value < 0) 0 else value\n          }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RecursivePropertyAccessor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonExternalClassifierExtendingStateOrProps",
                "shortDescription": {
                  "text": "State または Props を拡張している非外部分類子"
                },
                "fullDescription": {
                  "text": "State または Props を拡張している非外部分類子を報告します。 詳細は、移行ガイドを参照してください。",
                  "markdown": "State または Props を拡張している非外部分類子を報告します。 詳細は、[移行ガイド](https://kotlinlang.org/docs/js-ir-migration.html#convert-js-and-react-related-classes-and-interfaces-to-external-interfaces)を参照してください。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonExternalClassifierExtendingStateOrProps",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/React/潜在的なバグ",
                      "index": 129,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalExpectation",
                "shortDescription": {
                  "text": "オプションの expected アノテーションに actual アノテーションがありません"
                },
                "fullDescription": {
                  "text": "一部のプラットフォームモジュールで、対応する actual アノテーションがないオプションの expect アノテーションを報告します。 例: '// 共通コード\n@OptionalExpectation\nexpect annotation class JvmName(val name: String)\n\n@JvmName(name = \"JvmFoo\")\nfun foo() { }\n\n// jvm コード\nactual annotation class JvmName(val name: String)' このインスペクションは、'actual annotation class JvmName' が JVM でないプラットフォーム (Native など) で省略されているケースも報告します。",
                  "markdown": "一部のプラットフォームモジュールで、対応する actual アノテーションがないオプションの expect アノテーションを報告します。\n\n**例:**\n\n    // 共通コード\n    @OptionalExpectation\n    expect annotation class JvmName(val name: String)\n\n    @JvmName(name = \"JvmFoo\")\n    fun foo() { }\n\n    // jvm コード\n    actual annotation class JvmName(val name: String)\n\nこのインスペクションは、`actual annotation class JvmName` が JVM でないプラットフォーム (Native など) で省略されているケースも報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "OptionalExpectation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DestructuringWrongName",
                "shortDescription": {
                  "text": "分解宣言の変数が不正なデータクラスプロパティの名前を使用しています"
                },
                "fullDescription": {
                  "text": "分解されたデータクラスの異なるプロパティ名に一致する分解宣言のエントリを報告します。 例: 'data class Foo(val a: String, val b: Int, val c: String)\n\n  fun bar(f: Foo) {\n      val (a, c) = f\n  }' クイックフィックスを使用すると、対応するクラスフィールド名に一致するように変数名が変更されます。 'data class Foo(val a: String, val b: Int, val c: String)\n\n  fun bar(f: Foo) {\n      val (a, b) = f\n  }'",
                  "markdown": "分解されたデータクラスの異なるプロパティ名に一致する分解宣言のエントリを報告します。\n\n**例:**\n\n\n      data class Foo(val a: String, val b: Int, val c: String)\n\n      fun bar(f: Foo) {\n          val (a, c) = f\n      }\n\nクイックフィックスを使用すると、対応するクラスフィールド名に一致するように変数名が変更されます。\n\n\n      data class Foo(val a: String, val b: Int, val c: String)\n\n      fun bar(f: Foo) {\n          val (a, b) = f\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DestructuringWrongName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfThenToSafeAccess",
                "shortDescription": {
                  "text": "'?.' に折りたたみ可能な If-Then"
                },
                "fullDescription": {
                  "text": "安全なアクセス ('?.') 式に変換できる 'if-then' 式を報告します。 例: 'fun bar(x: String) = \"\"\n\n  fun foo(a: String?) {\n     if (a != null) bar(a) else null\n  }' クイックフィックスを使用すると、'if-then' 式が安全なアクセス ('?.') 式に変換されます。 'fun bar(x: String) = \"\"\n\n  fun foo(a: String?) {\n     a?.let { bar(it) }\n  }'",
                  "markdown": "安全なアクセス (`?.`) 式に変換できる `if-then` 式を報告します。\n\n**例:**\n\n\n      fun bar(x: String) = \"\"\n\n      fun foo(a: String?) {\n         if (a != null) bar(a) else null\n      }\n\nクイックフィックスを使用すると、`if-then` 式が安全なアクセス (`?.`) 式に変換されます。\n\n\n      fun bar(x: String) = \"\"\n\n      fun foo(a: String?) {\n         a?.let { bar(it) }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IfThenToSafeAccess",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RestrictReturnStatementTargetMigration",
                "shortDescription": {
                  "text": "1.4 以降のターゲットラベルは関数を示しません"
                },
                "fullDescription": {
                  "text": "関数を指していないラベルを報告します。 関数を指していないターゲットラベルを宣言することは禁止されています。 クイックフィックスを使用すると、このようなラベルが除去されます。 例: 'fun testValLabelInReturn() {\n      L@ val fn = { return@L }\n      fn()\n  }' クイックフィックス適用後: 'fun testValLabelInReturn() {\n      L@ val fn = { return }\n      fn()\n  }' このインスペクションは、プロジェクトまたはモジュールの言語レベルが 1.4 以上の場合にのみ報告します。",
                  "markdown": "関数を指していないラベルを報告します。\n\n関数を指していないターゲットラベルを宣言することは禁止されています。\n\nクイックフィックスを使用すると、このようなラベルが除去されます。\n\n**例:**\n\n\n      fun testValLabelInReturn() {\n          L@ val fn = { return@L }\n          fn()\n      }\n\nクイックフィックス適用後:\n\n\n      fun testValLabelInReturn() {\n          L@ val fn = { return }\n          fn()\n      }\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 1.4 以上の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "RestrictReturnStatementTargetMigration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantUnitExpression",
                "shortDescription": {
                  "text": "冗長な 'Unit'"
                },
                "fullDescription": {
                  "text": "冗長な 'Unit' 式を報告します。 Kotlin の 'Unit' は、有効な戻り値を返さない関数の戻り値の型として使用できます。 'Unit' 型の値となり得るのは 'Unit' オブジェクトだけです。 例: 'fun redundantA(): Unit {\n      return Unit // 'Unit' はデフォルトの戻り値であり、必要な戻り値の型と一致しているため冗長です\n  }\n\n  fun requiredA(condition: Boolean): Any {\n      if (condition) return \"hello\"\n      return Unit // 必要な型が 'Any' であるため、明示的な 'Unit' が必要です\n  }\n\n  fun redundantB(condition: Boolean): Any = if (condition) {\n      fun ancillary(): Int = 1\n      println(\"${ancillary()}\")\n      Unit // 最後の式の型がすでに 'Unit' であるため、冗長です\n  } else {\n      println(\"else\")\n  }\n\n  fun requiredB(condition: Boolean): Any = if (condition) {\n      1024\n      Unit // 必要です。ない場合は '1024' (Int) が戻り値になります\n  } else {\n      println(\"else\")\n  }'",
                  "markdown": "冗長な `Unit` 式を報告します。\n\n\nKotlin の `Unit` は、有効な戻り値を返さない関数の戻り値の型として使用できます。\n`Unit` 型の値となり得るのは `Unit` オブジェクトだけです。\n\n**例:**\n\n\n      fun redundantA(): Unit {\n          return Unit // 'Unit' はデフォルトの戻り値であり、必要な戻り値の型と一致しているため冗長です\n      }\n\n      fun requiredA(condition: Boolean): Any {\n          if (condition) return \"hello\"\n          return Unit // 必要な型が 'Any' であるため、明示的な 'Unit' が必要です\n      }\n\n      fun redundantB(condition: Boolean): Any = if (condition) {\n          fun ancillary(): Int = 1\n          println(\"${ancillary()}\")\n          Unit // 最後の式の型がすでに 'Unit' であるため、冗長です\n      } else {\n          println(\"else\")\n      }\n\n      fun requiredB(condition: Boolean): Any = if (condition) {\n          1024\n          Unit // 必要です。ない場合は '1024' (Int) が戻り値になります\n      } else {\n          println(\"else\")\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantUnitExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PlatformExtensionReceiverOfInline",
                "shortDescription": {
                  "text": "Kotlin 1.2 以下の nullable なレシーバーを持つ 'inline fun'"
                },
                "fullDescription": {
                  "text": "柔軟な nullable (null 許容性が不明なプラットフォーム型) 拡張レシーバーを持つインライン関数の安全でない可能性がある呼び出しを報告します。 Kotlin 1.2 以前は、バイトコードでの柔軟な nullable 拡張レシーバー (null 許容性が不明なプラットフォーム型) を持つ 'inline fun' の呼び出しに null 許容性チェックが含まれていませんでした。 Kotlin 1.2 以降は、null 許容性チェックがバイトコードに含まれるようになりました (KT-12899 を参照してください)。 例外をスローする必要があれば、明示的に「'!!'」を追加することが推奨されています。また、例外が発生せずに動作すると思われる場合は、関数のレシーバーの型を nullable に変更することを検討してください。 例: 'inline fun String.removePrefix(prefix: String): String {\n      return this.substring(prefix.length)\n  }\n\n  fun main() {\n      // `System.getProperty` は表示できない `String!` 型を返します\n      val property = System.getProperty(\"user.dir\")\n      println(property.removePrefix(\"/home\"))\n  }' クイックフィックス適用後: 'inline fun String.removePrefix(prefix: String): String {\n      return this.substring(prefix.length)\n  }\n\n  fun main() {\n      // `System.getProperty` は表示できない `String!` 型を返します\n      val property = System.getProperty(\"user.dir\")\n      println(property!!.removePrefix(\"/home\"))\n  }' このインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.2 未満の場合にのみ報告します。",
                  "markdown": "柔軟な nullable (null 許容性が不明なプラットフォーム型) 拡張レシーバーを持つインライン関数の安全でない可能性がある呼び出しを報告します。\n\n\nKotlin 1.2 以前は、バイトコードでの柔軟な nullable 拡張レシーバー (null 許容性が不明なプラットフォーム型) を持つ `inline fun` の呼び出しに null 許容性チェックが含まれていませんでした。 Kotlin 1.2 以降は、null 許容性チェックがバイトコードに含まれるようになりました ([KT-12899](https://youtrack.jetbrains.com/issue/KT-12899) を参照してください)。\n\n\n例外をスローする必要があれば、明示的に「`!!`」を追加することが推奨されています。また、例外が発生せずに動作すると思われる場合は、関数のレシーバーの型を nullable に変更することを検討してください。\n\n**例:**\n\n\n      inline fun String.removePrefix(prefix: String): String {\n          return this.substring(prefix.length)\n      }\n\n      fun main() {\n          // `System.getProperty` は表示できない `String!` 型を返します\n          val property = System.getProperty(\"user.dir\")\n          println(property.removePrefix(\"/home\"))\n      }\n\nクイックフィックス適用後:\n\n\n      inline fun String.removePrefix(prefix: String): String {\n          return this.substring(prefix.length)\n      }\n\n      fun main() {\n          // `System.getProperty` は表示できない `String!` 型を返します\n          val property = System.getProperty(\"user.dir\")\n          println(property!!.removePrefix(\"/home\"))\n      }\n\nこのインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.2 未満の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PlatformExtensionReceiverOfInline",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/Java 相互運用性の問題",
                      "index": 66,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousEqualsCombination",
                "shortDescription": {
                  "text": "疑わしい == と === の組み合わせ"
                },
                "fullDescription": {
                  "text": "1 つの式で同じ変数に対して使用されている '==' 比較と '===' 比較を報告します。 '==' と '===' は似通っているため、気付かないうちに混在してしまった可能性があります。また、代わりに '==' が使用されていることを注意深く確認する必要があります。 '===' 例: 'if (type === FIELD || type == METHOD || type == ANNOTATION_METHOD || // \"==\" の使い方が正しくありません\n      type === LAMBDA_EXPRESSION) return'",
                  "markdown": "1 つの式で同じ変数に対して使用されている `==` 比較と `===` 比較を報告します。\n\n`==` と `===` は似通っているため、気付かないうちに混在してしまった可能性があります。また、代わりに `==` が使用されていることを注意深く確認する必要があります。 `===`\n\n例:\n\n\n      if (type === FIELD || type == METHOD || type == ANNOTATION_METHOD || // \"==\" の使い方が正しくありません\n          type === LAMBDA_EXPRESSION) return\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SuspiciousEqualsCombination",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MigrateDiagnosticSuppression",
                "shortDescription": {
                  "text": "診断名を置換する必要があります"
                },
                "fullDescription": {
                  "text": "'@Suppress(\"HEADER_WITHOUT_IMPLEMENTATION\")' など、古い診断名が付けられた抑止を報告します。 Kotlin 1.2 以前のバージョンの診断には非推奨になったものがあるため、このような抑止は不要とされています。 例: '@Suppress(\"HEADER_DECLARATION_WITH_BODY\")\nexpect fun connection() {\n  // ...\n}' クイックフィックス適用後: '@Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\nexpect fun connection() {\n  // ...\n}'",
                  "markdown": "`@Suppress(\"HEADER_WITHOUT_IMPLEMENTATION\")` など、古い診断名が付けられた抑止を報告します。\n\n\nKotlin 1.2 以前のバージョンの診断には非推奨になったものがあるため、このような抑止は不要とされています。\n\n**例:**\n\n\n    @Suppress(\"HEADER_DECLARATION_WITH_BODY\")\n    expect fun connection() {\n      // ...\n    }\n\nクイックフィックス適用後:\n\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    expect fun connection() {\n      // ...\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MigrateDiagnosticSuppression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/他の問題",
                      "index": 54,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedDataClassCopyResult",
                "shortDescription": {
                  "text": "未使用のデータクラスコピーの結果"
                },
                "fullDescription": {
                  "text": "データクラスの 'copy' 関数の呼び出しで、その結果を使用していないものを報告します。",
                  "markdown": "データクラスの `copy` 関数の呼び出しで、その結果を使用していないものを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedDataClassCopyResult",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonNullableBooleanPropertyInExternalInterface",
                "shortDescription": {
                  "text": "external インターフェースには null 非許容の Boolean プロパティが含まれます"
                },
                "fullDescription": {
                  "text": "外部インターフェースの 非 nullable のブール値プロパティを報告します。 詳細は、移行ガイドを参照してください。",
                  "markdown": "外部インターフェースの 非 nullable のブール値プロパティを報告します。 詳細は、[移行ガイド](https://kotlinlang.org/docs/js-ir-migration.html#make-boolean-properties-nullable-in-external-interfaces)を参照してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonNullableBooleanPropertyInExternalInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeferredResultUnused",
                "shortDescription": {
                  "text": "使用されていない '@Deferred' の結果"
                },
                "fullDescription": {
                  "text": "結果型が 'Deferred' の関数呼び出しで、戻り値が使用されていないものを報告します。 'Deferred' の戻り値が使用されない場合、呼び出しサイトは待機せずにこの関数を完了します。 例: 'fun calcEverythingAsync() = CompletableDeferred(42)\n\n  fun usage() {\n      calcEverythingAsync()\n  }' クイックフィックスを使用すると、'Deferred' イニシャライザー付きの変数が提供されます。 'fun calcEverythingAsync() = CompletableDeferred(42)\n\n  fun usage() {\n      val answer = calcEverythingAsync()\n  }'",
                  "markdown": "結果型が `Deferred` の関数呼び出しで、戻り値が使用されていないものを報告します。\n\n`Deferred` の戻り値が使用されない場合、呼び出しサイトは待機せずにこの関数を完了します。\n\n**例:**\n\n\n      fun calcEverythingAsync() = CompletableDeferred(42)\n\n      fun usage() {\n          calcEverythingAsync()\n      }\n\nクイックフィックスを使用すると、`Deferred` イニシャライザー付きの変数が提供されます。\n\n\n      fun calcEverythingAsync() = CompletableDeferred(42)\n\n      fun usage() {\n          val answer = calcEverythingAsync()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeferredResultUnused",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantElseInIf",
                "shortDescription": {
                  "text": "'if' 内の冗長な 'else'"
                },
                "fullDescription": {
                  "text": "'return' がある 'if' の冗長な 'else' を報告します。 例: 'fun foo(arg: Boolean): Int {\n      if (arg) return 0\n      else { // この else は冗長です。波括弧内のコードを外に出して左に移動できます\n          someCode()\n      }\n  }' クイックフィックス適用後: 'fun foo(arg: Boolean): Int {\n      if (arg) return 0\n      someCode()\n  }'",
                  "markdown": "`return` がある `if` の冗長な `else` を報告します。\n\n**例:**\n\n\n      fun foo(arg: Boolean): Int {\n          if (arg) return 0\n          else { // この else は冗長です。波括弧内のコードを外に出して左に移動できます\n              someCode()\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(arg: Boolean): Int {\n          if (arg) return 0\n          someCode()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantElseInIf",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SelfReferenceConstructorParameter",
                "shortDescription": {
                  "text": "完全になることがないコンストラクター"
                },
                "fullDescription": {
                  "text": "非 null の自己参照パラメーターを持つコンストラクターを報告します。 このようなコンストラクターがクラスをインスタンス化することはありません。 クイックフィックスを使用すると、パラメーターの型が nullable に変換されます。 例: 'class SelfRef(val ref: SelfRef)' クイックフィックス適用後: 'class SelfRef(val ref: SelfRef?)'",
                  "markdown": "非 null の自己参照パラメーターを持つコンストラクターを報告します。\n\nこのようなコンストラクターがクラスをインスタンス化することはありません。\n\nクイックフィックスを使用すると、パラメーターの型が nullable に変換されます。\n\n**例:**\n\n\n      class SelfRef(val ref: SelfRef)\n\nクイックフィックス適用後:\n\n\n      class SelfRef(val ref: SelfRef?)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SelfReferenceConstructorParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaIoSerializableObjectMustHaveReadResolve",
                "shortDescription": {
                  "text": "Serializable オブジェクトは 'readResolve' を実装する必要があります"
                },
                "fullDescription": {
                  "text": "'java.io.Serializable' を実装しているものの、readResolve を実装していない 'object' ('data object' を含む) を報告します 例: 'import java.io.Serializable\n\n  object Foo : Serializable' クイックフィックスを使用すると、'readResolve' メソッドが実装されます。 'import java.io.Serializable\n\n  object Foo : Serializable {\n      private fun readResolve() = Foo\n  }'",
                  "markdown": "`java.io.Serializable` を実装しているものの、[readResolve](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/input.html#the-readresolve-method) を実装していない `object` (`data object` を含む) を報告します\n\n**例:**\n\n\n      import java.io.Serializable\n\n      object Foo : Serializable\n\nクイックフィックスを使用すると、`readResolve` メソッドが実装されます。\n\n\n      import java.io.Serializable\n\n      object Foo : Serializable {\n          private fun readResolve() = Foo\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaIoSerializableObjectMustHaveReadResolve",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplacePutWithAssignment",
                "shortDescription": {
                  "text": "'map.put()' は代入に変換できます"
                },
                "fullDescription": {
                  "text": "インデックス演算子 ('[]') に置換できる 'map.put' 関数の呼び出しを報告します。 糖衣構文を使用すると、コードを単純化できます。 クイックフィックスを使用すると、'put' の呼び出しが代入に置換されます。 例: 'fun foo(map: MutableMap<Int, String>) {\n      map.put(42, \"foo\")\n  }' クイックフィックス適用後: 'fun foo(map: MutableMap<Int, String>) {\n      map[42] = \"foo\"\n  }'",
                  "markdown": "インデックス演算子 (`[]`) に置換できる `map.put` 関数の呼び出しを報告します。\n\n糖衣構文を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、`put` の呼び出しが代入に置換されます。\n\n**例:**\n\n\n      fun foo(map: MutableMap<Int, String>) {\n          map.put(42, \"foo\")\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(map: MutableMap<Int, String>) {\n          map[42] = \"foo\"\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplacePutWithAssignment",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MainFunctionReturnUnit",
                "shortDescription": {
                  "text": "main 関数は 'Unit' を返す必要があります"
                },
                "fullDescription": {
                  "text": "main 関数に 'Unit' の戻り値の型がない場合に報告します。 例: 'fun main() = \"Hello world!\"'",
                  "markdown": "main 関数に `Unit` の戻り値の型がない場合に報告します。\n\n**例:**\n`fun main() = \"Hello world!\"`"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MainFunctionReturnUnit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousCallableReferenceInLambda",
                "shortDescription": {
                  "text": "ラムダの結果として使用される疑わしい呼び出し可能参照"
                },
                "fullDescription": {
                  "text": "1 つの呼び出し可能参照を含むラムダ式を報告します。 波括弧を丸括弧に変更せずにラムダを呼び出し可能参照に置換するのはよくある間違いです。 例: 'listOf(1,2,3).map { it::toString }' クイックフィックス適用後: 'listOf(1,2,3).map(Int::toString)'",
                  "markdown": "1 つの呼び出し可能参照を含むラムダ式を報告します。\n\n波括弧を丸括弧に変更せずにラムダを呼び出し可能参照に置換するのはよくある間違いです。\n\n**例:**\n\n      listOf(1,2,3).map { it::toString }\n\nクイックフィックス適用後:\n\n      listOf(1,2,3).map(Int::toString)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SuspiciousCallableReferenceInLambda",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinDoubleNegation",
                "shortDescription": {
                  "text": "冗長な二重否定"
                },
                "fullDescription": {
                  "text": "冗長な二重否定を報告します。 例: 'val truth = !!true'",
                  "markdown": "冗長な二重否定を報告します。\n\n**例:**\n\n      val truth = !!true\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DoubleNegation",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FunctionName",
                "shortDescription": {
                  "text": "関数の命名規則"
                },
                "fullDescription": {
                  "text": "推奨されている命名規則に従っていない関数名を報告します。 例: 'fun Foo() {}' この問題を修正するには、推奨されている命名規則に一致するように関数名を変更してください。",
                  "markdown": "推奨されている命名規則に従っていない関数名を報告します。\n\n**例:**\n\n\n      fun Foo() {}\n\nこの問題を修正するには、推奨されている命名規則に一致するように関数名を変更してください。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FunctionName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名規約",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertSecondaryConstructorToPrimary",
                "shortDescription": {
                  "text": "プライマリコンストラクターに変換"
                },
                "fullDescription": {
                  "text": "より簡潔なプライマリコンストラクターに置換できるセカンダリコンストラクターを報告します。 例: 'class User {\n      val name: String\n\n      constructor(name: String) {\n          this.name = name\n      }\n  }' クイックフィックスを使用すると、コードが自動的に変換されます。 'class User(val name: String) {\n  }'",
                  "markdown": "より簡潔なプライマリコンストラクターに置換できるセカンダリコンストラクターを報告します。\n\n**例:**\n\n\n      class User {\n          val name: String\n\n          constructor(name: String) {\n              this.name = name\n          }\n      }\n\nクイックフィックスを使用すると、コードが自動的に変換されます。\n\n\n      class User(val name: String) {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConvertSecondaryConstructorToPrimary",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DifferentKotlinMavenVersion",
                "shortDescription": {
                  "text": "Maven と IDE プラグインのバージョンが異なります"
                },
                "fullDescription": {
                  "text": "Maven プラグインのバージョンが現在の IDE プラグインで適切にサポートされていないことを報告します。 この不整合により、IDE とコンパイラーのエラー報告動作に差異が生じる可能性があります。",
                  "markdown": "Maven プラグインのバージョンが現在の IDE プラグインで適切にサポートされていないことを報告します。\n\nこの不整合により、IDE とコンパイラーのエラー報告動作に差異が生じる可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DifferentKotlinMavenVersion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin",
                      "index": 2,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceGetOrSet",
                "shortDescription": {
                  "text": "明示的な 'get' または 'set' の呼び出し"
                },
                "fullDescription": {
                  "text": "インデックス演算子 '[]' に置換できる 'get' 関数または 'set' 関数の明示的な呼び出しを報告します。 Kotlin では、定義する型に対して使用可能な操作 (関数および演算子) を宣言できます。 演算子をオーバーロードするには、対応する関数に 'operator' 修飾子を付与してください。 'operator fun get(index: Int) {}\n  operator fun set(index: Int, value: Int) {}' 上の関数はインデックス演算子に対応しています。 例: 'class Test {\n      operator fun get(i: Int): Int = 0\n  }\n\n  fun test() {\n      Test().get(0) // 置換可能な 'get()'\n  }' クイックフィックス適用後: 'class Test {\n      operator fun get(i: Int): Int = 0\n  }\n\n  fun test() {\n      Test()[0]\n  }'",
                  "markdown": "インデックス演算子 `[]` に置換できる `get` 関数または `set` 関数の明示的な呼び出しを報告します。\n\n\nKotlin では、定義する型に対して使用可能な操作 (関数および演算子) を宣言できます。\n演算子をオーバーロードするには、対応する関数に `operator` 修飾子を付与してください。\n\n\n      operator fun get(index: Int) {}\n      operator fun set(index: Int, value: Int) {}\n        \n上の関数はインデックス演算子に対応しています。\n\n**例:**\n\n      class Test {\n          operator fun get(i: Int): Int = 0\n      }\n\n      fun test() {\n          Test().get(0) // 置換可能な 'get()'\n      }\n\nクイックフィックス適用後:\n\n      class Test {\n          operator fun get(i: Int): Int = 0\n      }\n\n      fun test() {\n          Test()[0]\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceGetOrSet",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProhibitRepeatedUseSiteTargetAnnotationsMigration",
                "shortDescription": {
                  "text": "'@Repeatable' が付いていない繰り返しアノテーション"
                },
                "fullDescription": {
                  "text": "プロパティアクセサーに対する非 '@Repeatable' アノテーションの反復使用を報告します。 非 '@Repeatable' アノテーションを複数回使用すると、両方のアノテーションの使用箇所がバイトコードに現れ、リフレクションの呼び出しがあいまいになります。 Kotlin 1.4 以降は '@Repeatable' アノテーションを付与するか、あるいはアノテーションを繰り返さない必要があります。従わない場合、コンパイルエラーが発生します。 例: 'annotation class Foo(val x: Int)\n\n  @get:Foo(10)\n  val a: String\n      @Foo(20) get() = \"foo\" // アノテーションが 2 回繰り返されていますが @Repeatable が付いていません' このインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.4 以降の場合にのみ報告します。",
                  "markdown": "プロパティアクセサーに対する非 `@Repeatable` アノテーションの反復使用を報告します。\n\n\n非 `@Repeatable` アノテーションを複数回使用すると、両方のアノテーションの使用箇所がバイトコードに現れ、リフレクションの呼び出しがあいまいになります。\n\n\nKotlin 1.4 以降は `@Repeatable` アノテーションを付与するか、あるいはアノテーションを繰り返さない必要があります。従わない場合、コンパイルエラーが発生します。\n\n**例:**\n\n\n      annotation class Foo(val x: Int)\n\n      @get:Foo(10)\n      val a: String\n          @Foo(20) get() = \"foo\" // アノテーションが 2 回繰り返されていますが @Repeatable が付いていません\n\nこのインスペクションは、プロジェクトまたはモジュールの Kotlin 言語レベルが 1.4 以降の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ProhibitRepeatedUseSiteTargetAnnotationsMigration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/移行",
                      "index": 16,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantUnitReturnType",
                "shortDescription": {
                  "text": "冗長な 'Unit' の戻り値の型"
                },
                "fullDescription": {
                  "text": "省略できる冗長な戻り値の型 'Unit' を報告します。",
                  "markdown": "省略できる冗長な戻り値の型 `Unit` を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantUnitReturnType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Destructure",
                "shortDescription": {
                  "text": "分解宣言の使用"
                },
                "fullDescription": {
                  "text": "分解できる宣言を報告します。 例: 'data class My(val first: String, val second: Int, val third: Boolean)\n\n  fun foo(list: List<My>) {\n      list.forEach { my ->\n          println(my.second)\n          println(my.third)\n      }\n  }' クイックフィックスを使用すると、宣言を分解して対応するクラスの名前で新規変数が導入されます。 'data class My(val first: String, val second: Int, val third: Boolean)\n\n  fun foo(list: List<My>) {\n      list.forEach { (_, second, third) ->\n          println(second)\n          println(third)\n      }\n  }'",
                  "markdown": "分解できる宣言を報告します。\n\n**例:**\n\n\n      data class My(val first: String, val second: Int, val third: Boolean)\n\n      fun foo(list: List<My>) {\n          list.forEach { my ->\n              println(my.second)\n              println(my.third)\n          }\n      }\n\nクイックフィックスを使用すると、宣言を分解して対応するクラスの名前で新規変数が導入されます。\n\n\n      data class My(val first: String, val second: Int, val third: Boolean)\n\n      fun foo(list: List<My>) {\n          list.forEach { (_, second, third) ->\n              println(second)\n              println(third)\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "Destructure",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedReceiverParameter",
                "shortDescription": {
                  "text": "未使用のレシーバーパラメーター"
                },
                "fullDescription": {
                  "text": "使用されていない拡張関数とプロパティのレシーバーパラメーターを報告します。 「冗長なレシーバーパラメーターの除去」を使用すると、コードを自動的に修正できます。",
                  "markdown": "使用されていない拡張関数とプロパティのレシーバーパラメーターを報告します。\n\n「**冗長なレシーバーパラメーターの除去**」を使用すると、コードを自動的に修正できます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedReceiverParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertTryFinallyToUseCall",
                "shortDescription": {
                  "text": "try / finally を use() の呼び出しに変換"
                },
                "fullDescription": {
                  "text": "'finally' に 'resource.close()' がある 'try-finally' ブロックで、'resource.use()' の呼び出しに変換できるものを報告します。 'use()' を使用すると明示的に 'close()' を呼び出す必要がなくなるため、コードが読みやすくなり、エラーも発生しにくくなります。 例: 'fun example() {\n      val reader = File(\"file.txt\").bufferedReader()\n      try {\n          reader.lineSequence().forEach(::print)\n      } finally {\n          reader.close()\n      }\n  }' クイックフィックス適用後: 'fun example() {\n      File(\"file.txt\").bufferedReader().use { reader ->\n          reader.lineSequence().forEach(::print)\n      }\n  }'",
                  "markdown": "`finally` に `resource.close()` がある `try-finally` ブロックで、`resource.use()` の呼び出しに変換できるものを報告します。\n\n`use()` を使用すると明示的に `close()` を呼び出す必要がなくなるため、コードが読みやすくなり、エラーも発生しにくくなります。\n\n**例:**\n\n\n      fun example() {\n          val reader = File(\"file.txt\").bufferedReader()\n          try {\n              reader.lineSequence().forEach(::print)\n          } finally {\n              reader.close()\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun example() {\n          File(\"file.txt\").bufferedReader().use { reader ->\n              reader.lineSequence().forEach(::print)\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertTryFinallyToUseCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KotlinRedundantOverride",
                "shortDescription": {
                  "text": "冗長なオーバーライドするメソッド"
                },
                "fullDescription": {
                  "text": "不要なオーバーライド宣言を報告します。 可視性を変更するなどしても、継承元シグネチャーのセマンティクスを変更しないオーバーライドは省略できます。 例: 'open class Foo {\n      open fun singleExpression() {\n      }\n  }\n\n  class Bar : Foo() {\n      override fun singleExpression() = super.singleExpression()\n  }' クイックフィックス適用後: 'class Bar : Foo() {\n  }'",
                  "markdown": "不要なオーバーライド宣言を報告します。\n\n\n可視性を変更するなどしても、継承元シグネチャーのセマンティクスを変更しないオーバーライドは省略できます。\n\n**例:**\n\n\n      open class Foo {\n          open fun singleExpression() {\n          }\n      }\n\n      class Bar : Foo() {\n          override fun singleExpression() = super.singleExpression()\n      }\n\nクイックフィックス適用後:\n\n\n      class Bar : Foo() {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantOverride",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RunBlocking",
                "shortDescription": {
                  "text": "コルーチン内の RunBlocking"
                },
                "fullDescription": {
                  "text": "コルーチンから到達可能な runBlocking ビルダーを報告します。 コルーチンは実行スレッドを共有します。 runBlocking ビルダーがコルーチンから呼び出されると、元になるスレッドがブロックされ、他のコルーチンがこのリソースを使用できなくなります。 これによりパフォーマンスの問題が発生し、ひどい場合にはスレッドスターべーションが発生する可能性があります。 これは、コルーチンのプリミティブ (suspend 関数またはビルダー) から runBlocking ビルダーへの潜在的なコールスタックを提供します。 例: 'suspend fun main() {\n      foo() \n   }\n\n  fun foo() {\n      runBlocking { suspendFunction() }\n  }' 可能な解決策: 'suspend fun main() {\n      foo() \n   }\n\n  suspend fun foo() {\n      suspendFunction()\n  }' 仮想関数の解析を構成するには、「オーバーライドを含む関数を調べる」オプションを使用します。 オーバーライドを含む関数の解析をスキップするには、「いいえ」オプションを使用します。 定義された呼び出し先の型でのみ関数を調べるには、「はい、オーバーライドを除外する」オプションを使用します。 関数とすべてのオーバーライドを調べるには、「はい、オーバーライドを含める」を使用します。",
                  "markdown": "コルーチンから到達可能な runBlocking ビルダーを報告します。\n\nコルーチンは実行スレッドを共有します。 runBlocking ビルダーがコルーチンから呼び出されると、元になるスレッドがブロックされ、他のコルーチンがこのリソースを使用できなくなります。 これによりパフォーマンスの問題が発生し、ひどい場合にはスレッドスターべーションが発生する可能性があります。\n\nこれは、コルーチンのプリミティブ (suspend 関数またはビルダー) から runBlocking ビルダーへの潜在的なコールスタックを提供します。\n\n例:\n\n\n      suspend fun main() {\n          foo() \n       }\n\n      fun foo() {\n          runBlocking { suspendFunction() }\n      }\n\n可能な解決策:\n\n\n      suspend fun main() {\n          foo() \n       }\n\n      suspend fun foo() {\n          suspendFunction()\n      }\n\n仮想関数の解析を構成するには、「**オーバーライドを含む関数を調べる**」オプションを使用します。\n\n* オーバーライドを含む関数の解析をスキップするには、「**いいえ**」オプションを使用します。\n* 定義された呼び出し先の型でのみ関数を調べるには、「**はい、オーバーライドを除外する**」オプションを使用します。\n* 関数とすべてのオーバーライドを調べるには、「**はい、オーバーライドを含める**」を使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RunBlocking",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/コルーチンのインスペクション",
                      "index": 132,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceArrayOfWithLiteral",
                "shortDescription": {
                  "text": "'arrayOf' の呼び出しは配列リテラル [...] に置換できます"
                },
                "fullDescription": {
                  "text": "配列リテラル '[...]' に置換できる 'arrayOf' の呼び出しを報告します。 例: 'annotation class MyAnnotation(val strings: Array<String>)\n\n  @MyAnnotation(arrayOf(\"alpha\", \"beta\", \"omega\")) // 置換可能な 'arrayOf()'\n  class MyClass' クイックフィックス適用後: 'annotation class MyAnnotation(val strings: Array<String>)\n\n  @MyAnnotation([\"alpha\", \"beta\", \"omega\"])\n  class MyClass'",
                  "markdown": "配列リテラル `[...]` に置換できる `arrayOf` の呼び出しを報告します。\n\n**例:**\n\n      annotation class MyAnnotation(val strings: Array<String>)\n\n      @MyAnnotation(arrayOf(\"alpha\", \"beta\", \"omega\")) // 置換可能な 'arrayOf()'\n      class MyClass\n\nクイックフィックス適用後:\n\n      annotation class MyAnnotation(val strings: Array<String>)\n\n      @MyAnnotation([\"alpha\", \"beta\", \"omega\"])\n      class MyClass\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceArrayOfWithLiteral",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceRangeToWithUntil",
                "shortDescription": {
                  "text": "'rangeTo' または '..' の呼び出しは 'until' に置換する必要があります"
                },
                "fullDescription": {
                  "text": "'until' を呼び出す代わりに、'rangeTo' または '..' 演算子を呼び出していることを報告します。 対応する関数を使用すると、コードを単純化できます。 クイックフィックスを使用すると、'rangeTo' または '..' の呼び出しが 'until' に置換されます。 例: 'fun foo(a: Int) {\n      for (i in 0..a - 1) {\n\n      }\n  }' クイックフィックス適用後: 'fun foo(a: Int) {\n      for (i in 0 until a) {\n\n      }\n  }'",
                  "markdown": "`until` を呼び出す代わりに、`rangeTo` または `..` 演算子を呼び出していることを報告します。\n\n対応する関数を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、`rangeTo` または `..` の呼び出しが `until` に置換されます。\n\n**例:**\n\n\n      fun foo(a: Int) {\n          for (i in 0..a - 1) {\n\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(a: Int) {\n          for (i in 0 until a) {\n\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceRangeToWithUntil",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceToWithInfixForm",
                "shortDescription": {
                  "text": "中置形式に置換すべき 'to' の呼び出し"
                },
                "fullDescription": {
                  "text": "中置形式に置換できる 'to' 関数の呼び出しを報告します。 中置形式を使用すると、コードを単純化できます。 クイックフィックスを使用すると、'to' が中置形式に置換されます。 例: 'fun foo(a: Int, b: Int) {\n      val pair = a.to(b)\n  }' クイックフィックス適用後: 'fun foo(a: Int, b: Int) {\n      val pair = a to b\n  }'",
                  "markdown": "中置形式に置換できる `to` 関数の呼び出しを報告します。\n\n中置形式を使用すると、コードを単純化できます。\n\nクイックフィックスを使用すると、`to` が中置形式に置換されます。\n\n**例:**\n\n\n      fun foo(a: Int, b: Int) {\n          val pair = a.to(b)\n      }\n\nクイックフィックス適用後:\n\n\n      fun foo(a: Int, b: Int) {\n          val pair = a to b\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceToWithInfixForm",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedEquals",
                "shortDescription": {
                  "text": "未使用の equals 式"
                },
                "fullDescription": {
                  "text": "未使用の 'equals'('==') 式を報告します。",
                  "markdown": "未使用の `equals`(`==`) 式を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstPropertyName",
                "shortDescription": {
                  "text": "const プロパティの命名規則"
                },
                "fullDescription": {
                  "text": "推奨されている命名規則に従っていない 'const' プロパティ名を報告します。 命名方法に一貫性を持たせると、コードが読みやすく、理解しやすくなります。 Kotlin の公式スタイルガイドによると、'const' プロパティにはアンダースコアで区切った大文字の名前を使用する必要があります。 例: 'const val Planck: Double = 6.62607015E-34' クイックフィックスを使用すると、プロパティの名前が変更されます。 'const val PLANCK: Double = 6.62607015E-34'",
                  "markdown": "推奨されている命名規則に従っていない `const` プロパティ名を報告します。\n\n\n命名方法に一貫性を持たせると、コードが読みやすく、理解しやすくなります。\n[Kotlin の公式スタイルガイド](https://kotlinlang.org/docs/coding-conventions.html#property-names)によると、`const` プロパティにはアンダースコアで区切った大文字の名前を使用する必要があります。\n\n**例:**\n\n\n      const val Planck: Double = 6.62607015E-34\n\nクイックフィックスを使用すると、プロパティの名前が変更されます。\n\n\n      const val PLANCK: Double = 6.62607015E-34\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConstPropertyName",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/命名規約",
                      "index": 49,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantNullableReturnType",
                "shortDescription": {
                  "text": "冗長な null 許容の戻り値の型"
                },
                "fullDescription": {
                  "text": "戻り値の型が nullable の関数と変数で、戻り値がないか 'null' になるものを報告します。 例: 'fun greeting(user: String): String? = \"Hello, $user!\"' クイックフィックス適用後: 'fun greeting(user: String): String = \"Hello, $user!\"'",
                  "markdown": "戻り値の型が nullable の関数と変数で、戻り値がないか `null` になるものを報告します。\n\n**例:**\n\n\n      fun greeting(user: String): String? = \"Hello, $user!\"\n\nクイックフィックス適用後:\n\n\n      fun greeting(user: String): String = \"Hello, $user!\"\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantNullableReturnType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/冗長なコンストラクト",
                      "index": 5,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnclearPrecedenceOfBinaryExpression",
                "shortDescription": {
                  "text": "優先順位の異なる複数の演算子"
                },
                "fullDescription": {
                  "text": "丸括弧を使用していない複数の異なる演算子から構成されている二項式を報告します。 このような式は演算子の優先順位規則が異なるため、読みにくい可能性があります。 例:   fun foo(b: Boolean?, i: Int?) {\n      val x = b ?: i == null // `(b ?: i) == null` と評価される\n      val y = i ?: 0 + 1 // `i ?: (0 + 1)` と評価される\n  }",
                  "markdown": "丸括弧を使用していない複数の異なる演算子から構成されている二項式を報告します。\n\nこのような式は演算子の[優先順位規則](https://kotlinlang.org/docs/reference/grammar.html#expressions)が異なるため、読みにくい可能性があります。\n\n例:\n\n```\n  fun foo(b: Boolean?, i: Int?) {\n      val x = b ?: i == null // `(b ?: i) == null` と評価される\n      val y = i ?: 0 + 1 // `i ?: (0 + 1)` と評価される\n  }\n```"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnclearPrecedenceOfBinaryExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/スタイルの問題",
                      "index": 3,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UselessCallOnNotNull",
                "shortDescription": {
                  "text": "null 以外の型での不要な呼び出し"
                },
                "fullDescription": {
                  "text": "nullable レシーバーに対してのみ意味のある非 null レシーバーの呼び出しを報告します。 'orEmpty()' や 'isNullOrEmpty' のようないくつかの標準ライブラリ関数は、nullable レシーバーに対して呼び出された場合にのみ意味を持ちます。 それ以外の場合は同じ結果になるため、このような呼び出しは省略または単純化できます。 「冗長な呼び出しの除去」と「呼び出しを … に変更」クイックフィックスを使用すると、コードを自動的に修正できます。 例: 'fun test(s: String) {\n      val x = s.orEmpty() // クイックフィックスで 's' に単純化できます\n      val y = s.isNullOrEmpty() // クイックフィックスで 's.isEmpty()' に単純化できます\n  }'",
                  "markdown": "nullable レシーバーに対してのみ意味のある非 null レシーバーの呼び出しを報告します。\n\n`orEmpty()` や `isNullOrEmpty` のようないくつかの標準ライブラリ関数は、nullable レシーバーに対して呼び出された場合にのみ意味を持ちます。 それ以外の場合は同じ結果になるため、このような呼び出しは省略または単純化できます。\n\n「**冗長な呼び出しの除去** 」と「**呼び出しを ... に変更**」クイックフィックスを使用すると、コードを自動的に修正できます。\n\n例:\n\n\n      fun test(s: String) {\n          val x = s.orEmpty() // クイックフィックスで 's' に単純化できます\n          val y = s.isNullOrEmpty() // クイックフィックスで 's.isEmpty()' に単純化できます\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UselessCallOnNotNull",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedLambdaExpressionBody",
                "shortDescription": {
                  "text": "ラムダ式の本文を含む関数の未使用の戻り値"
                },
                "fullDescription": {
                  "text": "未使用の戻り値がある呼び出しで、呼び出し先の関数が式本体からラムダを返している場合に報告します。 関数のヘッダーと本体ブロックの間に '=' があると、関数内のコードが評価されず、不正な動作が発生する可能性があります。 「関数宣言から =トークンを除去」を使用すると、コードを自動的に修正できます。 例: 'fun printHello() = { println(\"Hello\") }\n\n  fun main() {\n      printHello() // この関数は何も出力しません\n  }' クイックフィックス適用後: 'fun printHello() { println(\"Hello\") }\n\n  fun main() {\n      printHello()\n  }'",
                  "markdown": "未使用の戻り値がある呼び出しで、呼び出し先の関数が式本体からラムダを返している場合に報告します。\n\n\n関数のヘッダーと本体ブロックの間に `=` があると、関数内のコードが評価されず、不正な動作が発生する可能性があります。\n\n「**関数宣言から =トークンを除去**」を使用すると、コードを自動的に修正できます。\n\n例:\n\n\n      fun printHello() = { println(\"Hello\") }\n\n      fun main() {\n          printHello() // この関数は何も出力しません\n      }\n\nクイックフィックス適用後:\n\n\n      fun printHello() { println(\"Hello\") }\n\n      fun main() {\n          printHello()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedLambdaExpressionBody",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsOrHashCode",
                "shortDescription": {
                  "text": "equals() と hashCode() がペアになっていません"
                },
                "fullDescription": {
                  "text": "'equals()' をオーバーライドしているものの、'hashCode()' をオーバーライドしていないクラスを報告します (逆の場合にも対応しています)。 'equals()' または 'hashCode()' をオーバーライドしているオブジェクト宣言も報告します。 これらは、'Collection' にクラスが追加される際に好ましくない動作を引き起こす場合があります。 例: 'class C1 {\n      override fun equals(other: Any?) = true\n  }\n\n  class C2 {\n      override fun hashCode() = 0\n  }\n\n  object O1 {\n      override fun equals(other: Any?) = true\n  }\n\n  object O2 {\n      override fun hashCode() = 0\n  }' クイックフィックスを使用すると、クラスの場合は 'equals()' または 'hashCode()' がオーバーライドされ、オブジェクトの場合はこれらのメソッドが除去されます。 'class C1 {\n       override fun equals(other: Any?) = true\n       override fun hashCode(): Int {\n           return javaClass.hashCode()\n       }\n   }\n\n   class C2 {\n       override fun hashCode() = 0\n       override fun equals(other: Any?): Boolean {\n           if (this === other) return true\n           if (javaClass != other?.javaClass) return false\n           return true\n       }\n   }\n\n   object O1 {\n   }\n\n   object O2 {\n   }'",
                  "markdown": "`equals()` をオーバーライドしているものの、`hashCode()` をオーバーライドしていないクラスを報告します (逆の場合にも対応しています)。 `equals()` または `hashCode()` をオーバーライドしているオブジェクト宣言も報告します。\n\nこれらは、`Collection` にクラスが追加される際に好ましくない動作を引き起こす場合があります。\n\n**例:**\n\n\n      class C1 {\n          override fun equals(other: Any?) = true\n      }\n\n      class C2 {\n          override fun hashCode() = 0\n      }\n\n      object O1 {\n          override fun equals(other: Any?) = true\n      }\n\n      object O2 {\n          override fun hashCode() = 0\n      }\n\nクイックフィックスを使用すると、クラスの場合は `equals()` または `hashCode()` がオーバーライドされ、オブジェクトの場合はこれらのメソッドが除去されます。\n\n\n       class C1 {\n           override fun equals(other: Any?) = true\n           override fun hashCode(): Int {\n               return javaClass.hashCode()\n           }\n       }\n\n       class C2 {\n           override fun hashCode() = 0\n           override fun equals(other: Any?): Boolean {\n               if (this === other) return true\n               if (javaClass != other?.javaClass) return false\n               return true\n           }\n       }\n\n       object O1 {\n       }\n\n       object O2 {\n       }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsOrHashCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kotlin/潜在的なバグ",
                      "index": 25,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.java",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "OverrideOnly",
                "shortDescription": {
                  "text": "メソッドはオーバーライドのみ可能"
                },
                "fullDescription": {
                  "text": "'@ApiStatus.OverrideOnly' でマークされている API メソッドの呼び出しを報告します。 '@ApiStatus.OverrideOnly' アノテーションは、このメソッドが SPI (サービスプロバイダーインターフェース) の一部であることを示しています。 宣言するライブラリのクライアントは、このようなメソッドを直接呼び出すのではなく、実装またはオーバーライドする必要があります。 このアノテーションでクラスやインターフェースをマークすることは、このアノテーションですべてのメソッドをマークすることと同じです。",
                  "markdown": "`@ApiStatus.OverrideOnly` でマークされている API メソッドの呼び出しを報告します。\n\n\n`@ApiStatus.OverrideOnly` アノテーションは、このメソッドが SPI (サービスプロバイダーインターフェース) の一部であることを示しています。\n宣言するライブラリのクライアントは、このようなメソッドを直接呼び出すのではなく、実装またはオーバーライドする必要があります。\nこのアノテーションでクラスやインターフェースをマークすることは、このアノテーションですべてのメソッドをマークすることと同じです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverrideOnly",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RuntimeExec",
                "shortDescription": {
                  "text": "'Runtime.exec()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'Runtime.exec()'、またはそのバリアントの呼び出しを報告します。 'Runtime.exec()' の呼び出しは本質的に移植性がありません。",
                  "markdown": "`Runtime.exec()`、またはそのバリアントの呼び出しを報告します。 `Runtime.exec()` の呼び出しは本質的に移植性がありません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToRuntimeExec",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ポータビリティ",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticInitializerReferencesSubClass",
                "shortDescription": {
                  "text": "static イニシャライザーはサブクラスを参照"
                },
                "fullDescription": {
                  "text": "static イニシャライザーまたは static フィールドで自身のサブクラスを参照しているクラスを報告します。 マルチスレッド環境であるスレッドがスーパークラスをロードしようとしており、それと同時に別のスレッドがサブクラスをロードしようとしている場合、このような参照が原因で JVM レベルのデッドロックが発生する可能性があります。 例: 'class Parent {\n    static final Child field = new Child();\n  }\n  class Child extends Parent { }'",
                  "markdown": "static イニシャライザーまたは static フィールドで自身のサブクラスを参照しているクラスを報告します。\n\nマルチスレッド環境であるスレッドがスーパークラスをロードしようとしており、それと同時に別のスレッドがサブクラスをロードしようとしている場合、このような参照が原因で JVM レベルのデッドロックが発生する可能性があります。\n\n**例:**\n\n\n      class Parent {\n        static final Child field = new Child();\n      }\n      class Child extends Parent { }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticInitializerReferencesSubClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingDeprecatedAnnotationOnScheduledForRemovalApi",
                "shortDescription": {
                  "text": "削除予定の API に '@Deprecated' 注釈がありません"
                },
                "fullDescription": {
                  "text": "'@ApiStatus.ScheduledForRemoval' が付いているものの、'@Deprecated' が付いていない宣言を報告します。 例: '@ApiStatus.ScheduledForRemoval(inVersion = \"2017.3\")\n  public void myLegacyMethod() { }' クイックフィックス適用後の結果は次のようになります。 '@Deprecated\n  @ApiStatus.ScheduledForRemoval(inVersion = \"2017.3\")\n  public void myLegacyMethod() { }'",
                  "markdown": "`@ApiStatus.ScheduledForRemoval` が付いているものの、`@Deprecated` が付いていない宣言を報告します。\n\n例:\n\n\n      @ApiStatus.ScheduledForRemoval(inVersion = \"2017.3\")\n      public void myLegacyMethod() { }\n\nクイックフィックス適用後の結果は次のようになります。\n\n\n      @Deprecated\n      @ApiStatus.ScheduledForRemoval(inVersion = \"2017.3\")\n      public void myLegacyMethod() { }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MissingDeprecatedAnnotationOnScheduledForRemovalApi",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToSuspiciousStringMethod",
                "shortDescription": {
                  "text": "疑わしい 'String' メソッドへの呼び出し"
                },
                "fullDescription": {
                  "text": "以下の呼び出しのうち: 'equals()' 'equalsIgnoreCase()' 'compareTo()' 'compareToIgnoreCase()' 'trim()' 'String' オブジェクトに対して呼び出しているものを報告します。 国際化された文字列の比較には、'java.text.Collator' を代わりに使用すべきだと思われます。 'String.trim()' は 0x00 と 0x20 の間の制御文字のみを除去します。 Java 11 で導入された 'String.strip()' メソッドは Unicode にさらに対応しており、代わりに使用することができます。",
                  "markdown": "以下の呼び出しのうち:\n\n* `equals()`\n* `equalsIgnoreCase()`\n* `compareTo()`\n* `compareToIgnoreCase()`\n* `trim()`\n\n\n`String` オブジェクトに対して呼び出しているものを報告します。\n国際化された文字列の比較には、`java.text.Collator` を代わりに使用すべきだと思われます。\n`String.trim()` は 0x00 と 0x20 の間の制御文字のみを除去します。\nJava 11 で導入された `String.strip()` メソッドは Unicode にさらに対応しており、代わりに使用することができます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSuspiciousStringMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KeySetIterationMayUseEntrySet",
                "shortDescription": {
                  "text": "最適化可能な 'keySet()' のイテレーション"
                },
                "fullDescription": {
                  "text": "'java.util.Map' インスタンスの 'keySet()' が繰り返しされており、繰り返し対象のキーがマップから値を取得するために使用されていることを報告します。 このような繰り返しは、'entrySet()' または 'values()' の繰り返しに置換したほうが効率的です (対象のキーが実際に使用されていない場合)。 同様に、値がラムダ内で取得されている場合は 'keySet().forEach(key -> ...)' を 'forEach((key, value) -> ...)' に置換できます。 例: 'for (Object key : map.keySet()) {\n   Object val = map.get(key);\n  }' クイックフィックス適用後: 'for (Object val : map.values()) {}'",
                  "markdown": "`java.util.Map` インスタンスの `keySet()` が繰り返しされており、繰り返し対象のキーがマップから値を取得するために使用されていることを報告します。\n\n\nこのような繰り返しは、`entrySet()` または `values()` の繰り返しに置換したほうが効率的です (対象のキーが実際に使用されていない場合)。\n\n\n同様に、値がラムダ内で取得されている場合は `keySet().forEach(key -> ...)` を `forEach((key, value) -> ...)` に置換できます。\n\n**例:**\n\n\n      for (Object key : map.keySet()) {\n       Object val = map.get(key);\n      }\n\nクイックフィックス適用後:\n\n\n      for (Object val : map.values()) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KeySetIterationMayUseEntrySet",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryQualifierForThis",
                "shortDescription": {
                  "text": "'this' または 'super' の不要な修飾子"
                },
                "fullDescription": {
                  "text": "'this' または 'super' の不要な修飾を報告します。 コードの参照を明確にするために付けられた 'this' または 'super' の修飾子は、自動リファクタリングを使用すれば簡単に不要にすることができます。また、明瞭さを求めるなら削除すべきです。 例: 'class Foo {\n    void foo() {}\n  }\n\n  class Bar extends Foo {\n    void bar() {\n      Bar.super.foo();\n    }\n  }' クイックフィックス適用後: 'class Foo {\n    void foo() {}\n  }\n\n  class Bar extends Foo {\n    void bar() {\n      super.foo();\n    }\n  }'",
                  "markdown": "`this` または `super` の不要な修飾を報告します。\n\n\nコードの参照を明確にするために付けられた `this` または `super` の修飾子は、自動リファクタリングを使用すれば簡単に不要にすることができます。また、明瞭さを求めるなら削除すべきです。\n\n**例:**\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          Bar.super.foo();\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          super.foo();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryQualifierForThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantDeclaredInAbstractClass",
                "shortDescription": {
                  "text": "'abstract' クラスで宣言された定数"
                },
                "fullDescription": {
                  "text": "抽象クラスで宣言されている定数 ('public static final' フィールド) を報告します。 一部のコーディング標準は、代わりにインターフェースで定数を宣言することを要求しています。",
                  "markdown": "抽象クラスで宣言されている定数 (`public static final` フィールド) を報告します。\n\n一部のコーディング標準は、代わりにインターフェースで定数を宣言することを要求しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantDeclaredInAbstractClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SubtractionInCompareTo",
                "shortDescription": {
                  "text": "'compareTo()' での減算"
                },
                "fullDescription": {
                  "text": "'compareTo()' メソッドと 'java.util.Comparator.compare()' を実装しているメソッドでの減算を報告します。 整数減算の結果を 'compareTo()' メソッドの結果として使用するのは一般的な用法ですが、このコンストラクトは整数がオーバーフローした場合に検出しにくく厄介なバグを引き起こす可能性があります。 ほとんどの場合は、整数値を直接比較して '-1'、'0'、'1' のいずれかを返すことをお勧めします。 即座に整数型にキャストされている浮動小数点値の減算も報告されます。このような場合は数値が丸められることで、精度が低下する可能性があるためです。 このインスペクションは、値の範囲が制限されており、オーバーフローが絶対に発生しないことが静的に判断される場合は報告しません。 また、'0' 以上の 'int' 数値の減算がオーバーフローすることはありません。 したがって、このインスペクションはそのような場合には警告しないようになっています。 常にゼロ以上を返すメソッドは、'javax.annotation.Nonnegative' アノテーションを付けるか、このインスペクションのオプションで指定できます。 例: 'class DoubleHolder implements Comparable<DoubleHolder> {\n    double d;\n    public int compareTo(DoubleHolder that) {\n        return (int)(this.d - that.d);\n    }\n }' マイナスにならないことが分かっている 'String.length()' を使用した例。この場合は警告が表示されません。 'class A implements Comparable<A> {\n    final String s = \"\";\n    public int compareTo(A a) {\n        return s.length() - a.s.length();\n    }\n }' 減算内で安全に使用できるメソッドをリストするには、オプションを使用します。 メソッドは、常に '0' 以上の 'int' 値を返す場合は安全です。",
                  "markdown": "`compareTo()` メソッドと `java.util.Comparator.compare()` を実装しているメソッドでの減算を報告します。\n\n\n整数減算の結果を `compareTo()` メソッドの結果として使用するのは一般的な用法ですが、このコンストラクトは整数がオーバーフローした場合に検出しにくく厄介なバグを引き起こす可能性があります。\nほとんどの場合は、整数値を直接比較して `-1`、`0`、`1` のいずれかを返すことをお勧めします。\n\n\n即座に整数型にキャストされている浮動小数点値の減算も報告されます。このような場合は数値が丸められることで、精度が低下する可能性があるためです。\n\n\nこのインスペクションは、値の範囲が制限されており、オーバーフローが絶対に発生しないことが静的に判断される場合は報告しません。\nまた、`0` 以上の `int` 数値の減算がオーバーフローすることはありません。\nしたがって、このインスペクションはそのような場合には警告しないようになっています。\n\n\n常にゼロ以上を返すメソッドは、`javax.annotation.Nonnegative` アノテーションを付けるか、このインスペクションのオプションで指定できます。\n\n**例:**\n\n\n      class DoubleHolder implements Comparable<DoubleHolder> {\n        double d;\n        public int compareTo(DoubleHolder that) {\n            return (int)(this.d - that.d);\n        }\n     }\n\nマイナスにならないことが分かっている `String.length()` を使用した例。この場合は警告が表示されません。\n\n\n      class A implements Comparable<A> {\n        final String s = \"\";\n        public int compareTo(A a) {\n            return s.length() - a.s.length();\n        }\n     }\n\n\n減算内で安全に使用できるメソッドをリストするには、オプションを使用します。\nメソッドは、常に `0` 以上の `int` 値を返す場合は安全です。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SubtractionInCompareTo",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UncheckedExceptionClass",
                "shortDescription": {
                  "text": "未チェックの 'Exception' クラス"
                },
                "fullDescription": {
                  "text": "'java.lang.RuntimeException' のサブクラスを報告します。 一部のコーディング標準は、ユーザー定義の例外クラスがすべてチェック例外クラスであることを要求します。 例: 'class EnigmaException extends RuntimeException {} // 警告: 非チェック例外クラス 'EnigmaException''",
                  "markdown": "`java.lang.RuntimeException` のサブクラスを報告します。\n\n一部のコーディング標準は、ユーザー定義の例外クラスがすべてチェック例外クラスであることを要求します。\n\n**例:**\n\n\n      class EnigmaException extends RuntimeException {} // 警告: 非チェック例外クラス 'EnigmaException'\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UncheckedExceptionClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedReturnValue",
                "shortDescription": {
                  "text": "'void' にできるメソッド"
                },
                "fullDescription": {
                  "text": "呼び出された際に戻り値が使用されることがないメソッドを報告します。 このようなメソッドの戻り値の型は、'void' にできます。 Error Prone または AssertJ の '@CanIgnoreReturnValue' アノテーションが付いたメソッドは報告されません。 クイックフィックスを使用すると、メソッドシグネチャーが更新され、メソッド内から 'return' ステートメントが除去されます。 例: '// 可視性が protected または public に設定されている場合に報告される\n  protected String myToUpperCase(String s) {\n    return s.toUpperCase();\n  }\n\n  // 単純な setter、報告されるかどうかは設定次第\n  public String setStr(String str) {\n    myStr = str;\n    return myStr;\n  }\n\n  void test() {\n    setStr(\"value\");          // 戻り値が使用されていない\n    myToUpperCase(\"result\");  // 戻り値が使用されていない\n  }' 両方のメソッドにクイックフィックスを適用後: 'protected void myToUpperCase(String s) {\n      // 's.toUpperCase()' は副作用がないため\n      // 'return' が完全に除去されています\n    }\n\n    public void setStr(String str) {\n      myStr = str;\n      // 'return' が除去されました\n    }\n  ...' 注意: パフォーマンス上の理由から、一部のメソッドはエディターでハイライトしている間は報告されません。 すべての結果を表示するには、「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」を使用してインスペクションを実行します。> チェーン可能な呼び出しからの未使用の戻り値を無視するには、「チェーン可能なメソッドを無視する」オプションを使用します。 報告対象とする最大のメソッド可視性を制御するには、「報告対象とする最大のメソッド可視性」オプションを使用します。",
                  "markdown": "呼び出された際に戻り値が使用されることがないメソッドを報告します。 このようなメソッドの戻り値の型は、`void` にできます。\n\nError Prone または AssertJ の `@CanIgnoreReturnValue` アノテーションが付いたメソッドは報告されません。\nクイックフィックスを使用すると、メソッドシグネチャーが更新され、メソッド内から `return` ステートメントが除去されます。\n\n**例:**\n\n\n      // 可視性が protected または public に設定されている場合に報告される\n      protected String myToUpperCase(String s) {\n        return s.toUpperCase();\n      }\n\n      // 単純な setter、報告されるかどうかは設定次第\n      public String setStr(String str) {\n        myStr = str;\n        return myStr;\n      }\n\n      void test() {\n        setStr(\"value\");          // 戻り値が使用されていない\n        myToUpperCase(\"result\");  // 戻り値が使用されていない\n      }\n\n両方のメソッドにクイックフィックスを適用後:\n\n\n        protected void myToUpperCase(String s) {\n          // 's.toUpperCase()' は副作用がないため\n          // 'return' が完全に除去されています\n        }\n\n        public void setStr(String str) {\n          myStr = str;\n          // 'return' が除去されました\n        }\n      ...\n\n\n**注意:** パフォーマンス上の理由から、一部のメソッドはエディターでハイライトしている間は報告されません。\nすべての結果を表示するには、「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」を使用してインスペクションを実行します。\\>\n\nチェーン可能な呼び出しからの未使用の戻り値を無視するには、「**チェーン可能なメソッドを無視する**」オプションを使用します。\n\n報告対象とする最大のメソッド可視性を制御するには、「**報告対象とする最大のメソッド可視性**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedReturnValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SizeReplaceableByIsEmpty",
                "shortDescription": {
                  "text": "'isEmpty()' に置換可能な 'size() == 0'"
                },
                "fullDescription": {
                  "text": "'0' リテラルを使用している '.size()' または '.length()' の比較で、'.isEmpty()' の呼び出しに置換できるものを報告します。 例: 'boolean emptyList = list.size() == 0;' クイックフィックス適用後: 'boolean emptyList = list.isEmpty();' '.size()' または '.length()' の比較を置換しないクラスを追加するには、「無視対象クラス」テーブルを使用します。 '!isEmpty()' に置換できる式を無視するには、「'!isEmpty()' に置換できる式を無視する」オプションを使用します。",
                  "markdown": "`0` リテラルを使用している `.size()` または `.length()` の比較で、`.isEmpty()` の呼び出しに置換できるものを報告します。\n\n**例:**\n\n\n      boolean emptyList = list.size() == 0;\n\nクイックフィックス適用後:\n\n\n      boolean emptyList = list.isEmpty();\n      \n\n`.size()` または `.length()` の比較を置換しないクラスを追加するには、「**無視対象クラス**」テーブルを使用します。\n\n`!isEmpty()` に置換できる式を無視するには、「**`!isEmpty()` に置換できる式を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SizeReplaceableByIsEmpty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnsupportedChronoFieldUnitCall",
                "shortDescription": {
                  "text": "サポート対象外の 'java.time.temporal.ChronoUnit' および 'java.time.temporal.ChronoField' を使用したメソッドの呼び出し"
                },
                "fullDescription": {
                  "text": "サポートされていない 'java.time.temporal.ChronoField' または 'java.time.temporal.ChronoUnit' 列挙型定数を引数として持つ 'java.time' メソッド呼び出し ('get()'、'getLong()'、'with()'、'plus()'、'minus()') を報告します。 このような呼び出しは、実行時に 'UnsupportedTemporalTypeException' をスローします。 例: 'LocalTime localTime = LocalTime.now();\nint year = localTime.get(ChronoField.YEAR);' 2023.2 の新機能です",
                  "markdown": "サポートされていない `java.time.temporal.ChronoField` または `java.time.temporal.ChronoUnit` 列挙型定数を引数として持つ `java.time` メソッド呼び出し (`get()`、`getLong()`、`with()`、`plus()`、`minus()`) を報告します。 このような呼び出しは、実行時に `UnsupportedTemporalTypeException` をスローします。\n\n例:\n\n\n    LocalTime localTime = LocalTime.now();\n    int year = localTime.get(ChronoField.YEAR);\n\n2023.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnsupportedChronoFieldUnitCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NumberEquality",
                "shortDescription": {
                  "text": "'equals()' の代わりに '==' を使用した数値比較"
                },
                "fullDescription": {
                  "text": "'equals()' ではなく == または != を使用して 'Number' の等価性をテストしているコードを報告します。 自動ボクシングに関して、2 つのプリミティブではなくラッパー型の 2 つのインスタンスを比較するのは良くある間違いです。たとえば、'int' ではなく 'Integer' を使用しているケースが挙げられます。 例: 'void foo(Integer a, Integer b) {\n    final boolean bool = a == b;\n  }' 'a' が非 null であることがわかっている場合は、「安全でない」クイックフィックスを適用して次のような結果を得ても問題ありません。 'void foo(Integer a, Integer b) {\n    final boolean bool = a.equals(b);\n  }'",
                  "markdown": "`equals()` ではなく **==** または **!=** を使用して `Number` の等価性をテストしているコードを報告します。\n\n\n自動ボクシングに関して、2 つのプリミティブではなくラッパー型の 2 つのインスタンスを比較するのは良くある間違いです。たとえば、`int` ではなく `Integer` を使用しているケースが挙げられます。\n\n**例:**\n\n      void foo(Integer a, Integer b) {\n        final boolean bool = a == b;\n      }\n\n`a` が非 null であることがわかっている場合は、「安全でない」クイックフィックスを適用して次のような結果を得ても問題ありません。\n\n      void foo(Integer a, Integer b) {\n        final boolean bool = a.equals(b);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NumberEquality",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithOnlyPrivateConstructors",
                "shortDescription": {
                  "text": "'private' コンストラクターのみを持つ 'final' 宣言すべきクラス"
                },
                "fullDescription": {
                  "text": "'private' コンストラクターのみを持つクラスを報告します。 'private' コンストラクターのみを持つクラスはファイル外に拡張できず、'final' として宣言する必要があります。",
                  "markdown": "`private` コンストラクターのみを持つクラスを報告します。\n\n`private` コンストラクターのみを持つクラスはファイル外に拡張できず、`final` として宣言する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithOnlyPrivateConstructors",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparatorNotSerializable",
                "shortDescription": {
                  "text": "'Serializable' 宣言されていない 'Comparator' クラス"
                },
                "fullDescription": {
                  "text": "'java.lang.Comparator' を実装しているものの、'java.io.Serializable' を実装していないクラスを報告します。 非 Serializable なコンパレーターが 'java.util.TreeMap' や 'java.util.TreeSet' などの順序指定されたコレクションを作成するために使用されている場合は、コレクションも非 Serializable になります。 これにより、予期しない診断が困難なバグが発生する可能性があります。 'java.lang.Comparator' のサブクラスはステートレスであることが多いため、Serializable を指定するだけでこのような問題を回避できます。 例: 'class Foo implements Comparator { // 警告\n      @Override\n      public int compare(Object o1, Object o2) {\n          /* ... */\n      }\n  }' クイックフィックス適用後: 'class Foo implements Comparator, Serializable { // ここでは警告は表示されません\n      @Override\n      public int compare(Object o1, Object o2) {\n          /* ... */\n      }\n  }'",
                  "markdown": "`java.lang.Comparator` を実装しているものの、`java.io.Serializable` を実装していないクラスを報告します。\n\n\n非 Serializable なコンパレーターが `java.util.TreeMap` や `java.util.TreeSet` などの順序指定されたコレクションを作成するために使用されている場合は、コレクションも非 Serializable になります。 これにより、予期しない診断が困難なバグが発生する可能性があります。\n\n\n`java.lang.Comparator` のサブクラスはステートレスであることが多いため、Serializable を指定するだけでこのような問題を回避できます。\n\n**例:**\n\n\n      class Foo implements Comparator { // 警告\n          @Override\n          public int compare(Object o1, Object o2) {\n              /* ... */\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo implements Comparator, Serializable { // ここでは警告は表示されません\n          @Override\n          public int compare(Object o1, Object o2) {\n              /* ... */\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparatorNotSerializable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConnectionResource",
                "shortDescription": {
                  "text": "安全に閉じられていない Connection"
                },
                "fullDescription": {
                  "text": "'try' ブロックの前で開かれておらず、または対応する 'finally' ブロックで閉じられていない Java ME の 'javax.microedition.io.Connection' リソースを報告します。 リソースが閉じられる前に例外がスローされている場合、予期しないリソースのリークが発生する可能性があります。 例: 'void example() throws IOException {\n    Connection c = Connector.open(\"foo\");\n  }'",
                  "markdown": "`try` ブロックの前で開かれておらず、または対応する `finally` ブロックで閉じられていない Java ME の `javax.microedition.io.Connection` リソースを報告します。 リソースが閉じられる前に例外がスローされている場合、予期しないリソースのリークが発生する可能性があります。\n\n**例:**\n\n\n      void example() throws IOException {\n        Connection c = Connector.open(\"foo\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConnectionOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス/組み込み",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UNUSED_IMPORT",
                "shortDescription": {
                  "text": "未使用の import"
                },
                "fullDescription": {
                  "text": "冗長な 'import' ステートメントを報告します。 ソースファイルでインポートされたクラスとパッケージを使用しない場合、通常の 'import' ステートメントは不要です。 インポートされた 'static' フィールドとメソッドで、ソースファイルで使用されていないものにも同じことが当てはまります。 例: 'import java.util.ArrayList;\n  public class Example {\n    public static void main(String[] args) {\n      System.out.println(\"Hello World!\");\n    }\n  }' クイックフィックス適用後: 'public class Example {\n    public static void main(String[] args) {\n      System.out.println(\"Hello World!\");\n    }\n  }'",
                  "markdown": "冗長な `import` ステートメントを報告します。\n\nソースファイルでインポートされたクラスとパッケージを使用しない場合、通常の `import` ステートメントは不要です。\nインポートされた `static` フィールドとメソッドで、ソースファイルで使用されていないものにも同じことが当てはまります。\n\n**例:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UNUSED_IMPORT",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/インポート",
                      "index": 23,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanVariableAlwaysNegated",
                "shortDescription": {
                  "text": "常に反転されているブール値"
                },
                "fullDescription": {
                  "text": "ブール変数またはフィールドのうち、その値が使用される際に常に否定されているものを報告します。 例: 'void m() {\n        boolean b = true; //ブール変数 'b' は常に反転されています\n        System.out.println(!b);\n      }'",
                  "markdown": "ブール変数またはフィールドのうち、その値が使用される際に常に否定されているものを報告します。\n\n例:\n\n\n          void m() {\n            boolean b = true; //ブール変数 'b' は常に反転されています\n            System.out.println(!b);\n          }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanVariableAlwaysNegated",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/データフロー",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsAnnotation",
                "shortDescription": {
                  "text": "アノテーションインターフェースを拡張しているクラス"
                },
                "fullDescription": {
                  "text": "アノテーションインターフェースの実装または拡張として宣言されているクラスを報告します。 アノテーションインターフェースの拡張は有効ですが、多くの場合は誤って行われています。また、その結果をアノテーションとして使用することはできません。 このインスペクションは Java 5 以降で使用できる Java の機能 'アノテーション' に依存しています。",
                  "markdown": "アノテーションインターフェースの実装または拡張として宣言されているクラスを報告します。\n\nアノテーションインターフェースの拡張は有効ですが、多くの場合は誤って行われています。また、その結果をアノテーションとして使用することはできません。\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 'アノテーション' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassExplicitlyAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldAccessedSynchronizedAndUnsynchronized",
                "shortDescription": {
                  "text": "'synchronized' コンテキストと非同期コンテキストの両方でアクセスされるフィールド"
                },
                "fullDescription": {
                  "text": "'synchronized' と非 'synchronized' の両方のコンテキストでアクセスされている非 final フィールドを報告します。 'volatile' フィールドとコンストラクターとイニシャライザーのアクセスは、このインスペクションにより無視されます。 このような「部分的な同期」アクセスは往々にしてコーディングの不備であり、一貫性のないデータ構造を予期せず生み出す可能性があります。 例: 'public class Program {\n    Console console; // 警告: 'console' フィールドは同期および非同期コンテンツの両方でアクセスされています\n\n    public synchronized void execute() {\n      console.print(\"running\");\n    }\n\n    public void check() {\n      console.check();\n    }\n  }'\n 単純な getter や setter もアクセスと見なすかどうかを指定するには、 オプションを使用します。",
                  "markdown": "`synchronized` と非 `synchronized` の両方のコンテキストでアクセスされている非 final フィールドを報告します。 `volatile` フィールドとコンストラクターとイニシャライザーのアクセスは、このインスペクションにより無視されます。\n\n\nこのような「部分的な同期」アクセスは往々にしてコーディングの不備であり、一貫性のないデータ構造を予期せず生み出す可能性があります。\n\n**例:**\n\n\n      public class Program {\n        Console console; // 警告: 'console' フィールドは同期および非同期コンテンツの両方でアクセスされています\n\n        public synchronized void execute() {\n          console.print(\"running\");\n        }\n\n        public void check() {\n          console.check();\n        }\n      }\n\n\n単純な getter や setter もアクセスと見なすかどうかを指定するには、 オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldAccessedSynchronizedAndUnsynchronized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveLiteralUnderscores",
                "shortDescription": {
                  "text": "数値リテラルのアンダースコア"
                },
                "fullDescription": {
                  "text": "アンダースコアを含む数値リテラルを報告し、クイックフィックスを使用して除去するよう提案します。 これは、言語レベルを下げる必要がある場合に役立つ可能性があります。 クイックフィックスは数値リテラルからアンダースコアを除去します。 たとえば、'1_000_000' は '1000000' に変換されます。 アンダースコアを含む数値リテラルは Java 7 で登場しました。 このインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。 2020.2 の新機能です",
                  "markdown": "アンダースコアを含む数値リテラルを報告し、クイックフィックスを使用して除去するよう提案します。 これは、言語レベルを下げる必要がある場合に役立つ可能性があります。\n\nクイックフィックスは数値リテラルからアンダースコアを除去します。 たとえば、`1_000_000` は `1000000` に変換されます。\n\n\n*アンダースコアを含む数値リテラル*は Java 7 で登場しました。\nこのインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。\n\n2020.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveLiteralUnderscores",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegatedEqualityExpression",
                "shortDescription": {
                  "text": "否定された等式"
                },
                "fullDescription": {
                  "text": "前置式で否定されている等式を報告します。 このような式は、'!=' 演算子を使用して単純化できます。 例: '!(i == 1)' クイックフィックス適用後: 'i != 1'",
                  "markdown": "前置式で否定されている等式を報告します。\n\nこのような式は、`!=` 演算子を使用して単純化できます。\n\n例:\n\n\n      !(i == 1)\n\nクイックフィックス適用後:\n\n\n      i != 1\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NegatedEqualityExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MathRandomCastToInt",
                "shortDescription": {
                  "text": "'Math.random()' を 'int' にキャスト"
                },
                "fullDescription": {
                  "text": "即座に 'int' にキャストされている 'Math.random()' の呼び出しを報告します。 '0.0' (最小値) と '1.0' (最大値) の間の 'double' は、'int' にキャストすると常にゼロに切り捨てられます。 このような値は 'int' にキャストする前に何らかの係数を掛けて、ゼロ (最小値) と乗算係数 (最大値) の間の値を取得する必要があります。 'java.util.Random' の 'nextInt()' メソッドを使用する方法でも解決できます。 例: 'int r = (int)Math.random() * 10;' クイックフィックス適用後: 'int r = (int)(Math.random() * 10);'",
                  "markdown": "即座に `int` にキャストされている `Math.random()` の呼び出しを報告します。\n\n`0.0` (最小値) と `1.0` (最大値) の間の `double` は、`int` にキャストすると常にゼロに切り捨てられます。 このような値は `int` にキャストする前に何らかの係数を掛けて、ゼロ (最小値) と乗算係数 (最大値) の間の値を取得する必要があります。\n`java.util.Random` の `nextInt()` メソッドを使用する方法でも解決できます。\n\n**例:**\n\n      int r = (int)Math.random() * 10;\n\nクイックフィックス適用後:\n\n      int r = (int)(Math.random() * 10);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MathRandomCastToInt",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DoubleBraceInitialization",
                "shortDescription": {
                  "text": "二重波括弧の初期化"
                },
                "fullDescription": {
                  "text": "二重波括弧の初期化 を報告します。 二重波括弧の初期化では追加のクラスをロードする必要があるため、通常の初期化に比べてパフォーマンスが悪化します。 同様に、'equals()' メソッドがサブクラスをパラメーターとして受け入れない場合、'equals()' 比較で失敗する可能性があります。 非 static のコンテキストで二重波括弧を使用して初期化すると、メモリリークが発生する場合があります。 Java 18 以前の javac でコンパイルすると、外側のオブジェクトを参照する匿名クラスが定義されるのがその原因です。 また、Java 9 より古いバージョンでは二重波括弧の初期化をダイヤモンド演算子と組み合わせることはできませんでした。匿名クラスと互換性がなかったためです。 例: 'List<Integer> list = new ArrayList<>() {{\n    add(1);\n    add(2);\n  }};' クイックフィックス適用後: 'List<Integer> list = new ArrayList<>();\n  list.add(1);\n  list.add(2);'",
                  "markdown": "[二重波括弧の初期化](https://www.c2.com/cgi/wiki?DoubleBraceInitialization) を報告します。\n\n二重波括弧の初期化では追加のクラスをロードする必要があるため、通常の初期化に比べてパフォーマンスが悪化します。\n\n同様に、`equals()` メソッドがサブクラスをパラメーターとして受け入れない場合、`equals()` 比較で失敗する可能性があります。\n\n非 static のコンテキストで二重波括弧を使用して初期化すると、メモリリークが発生する場合があります。 Java 18 以前の javac でコンパイルすると、外側のオブジェクトを参照する匿名クラスが定義されるのがその原因です。\n\nまた、Java 9 より古いバージョンでは二重波括弧の初期化をダイヤモンド演算子と組み合わせることはできませんでした。匿名クラスと互換性がなかったためです。\n\n**例:**\n\n\n      List<Integer> list = new ArrayList<>() {{\n        add(1);\n        add(2);\n      }};\n\nクイックフィックス適用後:\n\n\n      List<Integer> list = new ArrayList<>();\n      list.add(1);\n      list.add(2);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DoubleBraceInitialization",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初期化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "unused",
                "shortDescription": {
                  "text": "未使用の宣言"
                },
                "fullDescription": {
                  "text": "使用されていない、またはエントリポイントから到達不能なクラス、メソッド、またはフィールドを報告します。 エントリポイントにできるのは、main メソッド、テスト、指定したスコープ外のクラス、'module-info.java' からアクセス可能なクラスなどです。 名前のパターンまたはアノテーションを使用すると、カスタムのエントリポイントを構成できます。 例: 'public class Department {\n    private Organization myOrganization;\n  }' この例では、'Department' は 'Organization' を明示的に参照していますが、'Department' クラス自体が未使用の場合は両方のクラスがインスペクションによって報告されます。 このインスペクションは、所属するメソッドとすべてのメソッド実装/オーバーライド先で使用されていないパラメーターに加えて、宣言されているものの使用されていないローカル変数も報告します。 注意: 未使用のメンバーには、エディターのコードハイライトで報告されないものもあります。 パフォーマンス上の理由により、非 private メンバーは、その名前がプロジェクトでほぼ使用されていない場合に限ってチェックされます。 すべての結果を表示するには、メインメニューから「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」を選択してインスペクションを実行します。 報告するメンバーを構成するには、以下の可視性設定を使用します。 たとえば、'private' メソッドのみを報告するよう構成すると 'private' 内部クラスの 'public' メソッドは報告されますが、トップレベルクラスの 'protected' メソッドは無視されます。 インスペクションの実行中に評価すべきエントリポイントを構成するには、「エントリポイント」タブを使用します。 インスペクションの結果が出た時点でエントリポイントを手動で追加することも可能です。 コードでサポート対象外のフレームワークを使用している場合、次のような複数のオプションを使用できます。 フレームワークがアノテーションに依存する場合は、「アノテーション...」ボタンを使用してフレームワークのアノテーションを構成してください。 フレームワークがアノテーションに依存しない場合は、フレームワークが期待するクラス名のパターンを構成してみてください。 これにより、フレームワーク内部によりアクセス可能なアノテーション付きのコードは、使用済みとして扱われます。",
                  "markdown": "使用されていない、またはエントリポイントから到達不能なクラス、メソッド、またはフィールドを報告します。\n\nエントリポイントにできるのは、main メソッド、テスト、指定したスコープ外のクラス、`module-info.java` からアクセス可能なクラスなどです。 名前のパターンまたはアノテーションを使用すると、カスタムのエントリポイントを構成できます。\n\n**例:**\n\n\n      public class Department {\n        private Organization myOrganization;\n      }\n\nこの例では、`Department` は `Organization` を明示的に参照していますが、`Department` クラス自体が未使用の場合は両方のクラスがインスペクションによって報告されます。\n\n\nこのインスペクションは、所属するメソッドとすべてのメソッド実装/オーバーライド先で使用されていないパラメーターに加えて、宣言されているものの使用されていないローカル変数も報告します。\n\n\n**注意:** 未使用のメンバーには、エディターのコードハイライトで報告されないものもあります。 パフォーマンス上の理由により、非 private メンバーは、その名前がプロジェクトでほぼ使用されていない場合に限ってチェックされます。\nすべての結果を表示するには、メインメニューから「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」を選択してインスペクションを実行します。\n\n報告するメンバーを構成するには、以下の可視性設定を使用します。 たとえば、`private` メソッドのみを報告するよう構成すると `private` 内部クラスの `public` メソッドは報告されますが、トップレベルクラスの `protected` メソッドは無視されます。\n\n\nインスペクションの実行中に評価すべきエントリポイントを構成するには、「**エントリポイント**」タブを使用します。\n\nインスペクションの結果が出た時点でエントリポイントを手動で追加することも可能です。\n\nコードでサポート対象外のフレームワークを使用している場合、次のような複数のオプションを使用できます。\n\n* フレームワークがアノテーションに依存する場合は、「**アノテーション...**」ボタンを使用してフレームワークのアノテーションを構成してください。\n* フレームワークがアノテーションに依存しない場合は、フレームワークが期待するクラス名のパターンを構成してみてください。\n\nこれにより、フレームワーク内部によりアクセス可能なアノテーション付きのコードは、使用済みとして扱われます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "unused",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationInLoops",
                "shortDescription": {
                  "text": "ループ内の文字列連結"
                },
                "fullDescription": {
                  "text": "ループ内の文字列連結を報告します。 ループでは文字列連結のたびに文字列全体がコピーされるため、通常は 'StringBuilder.append()' または 'StringBuffer.append()' の明示的な呼び出しに置換することをお勧めします。 例: 'String str = \"\";\n  for(int i=0; i<10; i++) {\n    str += i;\n  }' クイックフィックス適用後: 'String str = \"\";\n  StringBuilder strBuilder = new StringBuilder(str);\n  for(int i = 0; i<10; i++) {\n    strBuilder.append(i);\n  }\n  str = strBuilder.toString();' このクイックフィックスを使用すると、'String' 変数を 'StringBuilder' に変換したり、新しい 'StringBuilder' を導入したりできる場合があります。 置換によってセマンティクスが変更される可能性があるため、元のコードが 'null' 値を特別扱いしている場合は注意してください。 'null' 値が使用される可能性がある場合、必要な null チェックを生成する null セーフな修正をお勧めします。 また、自動置換によって常にパフォーマンスが向上するとは限りません。",
                  "markdown": "ループ内の文字列連結を報告します。\n\n\nループでは文字列連結のたびに文字列全体がコピーされるため、通常は `StringBuilder.append()` または `StringBuffer.append()` の明示的な呼び出しに置換することをお勧めします。\n\n**例:**\n\n\n      String str = \"\";\n      for(int i=0; i<10; i++) {\n        str += i;\n      }\n\nクイックフィックス適用後:\n\n\n      String str = \"\";\n      StringBuilder strBuilder = new StringBuilder(str);\n      for(int i = 0; i<10; i++) {\n        strBuilder.append(i);\n      }\n      str = strBuilder.toString();\n\n\nこのクイックフィックスを使用すると、`String` 変数を `StringBuilder` に変換したり、新しい `StringBuilder` を導入したりできる場合があります。 置換によってセマンティクスが変更される可能性があるため、元のコードが `null` 値を特別扱いしている場合は注意してください。 `null` 値が使用される可能性がある場合、必要な null チェックを生成する null セーフな修正をお勧めします。 また、自動置換によって常にパフォーマンスが向上するとは限りません。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneableClassInSecureContext",
                "shortDescription": {
                  "text": "セキュリティに考慮が必要な Cloneable クラス"
                },
                "fullDescription": {
                  "text": "クローンされる可能性があるクラスを報告します。 'Cloneable' インターフェースをサポートし、その 'clone()' メソッドが即座にエラーをスローするように定義されていないクラスは、クローンされる可能性があります。 Cloneable クラスは、安全に使用することを目的としたコードでは危険な場合があります。 例: 'class SecureBean implements Cloneable {}' クイックフィックス適用後: 'class SecureBean {}' クラスが既存の Cloneable クラスを拡張しているか、Cloneable インターフェースを実装している場合、クイックフィックス適用後のコードは次のようになります。 'class SecureBean extends ParentBean {\n    @Override\n    protected SecureBean clone() throws CloneNotSupportedException {\n        throw new CloneNotSupportedException();\n    }\n}'",
                  "markdown": "クローンされる可能性があるクラスを報告します。\n\n\n`Cloneable` インターフェースをサポートし、その `clone()` メソッドが即座にエラーをスローするように定義されていないクラスは、クローンされる可能性があります。 Cloneable クラスは、安全に使用することを目的としたコードでは危険な場合があります。\n\n**例:**\n`class SecureBean implements Cloneable {}`\n\nクイックフィックス適用後:\n`class SecureBean {}`\n\n\nクラスが既存の Cloneable クラスを拡張しているか、Cloneable インターフェースを実装している場合、クイックフィックス適用後のコードは次のようになります。\n\n    class SecureBean extends ParentBean {\n        @Override\n        protected SecureBean clone() throws CloneNotSupportedException {\n            throw new CloneNotSupportedException();\n        }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneableClassInSecureContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InconsistentTextBlockIndent",
                "shortDescription": {
                  "text": "テキストブロック内の空白インデントに一貫性がありません"
                },
                "fullDescription": {
                  "text": "スペースとタブの両方を使用することが想定されているテキストブロックを報告します。 テキストブロックの処理ではスペースとタブは同じように扱われるため、このような場合は予期せぬ結果が生じます。 以下の例では、スぺ―スとタブをそれぞれ '·' と '␉' として視覚的に表現しています。また、エディターではタブは 4 つのスペースに相当します。 例: 'String colors = \"\"\"\n········red\n␉   ␉   green\n········blue\"\"\";' このような文字列を画面に出力すると、結果は以下のようになります。 '······red\ngreen\n······blue' コンパイラーによって各行の先頭から同じ量のスペースまたはタブが除去された後、一部の行の先頭にスペースが残ります。 2021.1 の新機能です このインスペクションは Java 15 以降で使用できる Java の機能 'テキストブロックリテラル' に依存しています。",
                  "markdown": "スペースとタブの両方を使用することが想定されているテキストブロックを報告します。 テキストブロックの処理ではスペースとタブは同じように扱われるため、このような場合は予期せぬ結果が生じます。\n\n以下の例では、スぺ―スとタブをそれぞれ `·` と `␉` として視覚的に表現しています。また、エディターではタブは 4 つのスペースに相当します。\n\n**例:**\n\n\n    String colors = \"\"\"\n    ········red\n    ␉   ␉   green\n    ········blue\"\"\";\n\nこのような文字列を画面に出力すると、結果は以下のようになります。\n\n\n    ······red\n    green\n    ······blue\n\nコンパイラーによって各行の先頭から同じ量のスペースまたはタブが除去された後、一部の行の先頭にスペースが残ります。\n\n2021.1 の新機能です\n\nこのインスペクションは Java 15 以降で使用できる Java の機能 'テキストブロックリテラル' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InconsistentTextBlockIndent",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousGetterSetter",
                "shortDescription": {
                  "text": "疑わしい getter/setter"
                },
                "fullDescription": {
                  "text": "名前からは予想できないフィールドにアクセスしている getter または setter メソッドを報告します。 たとえば、'getY()' が 'x' フィールドを返す場合が挙げられます。 これは通常、コピーと貼り付けの問題である可能性があります。 例: 'class Point {\n    private int x;\n    private int y;\n\n    public void setX(int x) { // 警告: setter 'setX()' がフィールド 'y' に代入しています\n      this.y = x;\n    }\n\n    public int getY() { // 警告: getter 'getY()' がフィールド 'x' を返しています\n      return x;\n    }\n  }' クラスのフィールドの名前が getter または setter の名前と一致している状況を報告するには、下のチェックボックスを使用します。",
                  "markdown": "名前からは予想できないフィールドにアクセスしている getter または setter メソッドを報告します。 たとえば、`getY()` が `x` フィールドを返す場合が挙げられます。 これは通常、コピーと貼り付けの問題である可能性があります。\n\n**例:**\n\n    class Point {\n        private int x;\n        private int y;\n\n        public void setX(int x) { // 警告: setter 'setX()' がフィールド 'y' に代入しています\n          this.y = x;\n        }\n\n        public int getY() { // 警告: getter 'getY()' がフィールド 'x' を返しています\n          return x;\n        }\n      }\n\n\nクラスのフィールドの名前が getter または setter の名前と一致している状況を報告するには、下のチェックボックスを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousGetterSetter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 関連の問題",
                      "index": 34,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedStringCase",
                "shortDescription": {
                  "text": "'String' 操作での大文字と小文字の不一致"
                },
                "fullDescription": {
                  "text": "小文字が大文字のみ (または大文字が小文字のみ) を含む文字列の中で検索されているため、常に同じ値 ('-1' または 'false') を返す 'String' メソッドの呼び出しを報告します。 報告されるメソッドには、'equals'、'startsWith'、'endsWith'、'contains'、'indexOf'、'lastIndexOf' などが含まれます。 例:   if (columnName.toLowerCase().equals(\"ID\")) {...}\n 2019.3 の新機能です",
                  "markdown": "小文字が大文字のみ (または大文字が小文字のみ) を含む文字列の中で検索されているため、常に同じ値 (`-1` または `false`) を返す `String` メソッドの呼び出しを報告します。\n\n報告されるメソッドには、`equals`、`startsWith`、`endsWith`、`contains`、`indexOf`、`lastIndexOf` などが含まれます。\n\n**例:**\n\n```\n  if (columnName.toLowerCase().equals(\"ID\")) {...}\n```\n\n2019.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedStringCase",
                    "cweIds": [
                      597
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DoubleNegation",
                "shortDescription": {
                  "text": "二重否定"
                },
                "fullDescription": {
                  "text": "単純化できる二重否定を報告します。 例: 'if (!!functionCall()) {}' クイックフィックス適用後: 'if (functionCall()) {}' 例: 'if (!(a != b)) {}' クイックフィックス適用後: 'if (a == b) {}'",
                  "markdown": "単純化できる二重否定を報告します。\n\n例:\n\n\n      if (!!functionCall()) {}\n\nクイックフィックス適用後:\n\n\n      if (functionCall()) {}\n\n例:\n\n\n      if (!(a != b)) {}\n\nクイックフィックス適用後:\n\n\n      if (a == b) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DoubleNegation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertionCanBeIf",
                "shortDescription": {
                  "text": "アサーションは 'if' ステートメントに置換できます"
                },
                "fullDescription": {
                  "text": "'assert' ステートメントを報告し、'java.lang.AssertionError' をスローする 'if' ステートメントに置換することを提案します。 例: 'assert param != null;' クイックフィックス適用後: 'if (param == null) throw new AssertionError();' このインスペクションは Java 1.4 以降で使用できる Java の機能 'アサーション' に依存しています。",
                  "markdown": "`assert` ステートメントを報告し、`java.lang.AssertionError` をスローする `if` ステートメントに置換することを提案します。\n\n例:\n\n\n      assert param != null;\n\nクイックフィックス適用後:\n\n\n      if (param == null) throw new AssertionError();\n\nこのインスペクションは Java 1.4 以降で使用できる Java の機能 'アサーション' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AssertionCanBeIf",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToNull",
                "shortDescription": {
                  "text": "'null' の代入"
                },
                "fullDescription": {
                  "text": "宣言の外で 'null' に代入されている変数を報告します。 Java で 'null' を使用する主な目的は、初期化されていない参照変数を表すことです。 まれなケースですが、変数を明示的に 'null' に代入するとガベージコレクションに役に立つこともあります。 ただし、欠落、未指定、または無効な値や見つからない要素を表すのに 'null' を使用するのは良いプラクティスとは言えず、コードで 'NullPointerExceptions' が発生しやすくなる可能性があります。 代わりに、意図したセマンティクスを持つ番兵オブジェクトを定義することを検討するか、'Optional' のようなライブラリ型を使用して値の欠如を表してください。 例: 'Integer convert(String s) {\n    Integer value;\n    try {\n      value = Integer.parseInt(s);\n    } catch (NumberFormatException e) {\n      // 警告: null が '無効な値' を表すのに使用されています\n      value = null;\n    }\n    return value;\n  }' フィールドへの代入を無視するには、「フィールドへの代入を無視する」オプションを使用します。",
                  "markdown": "宣言の外で ` null ` に代入されている変数を報告します。\n\nJava で `null` を使用する主な目的は、初期化されていない参照変数を表すことです。 まれなケースですが、変数を明示的に `null` に代入するとガベージコレクションに役に立つこともあります。 ただし、欠落、未指定、または無効な値や見つからない要素を表すのに `null` を使用するのは良いプラクティスとは言えず、コードで `NullPointerExceptions` が発生しやすくなる可能性があります。\n代わりに、意図したセマンティクスを持つ番兵オブジェクトを定義することを検討するか、`Optional` のようなライブラリ型を使用して値の欠如を表してください。\n\n**例:**\n\n\n      Integer convert(String s) {\n        Integer value;\n        try {\n          value = Integer.parseInt(s);\n        } catch (NumberFormatException e) {\n          // 警告: null が '無効な値' を表すのに使用されています\n          value = null;\n        }\n        return value;\n      }\n\n\nフィールドへの代入を無視するには、「**フィールドへの代入を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToNull",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代入関連の問題",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageWithTooFewClasses",
                "shortDescription": {
                  "text": "クラスが少なすぎるパッケージ"
                },
                "fullDescription": {
                  "text": "含んでいるクラスの数が指定された最小値よりも少ないパッケージを報告します。 サブパッケージを含むパッケージは報告されません。 パッケージが小さすぎる場合、デザインが細分化されている可能性があります。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。 パッケージで許容されるクラス数の最小値を指定するには、「最小クラス数」フィールドを使用します。",
                  "markdown": "含んでいるクラスの数が指定された最小値よりも少ないパッケージを報告します。\n\nサブパッケージを含むパッケージは報告されません。 パッケージが小さすぎる場合、デザインが細分化されている可能性があります。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。\n\nパッケージで許容されるクラス数の最小値を指定するには、「**最小クラス数**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageWithTooFewClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パッケージ関連の問題",
                      "index": 37,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceOnLiteralHasNoEffect",
                "shortDescription": {
                  "text": "置換操作は無効です"
                },
                "fullDescription": {
                  "text": "無効な 'String' のメソッド 'replace()'、'replaceAll()' もしくは 'replaceFirst()' への呼び出しを報告します。 修飾子と検索文字列がコンパイル時定数であり、検索文字列が修飾子に見つからない場合、このような呼び出しは確実に無効です。 このような呼び出しは冗長であり、誤りの可能性があります。 例: '// 置換は何もしません\n  \"hello\".replace(\"$value$\", value);' 2022.1 の新機能です",
                  "markdown": "無効な `String` のメソッド `replace()`、`replaceAll()` もしくは `replaceFirst()` への呼び出しを報告します。 修飾子と検索文字列がコンパイル時定数であり、検索文字列が修飾子に見つからない場合、このような呼び出しは確実に無効です。 このような呼び出しは冗長であり、誤りの可能性があります。\n\n**例:**\n\n\n      // 置換は何もしません\n      \"hello\".replace(\"$value$\", value);\n\n2022.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceOnLiteralHasNoEffect",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitCalledOnCondition",
                "shortDescription": {
                  "text": "'java.util.concurrent.locks.Condition' オブジェクトでの 'wait()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'java.util.concurrent.locks.Condition' オブジェクトに対して 'wait()' が呼び出されていることを報告します。 このような呼び出しはプログラミングの誤りであり、代わりに 'await()' メソッドのバリアントが意図されていた可能性があります。 例: 'void acquire(Condition released) throws InterruptedException {\n    while (acquired) {\n      released.wait();\n    }\n  }' 次のようなコードが適切です: 'void acquire(Condition released) throws InterruptedException {\n    while (acquired) {\n      released.await();\n    }\n  }'",
                  "markdown": "`java.util.concurrent.locks.Condition` オブジェクトに対して `wait()` が呼び出されていることを報告します。 このような呼び出しはプログラミングの誤りであり、代わりに `await()` メソッドのバリアントが意図されていた可能性があります。\n\n**例:**\n\n\n      void acquire(Condition released) throws InterruptedException {\n        while (acquired) {\n          released.wait();\n        }\n      }\n\n次のようなコードが適切です:\n\n\n      void acquire(Condition released) throws InterruptedException {\n        while (acquired) {\n          released.await();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitCalledOnCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SingleClassImport",
                "shortDescription": {
                  "text": "単一クラスのインポート"
                },
                "fullDescription": {
                  "text": "(パッケージ全体ではなく) 単一のクラスをインポートしている 'import' ステートメントを報告します。 一部のコーディング標準では、このような 'import' ステートメントは禁止されています。 「インポートの最適化」コマンドを使用すると、このようなステートメントを検出および修正するように IntelliJ IDEA を構成できます。 「設定 | エディター | コードスタイル | Java | インポート」に移動し、「シングルクラスインポートを使用する」チェックボックスをオフにします。 そのため、このインスペクションは変更を意図していないコードベースについて主にオフラインで報告させる目的で主に役立ちます。",
                  "markdown": "(パッケージ全体ではなく) 単一のクラスをインポートしている `import` ステートメントを報告します。\n\n一部のコーディング標準では、このような `import` ステートメントは禁止されています。\n\n\n「**インポートの最適化** 」コマンドを使用すると、このようなステートメントを検出および修正するように IntelliJ IDEA を構成できます。 「[設定 \\| エディター \\| コードスタイル \\| Java \\| インポート](settings://preferences.sourceCode.Java?Use%20single%20class%20import)」に移動し、「**シングルクラスインポートを使用する**」チェックボックスをオフにします。 そのため、このインスペクションは変更を意図していないコードベースについて主にオフラインで報告させる目的で主に役立ちます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SingleClassImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/インポート",
                      "index": 23,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSynchronizedMethodOverridesSynchronizedMethod",
                "shortDescription": {
                  "text": "非同期メソッドは 'synchronized' メソッドをオーバーライドします"
                },
                "fullDescription": {
                  "text": "'synchronized' メソッドをオーバーライドしている非 'synchronized' メソッドを報告します。 スーパークラスのメソッドが 'synchronized' と宣言されている場合、オーバーライドされたメソッドは自動的に同期されません。 これにより、サブクラスを使用する場合に予期しない競合状態が発生する可能性があります。 例: 'class Super {\n    synchronized void process() {}\n  }\n  class Sub extends Super {\n    // 非 synchronized のメソッド 'process()' が synchronized メソッドをオーバーライドしています\n    void process() {}\n  }'",
                  "markdown": "`synchronized` メソッドをオーバーライドしている非 `synchronized` メソッドを報告します。\n\n\nスーパークラスのメソッドが `synchronized` と宣言されている場合、オーバーライドされたメソッドは自動的に同期されません。 これにより、サブクラスを使用する場合に予期しない競合状態が発生する可能性があります。\n\n**例:**\n\n\n      class Super {\n        synchronized void process() {}\n      }\n      class Sub extends Super {\n        // 非 synchronized のメソッド 'process()' が synchronized メソッドをオーバーライドしています\n        void process() {}\n      }  \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSynchronizedMethodOverridesSynchronizedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TooBroadCatch",
                "shortDescription": {
                  "text": "広すぎる 'catch' ブロック"
                },
                "fullDescription": {
                  "text": "'catch' ブロックが対応する 'try' ブロックによってスローされる例外よりも一般的なパラメーターを含んでいることを報告します。 例: 'try  {\n    File file = new File(pathToFile);\n    return file.getAbsolutePath();\n  } catch (Exception ex) { // 警告: 'Exception' の 'catch' の範囲が広すぎるため、例外 'RuntimeException' がマスクされています\n    return defaultFilePath;\n  }' クイックフィックス適用後: 'try  {\n    File file = new File(pathToFile);\n    return file.getAbsolutePath();\n  } catch (RuntimeException ex) {\n    return defaultFilePath;\n  }' インスペクションの構成: このインスペクションで最も一般的な例外についてのみ警告するには、「RuntimeException、Exception、Error または Throwable についてのみ警告する」オプションを使用します。 他の例外を隠しているものの、なおスローされる可能性があるため、厳密には広すぎない例外を無視するには、「他の例外を隠しているが、それ自体がスローされる例外を無視する」オプションを使用します。",
                  "markdown": "`catch` ブロックが対応する `try` ブロックによってスローされる例外よりも一般的なパラメーターを含んでいることを報告します。\n\n**例:**\n\n\n      try  {\n        File file = new File(pathToFile);\n        return file.getAbsolutePath();\n      } catch (Exception ex) { // 警告: 'Exception' の 'catch' の範囲が広すぎるため、例外 'RuntimeException' がマスクされています\n        return defaultFilePath;\n      }\n\nクイックフィックス適用後:\n\n\n      try  {\n        File file = new File(pathToFile);\n        return file.getAbsolutePath();\n      } catch (RuntimeException ex) {\n        return defaultFilePath;\n      }\n\nインスペクションの構成:\n\n* このインスペクションで最も一般的な例外についてのみ警告するには、「**RuntimeException、Exception、Error または Throwable についてのみ警告する**」オプションを使用します。\n* 他の例外を隠しているものの、なおスローされる可能性があるため、厳密には広すぎない例外を無視するには、「**他の例外を隠しているが、それ自体がスローされる例外を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyBroadCatchBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProtectedMemberInFinalClass",
                "shortDescription": {
                  "text": "'final' クラスの 'protected' メンバー"
                },
                "fullDescription": {
                  "text": "'final' クラスにある 'protected' メンバーを報告します。 'final' クラスは継承できないため、メソッドを 'protected' にすると混乱を招く可能性があります。 このようなメンバーは、代わりに 'private' またはパッケージ可視で宣言するほうが賢明です。 例: 'record Bar(int a, int b) {\n  protected int sum() { \n     return a + b;\n  }\n}'\n クイックフィックス適用後: 'record Bar(int a, int b) {\n  int sum() { \n     return a + b;\n  }\n}' 上記の例のように、クラスは明示的または暗黙的に 'final' にすることができます。",
                  "markdown": "`final` クラスにある `protected` メンバーを報告します。\n\n`final` クラスは継承できないため、メソッドを `protected` にすると混乱を招く可能性があります。 このようなメンバーは、代わりに `private` またはパッケージ可視で宣言するほうが賢明です。\n\n**例:**\n\n    record Bar(int a, int b) {\n      protected int sum() { \n         return a + b;\n      }\n    }\n\nクイックフィックス適用後:\n\n    record Bar(int a, int b) {\n      int sum() { \n         return a + b;\n      }\n    }\n\n上記の例のように、クラスは明示的または暗黙的に `final` にすることができます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProtectedMemberInFinalClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggingConditionDisagreesWithLogLevelStatement",
                "shortDescription": {
                  "text": "ロギング呼び出しと一致しないログ条件"
                },
                "fullDescription": {
                  "text": "'if' ステートメントにあるログ出力の有効可否判定条件で、含んでいるロギング呼び出しのログレベルと一致していないものを報告します。 例: 'if (LOG.isTraceEnabled()) {\n    // デバッグレベルはログに記録されますが、トレースレベルではチェックされます\n    LOG.debug(\"some log message\");\n  }' このインスペクションは、java.util.logging、Log4j、Log4j2、Apache Commons Logging、SLF4J ロギングフレームワークを認識します。",
                  "markdown": "`if` ステートメントにある*ログ出力の有効可否判定* 条件で、含んでいるロギング呼び出しのログレベルと一致していないものを報告します。\n\n\n例:\n\n\n      if (LOG.isTraceEnabled()) {\n        // デバッグレベルはログに記録されますが、トレースレベルではチェックされます\n        LOG.debug(\"some log message\");\n      }\n\nこのインスペクションは、*java.util.logging* 、*Log4j* 、*Log4j2* 、*Apache Commons Logging* 、*SLF4J* ロギングフレームワークを認識します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoggingConditionDisagreesWithLogLevelStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語/ログ関連",
                      "index": 45,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BadOddness",
                "shortDescription": {
                  "text": "疑わしい奇数チェック"
                },
                "fullDescription": {
                  "text": "'x % 2 == 1' のような形式の奇数/偶数チェックを報告します。 このようなチェックは、負の奇数値と共に使用した場合に失敗します。 'x % 2 != 0' または '(x & 1) == 1' を代わりに使用することを検討してください。",
                  "markdown": "`x % 2 == 1` のような形式の奇数/偶数チェックを報告します。 このようなチェックは、負の奇数値と共に使用した場合に失敗します。 `x % 2 != 0` または `(x & 1) == 1` を代わりに使用することを検討してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BadOddness",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DanglingJavadoc",
                "shortDescription": {
                  "text": "不完全な Javadoc コメント"
                },
                "fullDescription": {
                  "text": "どのクラス、メソッド、フィールドにも属していない Javadoc のコメントを報告します。 Javadoc ツールは不完全な Javadoc コメントを無視し、生成する HTMLドキュメントにそのようなコメントを含めません。 例: 'class A {\n    /**\n     * 不完全なコメント\n     */\n    /**\n     * メソッド javadoc\n     */\n     public void m(){}\n  }' このようなコメントを完全に削除するか、ブロックコメントに変換するクイックフィックスを使用できます。 クイックフィックス適用後: 'class A {\n    /*\n      不完全なコメント\n    */\n    /**\n     * メソッド javadoc\n     */\n    public void m(){}\n  }' Java ファイルの最初にあるコメントを無視するには、「JavaDoc 形式のファイルヘッダーコメントを無視する」オプションを使用します。 これらは通常、コピーライトメッセージです。",
                  "markdown": "どのクラス、メソッド、フィールドにも属していない Javadoc のコメントを報告します。 Javadoc ツールは不完全な Javadoc コメントを無視し、生成する HTMLドキュメントにそのようなコメントを含めません。\n\n**例:**\n\n\n      class A {\n        /**\n         * 不完全なコメント\n         */\n        /**\n         * メソッド javadoc\n         */\n         public void m(){}\n      }\n\nこのようなコメントを完全に削除するか、ブロックコメントに変換するクイックフィックスを使用できます。 クイックフィックス適用後:\n\n\n      class A {\n        /*\n          不完全なコメント\n        */\n        /**\n         * メソッド javadoc\n         */\n        public void m(){}\n      }\n\nJava ファイルの最初にあるコメントを無視するには、「**JavaDoc 形式のファイルヘッダーコメントを無視する**」オプションを使用します。\nこれらは通常、コピーライトメッセージです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DanglingJavadoc",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HibernateResource",
                "shortDescription": {
                  "text": "安全に閉じられていない Hibernate リソース"
                },
                "fullDescription": {
                  "text": "'openSession()' メソッドの呼び出しで、返される 'org.hibernate.Session' リソースが安全に閉じられていないものを報告します。 デフォルトでは、このインスペクションは名前に 'close' または 'cleanup' を含む任意のメソッドでリソースを閉じることができると想定しています。 例: 'void doHibernateQuery(SessionFactory factory) {\n    Session session = factory.openSession(); //警告\n    session.createQuery(\"...\");\n  }' このインスペクションは、次のオプションを使用して構成できます。 'try' ブロック内で 'org.hibernate.Session' リソースを開くことを許可するかどうか。 この方法は 'try' ブロックの前でリソースを開く方法よりも冗長であるため、あまり望ましくありません。 リソースが引数として渡されている任意のメソッド呼び出しでリソースを閉じることができるかどうか。",
                  "markdown": "`openSession()` メソッドの呼び出しで、返される `org.hibernate.Session` リソースが安全に閉じられていないものを報告します。\n\n\nデフォルトでは、このインスペクションは名前に 'close' または 'cleanup' を含む任意のメソッドでリソースを閉じることができると想定しています。\n\n**例:**\n\n\n      void doHibernateQuery(SessionFactory factory) {\n        Session session = factory.openSession(); //警告\n        session.createQuery(\"...\");\n      }\n\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* `try` ブロック内で `org.hibernate.Session` リソースを開くことを許可するかどうか。 この方法は `try` ブロックの前でリソースを開く方法よりも冗長であるため、あまり望ましくありません。\n* リソースが引数として渡されている任意のメソッド呼び出しでリソースを閉じることができるかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HibernateResourceOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/リソース管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryInitCause",
                "shortDescription": {
                  "text": "'Throwable.initCause()' への不要な呼び出し"
                },
                "fullDescription": {
                  "text": "例外のコンストラクターも 'Throwable cause' 引数を取っている 'Throwable.initCause()' の呼び出しを報告します。 このような場合は 'initCause()' の呼び出しを除去し、その引数を例外のコンストラクターの呼び出しに追加できます。 例: 'try {\n      process();\n  }\n  catch (RuntimeException ex) {\n    RuntimeException wrapper = new RuntimeException(\"Error while processing\");\n    wrapper.initCause(ex); // 'Throwable.initCause()' の不要な呼び出し\n    throw wrapper;\n  }' コンストラクターにイベント引数を渡すためのクイックフィックスを使用できます。 クイックフィックス適用後: 'try {\n      process();\n  }\n  catch (RuntimeException ex) {\n    RuntimeException wrapper = new RuntimeException(\"Error while processing\", ex);\n    throw wrapper;\n  }'",
                  "markdown": "例外のコンストラクターも `Throwable cause` 引数を取っている `Throwable.initCause()` の呼び出しを報告します。\n\nこのような場合は `initCause()` の呼び出しを除去し、その引数を例外のコンストラクターの呼び出しに追加できます。\n\n**例:**\n\n\n      try {\n          process();\n      }\n      catch (RuntimeException ex) {\n        RuntimeException wrapper = new RuntimeException(\"Error while processing\");\n        wrapper.initCause(ex); // 'Throwable.initCause()' の不要な呼び出し\n        throw wrapper;\n      }\n\nコンストラクターにイベント引数を渡すためのクイックフィックスを使用できます。 クイックフィックス適用後:\n\n\n      try {\n          process();\n      }\n      catch (RuntimeException ex) {\n        RuntimeException wrapper = new RuntimeException(\"Error while processing\", ex);\n        throw wrapper;\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryInitCause",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparisonOfShortAndChar",
                "shortDescription": {
                  "text": "'short' と 'char' の値比較"
                },
                "fullDescription": {
                  "text": "'short' 値と 'char' 値のイコール比較を報告します。 このような比較はバグの検出を困難にします。なぜなら、両方の値が 2 バイト長であり、'short' 値は符号付き、'char' 値は符号なしだからです。 例: 'if (Character.MAX_VALUE == shortValue()) {} // true になることはありません'",
                  "markdown": "`short` 値と `char` 値のイコール比較を報告します。\n\nこのような比較はバグの検出を困難にします。なぜなら、両方の値が 2 バイト長であり、`short` 値は符号付き、`char` 値は符号なしだからです。\n\n**例:**\n\n\n    if (Character.MAX_VALUE == shortValue()) {} // true になることはありません\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparisonOfShortAndChar",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayCanBeReplacedWithEnumValues",
                "shortDescription": {
                  "text": "列挙値に置換できる配列"
                },
                "fullDescription": {
                  "text": "列挙型の定数で構成されている配列で、'EnumType.values()' の呼び出しに置換できるものを報告します。 通常、このような列挙型を更新する際には配列も更新する必要があります。 しかし、'EnumType.values()' を代わりに使用する場合は変更を加える必要はありません。 例: 'enum States {\n     NOT_RUN, IN_PROGRESS, FINISHED;\n  }\n  \n  handleStates(new States[] {NOT_RUN, IN_PROGRESS, FINISHED});' クイックフィックス適用後: 'handleStates(States.values());' 2019.1 の新機能です",
                  "markdown": "列挙型の定数で構成されている配列で、`EnumType.values()` の呼び出しに置換できるものを報告します。\n\n通常、このような列挙型を更新する際には配列も更新する必要があります。 しかし、`EnumType.values()` を代わりに使用する場合は変更を加える必要はありません。\n\n例:\n\n\n      enum States {\n         NOT_RUN, IN_PROGRESS, FINISHED;\n      }\n      \n      handleStates(new States[] {NOT_RUN, IN_PROGRESS, FINISHED});\n\nクイックフィックス適用後:\n\n\n      handleStates(States.values());\n\n2019.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ArrayCanBeReplacedWithEnumValues",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemOutErr",
                "shortDescription": {
                  "text": "'System.out' または 'System.err' の使用"
                },
                "fullDescription": {
                  "text": "'System.out' または 'System.err' の使用箇所を報告します。 このようなステートメントは一時的なデバッグによく使用されるため、プロダクションコードから除去するか、より堅牢なログ機能に置換する必要があります。 提供されるクイックフィックスは SLF4J と Log4j 2 をサポートしています。 'System.out' と 'System.err' の呼び出しをログ呼び出しに置換します 例: 'public static void test(Object o) {\n    System.out.println(\"Test: \"+ o);\n  }' クイックフィックス適用後: 'private static final Logger log = LoggerFactory.getLogger(Test.class);\n\n  public static void test(Object o) {\n      log.info(\"Test: {}\", o);;\n  }' 'System.err' 呼び出しのメッセージをログに記録するために使用されるメソッドを指定するには、「'System.err' 用のログメソッド」オプションを使用します。 'System.out' 呼び出しのメッセージをログに記録するために使用されるメソッドを指定するには、「'System.out' 用のログメソッド」オプションを使用します。",
                  "markdown": "`System.out` または `System.err` の使用箇所を報告します。\n\nこのようなステートメントは一時的なデバッグによく使用されるため、プロダクションコードから除去するか、より堅牢なログ機能に置換する必要があります。\n\n提供されるクイックフィックスは **SLF4J** と **Log4j 2** をサポートしています。\n`System.out` と `System.err` の呼び出しをログ呼び出しに置換します\n\n**例:**\n\n\n      public static void test(Object o) {\n        System.out.println(\"Test: \"+ o);\n      }\n\nクイックフィックス適用後:\n\n\n      private static final Logger log = LoggerFactory.getLogger(Test.class);\n\n      public static void test(Object o) {\n          log.info(\"Test: {}\", o);;\n      }\n\n\n'System.err' 呼び出しのメッセージをログに記録するために使用されるメソッドを指定するには、「**'System.err' 用のログメソッド** 」オプションを使用します。\n'System.out' 呼び出しのメッセージをログに記録するために使用されるメソッドを指定するには、「**'System.out' 用のログメソッド**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UseOfSystemOutOrSystemErr",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コード成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitNotifyNotInSynchronizedContext",
                "shortDescription": {
                  "text": "同期コンテキストにない 'wait()' または 'notify()'"
                },
                "fullDescription": {
                  "text": "'wait()'、'notify()' 、'notifyAll()' の呼び出しのうち、対応する同期ステートメントまたは同期メソッド内で行われていないものを報告します。 あるオブジェクトに対してロックを保持せずにそのオブジェクトに対してこれらのメソッドを呼び出すと、'IllegalMonitorStateException' が発生します。 このようなコンストラクトは必ずしも間違いではありませんが、一度確認することをおすすめします。含んでいるメソッドが呼び出される前に必要なロックが取得される可能性があるためです。 例: 'class Sync {\n    private final Object lock = new Object();\n\n    void test() throws InterruptedException {\n      synchronized (this) {\n        lock.wait(); // 'lock.wait()' は 'lock' で同期されません\n      }\n    }\n  }'",
                  "markdown": "`wait()`、`notify()` 、`notifyAll()` の呼び出しのうち、対応する同期ステートメントまたは同期メソッド内で行われていないものを報告します。\n\n\nあるオブジェクトに対してロックを保持せずにそのオブジェクトに対してこれらのメソッドを呼び出すと、`IllegalMonitorStateException` が発生します。\nこのようなコンストラクトは必ずしも間違いではありませんが、一度確認することをおすすめします。含んでいるメソッドが呼び出される前に必要なロックが取得される可能性があるためです。\n\n**例:**\n\n\n      class Sync {\n        private final Object lock = new Object();\n\n        void test() throws InterruptedException {\n          synchronized (this) {\n            lock.wait(); // 'lock.wait()' は 'lock' で同期されません\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitNotifyWhileNotSynced",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DollarSignInName",
                "shortDescription": {
                  "text": "識別子に '$' の使用"
                },
                "fullDescription": {
                  "text": "名前にドル記号 ('$') を含む変数、メソッド、クラスを報告します。 このような名前は Java では有効ですが、生成された java コードの外部で使用することを強くお勧めします。 例: 'class SalaryIn${}' エディター内でのみ、名前の変更クイックフィックスが提案されます。",
                  "markdown": "名前にドル記号 (`$`) を含む変数、メソッド、クラスを報告します。 このような名前は Java では有効ですが、生成された java コードの外部で使用することを強くお勧めします。\n\n**例:**\n\n\n      class SalaryIn${}\n\nエディター内でのみ、名前の変更クイックフィックスが提案されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DollarSignInName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規約",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckedExceptionClass",
                "shortDescription": {
                  "text": "チェック例外クラス"
                },
                "fullDescription": {
                  "text": "チェック例外クラス (すなわち、'java.lang.RuntimeException' のサブクラスではない 'java.lang.Exception' のサブクラス) を報告します。 一部のコーディング標準は、ユーザー定義のチェック例外クラスを抑止します。 例: 'class IllegalMoveException extends Exception {}'",
                  "markdown": "チェック例外クラス (すなわち、`java.lang.RuntimeException` のサブクラスではない `java.lang.Exception` のサブクラス) を報告します。\n\n一部のコーディング標準は、ユーザー定義のチェック例外クラスを抑止します。\n\n**例:**\n\n\n      class IllegalMoveException extends Exception {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CheckedExceptionClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DynamicRegexReplaceableByCompiledPattern",
                "shortDescription": {
                  "text": "動的な正規表現はコンパイルされた 'Pattern' に置換できます"
                },
                "fullDescription": {
                  "text": "定数引数を使用した 'java.lang.String' の正規表現メソッド ('matches()' や 'split()' など) の呼び出しを報告します。 このような呼び出しは 'private static final Pattern' フィールドに置換し、正規表現を使用するたびにコンパイルする必要性をなくすことができます。 例: 'text.replaceAll(\"abc\", replacement);' クイックフィックス適用後: 'private static final Pattern ABC = Pattern.compile(\"abc\", Pattern.LITERAL);\n  ABC.matcher(text).replaceAll(Matcher.quoteReplacement(replacement));'",
                  "markdown": "定数引数を使用した `java.lang.String` の正規表現メソッド (`matches()` や `split()` など) の呼び出しを報告します。\n\n\nこのような呼び出しは `private static final Pattern` フィールドに置換し、正規表現を使用するたびにコンパイルする必要性をなくすことができます。\n\n**例:**\n\n\n      text.replaceAll(\"abc\", replacement);\n\nクイックフィックス適用後:\n\n\n      private static final Pattern ABC = Pattern.compile(\"abc\", Pattern.LITERAL);\n      ABC.matcher(text).replaceAll(Matcher.quoteReplacement(replacement));\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DynamicRegexReplaceableByCompiledPattern",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyInitializer",
                "shortDescription": {
                  "text": "空のクラスイニシャライザー"
                },
                "fullDescription": {
                  "text": "空のクラスイニシャライザーブロックを報告します。",
                  "markdown": "空のクラスイニシャライザーブロックを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyClassInitializer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableStoresNonSerializable",
                "shortDescription": {
                  "text": "暗黙的に非 'Serializable' オブジェクトを格納する 'Serializable' オブジェクト"
                },
                "fullDescription": {
                  "text": "'Serializable' ラムダ、ローカルおよび匿名クラスの外にあるローカルの非 'Serializable' 変数の参照を報告します。 ローカル変数が匿名クラスから参照される場合、変数の値はそのクラスの暗黙的なフィールドに格納されます。 ローカルクラスとラムダについても同様です。 変数が非 'Serializable' 型のものである場合、シリアル化は失敗します。 例: 'interface A extends Serializable {\n      abstract void foo();\n  }\n  class B {}\n  class C {\n      void foo() {\n          B b = new B();\n          A a = new A() {\n              @Override\n              public void foo() {\n                  System.out.println(b); // 警告\n              }\n          };\n      }\n  }'",
                  "markdown": "`Serializable` ラムダ、ローカルおよび匿名クラスの外にあるローカルの非 `Serializable` 変数の参照を報告します。\n\n\nローカル変数が匿名クラスから参照される場合、変数の値はそのクラスの暗黙的なフィールドに格納されます。 ローカルクラスとラムダについても同様です。 変数が非 `Serializable` 型のものである場合、シリアル化は失敗します。\n\n**例:**\n\n\n      interface A extends Serializable {\n          abstract void foo();\n      }\n      class B {}\n      class C {\n          void foo() {\n              B b = new B();\n              A a = new A() {\n                  @Override\n                  public void foo() {\n                      System.out.println(b); // 警告\n                  }\n              };\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableStoresNonSerializable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InsertLiteralUnderscores",
                "shortDescription": {
                  "text": "読み取り不能な数値リテラル"
                },
                "fullDescription": {
                  "text": "アンダースコアが使用されていない長い数値リテラルを報告し、アンダースコアを追加することを提案します。 このようなリテラルは、アンダースコアを使用すると読みやすくなります。 例: '1000000' クイックフィックス適用後: '1_000_000' このインスペクションは、プロジェクトまたはモジュールの言語レベルが 7 以上の場合にのみ報告します。 2020.2 の新機能です",
                  "markdown": "アンダースコアが使用されていない長い数値リテラルを報告し、アンダースコアを追加することを提案します。 このようなリテラルは、アンダースコアを使用すると読みやすくなります。\n\n例:\n\n\n      1000000\n\nクイックフィックス適用後:\n\n\n      1_000_000\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 7 以上の場合にのみ報告します。\n\n2020.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "InsertLiteralUnderscores",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryBreak",
                "shortDescription": {
                  "text": "不要な 'break' ステートメント"
                },
                "fullDescription": {
                  "text": "不要な 'break' ステートメントを報告します。 除去しても他のステートメントが実行されない 'break' ステートメントは不要です。 例: 'switch (e) {\n    case A -> {\n        System.out.println(\"A\");\n        break; // 'break' ステートメントが不要なことを報告します\n    }\n    default -> {\n        System.out.println(\"Default\");\n        break; // 'break' ステートメントが不要なことを報告します\n    }\n  }'",
                  "markdown": "不要な `break` ステートメントを報告します。\n\n除去しても他のステートメントが実行されない `break` ステートメントは不要です。\n\n**例:**\n\n\n      switch (e) {\n        case A -> {\n            System.out.println(\"A\");\n            break; // 'break' ステートメントが不要なことを報告します\n        }\n        default -> {\n            System.out.println(\"Default\");\n            break; // 'break' ステートメントが不要なことを報告します\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryBreak",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BreakStatement",
                "shortDescription": {
                  "text": "'break' ステートメント"
                },
                "fullDescription": {
                  "text": "'switch' ステートメントの分岐の末尾以外で使用されている 'break' ステートメントを報告します。 'break' ステートメントはリファクタリングを複雑にし、混乱を招く可能性があります。 例: 'void foo(List<String> strs) {\n  for (String str : strs) {\n    if (str.contains(\"stop\")) break;\n    handleStr(str);\n  }\n}'",
                  "markdown": "`switch` ステートメントの分岐の末尾以外で使用されている `break` ステートメントを報告します。\n\n`break` ステートメントはリファクタリングを複雑にし、混乱を招く可能性があります。\n\n例:\n\n\n    void foo(List<String> strs) {\n      for (String str : strs) {\n        if (str.contains(\"stop\")) break;\n        handleStr(str);\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BreakStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RawUseOfParameterizedType",
                "shortDescription": {
                  "text": "型引数のないパラメーター化されたクラスの使用"
                },
                "fullDescription": {
                  "text": "型パラメーターが省略されているジェネリッククラスを報告します。 Java ではこのような型引数のないジェネリック型 (raw 型) を使用できますが、型パラメーターの目的が無意味になってしまい、バグがマスクされる可能性があります。 このインスペクションは 'javac' の 'rawtypes' 警告と同じ動作をします。 例: '//警告: 型引数のないパラメーター化されたクラス 'List’ の使用\nList list = new ArrayList<String>();\n//文字列のリストが作成されましたが、整数も受け付けています\nlist.add(1);' '//配列作成中に型引数を指定することはできないため、警告はありません\nIntFunction<List<?>[]> fun = List[]::new;' インスペクションの構成: オブジェクト構築で使用されている raw 型を無視するには、「新規オブジェクトの構築を無視する」オプションを使用します。 型キャストで使用されている raw 型を無視するには、「型のキャストを無視する」オプションを使用します。 型パラメーターがコンパイルに失敗するケース (配列の作成やライブラリメソッドのオーバーライドなど) を無視するには、「型パラメーターがコンパイルされない場所を無視」オプションを使用します。 オーバーライド対象メソッドのパラメーターに使用されている型パラメーターを無視するには、「オーバーライドするメソッドのパラメーター型を無視」オプションを使用します。 クイックフィックスを使用できないケースを無視するには、「自動クイックフィックスを使用できない時は無視する」オプションを使用します。 このインスペクションは Java 5 以降で使用できる Java の機能 'ジェネリクス' に依存しています。",
                  "markdown": "型パラメーターが省略されているジェネリッククラスを報告します。 Java ではこのような*型引数のない* ジェネリック型 (raw 型) を使用できますが、型パラメーターの目的が無意味になってしまい、バグがマスクされる可能性があります。 このインスペクションは `javac` の `rawtypes` 警告と同じ動作をします。\n\n**例:**\n\n\n    //警告: 型引数のないパラメーター化されたクラス 'List' の使用\n    List list = new ArrayList<String>();\n    //文字列のリストが作成されましたが、整数も受け付けています\n    list.add(1);\n\n\n    //配列作成中に型引数を指定することはできないため、警告はありません\n    IntFunction<List<?>[]> fun = List[]::new;\n\nインスペクションの構成:\n\n* オブジェクト構築で使用されている raw 型を無視するには、「**新規オブジェクトの構築を無視する**」オプションを使用します。\n* 型キャストで使用されている raw 型を無視するには、「**型のキャストを無視する**」オプションを使用します。\n* 型パラメーターがコンパイルに失敗するケース (配列の作成やライブラリメソッドのオーバーライドなど) を無視するには、「**型パラメーターがコンパイルされない場所を無視**」オプションを使用します。\n* オーバーライド対象メソッドのパラメーターに使用されている型パラメーターを無視するには、「**オーバーライドするメソッドのパラメーター型を無視**」オプションを使用します。\n* クイックフィックスを使用できないケースを無視するには、「**自動クイックフィックスを使用できない時は無視する**」オプションを使用します。\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 'ジェネリクス' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "rawtypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JDBCExecuteWithNonConstantString",
                "shortDescription": {
                  "text": "非定数文字列による 'Statement.execute()' の呼び出し"
                },
                "fullDescription": {
                  "text": "動的に作成される文字列を実行クエリとして受け取っている 'java.sql.Statement.execute()' か、そのバリアントの呼び出しを報告します。 動的に作成される SQL ステートメントは、一般的にセキュリティ違反の元になります。 このインスペクションはデフォルトではコンパイル時の定数を無視します。 例: 'ResultSet execute(Statement statement, String name) throws SQLException {\n    return statement.executeQuery(\"select * from \" + name); // 警告を報告します\n  }' すべての 'static' 'final' フィールドを定数と見なすには、インスペクションオプションを使用します。 このオプションが有効な場合、次のような文字列は無視されますので注意してください。 'private static final String SQL = \"SELECT * FROM user WHERE name='\" + getUserInput() + \"'\";'",
                  "markdown": "動的に作成される文字列を実行クエリとして受け取っている `java.sql.Statement.execute()` か、そのバリアントの呼び出しを報告します。\n\n動的に作成される SQL ステートメントは、一般的にセキュリティ違反の元になります。\nこのインスペクションはデフォルトではコンパイル時の定数を無視します。\n\n**例:**\n\n\n      ResultSet execute(Statement statement, String name) throws SQLException {\n        return statement.executeQuery(\"select * from \" + name); // 警告を報告します\n      }\n\n\nすべての `static` `final` フィールドを定数と見なすには、インスペクションオプションを使用します。\nこのオプションが有効な場合、次のような文字列は無視されますので注意してください。\n\n\n      private static final String SQL = \"SELECT * FROM user WHERE name='\" + getUserInput() + \"'\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JDBCExecuteWithNonConstantString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicConstructorInNonPublicClass",
                "shortDescription": {
                  "text": "non-public クラスの 'public' コンストラクター"
                },
                "fullDescription": {
                  "text": "非 'public' クラスにある 'public' コンストラクターを報告します。 通常、アクセスレベルがより低いクラスに 'public' コンストラクターを作成する理由はありません。 ただし、このインスペクションにより、一部のリフレクション呼び出しの動作が変わることに注意してください。 特に、'Class.getConstructor()' は更新後のコンストラクターを見つけることができなくなります (代わりに 'Class.getDeclaredConstructor()' を使用する必要があります)。 自身のコードや使用しているフレームワークのコードが 'getConstructor()' を介してコンストラクターのアクセシビリティに依存している場合は、このインスペクションを使用しないでください。 例: 'class House {\n    public House() {}\n  }' クイックフィックス適用後: 'class House {\n    House() {}\n  }'",
                  "markdown": "非 `public` クラスにある `public` コンストラクターを報告します。\n\n通常、アクセスレベルがより低いクラスに `public` コンストラクターを作成する理由はありません。\nただし、このインスペクションにより、一部のリフレクション呼び出しの動作が変わることに注意してください。 特に、`Class.getConstructor()` は更新後のコンストラクターを見つけることができなくなります (代わりに `Class.getDeclaredConstructor()` を使用する必要があります)。 自身のコードや使用しているフレームワークのコードが `getConstructor()` を介してコンストラクターのアクセシビリティに依存している場合は、このインスペクションを使用しないでください。\n\n**例:**\n\n\n      class House {\n        public House() {}\n      }\n\nクイックフィックス適用後:\n\n\n      class House {\n        House() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicConstructorInNonPublicClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantValueVariableUse",
                "shortDescription": {
                  "text": "値が定数であることが既知である変数の使用"
                },
                "fullDescription": {
                  "text": "一定であることが分かっている変数の使用箇所を報告します。 これは、変数の使用 (読み取り) 箇所が、変数を定数と比較している '==' 条件を持つ 'if'、'while'、'for' ステートメントで囲まれている場合に当てはまります。 この場合、一定であることが分かっている変数の使用箇所を実際の定数に置換できます。 例: 'private static void foo(double number) {\n        if (number == 1.0) {\n            f(number);\n        }\n    }\n    private static void f(double number) {}' クイックフィックス適用後: 'private static void foo(double number) {\n        if (number == 1.0) {\n            f(1.0);\n        }\n    }\n    private static void f(double number) {}'",
                  "markdown": "一定であることが分かっている変数の使用箇所を報告します。\n\nこれは、変数の使用 (読み取り) 箇所が、変数を定数と比較している `==` 条件を持つ `if`、`while`、`for` ステートメントで囲まれている場合に当てはまります。\nこの場合、一定であることが分かっている変数の使用箇所を実際の定数に置換できます。\n\n例:\n\n\n        private static void foo(double number) {\n            if (number == 1.0) {\n                f(number);\n            }\n        }\n        private static void f(double number) {}\n\nクイックフィックス適用後:\n\n\n        private static void foo(double number) {\n            if (number == 1.0) {\n                f(1.0);\n            }\n        }\n        private static void f(double number) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantValueVariableUse",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/データフロー",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewStringBufferWithCharArgument",
                "shortDescription": {
                  "text": "'char' 引数を持つ StringBuilder コンストラクターの呼び出し"
                },
                "fullDescription": {
                  "text": "'char' を引数に含む 'StringBuffer' および 'StringBuilder' コンストラクターへの呼び出しを報告します。 この場合、'char' は警告なしで整数にキャストされ、バッファーの初期容量として解釈されます。 例: 'new StringBuilder('(').append(\"1\").append(')');' クイックフィックス適用後: 'new StringBuilder(\"(\").append(\"1\").append(')');'",
                  "markdown": "`char` を引数に含む `StringBuffer` および `StringBuilder` コンストラクターへの呼び出しを報告します。 この場合、`char` は警告なしで整数にキャストされ、バッファーの初期容量として解釈されます。\n\n**例:**\n\n\n      new StringBuilder('(').append(\"1\").append(')');\n\nクイックフィックス適用後:\n\n\n      new StringBuilder(\"(\").append(\"1\").append(')');\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewStringBufferWithCharArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProtectedInnerClass",
                "shortDescription": {
                  "text": "protected ネストクラス"
                },
                "fullDescription": {
                  "text": "'protected' のネストしたクラスを報告します。 例: 'public class Outer {\n    protected static class Nested {} // 警告\n    protected class Inner {}         // 警告\n    protected enum Mode {}           // 設定に応じて警告\n    protected interface I {}         // 設定に応じて警告\n  }' インスペクションの構成: 'protected' 内の列挙型を無視するには、「'protected' 内の列挙型を無視する」オプションを使用します。 'protected' 内のインターフェースを無視するには、「'protected' 内のインターフェースを無視する」オプションを使用します。",
                  "markdown": "`protected` のネストしたクラスを報告します。\n\n**例:**\n\n\n      public class Outer {\n        protected static class Nested {} // 警告\n        protected class Inner {}         // 警告\n        protected enum Mode {}           // 設定に応じて警告\n        protected interface I {}         // 設定に応じて警告\n      }\n\nインスペクションの構成:\n\n* `protected` 内の列挙型を無視するには、「**'protected' 内の列挙型を無視する**」オプションを使用します。\n* `protected` 内のインターフェースを無視するには、「**'protected' 内のインターフェースを無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProtectedInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/カプセル化",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnqualifiedStaticUsage",
                "shortDescription": {
                  "text": "修飾されていない static アクセス"
                },
                "fullDescription": {
                  "text": "クラス名で修飾されていない static メンバーが使用されていることを報告します。 これは static メンバーが同じクラス内にある場合は有効ですが、混乱を招く可能性があります。 例: 'class Foo {\n    static void foo() {}\n    static int x;\n\n    void bar() {\n      foo();\n      System.out.println(x);\n    }\n\n    static void baz() { foo(); }\n  }' クイックフィックス適用後: 'class Foo {\n    static void foo() {}\n    static int x;\n\n    void bar() {\n      Foo.foo();\n      System.out.println(Foo.x);\n    }\n\n    static void baz() { Foo.foo(); }\n  }' 次の項目を報告するかどうかを切り替えるには、インスペクションの設定を使用します。 static フィールドのアクセス 'void bar() { System.out.println(x); }' static メソッドの呼び出し 'void bar() { foo(); }' 'static void baz() { foo(); }' また、非 static コンテキストにある static メンバーの使用箇所のみを報告するようにインスペクションを構成することもできます。 上記の例では、'static void baz() { foo(); }' は報告されません。",
                  "markdown": "クラス名で修飾されていない static メンバーが使用されていることを報告します。\n\n\nこれは static メンバーが同じクラス内にある場合は有効ですが、混乱を招く可能性があります。\n\n**例:**\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          foo();\n          System.out.println(x);\n        }\n\n        static void baz() { foo(); }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          Foo.foo();\n          System.out.println(Foo.x);\n        }\n\n        static void baz() { Foo.foo(); }\n      }\n\n次の項目を報告するかどうかを切り替えるには、インスペクションの設定を使用します。\n\n*\n  static フィールドのアクセス  \n\n  `void bar() { System.out.println(x); }`\n\n*\n  static メソッドの呼び出し  \n\n  `void bar() { foo(); }`  \n\n  `static void baz() { foo(); }`\n\n\nまた、非 static コンテキストにある static メンバーの使用箇所のみを報告するようにインスペクションを構成することもできます。\n上記の例では、`static void baz() { foo(); }` は報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnqualifiedStaticUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExternalizableWithoutPublicNoArgConstructor",
                "shortDescription": {
                  "text": "'public' の引数なしコンストラクターがない 'Externalizable' クラス"
                },
                "fullDescription": {
                  "text": "引数なしの public コンストラクターがない 'Externalizable' クラスを報告します。 'Externalizable' オブジェクトが再構築されると、'readExternal' メソッドが呼び出される前に引数なしの public コンストラクターを使用してインスタンスが作成されます。 引数なしの public コンストラクターが使用できない場合、実行時に 'java.io.InvalidClassException' がスローされます。",
                  "markdown": "引数なしの public コンストラクターがない `Externalizable` クラスを報告します。\n\n`Externalizable` オブジェクトが再構築されると、`readExternal` メソッドが呼び出される前に引数なしの public コンストラクターを使用してインスタンスが作成されます。 引数なしの public コンストラクターが使用できない場合、実行時に `java.io.InvalidClassException` がスローされます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExternalizableWithoutPublicNoArgConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ResultOfObjectAllocationIgnored",
                "shortDescription": {
                  "text": "オブジェクトの割り当て結果を無視"
                },
                "fullDescription": {
                  "text": "オブジェクトの割り当てで、割り当てられたオブジェクトが無視されており、変数に代入されておらず、別の方法でも使用されていないものを報告します。 このような割り当て式は Java では有効ですが、通常は意図しない、もしくは非常に奇妙なオブジェクト初期化方針が取られていることを表しています。 このインスペクションで割り当てを無視すべきクラスをリストするには、オプションを使用します。",
                  "markdown": "オブジェクトの割り当てで、割り当てられたオブジェクトが無視されており、変数に代入されておらず、別の方法でも使用されていないものを報告します。\n\n\nこのような割り当て式は Java では有効ですが、通常は意図しない、もしくは非常に奇妙なオブジェクト初期化方針が取られていることを表しています。\n\n\nこのインスペクションで割り当てを無視すべきクラスをリストするには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ResultOfObjectAllocationIgnored",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticGuardedByInstance",
                "shortDescription": {
                  "text": "インスタンスフィールドまたは this よってガードされている static メンバー"
                },
                "fullDescription": {
                  "text": "ガードが非 static フィールドまたは 'this' の 'static' フィールドまたはメソッドにある '@GuardedBy' アノテーションを報告します。 static 要素を非 static 要素でガードすると過剰な同時実行が発生する可能性があります。また、異なるオブジェクトコンテキストでロックすることで、複数のスレッドがガードされたフィールドに同時にアクセスできてしまう可能性があります。 例: 'private ReadWriteLock lock = new ReentrantReadWriteLock();\n\n    @GuardedBy(\"lock\")\n    public static void bar() {\n        // ...\n    }' サポート対象の '@GuardedBy' アノテーションは以下の通りです。 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "ガードが非 static フィールドまたは `this` の `static` フィールドまたはメソッドにある `@GuardedBy` アノテーションを報告します。\n\nstatic 要素を非 static 要素でガードすると過剰な同時実行が発生する可能性があります。また、異なるオブジェクトコンテキストでロックすることで、複数のスレッドがガードされたフィールドに同時にアクセスできてしまう可能性があります。\n\n例:\n\n\n        private ReadWriteLock lock = new ReentrantReadWriteLock();\n\n        @GuardedBy(\"lock\")\n        public static void bar() {\n            // ...\n        }\n\nサポート対象の `@GuardedBy` アノテーションは以下の通りです。\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticGuardedByInstance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/並行処理に関するアノテーションの問題",
                      "index": 58,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassGetClass",
                "shortDescription": {
                  "text": "疑わしい 'Class.getClass()' 呼び出し"
                },
                "fullDescription": {
                  "text": "'java.lang.Class' インスタンスに対して呼び出されている 'getClass()' メソッドを報告します。 この結果は常に 'Class.class' と等しくなるため、ミスであることが多いです。 ミスである場合は、'getClass()' の呼び出しを除去し、修飾子を直接使用することをお勧めします。 この動作が意図したものである場合は、混乱を避けるために 'Class.class' を明示的に記述することをお勧めします。 例: 'void test(Class<?> clazz) {\n    String name = clazz.getClass().getName();\n  }' 使用できるクイックフィックスの 1 つを実行すると、以下のようになります。 'void test(Class<?> clazz) {\n    String name = clazz.getName();\n  }' 2018.2 の新機能です",
                  "markdown": "`java.lang.Class` インスタンスに対して呼び出されている `getClass()` メソッドを報告します。\n\nこの結果は常に `Class.class` と等しくなるため、ミスであることが多いです。\nミスである場合は、`getClass()` の呼び出しを除去し、修飾子を直接使用することをお勧めします。\nこの動作が意図したものである場合は、混乱を避けるために `Class.class` を明示的に記述することをお勧めします。\n\n例:\n\n\n      void test(Class<?> clazz) {\n        String name = clazz.getClass().getName();\n      }\n\n使用できるクイックフィックスの 1 つを実行すると、以下のようになります。\n\n\n      void test(Class<?> clazz) {\n        String name = clazz.getName();\n      }\n\n2018.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassGetClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedLibrary",
                "shortDescription": {
                  "text": "未使用のライブラリ"
                },
                "fullDescription": {
                  "text": "指定したインスペクション範囲に関連付けられたライブラリのうち、コードで直接使用されていないものを報告します。",
                  "markdown": "指定したインスペクション範囲に関連付けられたライブラリのうち、コードで直接使用されていないものを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedLibrary",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ManualArrayCopy",
                "shortDescription": {
                  "text": "手動による配列のコピー"
                },
                "fullDescription": {
                  "text": "配列の内容を手動コピーしている処理で、'System.arraycopy()' の呼び出しに置換できるものを報告します。 例: 'for (int i = 0; i < array.length; i++) {\n    newArray[i] = array[i];\n  }' クイックフィックス適用後: 'System.arraycopy(array, 0, newArray, 0, array.length);'",
                  "markdown": "配列の内容を手動コピーしている処理で、`System.arraycopy()` の呼び出しに置換できるものを報告します。\n\n**例:**\n\n\n      for (int i = 0; i < array.length; i++) {\n        newArray[i] = array[i];\n      }\n\nクイックフィックス適用後:\n\n\n      System.arraycopy(array, 0, newArray, 0, array.length);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ManualArrayCopy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObsoleteCollection",
                "shortDescription": {
                  "text": "廃止されたコレクション型の使用"
                },
                "fullDescription": {
                  "text": "'java.util.Vector'、'java.util.Hashtable'、'java.util.Stack' の使用箇所を報告します。 多くの場合、これらのクラスの使用箇所は 'java.util.ArrayList'、'java.util.HashMap'、'java.util.ArrayDeque' を使用するように置換できます。 以前のクラスは引き続きサポートされていますが、JDK1.2 でコレクションクラスが導入されると共に廃止されたため、新しい開発では使用しないでください。 廃止されたコレクションがメソッド引数として使用されている箇所、または廃止された型を要求する変数に代入されている箇所を無視するには、「廃止されたコレクション型の要求箇所を無視する」オプションを使用します。 このオプションを有効にすると、大量のプロセッサーリソースが消費される可能性があります。",
                  "markdown": "`java.util.Vector`、`java.util.Hashtable`、`java.util.Stack` の使用箇所を報告します。\n\n多くの場合、これらのクラスの使用箇所は `java.util.ArrayList`、`java.util.HashMap`、`java.util.ArrayDeque` を使用するように置換できます。\n以前のクラスは引き続きサポートされていますが、JDK1.2 でコレクションクラスが導入されると共に廃止されたため、新しい開発では使用しないでください。\n\n\n廃止されたコレクションがメソッド引数として使用されている箇所、または廃止された型を要求する変数に代入されている箇所を無視するには、「**廃止されたコレクション型の要求箇所を無視する**」オプションを使用します。\nこのオプションを有効にすると、大量のプロセッサーリソースが消費される可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfObsoleteCollectionType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コード成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticPseudoFunctionalStyleMethod",
                "shortDescription": {
                  "text": "Guava の擬似関数呼び出しは Stream API の呼び出しに変換できます"
                },
                "fullDescription": {
                  "text": "'Java Stream API' を使用できる場合に Guava 擬似関数コードが使用されていることを報告します。 'Guava Iterable API' は 'Java Streams API' と同様の機能を提供しますが、若干異なる部分もあり、使用できない機能がある場合があります。 特に、'IntStream' のような Stream に対してプリミティブ特殊化を行ったものは、通常のものよりもパフォーマンスに優れています。 例: 'List<String> transformedIterable = Iterables.transform(someList, someTransformFunction);//警告: 擬似関数スタイルコード' クイックフィックス適用後: 'List<String> transformedIterable = someList.stream().map(someTransformFunction).collect(Collectors.toList());' 注意: コードのセマンティクスが変更される可能性があります。たとえば、Guava の 'Iterable.transform' は遅延評価されるイテラブルを生成しますが、置換後のコードは先行評価されます。 このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "`Java Stream API` を使用できる場合に Guava 擬似関数コードが使用されていることを報告します。\n\n`Guava Iterable API` は `Java Streams API` と同様の機能を提供しますが、若干異なる部分もあり、使用できない機能がある場合があります。\n特に、`IntStream` のような Stream に対してプリミティブ特殊化を行ったものは、通常のものよりもパフォーマンスに優れています。\n\n**例:**\n\n\n    List<String> transformedIterable = Iterables.transform(someList, someTransformFunction);//警告: 擬似関数スタイルコード\n\nクイックフィックス適用後:\n\n    List<String> transformedIterable = someList.stream().map(someTransformFunction).collect(Collectors.toList());\n\n\n**注意:** コードのセマンティクスが変更される可能性があります。たとえば、Guava の `Iterable.transform` は遅延評価されるイテラブルを生成しますが、置換後のコードは先行評価されます。\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticPseudoFunctionalStyleMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ControlFlowStatementWithoutBraces",
                "shortDescription": {
                  "text": "波括弧のない制御フローステートメント"
                },
                "fullDescription": {
                  "text": "波括弧のない 'if'、'while'、'do'、または 'for' ステートメントを報告します。 Google Java Style Guide など、一部のコードスタイルはすべての制御ステートメントに波括弧を要求しています。 波括弧のない制御ステートメントにさらにステートメントを追加する場合、波括弧を追加することを忘れないことが重要です。 また、コード行をコメントアウトする際に波括弧を使用しない場合は、制御フローステートメントの次のステートメント部分を無意識に作成しないよう、さらなる注意が必要です。 常に波括弧を使用することで、コード行の挿入またはコメントアウトがより安全になります。 常に波括弧を使用するコードスタイルを使用していれば、goto fail の脆弱性が発生することはないと思われます。 波括弧を使用した制御ステートメントにより制御フローが分かりやすくなり、間違える可能性のあるインデントを使用する必要もなくなります。 例: 'class Strange {\n    void x(boolean one, boolean two) {\n      if(one)\n        if(two)\n          foo();\n      else\n        bar();\n    }\n\n    void foo() {}\n    void bar() {}\n  }' クイックフィックスを実行すると、ステートメントの本体が波括弧で囲まれます。 'class Strange {\n    void x(boolean one, boolean two) {\n      if(one) {\n        if(two) {\n          foo();\n        } else {\n          bar();\n        }\n      }\n    }\n\n    void foo() {}\n    void bar() {}\n  }'",
                  "markdown": "波括弧のない `if`、`while`、`do`、または `for` ステートメントを報告します。 [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html) など、一部のコードスタイルはすべての制御ステートメントに波括弧を要求しています。\n\n\n波括弧のない制御ステートメントにさらにステートメントを追加する場合、波括弧を追加することを忘れないことが重要です。\nまた、コード行をコメントアウトする際に波括弧を使用しない場合は、制御フローステートメントの次のステートメント部分を無意識に作成しないよう、さらなる注意が必要です。\n常に波括弧を使用することで、コード行の挿入またはコメントアウトがより安全になります。\n\n\n常に波括弧を使用するコードスタイルを使用していれば、[goto fail の脆弱性](https://www.imperialviolet.org/2014/02/22/applebug.html)が発生することはないと思われます。\n波括弧を使用した制御ステートメントにより制御フローが分かりやすくなり、間違える可能性のあるインデントを使用する必要もなくなります。\n\n例:\n\n\n      class Strange {\n        void x(boolean one, boolean two) {\n          if(one)\n            if(two)\n              foo();\n          else\n            bar();\n        }\n\n        void foo() {}\n        void bar() {}\n      }\n\nクイックフィックスを実行すると、ステートメントの本体が波括弧で囲まれます。\n\n\n      class Strange {\n        void x(boolean one, boolean two) {\n          if(one) {\n            if(two) {\n              foo();\n            } else {\n              bar();\n            }\n          }\n        }\n\n        void foo() {}\n        void bar() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ControlFlowStatementWithoutBraces",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MisspelledEquals",
                "shortDescription": {
                  "text": "'equals()' の代用に 'equal()' を使用"
                },
                "fullDescription": {
                  "text": "パラメーターが 1 つの 'equal()' 宣言を報告します。 これは多くの場合、タイポであり、'equals()' が実際には意図されています。 メソッド名を 'equals' に変更するクイックフィックスが提案されます。 例: 'class Main {\n    public boolean equal(Object obj) {\n      return true;\n    }\n  }' クイックフィックス適用後: 'class Main {\n    public boolean equals(Object obj) {\n      return true;\n    }\n  }'",
                  "markdown": "パラメーターが 1 つの `equal()` 宣言を報告します。 これは多くの場合、タイポであり、`equals()` が実際には意図されています。\n\nメソッド名を `equals` に変更するクイックフィックスが提案されます。\n\n**例:**\n\n\n      class Main {\n        public boolean equal(Object obj) {\n          return true;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Main {\n        public boolean equals(Object obj) {\n          return true;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MisspelledEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalFieldInEnum",
                "shortDescription": {
                  "text": "'enum' 内の非 final フィールド"
                },
                "fullDescription": {
                  "text": "列挙型の非 final フィールドを報告します。 非 final フィールドはグローバルなミュータブルな状態を導入するため、一般的には望ましくないと考えられます。 例: 'enum Enum {\n    FIRST(\"first\"),\n    SECOND(\"second\");\n\n    public String str;\n\n    Enum(String str) {\n        this.str = str;\n    }\n  }' クイックフィックス適用後: 'enum Enum {\n    FIRST(\"first\"),\n    SECOND(\"second\");\n\n    public final String str;\n\n    Enum(String str) {\n        this.str = str;\n    }\n  }' このクイックフィックスを使用して final にできるフィールドに対してのみ警告するには、「'final' にできないフィールドを無視する」 オプションを使用します。",
                  "markdown": "列挙型の非 final フィールドを報告します。 非 final フィールドはグローバルなミュータブルな状態を導入するため、一般的には望ましくないと考えられます。\n\n**例:**\n\n\n      enum Enum {\n        FIRST(\"first\"),\n        SECOND(\"second\");\n\n        public String str;\n\n        Enum(String str) {\n            this.str = str;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      enum Enum {\n        FIRST(\"first\"),\n        SECOND(\"second\");\n\n        public final String str;\n\n        Enum(String str) {\n            this.str = str;\n        }\n      }\n\nこのクイックフィックスを使用して final にできるフィールドに対してのみ警告するには、「'final' にできないフィールドを無視する」 オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldInEnum",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LengthOneStringInIndexOf",
                "shortDescription": {
                  "text": "'String.indexOf()' 呼び出しの単一文字列引数"
                },
                "fullDescription": {
                  "text": "'String.indexOf()' および 'String.lastIndexOf()' 呼び出しの引数として使用されている単一文字列を報告します。 このような文字列リテラルを同等の文字リテラルに置換し、若干のパフォーマンス改善を行うクイックフィックスが提案されます。 例: 'return s.indexOf(\"x\");' クイックフィックス適用後: 'return s.indexOf('x');'",
                  "markdown": "`String.indexOf()` および `String.lastIndexOf()` 呼び出しの引数として使用されている単一文字列を報告します。\n\nこのような文字列リテラルを同等の文字リテラルに置換し、若干のパフォーマンス改善を行うクイックフィックスが提案されます。\n\n**例:**\n\n\n      return s.indexOf(\"x\");\n\nクイックフィックス適用後:\n\n\n      return s.indexOf('x');\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SingleCharacterStringConcatenation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForEachWithRecordPatternCanBeUsed",
                "shortDescription": {
                  "text": "レコードパターンを使用する拡張 'for' を使用できます"
                },
                "fullDescription": {
                  "text": "拡張 `for` ステートメントにあるローカル変数宣言とレコードコンポーネントへのアクセサーで、通常よりもコンパクトなパターン変数に置換できるものを報告します。 例: 'record Record(Integer x, String y) {\n}\n\npublic static void test(List<Record> records) {\n    for (Record record : records) {\n        System.out.println(record.y());\n        Integer x = record.x;\n        System.out.println(x);\n    }\n}' 上のコードは下のコードに置換できます。 'record Record(Integer x, String y) {\n}\n\npublic static void test(List<Record> records) {\n    for (Record(Integer x, String y) : records) {\n        System.out.println(y);\n        System.out.println(x);\n    }\n}' 報告するネストした分解パターンの最大数を指定するには「ネストの深さ制限」オプションを使用します レコードに含めて分解パターンで使用できるコンポーネントの最大数を指定するには「分解するレコードコンポーネントの最大数」オプションを使用します 'for' ステートメントで使用されないコンポーネントの最大数を指定するには「使用されないレコードコンポーネントの最大数」オプションを使用します 2023.1 の新機能です このインスペクションは Java X 以降で使用できる Java の機能 'for-each ループ内のレコードパターン' に依存しています。",
                  "markdown": "拡張 \\`for\\` ステートメントにあるローカル変数宣言とレコードコンポーネントへのアクセサーで、通常よりもコンパクトなパターン変数に置換できるものを報告します。\n\n**例:**\n\n\n    record Record(Integer x, String y) {\n    }\n\n    public static void test(List<Record> records) {\n        for (Record record : records) {\n            System.out.println(record.y());\n            Integer x = record.x;\n            System.out.println(x);\n        }\n    }\n\n上のコードは下のコードに置換できます。\n\n\n    record Record(Integer x, String y) {\n    }\n\n    public static void test(List<Record> records) {\n        for (Record(Integer x, String y) : records) {\n            System.out.println(y);\n            System.out.println(x);\n        }\n    }\n\n* 報告するネストした分解パターンの最大数を指定するには「**ネストの深さ制限**」オプションを使用します\n* レコードに含めて分解パターンで使用できるコンポーネントの最大数を指定するには「**分解するレコードコンポーネントの最大数**」オプションを使用します\n* `for` ステートメントで使用されないコンポーネントの最大数を指定するには「**使用されないレコードコンポーネントの最大数**」オプションを使用します\n\n2023.1 の新機能です\n\nこのインスペクションは Java X 以降で使用できる Java の機能 'for-each ループ内のレコードパターン' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForEachWithRecordPatternCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援",
                      "index": 52,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumClass",
                "shortDescription": {
                  "text": "列挙型クラス"
                },
                "fullDescription": {
                  "text": "enum クラスを報告します。 このようなステートメントは、Java 1.4 以前の JVM ではサポートされていません。",
                  "markdown": "**enum** クラスを報告します。 このようなステートメントは、Java 1.4 以前の JVM ではサポートされていません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EnumClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java の言語レベル関連の問題",
                      "index": 61,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrivialFunctionalExpressionUsage",
                "shortDescription": {
                  "text": "関数式の自明な使用"
                },
                "fullDescription": {
                  "text": "関数型インターフェースのメソッドの呼び出しで、ラムダ、メソッド参照、または匿名クラスの定義で直接呼び出されているものを報告します。 このようなメソッド呼び出しは、関数型インターフェースの実装本体に置換できます。 例: 'boolean contains(List<String> names, String name) {\n    return ((Predicate<String>)x -> {\n      return names.contains(x);\n    }).test(name);\n  }' クイックフィックスが適用されると、メソッドの呼び出しは次のように変更されます。 'boolean contains(List<String> names, String name) {\n    return names.contains(name);\n  }'",
                  "markdown": "関数型インターフェースのメソッドの呼び出しで、ラムダ、メソッド参照、または匿名クラスの定義で直接呼び出されているものを報告します。 このようなメソッド呼び出しは、関数型インターフェースの実装本体に置換できます。\n\n**例:**\n\n\n      boolean contains(List<String> names, String name) {\n        return ((Predicate<String>)x -> {\n          return names.contains(x);\n        }).test(name);\n      }\n\nクイックフィックスが適用されると、メソッドの呼び出しは次のように変更されます。\n\n\n      boolean contains(List<String> names, String name) {\n        return names.contains(name);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TrivialFunctionalExpressionUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedStringBuilderQueryUpdate",
                "shortDescription": {
                  "text": "'StringBuilder' のクエリと更新の不一致"
                },
                "fullDescription": {
                  "text": "内容が読み取られているが書き込まれていない、または書き込まれているが読み取られていない 'StringBuilder'、'StringBuffer' または 'StringJoiner' オブジェクトを報告します。 このような一貫性のない読み取りと書き込みは無意味であり、デッドコード、不完全なコード、または間違ったコードである可能性が高いです。 例: 'public void m1() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"a\");\n  }'",
                  "markdown": "内容が読み取られているが書き込まれていない、または書き込まれているが読み取られていない `StringBuilder`、`StringBuffer` または `StringJoiner` オブジェクトを報告します。\n\nこのような一貫性のない読み取りと書き込みは無意味であり、デッドコード、不完全なコード、または間違ったコードである可能性が高いです。\n\n**例:**\n\n\n      public void m1() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"a\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedQueryAndUpdateOfStringBuilder",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousHasLambdaAlternative",
                "shortDescription": {
                  "text": "より短い代替ラムダのある匿名型"
                },
                "fullDescription": {
                  "text": "ラムダ式を引数とするコンストラクターまたはファクトリメソッドの呼び出しに変換できる匿名クラスを報告します。 このインスペクションでは、以下のクラスが報告されます。 'initialValue()' メソッド ('ThreadLocal.withInitial' に置換可能) を持ち、'ThreadLocal' を拡張している匿名クラス。 'run()' メソッド ('new Thread(Runnable) に置換可能') を持ち、'Thread' を拡張している匿名クラス。 例: 'new Thread() {\n    @Override\n    public void run() {\n      System.out.println(\"Hello from thread!\");\n    }\n  }.start();' クイックフィックス適用後: 'new Thread(() -> {\n    System.out.println(\"Hello from thread!\");\n  }).start();' このインスペクションは Java 8 以降で使用できる Java の機能 'ThreadLocal.withInitial()' に依存しています。",
                  "markdown": "ラムダ式を引数とするコンストラクターまたはファクトリメソッドの呼び出しに変換できる匿名クラスを報告します。\n\nこのインスペクションでは、以下のクラスが報告されます。\n\n* `initialValue()` メソッド (`ThreadLocal.withInitial` に置換可能) を持ち、`ThreadLocal` を拡張している匿名クラス。\n* `run()` メソッド (`new Thread(Runnable) に置換可能`) を持ち、`Thread` を拡張している匿名クラス。\n\n例:\n\n\n      new Thread() {\n        @Override\n        public void run() {\n          System.out.println(\"Hello from thread!\");\n        }\n      }.start();\n\nクイックフィックス適用後:\n\n\n      new Thread(() -> {\n        System.out.println(\"Hello from thread!\");\n      }).start();\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'ThreadLocal.withInitial()' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnonymousHasLambdaAlternative",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalizeNotProtected",
                "shortDescription": {
                  "text": "'finalize()' は public でなく、protected である必要があります"
                },
                "fullDescription": {
                  "text": "'public' で宣言されている 'Object.finalize()' メソッドの実装を報告します。 'Object.finalize()' の契約によれば、ガベージコレクターのみがこのメソッドを呼び出します。 このメソッドを public にすると他のコードからメソッドを使用できるようになるため、誤解を招く可能性があります。 このメソッドを他のクラスから呼び出すことができないように 'protected' にするクイックフィックスが提供されています。 例: 'class X {\n    public void finalize() {\n      /* ... */\n    }\n  }' クイックフィックス適用後: 'class X {\n    protected void finalize() {\n      /* ... */\n    }\n  }'",
                  "markdown": "`public` で宣言されている `Object.finalize()` メソッドの実装を報告します。\n\n\n`Object.finalize()` の契約によれば、ガベージコレクターのみがこのメソッドを呼び出します。 このメソッドを public にすると他のコードからメソッドを使用できるようになるため、誤解を招く可能性があります。\n\n\nこのメソッドを他のクラスから呼び出すことができないように `protected` にするクイックフィックスが提供されています。\n\n**例:**\n\n\n      class X {\n        public void finalize() {\n          /* ... */\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class X {\n        protected void finalize() {\n          /* ... */\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalizeNotProtected",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ファイナライズ",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsThread",
                "shortDescription": {
                  "text": "クラスが直接 'Thread' を拡張しています"
                },
                "fullDescription": {
                  "text": "'java.lang.Thread' を直接拡張しているクラスを報告します。 後で変更しやすい再利用可能なコードを作成するため、通常は継承せずにゼロからコードを書くことをお勧めします。 例: 'class MainThread extends Thread {\n  }'",
                  "markdown": "`java.lang.Thread` を直接拡張しているクラスを報告します。 後で変更しやすい再利用可能なコードを作成するため、通常は継承せずにゼロからコードを書くことをお勧めします。\n\n**例:**\n\n\n      class MainThread extends Thread {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassExplicitlyExtendsThread",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyOptionalCallChains",
                "shortDescription": {
                  "text": "単純化できる Optional 呼び出しチェーン"
                },
                "fullDescription": {
                  "text": "単純化できる Optional の呼び出しチェーンを報告します。 以下に、単純化の例をいくつか紹介します。 'optional.map(x -> true).orElse(false)' → 'optional.isPresent()' 'optional.map(x -> Optional.of(x.trim())).orElseGet(Optional::empty)' → 'optional.map(String::trim)' 'optional.map(x -> (String)x).orElse(null)' → '(String) optional.orElse(null)' 'Optional.ofNullable(optional.orElse(null))' → 'optional' 'val = optional.orElse(null); val != null ? val : defaultExpr' → 'optional.orElse(defaultExpr)' 'val = optional.orElse(null); if(val != null) expr(val)' → 'optional.ifPresent(val -> expr(val))' 2017.2 の新機能です このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "単純化できる **Optional** の呼び出しチェーンを報告します。 以下に、単純化の例をいくつか紹介します。\n\n* `optional.map(x -> true).orElse(false)` → `optional.isPresent()`\n* `optional.map(x -> Optional.of(x.trim())).orElseGet(Optional::empty)` → `optional.map(String::trim)`\n* `optional.map(x -> (String)x).orElse(null)` → `(String) optional.orElse(null)`\n* `Optional.ofNullable(optional.orElse(null))` → `optional`\n* `val = optional.orElse(null); val != null ? val : defaultExpr ` → `optional.orElse(defaultExpr)`\n* `val = optional.orElse(null); if(val != null) expr(val) ` → `optional.ifPresent(val -> expr(val))`\n\n2017.2 の新機能です\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifyOptionalCallChains",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ModuleWithTooManyClasses",
                "shortDescription": {
                  "text": "クラスが多すぎるモジュール"
                },
                "fullDescription": {
                  "text": "含んでいるクラスが多すぎるモジュールを報告します。 モジュールが大きすぎる場合、デザインの明瞭性が欠けている可能性があります。 Java、Kotlin、および Groovy クラスがカウントされます。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。 モジュールに含めることができるクラスの最大数を指定するには、「最大クラス数」フィールドを使用します。",
                  "markdown": "含んでいるクラスが多すぎるモジュールを報告します。 モジュールが大きすぎる場合、デザインの明瞭性が欠けている可能性があります。 Java、Kotlin、および Groovy クラスがカウントされます。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。\n\nモジュールに含めることができるクラスの最大数を指定するには、「**最大クラス数**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ModuleWithTooManyClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/モジュール化関連の問題",
                      "index": 65,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InfiniteLoopStatement",
                "shortDescription": {
                  "text": "無限ループステートメント"
                },
                "fullDescription": {
                  "text": "例外のスローによってのみ終了できる 'for'、'while'、または 'do' ステートメントを報告します。 このようなステートメントは正しい場合もありますが、多くの場合はコーディングの間違いによるものです。 例: 'for (;;) {\n  }' 'Thread.run' 内にある無限ループステートメントを無視する場合は、「Thread.run 内にある場合は無視する」オプションを使用します。 これは、デーモンスレッドを使用する時に役に立つ場合があります。 例: 'new Thread(() -> {\n    while (true) {\n    }\n  }).start();'",
                  "markdown": "例外のスローによってのみ終了できる `for`、`while`、または `do` ステートメントを報告します。 このようなステートメントは正しい場合もありますが、多くの場合はコーディングの間違いによるものです。\n\n例:\n\n\n      for (;;) {\n      }\n\n\n`Thread.run` 内にある無限ループステートメントを無視する場合は、「**Thread.run 内にある場合は無視する**」オプションを使用します。\nこれは、デーモンスレッドを使用する時に役に立つ場合があります。\n\n例:\n\n\n      new Thread(() -> {\n        while (true) {\n        }\n      }).start();\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InfiniteLoopStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocHtmlLint",
                "shortDescription": {
                  "text": "Javadoc の HTML 問題 (DocLint)"
                },
                "fullDescription": {
                  "text": "Java 8 以降の DocLint が報告するものと同じ Javadoc コメントの HTML に関する問題を報告します。 このインスペクションは以下の問題を検出します。 自己終了タグ、閉じられていないタグ、不明なタグ、誤って配置されたタグ、または空のタグ 不明な属性または正しくない属性 誤って配置されたテキスト 例: '/**\n * 不明なタグ: List<String>\n * 閉じられていないタグ: error</b>\n * 誤って配置されたテキストまたはタグ: <ul><li>one</li>, <li>two</li></ul>\n * 正しくない、または空の属性: <a href=\"\"></a>\n * 自己終了タグ: <br/>\n * ...\n */\nvoid sample(){ }'",
                  "markdown": "Java 8 以降の DocLint が報告するものと同じ Javadoc コメントの HTML に関する問題を報告します。\n\nこのインスペクションは以下の問題を検出します。\n\n* 自己終了タグ、閉じられていないタグ、不明なタグ、誤って配置されたタグ、または空のタグ\n* 不明な属性または正しくない属性\n* 誤って配置されたテキスト\n\n例:\n\n\n    /**\n     * 不明なタグ: List<String>\n     * 閉じられていないタグ: error</b>\n     * 誤って配置されたテキストまたはタグ: <ul><li>one</li>, <li>two</li></ul>\n     * 正しくない、または空の属性: <a href=\"\"></a>\n     * 自己終了タグ: <br/>\n     * ...\n     */\n    void sample(){ }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JavadocHtmlLint",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RandomDoubleForRandomInteger",
                "shortDescription": {
                  "text": "ランダムな整数の取得に 'Random.nextDouble()' を使用"
                },
                "fullDescription": {
                  "text": "呼び出しに何らかの係数を掛けて数値にキャストすることで正の整数を作成している 'java.util.Random.nextDouble()' の呼び出しを報告します。 ある範囲内でランダムな正の整数を生成するには、'java.util.Random.nextInt(int)' を使用するほうが単純で効率的です。 例: 'int getRandomInt() {\n    return (int) ((new Random()).nextDouble() * SIZE);\n  }'\n クイックフィックス適用後: 'int getRandomInt() {\n    return (new Random()).nextInt(SIZE);\n  }'",
                  "markdown": "呼び出しに何らかの係数を掛けて数値にキャストすることで正の整数を作成している `java.util.Random.nextDouble()` の呼び出しを報告します。\n\n\nある範囲内でランダムな正の整数を生成するには、`java.util.Random.nextInt(int)` を使用するほうが単純で効率的です。\n\n**例:**\n\n\n      int getRandomInt() {\n        return (int) ((new Random()).nextDouble() * SIZE);\n      }\n      \nクイックフィックス適用後:\n\n\n      int getRandomInt() {\n        return (new Random()).nextInt(SIZE);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UsingRandomNextDoubleForRandomInteger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousArrayCast",
                "shortDescription": {
                  "text": "疑わしい配列キャスト"
                },
                "fullDescription": {
                  "text": "疑わしい配列キャストを報告します。 より具体的な配列型にキャストしている配列キャストは疑わしいと見なされます。 このようなキャストはコンパイル時には有効ですが、実行時には 'ClassCastException' で失敗する可能性があります。 例: 'Number[] numbers = new Number[]{1L, 2L, 4L};\n  Long[] longs = (Long[])numbers;'",
                  "markdown": "疑わしい配列キャストを報告します。 より具体的な配列型にキャストしている配列キャストは疑わしいと見なされます。 このようなキャストはコンパイル時には有効ですが、実行時には `ClassCastException` で失敗する可能性があります。\n\n**例:**\n\n\n      Number[] numbers = new Number[]{1L, 2L, 4L};\n      Long[] longs = (Long[])numbers;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousArrayCast",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassUnconnectedToPackage",
                "shortDescription": {
                  "text": "パッケージに依存しないクラス"
                },
                "fullDescription": {
                  "text": "自身は所属するパッケージ内の他のクラスに依存せず、所属するパッケージの他のクラスに対して依存関係になっていないクラスを報告します。 このようなクラスは、パッケージング戦略が場当たり的または矛盾していることを暗に示しており、多くの場合は移動するのが得策です。 パッケージ内の唯一のクラスであるクラスは報告されません。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "自身は所属するパッケージ内の他のクラスに依存せず、所属するパッケージの他のクラスに対して依存関係になっていないクラスを報告します。 このようなクラスは、パッケージング戦略が場当たり的または矛盾していることを暗に示しており、多くの場合は移動するのが得策です。 パッケージ内の唯一のクラスであるクラスは報告されません。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassUnconnectedToPackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パッケージ関連の問題",
                      "index": 37,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExceptionNameDoesntEndWithException",
                "shortDescription": {
                  "text": "クラス名が 'Exception' で終わらない例外クラス"
                },
                "fullDescription": {
                  "text": "名前が 'Exception' で終わっていない例外クラスを報告します。 Example: 'class NotStartedEx extends Exception {}' このようなクラスの名前を変更するクイックフィックスは、エディターでのみ使用できます。",
                  "markdown": "名前が `Exception` で終わっていない例外クラスを報告します。\n\n**Example:** `class NotStartedEx extends Exception {}`\n\nこのようなクラスの名前を変更するクイックフィックスは、エディターでのみ使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExceptionClassNameDoesntEndWithException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規則/クラス",
                      "index": 68,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ZeroLengthArrayInitialization",
                "shortDescription": {
                  "text": "長さゼロの配列を割り当て"
                },
                "fullDescription": {
                  "text": "既知の長さゼロの配列の割り当てを報告します。 Java では配列の長さを変更できないため、ほとんどの場合は新しい配列を何度も割り当てる代わりに長さゼロの配列を共有することができます。 このような共有は、プログラムの実行時間や占有領域を最適化するのに役立つ場合があります。 このインスペクションは、static final フィールドとして割り当てられている長さゼロの配列を報告しません。そのような配列は、配列の共有を実装する目的で使用されていると考えられるためです。",
                  "markdown": "既知の長さゼロの配列の割り当てを報告します。\n\n\nJava では配列の長さを変更できないため、ほとんどの場合は新しい配列を何度も割り当てる代わりに長さゼロの配列を共有することができます。 このような共有は、プログラムの実行時間や占有領域を最適化するのに役立つ場合があります。\n\n\nこのインスペクションは、static final フィールドとして割り当てられている長さゼロの配列を報告しません。そのような配列は、配列の共有を実装する目的で使用されていると考えられるためです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ZeroLengthArrayAllocation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メモリ",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalStaticVariableUsedInClassInitialization",
                "shortDescription": {
                  "text": "非 final の static フィールドがクラスの初期化中に使用されています"
                },
                "fullDescription": {
                  "text": "クラスを初期化中に非 'final' の 'static' 変数が使用されていることを報告します。 このような場合、コードのセマンティクスがクラスの作成順序に依存するようになる可能性があります。 また、初期化されていない変数の使用を誘発する可能性があり、得てして難解で分かりにくいバグを引き起こします。 例: 'class Foo {\n    public static int bar = 0;\n\n    static {\n      System.out.println(bar);\n    }\n  }'",
                  "markdown": "クラスを初期化中に非 `final` の `static` 変数が使用されていることを報告します。\n\nこのような場合、コードのセマンティクスがクラスの作成順序に依存するようになる可能性があります。 また、初期化されていない変数の使用を誘発する可能性があり、得てして難解で分かりにくいバグを引き起こします。\n\n**例:**\n\n\n      class Foo {\n        public static int bar = 0;\n\n        static {\n          System.out.println(bar);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalStaticVariableUsedInClassInitialization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初期化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DivideByZero",
                "shortDescription": {
                  "text": "ゼロ除算"
                },
                "fullDescription": {
                  "text": "0 による除算または剰余計算を報告します。 このような式は、double または float に対しては 'Infinity'、'-Infinity' または 'NaN' の結果を生成し、integer に対しては 'ArithmeticException' をスローします。 式の結果が 'NaN' の場合、修正によって除算式を 'NaN' 定数に置換することをお勧めします。",
                  "markdown": "0 による除算または剰余計算を報告します。 このような式は、double または float に対しては `Infinity`、`-Infinity` または `NaN` の結果を生成し、integer に対しては `ArithmeticException` をスローします。\n\n式の結果が `NaN` の場合、修正によって除算式を `NaN` 定数に置換することをお勧めします。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "divzero",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadStopSuspendResume",
                "shortDescription": {
                  "text": "'Thread.stop()'、'suspend()' または 'resume()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'Thread.stop()'、'Thread.suspend()'、および 'Thread.resume()' の呼び出しを報告します。 これらの呼び出しは本質的にデータの破損やデッドロックを誘発しやすいため、使用しないことを強くお勧めします。 'stop' の代わりに協調キャンセルを使用し、'suspend' と 'resume' を直接呼び出す代わりに中断を使用することをお勧めします。",
                  "markdown": "`Thread.stop()`、`Thread.suspend()`、および `Thread.resume()` の呼び出しを報告します。\n\n\nこれらの呼び出しは本質的にデータの破損やデッドロックを誘発しやすいため、使用しないことを強くお勧めします。\n`stop` の代わりに協調キャンセルを使用し、`suspend` と `resume` を直接呼び出す代わりに中断を使用することをお勧めします。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadStopSuspendOrResumeManager",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryTemporaryOnConversionFromString",
                "shortDescription": {
                  "text": "'String' からの変換に不要な一時オブジェクト"
                },
                "fullDescription": {
                  "text": "'String' からプリミティブ型に変換する際に不要な一時オブジェクトが作成されていることを報告します。 例: 'new Integer(\"3\").intValue()' クイックフィックス適用後: 'Integer.valueOf(\"3\")'",
                  "markdown": "`String` からプリミティブ型に変換する際に不要な一時オブジェクトが作成されていることを報告します。\n\n**例:**\n\n\n      new Integer(\"3\").intValue()\n\nクイックフィックス適用後:\n\n\n      Integer.valueOf(\"3\")\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryTemporaryOnConversionFromString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingSerialAnnotation",
                "shortDescription": {
                  "text": "'@Serial' アノテーションを使用できます"
                },
                "fullDescription": {
                  "text": "'java.io.Serial' アノテーションを付けるのに適している'Serializable' および 'Externalizable' クラスのメソッドとフィールドを報告します。 クイックフィックスを使用すると、アノテーションが追加されます。 例: 'class Main implements Serializable {\n  private static final long serialVersionUID = 7874493593505141603L;\n\n  private void writeObject(ObjectOutputStream out) throws IOException {\n  }\n}' クイックフィックス適用後: 'class Main implements Serializable {\n    @Serial\n    private static final long serialVersionUID = 7874493593505141603L;\n\n    @Serial\n    private void writeObject(ObjectOutputStream out) throws IOException {\n    }\n}' 例: 'class Main implements Externalizable {\n    protected Object readResolve() throws ObjectStreamException {\n      return \"SomeObject\";\n    }\n  }' クイックフィックス適用後: 'class Main implements Externalizable {\n    @Serial\n    protected Object readResolve() throws ObjectStreamException {\n        return \"SomeObject\";\n    }\n  }' 想定されるすべてのケースに関する詳細は、'java.io.Serial' クラスの Javadoc を参照してください。 2020.3 の新機能です このインスペクションは Java 14 以降で使用できる Java の機能 '@Serial アノテーション' に依存しています。",
                  "markdown": "`java.io.Serial` アノテーションを付けるのに適している`Serializable` および `Externalizable` クラスのメソッドとフィールドを報告します。 クイックフィックスを使用すると、アノテーションが追加されます。\n\n**例:**\n\n\n    class Main implements Serializable {\n      private static final long serialVersionUID = 7874493593505141603L;\n\n      private void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\nクイックフィックス適用後:\n\n\n      class Main implements Serializable {\n        @Serial\n        private static final long serialVersionUID = 7874493593505141603L;\n\n        @Serial\n        private void writeObject(ObjectOutputStream out) throws IOException {\n        }\n    }\n\n**例:**\n\n\n      class Main implements Externalizable {\n        protected Object readResolve() throws ObjectStreamException {\n          return \"SomeObject\";\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Main implements Externalizable {\n        @Serial\n        protected Object readResolve() throws ObjectStreamException {\n            return \"SomeObject\";\n        }\n      }\n\n想定されるすべてのケースに関する詳細は、`java.io.Serial` クラスの Javadoc を参照してください。\n\n2020.3 の新機能です\n\nこのインスペクションは Java 14 以降で使用できる Java の機能 '@Serial アノテーション' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MissingSerialAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationMissingWhitespace",
                "shortDescription": {
                  "text": "文字列連結で空白が欠落している可能性あり"
                },
                "fullDescription": {
                  "text": "空白が欠落している文字列連結 (左側が Unicode の文字または数字で終わり、右側が Unicode の文字または数字で始まっているもの) を報告します。 例: 'String sql = \"SELECT column\" +\n               \"FROM table\";' 連結の左側と右側の両方がリテラルである場合にのみ報告するには、「可変長文字列による連結を無視する」オプションを使用します。",
                  "markdown": "空白が欠落している文字列連結 (左側が Unicode の文字または数字で終わり、右側が Unicode の文字または数字で始まっているもの) を報告します。\n\n**例:**\n\n\n      String sql = \"SELECT column\" +\n                   \"FROM table\";\n\n\n連結の左側と右側の両方がリテラルである場合にのみ報告するには、「**可変長文字列による連結を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationMissingWhitespace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StandardVariableNames",
                "shortDescription": {
                  "text": "標準変数名"
                },
                "fullDescription": {
                  "text": "変数のうち、型に対応しない '標準的' な名前を持つものを報告します。 このような名前は混乱を招く可能性があります。 特定の型に対応する標準的な名前を以下に示しています。 i, j, k, m, n - 'int' f - 'float' d - 'double' b - 'byte' c, ch - 'char' l - 'long' s, str - 'String' エディター内でのみ、名前の変更クイックフィックスが提案されます。 直接のスーパーメソッドのパラメーター名と同じパラメーター名を無視するには、オプションを使用します。",
                  "markdown": "変数のうち、型に対応しない '標準的' な名前を持つものを報告します。 このような名前は混乱を招く可能性があります。 特定の型に対応する標準的な名前を以下に示しています。\n\n* i, j, k, m, n - `int`\n* f - `float`\n* d - `double`\n* b - `byte`\n* c, ch - `char`\n* l - `long`\n* s, str - `String`\n\nエディター内でのみ、名前の変更クイックフィックスが提案されます。\n\n\n直接のスーパーメソッドのパラメーター名と同じパラメーター名を無視するには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StandardVariableNames",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規約",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfConcreteClass",
                "shortDescription": {
                  "text": "具象クラスの使用"
                },
                "fullDescription": {
                  "text": "インターフェースではなく、具象クラスが使用されていることを報告します。 このような宣言は抽象化の失敗を引き起こし、テストをより困難にする可能性があります。 クラスがシステムまたはサードパーティのライブラリに由来している宣言は、このインスペクションでは報告されません。 キャスト、instanceof、およびローカル変数は、'equals()' メソッドの実装では報告されません。 また、キャストは 'clone()' メソッドの実装では報告されません。 例: 'interface Entity {}\n  class EntityImpl implements Entity {}\n\n  void processObject(Object obj) {\n    // 警告: 具象クラスの instanceof\n    if (obj instanceof EntityImpl) {\n      // 警告: インターフェースではなく、\n      // 具象クラスにキャスト\n      processEntity((EntityImpl)obj);\n    }\n  }\n  // 警告: 具象のパラメーター\n  void processEntity(EntityImpl obj) {\n  }' 抽象クラスへのキャストを無視するには、「抽象クラス型を無視する」オプションを使用します。 問題の報告対象となるコンテキストを制御するには、次のオプションを使用します。",
                  "markdown": "インターフェースではなく、具象クラスが使用されていることを報告します。 このような宣言は抽象化の失敗を引き起こし、テストをより困難にする可能性があります。\n\n\nクラスがシステムまたはサードパーティのライブラリに由来している宣言は、このインスペクションでは報告されません。\nキャスト、instanceof、およびローカル変数は、`equals()` メソッドの実装では報告されません。\nまた、キャストは `clone()` メソッドの実装では報告されません。\n\n例:\n\n\n      interface Entity {}\n      class EntityImpl implements Entity {}\n\n      void processObject(Object obj) {\n        // 警告: 具象クラスの instanceof\n        if (obj instanceof EntityImpl) {\n          // 警告: インターフェースではなく、\n          // 具象クラスにキャスト\n          processEntity((EntityImpl)obj);\n        }\n      }\n      // 警告: 具象のパラメーター\n      void processEntity(EntityImpl obj) {\n      }\n\n\n抽象クラスへのキャストを無視するには、「**抽象クラス型を無視する**」オプションを使用します。\n\n問題の報告対象となるコンテキストを制御するには、次のオプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfConcreteClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeconstructionCanBeUsed",
                "shortDescription": {
                  "text": "レコードパターンを使用できます"
                },
                "fullDescription": {
                  "text": "レコードパターンに置換できるパターンを報告します。 例: 'record Point(int x, int y) {\n    static void printSum(Object obj) {\n      if (obj instanceof Point p) {\n        int x = p.x();\n        int y = p.y();\n        System.out.println(x + y);\n      }\n    }\n  }' クイックフィックス適用後: 'record Point(int x, int y) {\n    static void printSum(Object obj) {\n      if (obj instanceof Point(int x, int y)) {\n        System.out.println(x + y);\n      }\n    }\n  }' 2023.1 の新機能です このインスペクションは Java 21 以降で使用できる Java の機能 'パターンガードおよびレコードパターン' に依存しています。",
                  "markdown": "レコードパターンに置換できるパターンを報告します。\n\n例:\n\n\n      record Point(int x, int y) {\n        static void printSum(Object obj) {\n          if (obj instanceof Point p) {\n            int x = p.x();\n            int y = p.y();\n            System.out.println(x + y);\n          }\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      record Point(int x, int y) {\n        static void printSum(Object obj) {\n          if (obj instanceof Point(int x, int y)) {\n            System.out.println(x + y);\n          }\n        }\n      }\n\n2023.1 の新機能です\n\nこのインスペクションは Java 21 以降で使用できる Java の機能 'パターンガードおよびレコードパターン' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeconstructionCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 21",
                      "index": 75,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLabeledSwitchRuleCodeBlock",
                "shortDescription": {
                  "text": "冗長なコードブロックがあるラベル付き switch ルール"
                },
                "fullDescription": {
                  "text": "'switch' ステートメントのラベル付きルール、または冗長なコードブロックを持つ 'switch' 式を報告します。 例: 'String s = switch (n) {\n    case 1 -> { yield Integer.toString(n); }\n    default -> \"default\";\n  };' クイックフィックス適用後: 'String s = switch (n) {\n    case 1 -> Integer.toString(n);\n    default -> \"default\";\n  };' 2019.1 の新機能です このインスペクションは Java 14 以降で使用できる Java の機能 '拡張 'switch' ブロック' に依存しています。",
                  "markdown": "`switch` ステートメントのラベル付きルール、または冗長なコードブロックを持つ `switch` 式を報告します。\n\n例:\n\n\n      String s = switch (n) {\n        case 1 -> { yield Integer.toString(n); }\n        default -> \"default\";\n      };\n\nクイックフィックス適用後:\n\n\n      String s = switch (n) {\n        case 1 -> Integer.toString(n);\n        default -> \"default\";\n      };\n\n2019.1 の新機能です\n\nこのインスペクションは Java 14 以降で使用できる Java の機能 '拡張 'switch' ブロック' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantLabeledSwitchRuleCodeBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IOStreamConstructor",
                "shortDescription": {
                  "text": "'InputStream' と 'OutputStream' は 'Files' メソッドを使用して作成できます"
                },
                "fullDescription": {
                  "text": "'Files.newInputStream()' または 'Files.newOutputStream()' の呼び出しにそれぞれ置換できる 'new FileInputStream()' または 'new FileOutputStream()' 式を報告します。 'Files' メソッドを使用して作成されるストリームは、ストリームコンストラクターを使用して作成されるものよりも一般的に効率が良くなります。 例: 'InputStream is = new BufferedInputStream(new FileInputStream(file));' クイックフィックス適用後: 'InputStream is = new BufferedInputStream(Files.newInputStream(file.toPath()));' このインスペクションは言語レベルが 10 レベル以上の場合は警告を表示しませんが、その場合でもクイックフィックスは使用できます。 このインスペクションは、プロジェクトまたはモジュールの言語レベルが 7 以上の場合にのみ報告します。 2022.1 の新機能です",
                  "markdown": "`Files.newInputStream()` または `Files.newOutputStream()` の呼び出しにそれぞれ置換できる `new FileInputStream()` または `new FileOutputStream()` 式を報告します。   \n`Files` メソッドを使用して作成されるストリームは、ストリームコンストラクターを使用して作成されるものよりも一般的に効率が良くなります。\n\n例:\n\n\n      InputStream is = new BufferedInputStream(new FileInputStream(file));\n\nクイックフィックス適用後:\n\n\n      InputStream is = new BufferedInputStream(Files.newInputStream(file.toPath()));\n\nこのインスペクションは言語レベルが 10 レベル以上の場合は警告を表示しませんが、その場合でもクイックフィックスは使用できます。\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 7 以上の場合にのみ報告します。\n\n2022.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IOStreamConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToForLoopParameter",
                "shortDescription": {
                  "text": "'for' ループパラメーターへの代入"
                },
                "fullDescription": {
                  "text": "ループ本文内の 'for' ループパラメーターへの代入、または変更を報告します。 意図している場合もありますが、このようなコンストラクトは混乱を招く可能性があり、タイプミスや誤った変数の使用によって生じていることがしばしばです。 このクイックフィックスは新しい変数の宣言を追加します。 例: 'for (String s : list) {\n    // 警告: s がループ内で変更されています\n    s = s.trim();\n    System.out.println(\"String: \" + s);\n  }' クイックフィックス適用後: 'for (String s : list) {\n    String trimmed = s.trim();\n    System.out.println(\"String: \" + trimmed);\n  }' 更新を行うステートメントのない基本的な 'for' ループでの代入は報告されません。 そのような場合、代入は意図的である可能性が高く、'for' ループの更新部分に移動することは容易ではありません。 例: 'for (int i = 0; i < list.size(); ) {\n    if (element.equals(list.get(i))) {\n      list.remove(i);\n    } else {\n      // 更新を行うステートメントがないため\n      // for ループパラメーターの変更は報告されません\n      i++;\n    }\n  }' 「拡張 'for' ループパラメーターをチェック」オプションを使用すると、拡張 'for' ループパラメーターの変更も報告するかどうかを指定できます。",
                  "markdown": "ループ本文内の `for` ループパラメーターへの代入、または変更を報告します。\n\n意図している場合もありますが、このようなコンストラクトは混乱を招く可能性があり、タイプミスや誤った変数の使用によって生じていることがしばしばです。\n\nこのクイックフィックスは新しい変数の宣言を追加します。\n\n**例:**\n\n\n      for (String s : list) {\n        // 警告: s がループ内で変更されています\n        s = s.trim();\n        System.out.println(\"String: \" + s);\n      }\n\nクイックフィックス適用後:\n\n\n      for (String s : list) {\n        String trimmed = s.trim();\n        System.out.println(\"String: \" + trimmed);\n      }\n\n更新を行うステートメントのない基本的な `for` ループでの代入は報告されません。\nそのような場合、代入は意図的である可能性が高く、`for` ループの更新部分に移動することは容易ではありません。\n\n**例:**\n\n\n      for (int i = 0; i < list.size(); ) {\n        if (element.equals(list.get(i))) {\n          list.remove(i);\n        } else {\n          // 更新を行うステートメントがないため\n          // for ループパラメーターの変更は報告されません\n          i++;\n        }\n      }\n\n「**拡張 'for' ループパラメーターをチェック** 」オプションを使用すると、拡張 `for` ループパラメーターの変更も報告するかどうかを指定できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToForLoopParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代入関連の問題",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9CollectionFactory",
                "shortDescription": {
                  "text": "コレクションのファクトリ呼び出しに置換可能なイミュータブルコレクションの作成"
                },
                "fullDescription": {
                  "text": "変更不可能な 'java.util.Collections' コレクションの呼び出しで、より新しいコレクションのファクトリメソッドに変換できるものを報告します。 このような呼び出しは、Java 9 で導入された 'List.of()' や 'Set.of()'、もしくは Java 10 で導入された 'List.copyOf()' などに置換できます。 Java 9 コレクションのファクトリメソッドは、'java.util.Collections' のメソッドと以下の点で異なります。 'null' 値を受け付けない。 Set の要素と Map のキーが一意でなくてはいけない。 返されるコレクションのクエリメソッド ('List.contains()' や 'Map.get()' など) に 'null' 引数を使用できない。 これらのケースに違反している場合、例外がスローされます。 そのため、移行後にコードのセマンティクスが変更される場合があります。 例: 'List<Integer> even = Collections.unmodifiableList(\n    Arrays.asList(2, 4, 6, 8, 10, 2));\n  List<Integer> evenCopy = Collections.unmodifiableList(\n    new ArrayList<>(list1));' クイックフィックス適用後: 'List<Integer> even = List.of(2, 4, 6, 8, 10, 2);\n  List<Integer> evenCopy = List.copyOf(list);' 指定されている引数がコンパイル時定数である場合にのみ報告する場合は、「内容が定数でない場合に警告しない」オプションを使用します。 これにより、動作が変わる可能性が低くなります。元の要素が一意であり、かつ 'null' ではないということを静的に確認できるとは限らないためです。 10 個以上のエントリを持つ変更不可能なマップを 'Map.ofEntries()' に置換することを提案するには、「'Map.ofEntries()' の提案」オプションを使用します。 2017.2 の新機能です このインスペクションは Java 9 以降で使用できる Java の機能 'コレクションファクトリメソッド' に依存しています。",
                  "markdown": "変更不可能な `java.util.Collections` コレクションの呼び出しで、より新しいコレクションのファクトリメソッドに変換できるものを報告します。 このような呼び出しは、Java 9 で導入された `List.of()` や `Set.of()`、もしくは Java 10 で導入された `List.copyOf()` などに置換できます。\n\nJava 9 コレクションのファクトリメソッドは、`java.util.Collections` のメソッドと以下の点で異なります。\n\n* `null` 値を受け付けない。\n* Set の要素と Map のキーが一意でなくてはいけない。\n* 返されるコレクションのクエリメソッド (`List.contains()` や `Map.get()` など) に `null` 引数を使用できない。\n\nこれらのケースに違反している場合、例外がスローされます。\nそのため、移行後にコードのセマンティクスが変更される場合があります。\n\n例:\n\n\n      List<Integer> even = Collections.unmodifiableList(\n        Arrays.asList(2, 4, 6, 8, 10, 2));\n      List<Integer> evenCopy = Collections.unmodifiableList(\n        new ArrayList<>(list1));\n\nクイックフィックス適用後:\n\n\n      List<Integer> even = List.of(2, 4, 6, 8, 10, 2);\n      List<Integer> evenCopy = List.copyOf(list);\n\n\n指定されている引数がコンパイル時定数である場合にのみ報告する場合は、「**内容が定数でない場合に警告しない** 」オプションを使用します。\nこれにより、動作が変わる可能性が低くなります。元の要素が一意であり、かつ `null` ではないということを静的に確認できるとは限らないためです。\n\n\n10 個以上のエントリを持つ変更不可能なマップを `Map.ofEntries()` に置換することを提案するには、「**'Map.ofEntries()' の提案**」オプションを使用します。\n\n2017.2 の新機能です\n\nこのインスペクションは Java 9 以降で使用できる Java の機能 'コレクションファクトリメソッド' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "Java9CollectionFactory",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 9",
                      "index": 76,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExceptionFromCatchWhichDoesntWrap",
                "shortDescription": {
                  "text": "キャッチされた例外を無視する 'catch' ブロック内の 'throw'"
                },
                "fullDescription": {
                  "text": "'catch' ブロック内からスローされているものの、キャッチした例外を「ラップ」していない例外を報告します。 例外に反応して例外がスローされる場合、最初の例外をラップするとスタックフレームや行番号などの有益なコンテキスト情報を失うのを防ぐことが出来ます。 例: '...\n  catch (IOException e) {\n    closeAllConnections();\n    throw new ConnectException(\"Connection problem.\"); // 警告: 'catch' ブロック内の 'throw' はキャッチされた 'e' を無視しています\n  }' インスペクションの構成: 'getMessage()' のように、元の例外でのメソッド呼び出しの結果が引数になっている例外をこのインスペクションが無視するかどうかを指定するには、「例外メソッド呼び出しの結果が使用されている場合は無視する」オプションを使用します。 'Throwable' 節を受け付けるコンストラクターのない例外をスローする 'throw' ステートメントを無視するには、「スローされた例外が例外をラップできない場合は無視する」オプションを使用します。",
                  "markdown": "`catch` ブロック内からスローされているものの、キャッチした例外を「ラップ」していない例外を報告します。\n\n例外に反応して例外がスローされる場合、最初の例外をラップするとスタックフレームや行番号などの有益なコンテキスト情報を失うのを防ぐことが出来ます。\n\n**例:**\n\n\n      ...\n      catch (IOException e) {\n        closeAllConnections();\n        throw new ConnectException(\"Connection problem.\"); // 警告: 'catch' ブロック内の 'throw' はキャッチされた 'e' を無視しています\n      }\n\nインスペクションの構成:\n\n* `getMessage()` のように、元の例外でのメソッド呼び出しの結果が引数になっている例外をこのインスペクションが無視するかどうかを指定するには、「**例外メソッド呼び出しの結果が使用されている場合は無視する**」オプションを使用します。\n* `Throwable` 節を受け付けるコンストラクターのない例外をスローする `throw` ステートメントを無視するには、「**スローされた例外が例外をラップできない場合は無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowInsideCatchBlockWhichIgnoresCaughtException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodOnlyUsedFromInnerClass",
                "shortDescription": {
                  "text": "内部クラスからのみ使用される private メソッド"
                },
                "fullDescription": {
                  "text": "'private' メソッドで、そのメソッドを含んでいるクラスの内部クラスからのみ呼び出されているものを報告します。 このようなメソッドは、対象の内部クラスに安全に移動できます。 例: 'public class Outer {\n  public static void main(String[] args) {\n    new Inner().run(args[0]);\n  }\n\n  static class Inner {\n    void run(String arg) {\n      // Method isEmpty() は Inner クラスからのみ使用されています\n      // Inner クラスにメソッドを移動することを検討してください\n      if (!isEmpty(arg)) {\n        System.out.println(\"Argument is supplied\");\n      }\n    }\n  }\n\n  private static boolean isEmpty(String s) {\n    return s != null && s.trim().isEmpty();\n  }\n}' 匿名クラスまたはローカルクラスから呼び出される 'private' メソッドを無視するには、以下にある最初のチェックボックスを使用します。 'static' メソッドのみを報告するには、3 番目のチェックボックスを使用します。",
                  "markdown": "`private` メソッドで、そのメソッドを含んでいるクラスの内部クラスからのみ呼び出されているものを報告します。 このようなメソッドは、対象の内部クラスに安全に移動できます。\n\n例:\n\n\n    public class Outer {\n      public static void main(String[] args) {\n        new Inner().run(args[0]);\n      }\n\n      static class Inner {\n        void run(String arg) {\n          // Method isEmpty() は Inner クラスからのみ使用されています\n          // Inner クラスにメソッドを移動することを検討してください\n          if (!isEmpty(arg)) {\n            System.out.println(\"Argument is supplied\");\n          }\n        }\n      }\n\n      private static boolean isEmpty(String s) {\n        return s != null && s.trim().isEmpty();\n      }\n    }\n\n\n匿名クラスまたはローカルクラスから呼び出される `private` メソッドを無視するには、以下にある最初のチェックボックスを使用します。\n\n\n`static` メソッドのみを報告するには、3 番目のチェックボックスを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodOnlyUsedFromInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparisonToNaN",
                "shortDescription": {
                  "text": "'Double.NaN' または 'Float.NaN' との比較"
                },
                "fullDescription": {
                  "text": "'Double.NaN' または 'Float.NaN' に対する比較を報告します。 NaN はそれ自身を含めて等しいものがないため、このような比較は意味がありません。 'Double.isNaN()' または 'Float.isNaN()' メソッドを代わりに使用してください。 例: 'if (x == Double.NaN) {...}' クイックフィックス適用後: 'if (Double.isNaN(x)) {...}'",
                  "markdown": "`Double.NaN` または `Float.NaN` に対する比較を報告します。 NaN はそれ自身を含めて等しいものがないため、このような比較は意味がありません。 `Double.isNaN()` または `Float.isNaN()` メソッドを代わりに使用してください。\n\n**例:**\n\n\n      if (x == Double.NaN) {...}\n\nクイックフィックス適用後:\n\n\n      if (Double.isNaN(x)) {...}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparisonToNaN",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultiCatchCanBeSplit",
                "shortDescription": {
                  "text": "別々の catch ブロックに分割可能な複数 catch"
                },
                "fullDescription": {
                  "text": "複数の 'catch' 節を含むセクションを報告し、個別の 'catch' ブロックに分割することを提案します。 例: 'try {\n    int i = getIndex();\n  } catch (NullPointerException|IndexOutOfBoundsException e) {\n    e.printStackTrace();\n  }' クイックフィックス適用後: 'try {\n    int i = getIndex();\n  } catch (NullPointerException e) {\n    e.printStackTrace();\n  } catch (IndexOutOfBoundsException e) {\n    e.printStackTrace();\n  }' このインスペクションは Java 7 以降で使用できる Java の機能 '複数 catch' に依存しています。",
                  "markdown": "複数の `catch` 節を含むセクションを報告し、個別の `catch` ブロックに分割することを提案します。\n\n例:\n\n\n      try {\n        int i = getIndex();\n      } catch (NullPointerException|IndexOutOfBoundsException e) {\n        e.printStackTrace();\n      }\n\nクイックフィックス適用後:\n\n\n      try {\n        int i = getIndex();\n      } catch (NullPointerException e) {\n        e.printStackTrace();\n      } catch (IndexOutOfBoundsException e) {\n        e.printStackTrace();\n      }\n\nこのインスペクションは Java 7 以降で使用できる Java の機能 '複数 catch' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MultiCatchCanBeSplit",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ResultSetIndexZero",
                "shortDescription": {
                  "text": "JDBC ResultSet でのインデックス 0 の使用"
                },
                "fullDescription": {
                  "text": "'java.sql.ResultSet' または 'java.sql.PreparedStatement' の 0 列へのアクセス試行を報告します。 歴史的な理由から、'java.sql.ResultSet' と 'java.sql.PreparedStatement' の列には 0 ではなく 1 で始まる番号が付けられているため、JDBC のプログラミングでは 0 列が誤ってアクセスされることがよくあります。 例: 'String getName(ResultSet rs) {\n    return rs.getString(0);\n  }'",
                  "markdown": "`java.sql.ResultSet` または `java.sql.PreparedStatement` の 0 列へのアクセス試行を報告します。 歴史的な理由から、`java.sql.ResultSet` と `java.sql.PreparedStatement` の列には **0** ではなく **1** で始まる番号が付けられているため、JDBC のプログラミングでは 0 列が誤ってアクセスされることがよくあります。\n\n**例:**\n\n\n      String getName(ResultSet rs) {\n        return rs.getString(0);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfIndexZeroInJDBCResultSet",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionCoveredByFurtherCondition",
                "shortDescription": {
                  "text": "後続の条件でカバーされている条件"
                },
                "fullDescription": {
                  "text": "後続の条件によって完全にカバーされる内容であるため、結果的に冗長となる条件を報告します。 たとえば、'value != -1 && value > 0' という条件では最初の部分が冗長です。最初の部分が false と評価されると、2 つ目の部分も false になります。 また、'obj != null && obj instanceof String' のような条件では、'instanceof' 演算子が null になり得ないことを暗示しているため、null チェックは冗長です。 2018.3 の新機能です",
                  "markdown": "後続の条件によって完全にカバーされる内容であるため、結果的に冗長となる条件を報告します。\n\nたとえば、`value != -1 && value > 0` という条件では最初の部分が冗長です。最初の部分が false と評価されると、2 つ目の部分も false になります。\nまた、`obj != null && obj instanceof String` のような条件では、`instanceof` 演算子が null になり得ないことを暗示しているため、null チェックは冗長です。\n\n2018.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConditionCoveredByFurtherCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MetaAnnotationWithoutRuntimeRetention",
                "shortDescription": {
                  "text": "'@Retention(RUNTIME)' アノテーションのないテストアノテーション"
                },
                "fullDescription": {
                  "text": "JUnit 5 で使用すべき 'SOURCE' または 'CLASS' 保持ポリシーを含むアノテーションを報告します。 このようなアノテーションは実行時には使用できないため、リフレクションを通じてアクセスできるように保持ポリシーを修正する必要があると思われます。 保持ポリシーが指定されていない場合は、デフォルトの保持ポリシー 'CLASS' が使用されることに注意してください。 例: '@Testable\n  public @interface UnitTest {}' クイックフィックス適用後: '@Retention(RetentionPolicy.RUNTIME)\n  @Testable\n  public @interface UnitTest {}'",
                  "markdown": "JUnit 5 で使用すべき `SOURCE` または `CLASS` 保持ポリシーを含むアノテーションを報告します。 このようなアノテーションは実行時には使用できないため、リフレクションを通じてアクセスできるように保持ポリシーを修正する必要があると思われます。\n\n保持ポリシーが指定されていない場合は、デフォルトの保持ポリシー `CLASS` が使用されることに注意してください。\n\n**例:**\n\n\n      @Testable\n      public @interface UnitTest {}\n\nクイックフィックス適用後:\n\n\n      @Retention(RetentionPolicy.RUNTIME)\n      @Testable\n      public @interface UnitTest {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MetaAnnotationWithoutRuntimeRetention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JUnit",
                      "index": 77,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternVariableHidesField",
                "shortDescription": {
                  "text": "フィールドを非表示にするパターン変数"
                },
                "fullDescription": {
                  "text": "外部クラスのフィールドと名前がまったく同じパターン変数を報告します。 このような命名を行うと、まったく同じ名前のフィールドを使用することが意図されている場合にパターン変数を誤って使用する可能性があります。 変数の名前を変更するクイックフィックスが提案されます。 例: 'class Pointless {\n    Point p = new Point();\n\n    public void test(Object a) {\n      if (a instanceof Point p) {\n        System.out.print(\"a is a point (\" + p.x + \", \" + p.y + ')');\n      } else {\n        System.out.print(\"p is a point (\" + p.x + \", \" + p.y + ')');\n      }\n    }\n  }' 2022.2 の新機能です",
                  "markdown": "外部クラスのフィールドと名前がまったく同じパターン変数を報告します。 このような命名を行うと、まったく同じ名前のフィールドを使用することが意図されている場合にパターン変数を誤って使用する可能性があります。\n\n\n変数の名前を変更するクイックフィックスが提案されます。\n\n**例:**\n\n\n      class Pointless {\n        Point p = new Point();\n\n        public void test(Object a) {\n          if (a instanceof Point p) {\n            System.out.print(\"a is a point (\" + p.x + \", \" + p.y + ')');\n          } else {\n            System.out.print(\"p is a point (\" + p.x + \", \" + p.y + ')');\n          }\n        }\n      }\n\n2022.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PatternVariableHidesField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JoinDeclarationAndAssignmentJava",
                "shortDescription": {
                  "text": "宣言と結合できる代入"
                },
                "fullDescription": {
                  "text": "変数の宣言と結合できる変数の代入を報告します。 例: 'int x;\n  x = 1;' クイックフィックスを使用すると、代入がイニシャライザーに変換されます。 'int x = 1;' 2018.3 の新機能です",
                  "markdown": "変数の宣言と結合できる変数の代入を報告します。\n\n例:\n\n\n      int x;\n      x = 1;\n\nクイックフィックスを使用すると、代入がイニシャライザーに変換されます。\n\n\n      int x = 1;\n\n2018.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JoinDeclarationAndAssignmentJava",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryContinue",
                "shortDescription": {
                  "text": "不要な 'continue' ステートメント"
                },
                "fullDescription": {
                  "text": "ループ内で最後に到達可能なステートメントになっている 'continue' ステートメントを報告します。 このような 'continue' ステートメントは不要であり、安全に除去できます。 例: 'for (String element: elements) {\n    System.out.println();\n    continue;\n  }' クイックフィックス適用後: 'for (String element: elements) {\n    System.out.println();\n  }' このインスペクションは JSP ファイルを解析しません。 完全な 'if'-'else' ステートメントの 'then' 分岐にある 'continue' ステートメントを無視するには、「'else' 分岐のある 'if' ステートメントの then 分岐で無視する」オプションを使用します。 例: 'for (String element: elements) {\n    if(element.isEmpty()) {\n      continue;\n    } else {\n      //...\n    }\n  }'",
                  "markdown": "ループ内で最後に到達可能なステートメントになっている `continue` ステートメントを報告します。 このような `continue` ステートメントは不要であり、安全に除去できます。\n\n例:\n\n\n      for (String element: elements) {\n        System.out.println();\n        continue;\n      }\n\nクイックフィックス適用後:\n\n\n      for (String element: elements) {\n        System.out.println();\n      }\n\nこのインスペクションは JSP ファイルを解析しません。\n\n\n完全な `if`-`else` ステートメントの `then` 分岐にある `continue` ステートメントを無視するには、「**'else' 分岐のある 'if' ステートメントの then 分岐で無視する**」オプションを使用します。\n\n例:\n\n\n      for (String element: elements) {\n        if(element.isEmpty()) {\n          continue;\n        } else {\n          //...\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryContinue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InnerClassVariableHidesOuterClassVariable",
                "shortDescription": {
                  "text": "外部クラスフィールドを非表示にする内部クラスフィールド"
                },
                "fullDescription": {
                  "text": "外部クラスのフィールドと名前がまったく同じ内部クラスフィールドを報告します。 このような命名を行うと、外部クラスの名前がまったく同じフィールドを使用することが意図されている場合に内部クラスのフィールドを誤って使用する可能性があります。 内部クラスのフィールドの名前を変更するクイックフィックスが提案されます。 例: 'class Outer {\n    private String name;\n\n    class Inner {\n      private String name;\n    }\n  }' このインスペクションがすべての名前の競合を報告すべきか、内部クラスから見えるフィールドとの競合のみを報告すべきかを選択するには、オプションを使用します。",
                  "markdown": "外部クラスのフィールドと名前がまったく同じ内部クラスフィールドを報告します。 このような命名を行うと、外部クラスの名前がまったく同じフィールドを使用することが意図されている場合に内部クラスのフィールドを誤って使用する可能性があります。\n\n内部クラスのフィールドの名前を変更するクイックフィックスが提案されます。\n\n**例:**\n\n\n      class Outer {\n        private String name;\n\n        class Inner {\n          private String name;\n        }\n      }\n\n\nこのインスペクションがすべての名前の競合を報告すべきか、内部クラスから見えるフィールドとの競合のみを報告すべきかを選択するには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassFieldHidesOuterClassField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MISSORTED_IMPORTS",
                "shortDescription": {
                  "text": "誤った順序のインポート"
                },
                "fullDescription": {
                  "text": "現在のコードスタイルに従って配置されていない 'import' ステートメントを報告します (「設定|エディター|コードスタイル」を参照してください)。 例: 'import java.util.List;\n  import java.util.ArrayList;\n\n  public class Example {\n    List list = new ArrayList();\n  }' 「インポートの最適化」クイックフィックスを適用後: 'import java.util.ArrayList;\n  import java.util.List;\n\n  public class Example {\n    List list = new ArrayList();\n  }'",
                  "markdown": "現在のコードスタイルに従って配置されていない `import` ステートメントを報告します (「設定\\|エディター\\|コードスタイル」を参照してください)。\n\n**例:**\n\n\n      import java.util.List;\n      import java.util.ArrayList;\n\n      public class Example {\n        List list = new ArrayList();\n      }\n\n「インポートの最適化」クイックフィックスを適用後:\n\n\n      import java.util.ArrayList;\n      import java.util.List;\n\n      public class Example {\n        List list = new ArrayList();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MISSORTED_IMPORTS",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/インポート",
                      "index": 23,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryModifier",
                "shortDescription": {
                  "text": "不要な修飾子"
                },
                "fullDescription": {
                  "text": "冗長な修飾子を報告し、除去することを提案します。 除去することでコードは短縮されますが、動作と意味は変わりません。 例 1: '// Java 17 以降、すべてのコードは暗黙的に strictfp です\n  strictfp class X {\n\n    // 内部列挙型は暗黙的に static です\n    static enum Inner {\n        A, B, C\n    }\n\n    // 内部レコードは暗黙的に static です\n    static record R() {\n    }\n  }' 例 2: 'final record R() {\n    // すべてのレコードは暗黙的に final です\n  }' 例 3: '// すべてのインターフェースは暗黙的に abstract です\n  abstract interface Printer {\n\n    // すべてのインターフェースメンバーは暗黙的に public です\n    public int size();\n\n    // インターフェースのすべての内部クラスは暗黙的に static です\n    static class Inner {}\n  }'",
                  "markdown": "冗長な修飾子を報告し、除去することを提案します。 除去することでコードは短縮されますが、動作と意味は変わりません。\n\n**例 1:**\n\n\n      // Java 17 以降、すべてのコードは暗黙的に strictfp です\n      strictfp class X {\n\n        // 内部列挙型は暗黙的に static です\n        static enum Inner {\n            A, B, C\n        }\n\n        // 内部レコードは暗黙的に static です\n        static record R() {\n        }\n      }\n\n**例 2:**\n\n\n      final record R() {\n        // すべてのレコードは暗黙的に final です\n      }\n\n**例 3:**\n\n\n      // すべてのインターフェースは暗黙的に abstract です\n      abstract interface Printer {\n\n        // すべてのインターフェースメンバーは暗黙的に public です\n        public int size();\n\n        // インターフェースのすべての内部クラスは暗黙的に static です\n        static class Inner {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonThreadSafeLazyInitialization",
                "shortDescription": {
                  "text": "安全でない 'static' フィールドの遅延初期化"
                },
                "fullDescription": {
                  "text": "スレッドセーフな方法で遅延初期化されている 'static' 変数を報告します。 異なるスレッドによる初期化の競合を防ぐため、'static' 変数の遅延初期化は適切な同期コンストラクトで行う必要があります。 遅延初期化ホルダークラスイディオムを導入するクイックフィックスが適切な場合に提案されます。 このイディオムは、クラスが使用されるまでは初期化されないことを JVM が保証しているという事実を利用しています。 例: 'class X {\n    private static List<String> list;\n\n    public List<String> getList() {\n      if (list == null) {\n        list = List.of(\"one\", \"two\", \"tree\");\n      }\n      return list;\n    }\n  }' クイックフィックス適用後: 'class X {\n    private static final class ListHolder {\n      static final List<String> list = List.of(\"one\", \"two\", \"tree\");\n    }\n\n    public List<String> getList() {\n      return ListHolder.list;\n    }\n  }'",
                  "markdown": "スレッドセーフな方法で遅延初期化されている `static` 変数を報告します。\n\n異なるスレッドによる初期化の競合を防ぐため、`static` 変数の遅延初期化は適切な同期コンストラクトで行う必要があります。\n\n[遅延初期化ホルダークラスイディオム](https://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom)を導入するクイックフィックスが適切な場合に提案されます。\nこのイディオムは、クラスが使用されるまでは初期化されないことを JVM が保証しているという事実を利用しています。\n\n**例:**\n\n\n      class X {\n        private static List<String> list;\n\n        public List<String> getList() {\n          if (list == null) {\n            list = List.of(\"one\", \"two\", \"tree\");\n          }\n          return list;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class X {\n        private static final class ListHolder {\n          static final List<String> list = List.of(\"one\", \"two\", \"tree\");\n        }\n\n        public List<String> getList() {\n          return ListHolder.list;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonThreadSafeLazyInitialization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初期化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalCanBePushedInsideExpression",
                "shortDescription": {
                  "text": "条件式を分岐式の中にプッシュ可能"
                },
                "fullDescription": {
                  "text": "非常に類似した 'then' 分岐と else 分岐を含む条件式があり、その式を内側に移動できる場合に報告します。 そのように処理することで、コード量を削減できます。 例: 'double g(int a, int b) {\n    return a == b ? Math.cos(0) : Math.cos(1);\n  }' クイックフィックス適用後: 'double g(int a, int b) {\n    return Math.cos(a == b ? 0 : 1);\n  }' 2017.2 の新機能です",
                  "markdown": "非常に類似した `then` 分岐と else 分岐を含む条件式があり、その式を内側に移動できる場合に報告します。 そのように処理することで、コード量を削減できます。\n\n例:\n\n\n      double g(int a, int b) {\n        return a == b ? Math.cos(0) : Math.cos(1);\n      }\n\nクイックフィックス適用後:\n\n\n      double g(int a, int b) {\n        return Math.cos(a == b ? 0 : 1);\n      }\n\n2017.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConditionalCanBePushedInsideExpression",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneInNonCloneableClass",
                "shortDescription": {
                  "text": "非 Cloneable クラスの 'clone()' メソッド"
                },
                "fullDescription": {
                  "text": "'clone()' メソッドをオーバーライドしているものの、'Cloneable' インターフェースを実装していないクラスを報告します。 これは多くの場合、プログラミングに問題があることを表しています。 非 'public' のメソッドを無視するには、「'public' の clone メソッドについてのみ警告する」オプションを使用します。 継承するように設計されたクラスの場合、'Cloneable' インターフェースを実装せずに 'clone()' をオーバーライドして 'protected' として宣言し、サブクラスに 'Cloneable' インターフェースを実装するかどうかを選択できます。",
                  "markdown": "`clone()` メソッドをオーバーライドしているものの、`Cloneable` インターフェースを実装していないクラスを報告します。 これは多くの場合、プログラミングに問題があることを表しています。\n\n\n非 `public` のメソッドを無視するには、「**'public' の clone メソッドについてのみ警告する**」オプションを使用します。\n\n継承するように設計されたクラスの場合、`Cloneable` インターフェースを実装せずに `clone()` をオーバーライドして `protected` として宣言し、サブクラスに `Cloneable` インターフェースを実装するかどうかを選択できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneInNonCloneableClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クローン関連の問題",
                      "index": 79,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CStyleArrayDeclaration",
                "shortDescription": {
                  "text": "C 形式の配列宣言"
                },
                "fullDescription": {
                  "text": "C 形式の構文で書かれた配列の宣言で、配列の角括弧が変数名またはメソッドのパラメーターリストの後にあるものを報告します。 多くのコードスタイルでは、次のように配列の角括弧を型の名前の後に配置した Java 形式の配列宣言が推奨されています。 例: 'public String process(String value[])[] {\n    return value;\n  }' クイックフィックス適用後: 'public String[] process(String[] value) {\n    return value;\n  }' インスペクションの構成: メソッドの戻り値の型が C 形式の配列で宣言されているものだけを報告するには、「変数内の C 形式の宣言を無視」オプションを使用します。",
                  "markdown": "C 形式の構文で書かれた配列の宣言で、配列の角括弧が変数名またはメソッドのパラメーターリストの後にあるものを報告します。 多くのコードスタイルでは、次のように配列の角括弧を型の名前の後に配置した Java 形式の配列宣言が推奨されています。\n\n**例:**\n\n\n      public String process(String value[])[] {\n        return value;\n      }\n\nクイックフィックス適用後:\n\n\n      public String[] process(String[] value) {\n        return value;\n      }\n\nインスペクションの構成:\n\n\nメソッドの戻り値の型が C 形式の配列で宣言されているものだけを報告するには、「**変数内の C 形式の宣言を無視**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CStyleArrayDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8ListReplaceAll",
                "shortDescription": {
                  "text": "ループは 'List.replaceAll()' に置換できます"
                },
                "fullDescription": {
                  "text": "単一の 'List.replaceAll()' の呼び出しに縮小できるループを報告します。 例: 'for (int i = 0; i < strings.size(); i++) {\n    String str = strings.get(i).toLowerCase();\n    strings.set(i, str);\n  }' クイックフィックス適用後: 'strings.replaceAll(String::toLowerCase);' 2022.1 の新機能です このインスペクションは Java 8 以降で使用できる Java の機能 'コレクション内のラムダメソッド' に依存しています。",
                  "markdown": "単一の `List.replaceAll()` の呼び出しに縮小できるループを報告します。\n\n**例:**\n\n\n      for (int i = 0; i < strings.size(); i++) {\n        String str = strings.get(i).toLowerCase();\n        strings.set(i, str);\n      }\n\nクイックフィックス適用後:\n\n\n      strings.replaceAll(String::toLowerCase);\n\n2022.1 の新機能です\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'コレクション内のラムダメソッド' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8ListReplaceAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemExit",
                "shortDescription": {
                  "text": "'System.exit()' または関連するメソッド呼び出し"
                },
                "fullDescription": {
                  "text": "'System.exit()'、'Runtime.exit()'、および 'Runtime.halt()' の呼び出しを報告します。 'System.exit()' または 'Runtime.exit()' を呼び出すと、シャットダウンフックが呼び出され、実行中の Java 仮想マシンが終了します。 'Runtime.halt()' を強制的に呼び出すと、シャットダウンフックが起動されずに JVM が終了します。 これらのメソッドはすべて、細心の注意を払って使用すべきです。 これらのメソッドを呼び出している場合、呼び出し元のコードをほとんどのアプリケーションサーバーに移植できなくなります。 main メソッド内の呼び出しを無視するには、オプションを使用します。",
                  "markdown": "`System.exit()`、`Runtime.exit()`、および `Runtime.halt()` の呼び出しを報告します。\n\n\n`System.exit()` または `Runtime.exit()` を呼び出すと、シャットダウンフックが呼び出され、実行中の Java 仮想マシンが終了します。 `Runtime.halt()` を強制的に呼び出すと、シャットダウンフックが起動されずに JVM が終了します。\nこれらのメソッドはすべて、細心の注意を払って使用すべきです。 これらのメソッドを呼び出している場合、呼び出し元のコードをほとんどのアプリケーションサーバーに移植できなくなります。\n\n\nmain メソッド内の呼び出しを無視するには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemExit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ポータビリティ",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BigDecimalLegacyMethod",
                "shortDescription": {
                  "text": "'BigDecimal' レガシーメソッド呼び出し"
                },
                "fullDescription": {
                  "text": "'BigDecimal.divide()' または 'BigDecimal.setScale()' の呼び出しで、整数定数を使用して丸めモードを指定しているものを報告します。 JDK 1.5 以降は、'RoundingMode' 'enum' パラメーターを取るメソッドを代わりに使用することを検討してください。 例: 'new BigDecimal(\"42\").setScale(2, BigDecimal.ROUND_FLOOR);' クイックフィックス適用後: 'new BigDecimal(\"42\").setScale(2, RoundingMode.FLOOR);'",
                  "markdown": "`BigDecimal.divide()` または `BigDecimal.setScale()` の呼び出しで、整数定数を使用して丸めモードを指定しているものを報告します。 JDK 1.5 以降は、`RoundingMode` `enum` パラメーターを取るメソッドを代わりに使用することを検討してください。\n\n**例:**\n\n    new BigDecimal(\"42\").setScale(2, BigDecimal.ROUND_FLOOR);\n\nクイックフィックス適用後:\n\n    new BigDecimal(\"42\").setScale(2, RoundingMode.FLOOR);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BigDecimalLegacyMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeclareCollectionAsInterface",
                "shortDescription": {
                  "text": "インターフェースではなくクラスによって宣言されたコレクション"
                },
                "fullDescription": {
                  "text": "適切なインターフェースではなく、コレクションクラスを型として使用して作成されている 'Collection' 変数の宣言を報告します。 変数の型を弱化するとコンパイラーエラーが発生する場合は、警告は表示されません。 例: '// 警告: 具象コレクションクラスである ArrayList が使用されています。\n  int getTotalLength(ArrayList<String> list) {\n    return list.stream().mapToInt(String::length).sum();\n  }\n\n  // trimToSize() メソッドは List インターフェースでは\n  // 使用できないため、警告は表示されません。\n  void addData(ArrayList<String> data) {\n    data.add(\"Hello\");\n    data.add(\"World\");\n    data.trimToSize();\n  }' 適切なコレクションインターフェース ('Collection'、'Set'、'List' など) を使用するためのクイックフィックスが提案されます。",
                  "markdown": "適切なインターフェースではなく、コレクションクラスを型として使用して作成されている `Collection` 変数の宣言を報告します。 変数の型を弱化するとコンパイラーエラーが発生する場合は、警告は表示されません。\n\n例:\n\n\n      // 警告: 具象コレクションクラスである ArrayList が使用されています。\n      int getTotalLength(ArrayList<String> list) {\n        return list.stream().mapToInt(String::length).sum();\n      }\n\n      // trimToSize() メソッドは List インターフェースでは\n      // 使用できないため、警告は表示されません。\n      void addData(ArrayList<String> data) {\n        data.add(\"Hello\");\n        data.add(\"World\");\n        data.trimToSize();\n      }\n\n適切なコレクションインターフェース (`Collection`、`Set`、`List` など) を使用するためのクイックフィックスが提案されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionDeclaredAsConcreteClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrivialStringConcatenation",
                "shortDescription": {
                  "text": "空の文字列との連結"
                },
                "fullDescription": {
                  "text": "文字列連結内の空文字列オペランドを報告します。 空文字列との連結は 'String' でないオブジェクトまたはプリミティブを 'String' に変換するために使用できますが、'String.valueOf()' メソッド呼び出しを使用する方が明確になる可能性があります。 連結を単純化するクイックフィックスが提案されます。 例: 'void foo(int x, int y) {\n    String s = \"\" + x + \" ; \" + y;\n  }' クイックフィックス適用後: 'void foo(int x, int y) {\n    String s = x + \" ; \" + y;\n  }' 空文字列を除去するのに別オペランドの 'String.valueOf()' 変換を追加する必要がある状況を無視するには、「他を変更せずに空文字列を除去できる状況のみを報告する」オプションを使用します。",
                  "markdown": "文字列連結内の空文字列オペランドを報告します。 空文字列との連結は `String` でないオブジェクトまたはプリミティブを `String` に変換するために使用できますが、`String.valueOf()` メソッド呼び出しを使用する方が明確になる可能性があります。\n\n\n連結を単純化するクイックフィックスが提案されます。\n\n**例:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nクイックフィックス適用後:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n\n\n空文字列を除去するのに別オペランドの `String.valueOf()` 変換を追加する必要がある状況を無視するには、「**他を変更せずに空文字列を除去できる状況のみを報告する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConcatenationWithEmptyString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousInvocationHandlerImplementation",
                "shortDescription": {
                  "text": "疑わしい 'InvocationHandler' の実装"
                },
                "fullDescription": {
                  "text": "'hashCode()'、'equals()'、'toString()' などの標準 'Object' メソッドをプロキシしていない 'InvocationHandler' の実装を報告します。 これらのメソッドの処理に失敗すると、プロキシインスタンスに対してメソッドを呼び出すときに予期しない問題が発生する可能性があります。 例: 'InvocationHandler myHandler = (proxy, method, params) -> {\n    System.out.println(\"Hello World!\");\n    return null;\n  };\n  Runnable myProxy = (Runnable) Proxy.newProxyInstance(\n    Thread.currentThread().getContextClassLoader(),\n    new Class[] {Runnable.class}, myHandler\n  );' このコードスニペットは、'Runnable.run()' メソッドのみをプロキシするように設計されています。 ただし、'hashCode()' などの 'Object' メソッドの呼び出しもプロキシされます。 そのため、'myProxy' を 'HashSet' に追加する場合などに 'NullPointerException' のような問題が発生する可能性があります。 2020.2 の新機能です",
                  "markdown": "`hashCode()`、`equals()`、`toString()` などの標準 `Object` メソッドをプロキシしていない `InvocationHandler` の実装を報告します。\n\nこれらのメソッドの処理に失敗すると、プロキシインスタンスに対してメソッドを呼び出すときに予期しない問題が発生する可能性があります。\n\n**例:**\n\n\n      InvocationHandler myHandler = (proxy, method, params) -> {\n        System.out.println(\"Hello World!\");\n        return null;\n      };\n      Runnable myProxy = (Runnable) Proxy.newProxyInstance(\n        Thread.currentThread().getContextClassLoader(),\n        new Class[] {Runnable.class}, myHandler\n      );\n\n\nこのコードスニペットは、`Runnable.run()` メソッドのみをプロキシするように設計されています。\nただし、`hashCode()` などの `Object` メソッドの呼び出しもプロキシされます。\nそのため、`myProxy` を `HashSet` に追加する場合などに `NullPointerException` のような問題が発生する可能性があります。\n\n2020.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousInvocationHandlerImplementation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingPackageInfo",
                "shortDescription": {
                  "text": "欠落した 'package-info.java'"
                },
                "fullDescription": {
                  "text": "クラスを含むものの、'package-info.java' または 'package.html' ファイルを含んでおらず、結果的にパッケージのドキュメントが欠落しているパッケージを報告します。 このクイックフィックスは最初の 'package-info.java' ファイルを作成します。",
                  "markdown": "クラスを含むものの、`package-info.java` または `package.html` ファイルを含んでおらず、結果的にパッケージのドキュメントが欠落しているパッケージを報告します。\n\nこのクイックフィックスは最初の `package-info.java` ファイルを作成します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MissingPackageInfo",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryConstructor",
                "shortDescription": {
                  "text": "冗長な引数なしのコンストラクター"
                },
                "fullDescription": {
                  "text": "不要なコンストラクターを報告します。 クラスの唯一のコンストラクターであり、パラメーターがなく、その包含クラスと同じアクセス修飾子を持つコンストラクターは不要であり、引数なしでスーパークラスのコンストラクターを明示的または暗黙的に呼び出す以外は初期化を行いません。 このようなコンストラクターは未指定であってもコンパイラーによって生成されるため、安全に除去できます。 例: 'public class Foo {\n    public Foo() {}\n  }' クイックフィックス適用後: 'public class Foo {}' アノテーション付きの不要なコンストラクターを無視するには、インスペクションの設定を使用します。",
                  "markdown": "不要なコンストラクターを報告します。\n\n\nクラスの唯一のコンストラクターであり、パラメーターがなく、その包含クラスと同じアクセス修飾子を持つコンストラクターは不要であり、引数なしでスーパークラスのコンストラクターを明示的または暗黙的に呼び出す以外は初期化を行いません。\nこのようなコンストラクターは未指定であってもコンパイラーによって生成されるため、安全に除去できます。\n\n**例:**\n\n\n      public class Foo {\n        public Foo() {}\n      }\n\nクイックフィックス適用後:\n\n\n      public class Foo {}\n\n\nアノテーション付きの不要なコンストラクターを無視するには、インスペクションの設定を使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantNoArgConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnreachableCode",
                "shortDescription": {
                  "text": "到達不能コード"
                },
                "fullDescription": {
                  "text": "データフローを解析した結果、到達することがないと判断されたコードを報告します。 このようなコードは、常に結果が true または常に false になる先行する条件の結果、到達不能な loop 本体または catch 部である可能性があります。 通常 (常にではありません)、到達不能コードは先行する警告の結果であるため、原因をよりよく理解するには、\"null 許容性とデータフローの問題\"、\"定数値\"、または \"空のコンテナーでの冗長な操作\" インスペクションの警告を確認してください。 例: 'void finishApplication() {\n    System.exit(0);\n    System.out.println(\"Application is terminated\"); // 到達不能コード\n  }' このインスペクションはメソッド契約の推論に依存することに注意してください。 特に常に例外をスローする static または final メソッドを呼び出す場合は「常に失敗する」契約が推論され、メソッド呼び出し後のコードは到達不能と見なされます。 例: 'void run() {\n    performAction();\n    System.out.println(\"Action is performed\"); // 到達不能コード\n  }\n  \n  static void performAction() {\n    throw new AssertionError();\n  }' そのため、どんなコードの後処理が行われていても誤検知が発生する可能性があります。たとえば、アノテーションプロセッサが後でメソッド本体を有効な内容に置換する処理を行っている場合が挙げられます。 誤検知の警告を回避するには、次のように 'org.jetbrains:annotations' パッケージの明示的な '@org.jetbrains.annotations.Contract' アノテーションを使用して自動コントラクト推論を抑止してください。 'void run() {\n    performAction();\n    System.out.println(\"Action is performed\"); // もう警告は発生しません\n  }\n\n  @Contract(\"-> _\") // 実装は置換されます\n  static void performAction() {\n    throw new AssertionError();\n  }' 2024.1 の新機能です",
                  "markdown": "データフローを解析した結果、到達することがないと判断されたコードを報告します。 このようなコードは、常に結果が true または常に false になる先行する条件の結果、到達不能な loop 本体または catch 部である可能性があります。 通常 (常にではありません)、到達不能コードは先行する警告の結果であるため、原因をよりよく理解するには、\"null 許容性とデータフローの問題\"、\"定数値\"、または \"空のコンテナーでの冗長な操作\" インスペクションの警告を確認してください。\n\n例:\n\n\n      void finishApplication() {\n        System.exit(0);\n        System.out.println(\"Application is terminated\"); // 到達不能コード\n      }\n\n\nこのインスペクションはメソッド契約の推論に依存することに注意してください。 特に常に例外をスローする static または final メソッドを呼び出す場合は「常に失敗する」契約が推論され、メソッド呼び出し後のコードは到達不能と見なされます。 例:\n\n\n      void run() {\n        performAction();\n        System.out.println(\"Action is performed\"); // 到達不能コード\n      }\n      \n      static void performAction() {\n        throw new AssertionError();\n      }\n\n\nそのため、どんなコードの後処理が行われていても誤検知が発生する可能性があります。たとえば、アノテーションプロセッサが後でメソッド本体を有効な内容に置換する処理を行っている場合が挙げられます。 誤検知の警告を回避するには、次のように `org.jetbrains:annotations` パッケージの明示的な\n`@org.jetbrains.annotations.Contract` アノテーションを使用して自動コントラクト推論を抑止してください。\n\n\n      void run() {\n        performAction();\n        System.out.println(\"Action is performed\"); // もう警告は発生しません\n      }\n\n      @Contract(\"-> _\") // 実装は置換されます\n      static void performAction() {\n        throw new AssertionError();\n      }\n\n2024.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnreachableCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlTagCanBeJavadocTag",
                "shortDescription": {
                  "text": "'<code>…</code>' は '{@code …}' に置換できます"
                },
                "fullDescription": {
                  "text": "Javadoc コメントで '<code>' タグが使用されていることを報告します。 Java 5 以降、このようなタグは '{@code ...}' コンストラクトに置換できます。 これにより、コメント内で HTML 文字エンティティの代わりに山括弧の '<' と '>' を使用できるようになっています。 例: '/**\n   * @return empty <code>ArrayList&lt;Integer&gt;</code>\n   */\n  List<Integer> getList(){ ... }' クイックフィックス適用後: '/**\n   * @return empty {@code ArrayList<Integer>}\n   */\n  List<Integer> getList(){ ... }'",
                  "markdown": "Javadoc コメントで `<code>` タグが使用されていることを報告します。 Java 5 以降、このようなタグは `{@code ...}` コンストラクトに置換できます。 これにより、コメント内で HTML 文字エンティティの代わりに山括弧の `<` と `>` を使用できるようになっています。\n\n**例:**\n\n\n      /**\n       * @return empty <code>ArrayList&lt;Integer&gt;</code>\n       */\n      List<Integer> getList(){ ... }\n\nクイックフィックス適用後:\n\n\n      /**\n       * @return empty {@code ArrayList<Integer>}\n       */\n      List<Integer> getList(){ ... }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlTagCanBeJavadocTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringBufferField",
                "shortDescription": {
                  "text": "'StringBuilder' フィールド"
                },
                "fullDescription": {
                  "text": "型が 'java.lang.StringBuffer' または 'java.lang.StringBuilder' のフィールドを報告します。 このようなフィールドは無制限に肥大化する可能性があるため、往々にしてメモリリークの原因になります。 例: 'public class Example {\n    private StringBuilder builder = new StringBuilder();\n\n  }'",
                  "markdown": "型が `java.lang.StringBuffer` または `java.lang.StringBuilder` のフィールドを報告します。 このようなフィールドは無制限に肥大化する可能性があるため、往々にしてメモリリークの原因になります。\n\n**例:**\n\n\n      public class Example {\n        private StringBuilder builder = new StringBuilder();\n\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringBufferField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メモリ",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassEscapesItsScope",
                "shortDescription": {
                  "text": "クラスは可視性スコープの外側で公開されています"
                },
                "fullDescription": {
                  "text": "フィールドまたはメソッドのシグネチャー内のクラスで、クラスの可視性がそのクラスを使用するメンバーよりも低くなっているものの使用箇所を報告します。 このようなメンバーは Java では有効ですが、参照しているクラス型の可視範囲外では使用できません。 例: 'public class Parent {\n    public Child getChild() {\n      return new Child();\n    }\n\n    private class Child {}\n  }' また、Java 9 以降ではパッケージをエクスポートしないことで、あるモジュールのクラスの一部を他のモジュールから非表示にできます。 ただし、エクスポートされた API の一部になっているメンバーがそのシグネチャーでエクスポートされていないクラスを参照している場合、このようなメンバーはモジュール外で使用できません。 インスペクションの構成: エクスポートされていないクラスを公開しているモジュールの API メンバーを報告するには、「モジュール API (Java 9 以降) で公開されているエクスポートされていないクラスを報告する」オプションを使用します。 このオプションを使用する場合、プロジェクトまたはモジュールの言語レベルを 9 以降にする必要があります。 より可視範囲が小さいクラスを公開している public メンバーを報告するには、「公開 API で公開されているアクセスできないクラスを報告する」オプションを使用します。 'private' クラスを公開しているパッケージローカルのメンバーについて報告するには、「パッケージローカル API で公開されている private クラスを報告する」オプションを使用します。",
                  "markdown": "フィールドまたはメソッドのシグネチャー内のクラスで、クラスの可視性がそのクラスを使用するメンバーよりも低くなっているものの使用箇所を報告します。 このようなメンバーは Java では有効ですが、参照しているクラス型の可視範囲外では使用できません。\n\n**例:**\n\n\n      public class Parent {\n        public Child getChild() {\n          return new Child();\n        }\n\n        private class Child {}\n      }\n\n\nまた、Java 9 以降ではパッケージをエクスポートしないことで、あるモジュールのクラスの一部を他のモジュールから非表示にできます。\nただし、エクスポートされた API の一部になっているメンバーがそのシグネチャーでエクスポートされていないクラスを参照している場合、このようなメンバーはモジュール外で使用できません。\n\nインスペクションの構成:\n\n* エクスポートされていないクラスを公開しているモジュールの API メンバーを報告するには、「**モジュール API (Java 9 以降) で公開されているエクスポートされていないクラスを報告する** 」オプションを使用します。  \n  このオプションを使用する場合、プロジェクトまたはモジュールの言語レベルを 9 以降にする必要があります。\n* より可視範囲が小さいクラスを公開している public メンバーを報告するには、「**公開 API で公開されているアクセスできないクラスを報告する**」オプションを使用します。\n* `private` クラスを公開しているパッケージローカルのメンバーについて報告するには、「**パッケージローカル API で公開されている private クラスを報告する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassEscapesDefinedScope",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNameSameAsAncestorName",
                "shortDescription": {
                  "text": "祖先と同じ名前のクラス名"
                },
                "fullDescription": {
                  "text": "スーパークラスのいずれかと同じ名前であるものの、完全修飾名は異なっているクラスを報告します。 このようなクラス名は大きな混乱を招く可能性があります。 例: 'package util;\n  abstract class Iterable<T> implements java.lang.Iterable<T> {}' このようなクラスの名前を変更するクイックフィックスは、エディターでのみ使用できます。",
                  "markdown": "スーパークラスのいずれかと同じ名前であるものの、完全修飾名は異なっているクラスを報告します。 このようなクラス名は大きな混乱を招く可能性があります。\n\n**例:**\n\n\n      package util;\n      abstract class Iterable<T> implements java.lang.Iterable<T> {}\n\nこのようなクラスの名前を変更するクイックフィックスは、エディターでのみ使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassNameSameAsAncestorName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規則/クラス",
                      "index": 68,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantMethodOverride",
                "shortDescription": {
                  "text": "スーパーメソッドと同じメソッド"
                },
                "fullDescription": {
                  "text": "スーパーメソッドとまったく同じメソッドを報告します。 このようなメソッドは、スーパーメソッドと同じシグネチャーを持ち、本体がまったく同じであるか、本体がスーパーメソッドの呼び出しのみで構成されています。 このようなメソッドは冗長であり、除去できます。 ライブラリメソッドをオーバーライドしているメソッドに対してインスペクションを実行するには、以下の 1 つ目のチェックボックスを使用します。 ライブラリメソッドをチェックすると、インスペクションが遅くなる可能性があります。 スーパーメソッドに呼び出しを委譲するだけのメソッドを無視するには、以下の 2 つ目のチェックボックスを使用します。",
                  "markdown": "スーパーメソッドとまったく同じメソッドを報告します。 このようなメソッドは、スーパーメソッドと同じシグネチャーを持ち、本体がまったく同じであるか、本体がスーパーメソッドの呼び出しのみで構成されています。 このようなメソッドは冗長であり、除去できます。\n\n\nライブラリメソッドをオーバーライドしているメソッドに対してインスペクションを実行するには、以下の 1 つ目のチェックボックスを使用します。\nライブラリメソッドをチェックすると、インスペクションが遅くなる可能性があります。\n\n\nスーパーメソッドに呼び出しを委譲するだけのメソッドを無視するには、以下の 2 つ目のチェックボックスを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantMethodOverride",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsUsesNonFinalVariable",
                "shortDescription": {
                  "text": "'equals()' で参照される非 final のフィールド"
                },
                "fullDescription": {
                  "text": "非 'final' 変数にアクセスしている 'equals()' の実装を報告します。 このようなアクセスを行うと、'equals()' がオブジェクトのライフサイクルのさまざまな時点で異なる結果を返す可能性があります。その結果、標準コレクションクラスを使用する際に問題が発生する可能性があります。 例: 'public class Person {\n    private String lastName;\n\n    @Override\n    public boolean equals(Object obj) {\n      ...\n      Person other = (Person) obj;\n      if (lastName == null) {\n        if (!lastName.equals(other.lastName)) {\n        return false;\n      ...\n      }\n    }\n  }'",
                  "markdown": "非 `final` 変数にアクセスしている `equals()` の実装を報告します。 このようなアクセスを行うと、`equals()` がオブジェクトのライフサイクルのさまざまな時点で異なる結果を返す可能性があります。その結果、標準コレクションクラスを使用する際に問題が発生する可能性があります。\n\n**例:**\n\n\n      public class Person {\n        private String lastName;\n\n        @Override\n        public boolean equals(Object obj) {\n          ...\n          Person other = (Person) obj;\n          if (lastName == null) {\n            if (!lastName.equals(other.lastName)) {\n            return false;\n          ...\n          }\n        }\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldReferenceInEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ContinueStatementWithLabel",
                "shortDescription": {
                  "text": "ラベル付きの 'continue' ステートメント"
                },
                "fullDescription": {
                  "text": "ラベル付きの 'continue' ステートメントを報告します。 ラベル付きの 'continue' ステートメントはリファクタリングを複雑にし、混乱を招く可能性があります。 例: 'void handle(List<String> strs) {\n    outer:\n    for (String s: strs) {\n      for (char ch : s.toCharArray()) {\n        if ('s' == ch) continue outer;\n        handleChar(ch);\n      }\n    }\n  }'",
                  "markdown": "ラベル付きの `continue` ステートメントを報告します。\n\nラベル付きの `continue` ステートメントはリファクタリングを複雑にし、混乱を招く可能性があります。\n\n例:\n\n\n      void handle(List<String> strs) {\n        outer:\n        for (String s: strs) {\n          for (char ch : s.toCharArray()) {\n            if ('s' == ch) continue outer;\n            handleChar(ch);\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ContinueStatementWithLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedAssignment",
                "shortDescription": {
                  "text": "ネストした代入"
                },
                "fullDescription": {
                  "text": "他の式の中にネストしている代入式を報告します。 そのような式は混乱を招く可能性があり、コンストラクトが 1 つのみのタスクを実行するという一般的な設計原則に違反しています。 例: 'String userName;\n  // 警告: 'userName' への代入結果が使用されています\n  String message = \"Hello \" + (userName = \"Alice\") + \"!\"\n  System.out.println(message);\n  System.out.println(\"Goodbye \" + userName);'",
                  "markdown": "他の式の中にネストしている代入式を報告します。\n\nそのような式は混乱を招く可能性があり、コンストラクトが 1 つのみのタスクを実行するという一般的な設計原則に違反しています。\n\n**例:**\n\n\n      String userName;\n      // 警告: 'userName' への代入結果が使用されています\n      String message = \"Hello \" + (userName = \"Alice\") + \"!\"\n      System.out.println(message);\n      System.out.println(\"Goodbye \" + userName);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代入関連の問題",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AutoUnboxing",
                "shortDescription": {
                  "text": "オートアンボクシング"
                },
                "fullDescription": {
                  "text": "アンボクシング変換 (オブジェクトをプリミティブ値に自動アンラップ) の影響を受ける式を報告します。 オブジェクトをプリミティブの代わりに使用しないようにしてください。 使用した場合、パフォーマンスに大きな影響を与える可能性があります。 例: 'int x = new Integer(42);' クイックフィックスを使用すると、変換が明示的になります。 'int x = new Integer(42).intValue();' オートアンボクシングは Java 5 で登場しました。 このインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。",
                  "markdown": "アンボクシング変換 (オブジェクトをプリミティブ値に自動アンラップ) の影響を受ける式を報告します。 オブジェクトをプリミティブの代わりに使用しないようにしてください。 使用した場合、パフォーマンスに大きな影響を与える可能性があります。\n\n**例:**\n\n    int x = new Integer(42);\n\nクイックフィックスを使用すると、変換が明示的になります。\n\n    int x = new Integer(42).intValue();\n\n\n*オートアンボクシング*は Java 5 で登場しました。\nこのインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AutoUnboxing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableBooleanExpression",
                "shortDescription": {
                  "text": "単純化できるブール式"
                },
                "fullDescription": {
                  "text": "単純化できるブール式を報告します。 例: 'void f(boolean foo, boolean bar) {\n    boolean b = !(foo ^ bar);\n  }' クイックフィックス適用後: 'void f(boolean foo, boolean bar) {\n    boolean b = foo == bar;\n  }' 例: 'void f(boolean foo, boolean bar) {\n    boolean b = (foo && bar) || !foo;\n  }' クイックフィックス適用後: 'void f(boolean foo, boolean bar) {\n    boolean b = !foo || bar;\n  }'",
                  "markdown": "単純化できるブール式を報告します。\n\n例:\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = !(foo ^ bar);\n      }\n\nクイックフィックス適用後:\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = foo == bar;\n      }\n\n例:\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = (foo && bar) || !foo;\n      }\n      \nクイックフィックス適用後:\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = !foo || bar;\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableBooleanExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalFieldInImmutable",
                "shortDescription": {
                  "text": "'@Immutable' クラスの非 final フィールド"
                },
                "fullDescription": {
                  "text": "'@Immutable' アノテーションが付いたクラスにある 非 final フィールドを報告します。 これは '@Immutable' アノテーションの契約に違反しています。 例: 'import javax.annotation.concurrent.Immutable;\n  @Immutable\n  class Foo {\n    String bar = \"foo\";\n  }' サポート対象の '@GuardedBy' アノテーションは以下の通りです。 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "`@Immutable` アノテーションが付いたクラスにある 非 final フィールドを報告します。 これは `@Immutable` アノテーションの契約に違反しています。\n\n例:\n\n\n      import javax.annotation.concurrent.Immutable;\n      @Immutable\n      class Foo {\n        String bar = \"foo\";\n      }\n\nサポート対象の `@GuardedBy` アノテーションは以下の通りです。\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldInImmutable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/並行処理に関するアノテーションの問題",
                      "index": 58,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationInMessageFormatCall",
                "shortDescription": {
                  "text": "文字列連結を 'MessageFormat.format()' の呼び出し引数に使用"
                },
                "fullDescription": {
                  "text": "'MessageFormat.format()' の呼び出しに渡す引数として使用されている非定数の文字列連結を報告します。 このような文字列連結は意図的な場合もありますが、フォーマットメソッドを誤用している場合がほとんどです。また、連結された文字列で使用されている変数に '{' などの特殊文字が含まれている場合には予期しない例外が発生することもあります。 また、',' のつもりで '+' を入力することで、文字列書式設定の引数を誤って連結した結果である可能性もあります。 例: 'String formatGreeting(String userName, int balance) {\n    return MessageFormat.format(\"Hello, \" + userName + \"! Your balance is {0}.\", balance);\n  }' この例では、'userName' がフォーマット文字列の一部として解釈されます。その結果、'IllegalArgumentException' が発生する可能性があります ('userName' が '\"{\"' の場合など)。 この呼び出しは 'MessageFormat.format(\"Hello, {0}! Your balance is {1}.\", userName, balance)' に置換する必要があると思われます。",
                  "markdown": "`MessageFormat.format()` の呼び出しに渡す引数として使用されている非定数の文字列連結を報告します。\n\n\nこのような文字列連結は意図的な場合もありますが、フォーマットメソッドを誤用している場合がほとんどです。また、連結された文字列で使用されている変数に `{` などの特殊文字が含まれている場合には予期しない例外が発生することもあります。\n\n\nまた、`,` のつもりで `+` を入力することで、文字列書式設定の引数を誤って連結した結果である可能性もあります。\n\n**例:**\n\n\n      String formatGreeting(String userName, int balance) {\n        return MessageFormat.format(\"Hello, \" + userName + \"! Your balance is {0}.\", balance);\n      }\n\n\nこの例では、`userName` がフォーマット文字列の一部として解釈されます。その結果、`IllegalArgumentException` が発生する可能性があります (`userName` が `\"{\"` の場合など)。\nこの呼び出しは `MessageFormat.format(\"Hello, {0}! Your balance is {1}.\", userName, balance)` に置換する必要があると思われます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationInMessageFormatCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToStringConcatCanBeReplacedByOperator",
                "shortDescription": {
                  "text": "'+' に置換できる 'String.concat()' への呼び出し"
                },
                "fullDescription": {
                  "text": "'java.lang.String.concat()' の呼び出しを報告します。 メソッドが引数が変わらない定数に対して呼び出されている場合、このような呼び出しを '+' 演算子に置換してコードの明瞭さとパフォーマンスを向上させることができます。 例: 'String foo(String name) {\n    return name.concat(\"foo\");\n  }' クイックフィックス適用後: 'String foo(String name) {\n    return name + \"foo\";\n  }'",
                  "markdown": "`java.lang.String.concat()` の呼び出しを報告します。\n\n\nメソッドが引数が変わらない定数に対して呼び出されている場合、このような呼び出しを `+` 演算子に置換してコードの明瞭さとパフォーマンスを向上させることができます。\n\n**例:**\n\n\n      String foo(String name) {\n        return name.concat(\"foo\");\n      }\n\nクイックフィックス適用後:\n\n\n      String foo(String name) {\n        return name + \"foo\";\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToStringConcatCanBeReplacedByOperator",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SignalWithoutCorrespondingAwait",
                "shortDescription": {
                  "text": "対応する 'await()' のない 'signal()'"
                },
                "fullDescription": {
                  "text": "'Condition.signal()' または 'Condition.signalAll()' の呼び出しのうち、対応する 'Condition.await()' の呼び出しが見つからないものを報告します。 このインスペクションは、現在のクラスのフィールドを対象とする呼び出しのみを報告します。 例: 'class Queue {\n    private final Condition isEmpty = ...;\n\n    void add(Object elem) {\n      // ...\n      isEmpty.signal(); // 警告: 'signal()' が対応する 'await()' なしで呼び出されています\n      // ...\n    }\n\n    void remove(Object elem) throws InterruptedException {\n      // ...\n      //      isEmpty.await();\n      // ...\n    }\n  }'",
                  "markdown": "`Condition.signal()` または `Condition.signalAll()` の呼び出しのうち、対応する `Condition.await()` の呼び出しが見つからないものを報告します。\n\nこのインスペクションは、現在のクラスのフィールドを対象とする呼び出しのみを報告します。\n\n**例:**\n\n\n      class Queue {\n        private final Condition isEmpty = ...;\n\n        void add(Object elem) {\n          // ...\n          isEmpty.signal(); // 警告: 'signal()' が対応する 'await()' なしで呼び出されています\n          // ...\n        }\n\n        void remove(Object elem) throws InterruptedException {\n          // ...\n          //      isEmpty.await();\n          // ...\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SignalWithoutCorrespondingAwait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FoldExpressionIntoStream",
                "shortDescription": {
                  "text": "Stream チェーンに折りたたみ可能な式"
                },
                "fullDescription": {
                  "text": "繰り返しのパターンを持つ式で、Stream API または 'String.join()' の呼び出しに置換できるものを報告します。 例: 'boolean allStartWith(String a, String b, String c, String d, String prefix) {\n    return a.startsWith(prefix) && b.startsWith(prefix) && c.startsWith(prefix) && d.startsWith(prefix);\n  }' クイックフィックス適用後: 'boolean foo(String a, String b, String c, String d, String prefix) {\n    return Stream.of(a, b, c, d).allMatch(s -> s.startsWith(prefix));\n  }' 例: 'String joinAll(String a, String b, String c, String d) {\n    return a + \",\" + b + \",\" + c + \",\" + d;\n  }' クイックフィックス適用後: 'String joinAll(String a, String b, String c, String d) {\n    return String.join(\",\", a, b, c, d);\n  }' 2018.2 の新機能です このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "繰り返しのパターンを持つ式で、*Stream API* または `String.join()` の呼び出しに置換できるものを報告します。\n\n例:\n\n\n      boolean allStartWith(String a, String b, String c, String d, String prefix) {\n        return a.startsWith(prefix) && b.startsWith(prefix) && c.startsWith(prefix) && d.startsWith(prefix);\n      }\n\nクイックフィックス適用後:\n\n\n      boolean foo(String a, String b, String c, String d, String prefix) {\n        return Stream.of(a, b, c, d).allMatch(s -> s.startsWith(prefix));\n      }\n\n例:\n\n\n      String joinAll(String a, String b, String c, String d) {\n        return a + \",\" + b + \",\" + c + \",\" + d;\n      }\n\nクイックフィックス適用後:\n\n\n      String joinAll(String a, String b, String c, String d) {\n        return String.join(\",\", a, b, c, d);\n      }\n\n2018.2 の新機能です\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FoldExpressionIntoStream",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HardcodedFileSeparators",
                "shortDescription": {
                  "text": "ハードコードされたファイル区切り文字"
                },
                "fullDescription": {
                  "text": "文字列または文字リテラル内のスラッシュ ('/') またはバックスラッシュ ('\\') を報告します。 これらの文字はファイルの区切り文字としてよく使用されているため、ハードコードすると移植性に問題が生じる可能性があります。 このインスペクションは、エスケープシーケンス内のバックスラッシュや、'<' 文字の直後または '>' 文字の直前にあるスラッシュを報告しません。そのような文字は、ファイル名ではなく XML タグや HTML タグである可能性が高いためです。 'java.util.TimeZone' ID を表す文字列、有効な正規表現文字列、または IANA に登録されている MIME メディアタイプに等しい文字列も報告されません。 例: 'new File(\"C:\\\\Users\\\\Name\");' 認識された MIME メディアタイプに 'example/*' を含めるには、オプションを使用します。 通常、'example/*' MIME メディアタイプを example の外 ('Content-Type' ヘッダー内など)で使用するのは誤りです。",
                  "markdown": "文字列または文字リテラル内のスラッシュ (`/`) またはバックスラッシュ (`\\`) を報告します。 これらの文字はファイルの区切り文字としてよく使用されているため、ハードコードすると移植性に問題が生じる可能性があります。\n\n\nこのインスペクションは、エスケープシーケンス内のバックスラッシュや、'\\<' 文字の直後または '\\>' 文字の直前にあるスラッシュを報告しません。そのような文字は、ファイル名ではなく XML タグや HTML タグである可能性が高いためです。\n`java.util.TimeZone` ID を表す文字列、有効な正規表現文字列、または IANA に登録されている MIME メディアタイプに等しい文字列も報告されません。\n\n**例:**\n\n\n      new File(\"C:\\\\Users\\\\Name\");\n\n\n認識された MIME メディアタイプに `example/*` を含めるには、オプションを使用します。\n通常、`example/*` MIME メディアタイプを example の外 (`Content-Type` ヘッダー内など)で使用するのは誤りです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HardcodedFileSeparator",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ポータビリティ",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableDeserializableClassInSecureContext",
                "shortDescription": {
                  "text": "セキュリティに考慮が必要な Serializable クラス"
                },
                "fullDescription": {
                  "text": "シリアル化または逆シリアル化できるクラスを報告します。 あるクラスが 'Serializable' インターフェイスをサポートし、その 'readObject()' メソッドと 'writeObject()' メソッドが常に例外をスローするように定義されていない場合、そのクラスはシリアル化できます。 Serializable クラスは、安全に使用することを目的としたコードでは危険な場合があります。 例: 'class DeserializableClass implements Serializable { // クラスに例外をスローする 'writeObject()' メソッドが含まれていません\n    private int sensitive = 736326;\n\n    private void readObject(ObjectInputStream in) {\n        throw new Error();\n    }\n}' クイックフィックス適用後: 'class DeserializableClass implements Serializable {\n    private int sensitive = 736326;\n\n    private void readObject(ObjectInputStream in) {\n        throw new Error();\n    }\n\n    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {\n        throw new java.io.NotSerializableException(\"DeserializableClass\");\n    }\n  }' このインスペクションは、次のオプションを使用して構成できます。 このインスペクションで継承先を報告対象外とするクラスをリストする。 これは、スーパークラスの 'Serializable' を継承しているものの、シリアル化を目的としていないクラスを対象としています。 これらのクラスを無視する代わりに、常に例外をスローする 'readObject()' および 'writeObject()' メソッドを追加する方が安全な場合があります。 シリアル化可能な匿名クラスを無視するかどうか。",
                  "markdown": "シリアル化または逆シリアル化できるクラスを報告します。\n\n\nあるクラスが `Serializable` インターフェイスをサポートし、その `readObject()` メソッドと `writeObject()` メソッドが常に例外をスローするように定義されていない場合、そのクラスはシリアル化できます。 Serializable クラスは、安全に使用することを目的としたコードでは危険な場合があります。\n\n**例:**\n\n\n      class DeserializableClass implements Serializable { // クラスに例外をスローする 'writeObject()' メソッドが含まれていません\n        private int sensitive = 736326;\n\n        private void readObject(ObjectInputStream in) {\n            throw new Error();\n        }\n    }\n\nクイックフィックス適用後:\n\n\n      class DeserializableClass implements Serializable {\n        private int sensitive = 736326;\n\n        private void readObject(ObjectInputStream in) {\n            throw new Error();\n        }\n\n        private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {\n            throw new java.io.NotSerializableException(\"DeserializableClass\");\n        }\n      }\n\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* このインスペクションで継承先を報告対象外とするクラスをリストする。 これは、スーパークラスの `Serializable` を継承しているものの、シリアル化を目的としていないクラスを対象としています。 これらのクラスを無視する代わりに、常に例外をスローする `readObject()` および `writeObject()` メソッドを追加する方が安全な場合があります。\n* シリアル化可能な匿名クラスを無視するかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableDeserializableClassInSecureContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfusingFloatingPointLiteral",
                "shortDescription": {
                  "text": "紛らわしい浮動小数点型リテラル"
                },
                "fullDescription": {
                  "text": "小数点がないか、小数点の前に数字がないか、小数点の後に数字がない浮動小数点数を報告します。 このようなリテラルは混乱を招く可能性があり、いくつかのコーディング標準に違反しています。 例: 'double d = .03;' クイックフィックス適用後: 'double d = 0.03;' 科学表記法の浮動小数点数を無視するには、「科学表記法の浮動小数点リテラルを無視する」オプションを使用します。",
                  "markdown": "小数点がないか、小数点の前に数字がないか、小数点の後に数字がない浮動小数点数を報告します。\n\nこのようなリテラルは混乱を招く可能性があり、いくつかのコーディング標準に違反しています。\n\n**例:**\n\n    double d = .03;\n\nクイックフィックス適用後:\n\n    double d = 0.03;\n\n\n科学表記法の浮動小数点数を無視するには、「**科学表記法の浮動小数点リテラルを無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfusingFloatingPointLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaModuleNaming",
                "shortDescription": {
                  "text": "Java モジュール名が規則と矛盾しています"
                },
                "fullDescription": {
                  "text": "モジュール名が Java Platform Module System の推奨事項と矛盾している場合に報告します。 推奨事項 の 1 つは、モジュール名の末尾に数値の使用を避けることです。 例: 'module foo1.bar2 {}'",
                  "markdown": "モジュール名が Java Platform Module System の推奨事項と矛盾している場合に報告します。\n\n[推奨事項](http://mail.openjdk.org/pipermail/jpms-spec-experts/2017-March/000659.html) の 1 つは、モジュール名の末尾に数値の使用を避けることです。\n\n**例:**\n\n\n    module foo1.bar2 {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaModuleNaming",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規約",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocReference",
                "shortDescription": {
                  "text": "問題のある Javadoc 参照の宣言"
                },
                "fullDescription": {
                  "text": "Javadoc コメント内に未解決の参照があることを報告します。 以下の例では 'someParam' パラメーターがないため、ハイライトされます。 'class A {\n    /**\n     * @param someParam の説明\n     **/\n    void foo() {\n    }\n}' 見つからないメソッドパラメーター、クラス、フィールド、メソッドを参照するタグを無視するには、「アクセスできないシンボルを報告しない」オプションを無効にします。",
                  "markdown": "Javadoc コメント内に未解決の参照があることを報告します。\n\n以下の例では `someParam` パラメーターがないため、ハイライトされます。\n\n\n    class A {\n        /**\n         * @param someParam の説明\n         **/\n        void foo() {\n        }\n    }\n\n\n見つからないメソッドパラメーター、クラス、フィールド、メソッドを参照するタグを無視するには、「**アクセスできないシンボルを報告しない**」オプションを無効にします。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavadocReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnaryPlus",
                "shortDescription": {
                  "text": "単項プラス"
                },
                "fullDescription": {
                  "text": "'+' 単項演算子が使用されていることを報告します。 単項プラスは一般的には無効な演算であり、それが存在するということはコードにミスがある可能性があります。 たとえば、インクリメント演算子との結合 ('+++' など) や等価演算子との結合 ('=+' など) があります。 例: 'void unaryPlus(int i) {\n    int x = + +i;\n  }' 次のクイックフィックスが提案されます。 'i' 変数の前の '+' 演算子を除去: 'void unaryPlus(int i) {\n    int x = i;\n  }' '+' 演算子を前置インクリメント演算に置換: 'void unaryPlus(int i) {\n    int x = ++i;\n  }' 二項式または別の単項式と共に使用されている単項プラスを報告するには、以下のチェックボックスを使用します。 つまり、このインスペクションは単項プラス式が配列イニシャライザー式で使用されている場合や、メソッドの引数として使用されている場合は報告しません。",
                  "markdown": "`+` 単項演算子が使用されていることを報告します。 単項プラスは一般的には無効な演算であり、それが存在するということはコードにミスがある可能性があります。 たとえば、インクリメント演算子との結合 (`+++` など) や等価演算子との結合 (`=+` など) があります。\n\n**例:**\n\n\n      void unaryPlus(int i) {\n        int x = + +i;\n      }\n\n次のクイックフィックスが提案されます。\n\n* `i` 変数の前の `+` 演算子を除去:\n\n\n        void unaryPlus(int i) {\n          int x = i;\n        }\n\n* `+` 演算子を前置インクリメント演算に置換:\n\n\n        void unaryPlus(int i) {\n          int x = ++i;\n        }\n\n\n二項式または別の単項式と共に使用されている単項プラスを報告するには、以下のチェックボックスを使用します。\nつまり、このインスペクションは単項プラス式が配列イニシャライザー式で使用されている場合や、メソッドの引数として使用されている場合は報告しません。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnaryPlus",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstructorCount",
                "shortDescription": {
                  "text": "コンストラクターが多すぎるクラス"
                },
                "fullDescription": {
                  "text": "コンストラクター数が指定された最大値を超えているクラスを報告します。 コンストラクターが多すぎるクラスは初期化エラーが発生する可能性があります。多くの場合、このようなクラスは複数のサブクラスとしてモデリングすることが望ましいと考えられています。 インスペクションの構成: クラスで許容されるコンストラクター数の最大値を指定するには、「コンストラクター数の制限」フィールドを使用します。 非推奨のコンストラクターを合計数から除外するには、「非推奨のコンストラクターを無視する」オプションを使用します。",
                  "markdown": "コンストラクター数が指定された最大値を超えているクラスを報告します。\n\nコンストラクターが多すぎるクラスは初期化エラーが発生する可能性があります。多くの場合、このようなクラスは複数のサブクラスとしてモデリングすることが望ましいと考えられています。\n\nインスペクションの構成:\n\n* クラスで許容されるコンストラクター数の最大値を指定するには、「**コンストラクター数の制限**」フィールドを使用します。\n* 非推奨のコンストラクターを合計数から除外するには、「**非推奨のコンストラクターを無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyConstructors",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラスメトリクス",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DisjointPackage",
                "shortDescription": {
                  "text": "支離滅裂な依存関係グラフを持つパッケージ"
                },
                "fullDescription": {
                  "text": "含んでいるクラスを相互に独立したサブセットに分割できるパッケージを報告します。 このように互いに素なパッケージは、パッケージングが場当たり的であるか、概念的な結合関係が欠落していることを暗に示しています。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "含んでいるクラスを相互に独立したサブセットに分割できるパッケージを報告します。\n\nこのように互いに素なパッケージは、パッケージングが場当たり的であるか、概念的な結合関係が欠落していることを暗に示しています。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DisjointPackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パッケージ関連の問題",
                      "index": 37,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncrementDecrementUsedAsExpression",
                "shortDescription": {
                  "text": "'++' または '--' の結果を使用"
                },
                "fullDescription": {
                  "text": "他の式の中にネストしているインクリメント式またはデクリメント式を報告します。 そのような式は混乱を招く可能性があり、コンストラクトが 1 つのみのタスクを実行するという一般的な設計原則に違反しています。 クイックフィックスを使用すると、インクリメント演算またはデクリメント演算が別の式ステートメントに抽出されます。 例: 'int i = 10;\n  while (i-- > 0) {\n    System.out.println(i);\n  }' クイックフィックス適用後: 'int i = 10;\n  while (i > 0) {\n    i--;\n    System.out.println(i);\n  }\n  i--;'",
                  "markdown": "他の式の中にネストしているインクリメント式またはデクリメント式を報告します。 そのような式は混乱を招く可能性があり、コンストラクトが 1 つのみのタスクを実行するという一般的な設計原則に違反しています。\n\nクイックフィックスを使用すると、インクリメント演算またはデクリメント演算が別の式ステートメントに抽出されます。\n\n**例:**\n\n\n      int i = 10;\n      while (i-- > 0) {\n        System.out.println(i);\n      }\n\nクイックフィックス適用後:\n\n\n      int i = 10;\n      while (i > 0) {\n        i--;\n        System.out.println(i);\n      }\n      i--;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ValueOfIncrementOrDecrementUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代入関連の問題",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodOverloadsParentMethod",
                "shortDescription": {
                  "text": "意図していない可能性のあるスーパークラスメソッドのオーバーロード"
                },
                "fullDescription": {
                  "text": "スーパークラスのメソッドと同じ名前と同じパラメーター数を持ち、1 つ以上のパラメーターが互換性のない異なる型になっているインスタンスメソッドを報告します。 このような場合、サブクラスのメソッドはスーパークラスのメソッドをオーバーライドする代わりにオーバーロードします。 これが意図したものでない場合は、潜在的なバグが発生する可能性があります。 例: 'public class Foo {\n    void foo(int x) {}\n  }\n\n  public class Bar extends Foo {\n    void foo(Number x) {} // Method 'foo()' はオーバーライドが意図されている可能性がある場合に\n                          // 互換性のあるスーパークラスのメソッドをオーバーロードします\n  }' このインスペクションがパラメーターの型に互換性がない状況も報告する必要があるかどうかを選択するには、オプションを使用します。",
                  "markdown": "スーパークラスのメソッドと同じ名前と同じパラメーター数を持ち、1 つ以上のパラメーターが互換性のない異なる型になっているインスタンスメソッドを報告します。\n\n\nこのような場合、サブクラスのメソッドはスーパークラスのメソッドをオーバーライドする代わりにオーバーロードします。 これが意図したものでない場合は、潜在的なバグが発生する可能性があります。\n\n**例:**\n\n\n      public class Foo {\n        void foo(int x) {}\n      }\n\n      public class Bar extends Foo {\n        void foo(Number x) {} // Method 'foo()' はオーバーライドが意図されている可能性がある場合に\n                              // 互換性のあるスーパークラスのメソッドをオーバーロードします\n      }\n\n\nこのインスペクションがパラメーターの型に互換性がない状況も報告する必要があるかどうかを選択するには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodOverloadsMethodOfSuperclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodMayBeSynchronized",
                "shortDescription": {
                  "text": "単一の 'synchronized' ブロックを持つメソッドは 'synchronized' メソッドに置換できます"
                },
                "fullDescription": {
                  "text": "メソッド本体に 1 つの 'synchronized' ステートメントが含まれているメソッドを報告します。 このような 'synchronized' ステートメントに対するロック式は、インスタンスメソッドの場合は 'this'、static メソッドの場合は '[ClassName].class' と等しくなければなりません。 このようなメソッドを読みやすくするため、'synchronized' ラッパーを除去してメソッドに 'synchronized' を指定できます。 例: 'public int generateInt(int x) {\n    synchronized (this) {\n      return 1;\n    }\n  }' クイックフィックス適用後: 'public synchronized int generateInt(int x) {\n    return 1;\n  }'",
                  "markdown": "メソッド本体に 1 つの `synchronized` ステートメントが含まれているメソッドを報告します。 このような `synchronized` ステートメントに対するロック式は、インスタンスメソッドの場合は `this`、static メソッドの場合は `[ClassName].class` と等しくなければなりません。\n\n\nこのようなメソッドを読みやすくするため、`synchronized` ラッパーを除去してメソッドに `synchronized` を指定できます。\n\n**例:**\n\n\n      public int generateInt(int x) {\n        synchronized (this) {\n          return 1;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public synchronized int generateInt(int x) {\n        return 1;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodMayBeSynchronized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UpperCaseFieldNameNotConstant",
                "shortDescription": {
                  "text": "大文字の名前を持つ非定数フィールド"
                },
                "fullDescription": {
                  "text": "名前がすべて大文字のフィールドを含む非 'static' の非 'final' フィールドを報告します。 このようなフィールドは一般的な命名規則に違反しているため、混乱を招く可能性があり、しばしば誤って使用されています。 例: 'public static int THE_ANSWER = 42; // ここで警告が発生します: final 修飾子がありません' このようなフィールドの名前を変更するクイックフィックスは、エディターでのみ使用できます。",
                  "markdown": "名前がすべて大文字のフィールドを含む非 `static` の非 `final` フィールドを報告します。\n\nこのようなフィールドは一般的な命名規則に違反しているため、混乱を招く可能性があり、しばしば誤って使用されています。\n\n**例:**\n\n\n      public static int THE_ANSWER = 42; // ここで警告が発生します: final 修飾子がありません\n\nこのようなフィールドの名前を変更するクイックフィックスは、エディターでのみ使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonConstantFieldWithUpperCaseName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規約",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggingPlaceholderCountMatchesArgumentCount",
                "shortDescription": {
                  "text": "ロギング呼び出しの引数の数と一致しないプレースホルダーの数"
                },
                "fullDescription": {
                  "text": "'logger.info(\"{}: {}\", key)' などの SLF4J、Log4j2 および akka.event.LoggingAdapter ロギング呼び出しで、ロガーメッセージに含まれる '{}' プレースホルダーの数がロギング呼び出しの他の引数の数と一致していないものを報告します。 SLF4J が使用する実装を指定するには、インスペクションのオプションを使用します。 「自動的に確認する」が選択されている場合は、クラスパス内の 'org.apache.logging.slf4j.Log4jLogger' が検索されます。 SLFJ4 API ではこのファイルが見つかったか「はい」が選択されている場合、例外の型がある最後のパラメーターにプレースホルダーがある場合は報告されません。 例: '//この場合は「はい」オプションでは報告されません\nlog.error(\"For id {}: {}\", \"1\", new RuntimeException());' この場合、'new RuntimeException()' は 'toString()' を使用して出力されます (スタックトレースは出力されません)。 'For id 1: java.lang.RuntimeException' それ以外の場合は最後のプレースホルダーは使用されないため、ハイライトされます。 'For id 1: {}\njava.lang.RuntimeException: null' 「いいえ」オプションは 'org.apache.logging.slf4j.Log4jLogger' がバックエンドとして使用されていてもプレースホルダーが例外に使用されている状況を常にハイライトするために使用できます。",
                  "markdown": "`logger.info(\"{}: {}\", key)` などの SLF4J、Log4j2 および akka.event.LoggingAdapter ロギング呼び出しで、ロガーメッセージに含まれる `{}` プレースホルダーの数がロギング呼び出しの他の引数の数と一致していないものを報告します。\n\n\nSLF4J が使用する実装を指定するには、インスペクションのオプションを使用します。\n「**自動的に確認する** 」が選択されている場合は、クラスパス内の `org.apache.logging.slf4j.Log4jLogger` が検索されます。\nSLFJ4 API ではこのファイルが見つかったか「**はい** 」が選択されている場合、例外の型がある最後のパラメーターにプレースホルダーがある場合は報告されません。  \n\n例:\n\n\n    //この場合は「はい」オプションでは報告されません\n    log.error(\"For id {}: {}\", \"1\", new RuntimeException());\n\nこの場合、'new RuntimeException()' は 'toString()' を使用して出力されます (スタックトレースは出力されません)。\n\n\n    For id 1: java.lang.RuntimeException\n\nそれ以外の場合は最後のプレースホルダーは使用されないため、ハイライトされます。\n\n\n    For id 1: {}\n    java.lang.RuntimeException: null\n\n「**いいえ** 」オプションは `org.apache.logging.slf4j.Log4jLogger` がバックエンドとして使用されていてもプレースホルダーが例外に使用されている状況を常にハイライトするために使用できます。  "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoggingPlaceholderCountMatchesArgumentCount",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語/ログ関連",
                      "index": 45,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Convert2streamapi",
                "shortDescription": {
                  "text": "Stream API で折りたたみ可能なループ"
                },
                "fullDescription": {
                  "text": "ラムダ式を使用するストリーム API の呼び出しに置換できるループを報告します。 このような置換を行うと、命令的なスタイルが機能的なスタイルへと変わり、コードがよりコンパクトになります。 例: 'boolean check(List<String> data) {\n    for (String e : data) {\n      String trimmed = e.trim();\n      if (!trimmed.startsWith(\"xyz\")) {\n        return false;\n      }\n    }\n    return true;\n  }' クイックフィックス適用後: 'boolean check(List<String> data) {\n    return data.stream().map(String::trim).allMatch(trimmed -> trimmed.startsWith(\"xyz\"));\n  }' このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "ラムダ式を使用するストリーム API の呼び出しに置換できるループを報告します。\n\nこのような置換を行うと、命令的なスタイルが機能的なスタイルへと変わり、コードがよりコンパクトになります。\n\n例:\n\n\n      boolean check(List<String> data) {\n        for (String e : data) {\n          String trimmed = e.trim();\n          if (!trimmed.startsWith(\"xyz\")) {\n            return false;\n          }\n        }\n        return true;\n      }\n\nクイックフィックス適用後:\n\n\n      boolean check(List<String> data) {\n        return data.stream().map(String::trim).allMatch(trimmed -> trimmed.startsWith(\"xyz\"));\n      }\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "Convert2streamapi",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerialPersistentFieldsWithWrongSignature",
                "shortDescription": {
                  "text": "'private static final ObjectStreamField[]' と宣言されていない 'serialPersistentFields' フィールド"
                },
                "fullDescription": {
                  "text": "'Serializable' クラスで、その 'serialPersistentFields' フィールドが 'private static final ObjectStreamField[]' で宣言されていないものを報告します。 'serialPersistentFields' フィールドがこれらの修飾子で宣言されていない場合、シリアル化はフィールドがまったく宣言されていないかのように動作します。 例: 'class List implements Serializable {\n    private List next;\n\n    ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"next\", List.class)};\n\n  }'",
                  "markdown": "`Serializable` クラスで、その `serialPersistentFields` フィールドが `private static final ObjectStreamField[]` で宣言されていないものを報告します。\n\n\n`serialPersistentFields` フィールドがこれらの修飾子で宣言されていない場合、シリアル化はフィールドがまったく宣言されていないかのように動作します。\n\n**例:**\n\n\n      class List implements Serializable {\n        private List next;\n\n        ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"next\", List.class)};\n\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerialPersistentFieldsWithWrongSignature",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparatorResultComparison",
                "shortDescription": {
                  "text": "疑わしい compare メソッドの使用"
                },
                "fullDescription": {
                  "text": "0 以外の定数を使用して 'Comparator.compare()' または 'Comparable.compareTo()' 呼び出しの結果を比較していることを報告します。 契約により、このようなメソッドは任意の整数 (-1、0、1 に限らない) を返す可能性があるため、特定の数値と比較することはお勧めできません。 一般的に使用されている比較メソッド ('String.compareTo()' など) の一部は、実際には [-1..1] の範囲を外れた値を返すため、そのような比較をするとプログラムの正常な動作に影響する可能性があります。 例: 'void validate(String s1, String s2) {\n    // 1 と比較するのは誤りです\n    if (s1.compareTo(s2) == 1) {\n      throw new IllegalArgumentException(\"Incorrect order\");\n    }\n  }' クイックフィックス適用後: 'void validate(String s1, String s2) {\n    if (s1.compareTo(s2) > 0) {\n      throw new IllegalArgumentException(\"Incorrect order\");\n    }\n  }' 2017.2 の新機能です",
                  "markdown": "0 以外の定数を使用して `Comparator.compare()` または `Comparable.compareTo()` 呼び出しの結果を比較していることを報告します。 契約により、このようなメソッドは任意の整数 (-1、0、1 に限らない) を返す可能性があるため、特定の数値と比較することはお勧めできません。 一般的に使用されている比較メソッド (`String.compareTo()` など) の一部は、実際には \\[-1..1\\] の範囲を外れた値を返すため、そのような比較をするとプログラムの正常な動作に影響する可能性があります。\n\n例:\n\n\n      void validate(String s1, String s2) {\n        // 1 と比較するのは誤りです\n        if (s1.compareTo(s2) == 1) {\n          throw new IllegalArgumentException(\"Incorrect order\");\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      void validate(String s1, String s2) {\n        if (s1.compareTo(s2) > 0) {\n          throw new IllegalArgumentException(\"Incorrect order\");\n        }\n      }\n\n2017.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparatorResultComparison",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ListIndexOfReplaceableByContains",
                "shortDescription": {
                  "text": "'contains()' に置換可能な 'List.indexOf()' 式"
                },
                "fullDescription": {
                  "text": "'List.contains()' メソッドに置換できる 'List.indexOf()' 式を報告します。 例: 'boolean hasEmptyString(List<String> list) {\n    // 警告: 単純化できます\n    return list.indexOf(\"\") >= 0;\n  }' 提供されるクイックフィックスを使用すると、'indexOf' 呼び出しが 'contains' 呼び出しに置換されます: 'boolean hasEmptyString(List<String> list) {\n    // クイックフィックス適用後\n    return list.contains(\"\");\n  }'",
                  "markdown": "`List.contains()` メソッドに置換できる `List.indexOf()` 式を報告します。\n\n例:\n\n\n      boolean hasEmptyString(List<String> list) {\n        // 警告: 単純化できます\n        return list.indexOf(\"\") >= 0;\n      }\n\n提供されるクイックフィックスを使用すると、`indexOf` 呼び出しが `contains` 呼び出しに置換されます:\n\n\n      boolean hasEmptyString(List<String> list) {\n        // クイックフィックス適用後\n        return list.contains(\"\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ListIndexOfReplaceableByContains",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonStrictComparisonCanBeEquality",
                "shortDescription": {
                  "text": "厳密でない不等式 '>=' または '<=' は、'==' に置換できます"
                },
                "fullDescription": {
                  "text": "データフロー解析に従って、単一のオペランド値に対してのみ条件が満たされる不等式条件を報告します。 コードを分かりやすくするため、このような条件は等式条件に置換できます。 例: 'if (x >= 10) {\n    ...\n    if (x <= 10) { // can be replaced with 'x == 10'\n    }\n  }' 2022.2 の新機能です",
                  "markdown": "データフロー解析に従って、単一のオペランド値に対してのみ条件が満たされる不等式条件を報告します。 コードを分かりやすくするため、このような条件は等式条件に置換できます。\n\n例:\n\n\n      if (x >= 10) {\n        ...\n        if (x <= 10) { // can be replaced with 'x == 10'\n        }\n      }\n\n2022.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "NonStrictComparisonCanBeEquality",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryParentheses",
                "shortDescription": {
                  "text": "不要な丸括弧"
                },
                "fullDescription": {
                  "text": "不要な丸括弧をすべて報告します。 丸括弧を除去しても式の評価順序が変化しない場合、その丸括弧は不要だと考えられます。 例: 'int n = 3 + (9 * 8);' クイックフィックス適用後: 'int n = 3 + 9 * 8;' インスペクションの構成: 二項式の意図を明確化するための丸括弧を無視する場合は、「明確化のための丸括弧を無視する」オプションを使用します。 丸括弧で囲まれた式がより大きな式を構成する 'instanceof' 式であるか、親の式とは異なる演算子を使用している場合、その丸括弧は意図を明確にするためのものです。 条件式の条件を囲む丸括弧をすべて無視する場合は、「条件式の条件を囲む丸括弧を無視する」オプションを使用します。 一部のコーディング標準では、このような条件はすべて丸括弧で囲む必要があると定められています。 ラムダ式内の単一のラムダパラメーターを囲む丸括弧を無視する場合は、「単一の仮引数の型を持つラムダパラメーターを囲む丸括弧を無視する」オプションを使用します。",
                  "markdown": "不要な丸括弧をすべて報告します。\n\n丸括弧を除去しても式の評価順序が変化しない場合、その丸括弧は不要だと考えられます。\n\n例:\n\n\n      int n = 3 + (9 * 8);\n\nクイックフィックス適用後:\n\n\n      int n = 3 + 9 * 8;\n\nインスペクションの構成:\n\n* 二項式の意図を明確化するための丸括弧を無視する場合は、「**明確化のための丸括弧を無視する** 」オプションを使用します。 丸括弧で囲まれた式がより大きな式を構成する `instanceof` 式であるか、親の式とは異なる演算子を使用している場合、その丸括弧は意図を明確にするためのものです。\n* 条件式の条件を囲む丸括弧をすべて無視する場合は、「**条件式の条件を囲む丸括弧を無視する**」オプションを使用します。 一部のコーディング標準では、このような条件はすべて丸括弧で囲む必要があると定められています。\n* ラムダ式内の単一のラムダパラメーターを囲む丸括弧を無視する場合は、「**単一の仮引数の型を持つラムダパラメーターを囲む丸括弧を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessaryParentheses",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitArrayToString",
                "shortDescription": {
                  "text": "配列での 'toString()' 呼び出し"
                },
                "fullDescription": {
                  "text": "'String' 連結で使用される配列、または 'System.out.println()' などの 'java.io.PrintStream' メソッドにパラメーターとして渡されている配列を報告します。 このような場合、通常は配列オブジェクト自体ではなく、配列の内容が使用されることが想定されています。 例: 'void print(Object[] objects) {\n    System.out.println(objects);\n  }' クイックフィックス適用後: 'void print(Object[] objects) {\n    System.out.println(Arrays.toString(objects));\n  }'",
                  "markdown": "`String` 連結で使用される配列、または `System.out.println()` などの `java.io.PrintStream` メソッドにパラメーターとして渡されている配列を報告します。\n\n\nこのような場合、通常は配列オブジェクト自体ではなく、配列の内容が使用されることが想定されています。\n\n**例:**\n\n\n      void print(Object[] objects) {\n        System.out.println(objects);\n      }\n\nクイックフィックス適用後:\n\n\n      void print(Object[] objects) {\n        System.out.println(Arrays.toString(objects));\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ImplicitArrayToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReuseOfLocalVariable",
                "shortDescription": {
                  "text": "ローカル変数の再利用"
                },
                "fullDescription": {
                  "text": "「再利用」されており、元の用途とは無関係な新しい値で値を上書きしているローカル変数を報告します。 このようなローカル変数の再利用は混乱を招く可能性があります。ローカル変数の意図が使用するたびに変わっている可能性があるためです。 また、コードの変更により、上書きされたと見なされている値が実際には存続しているように見える場合にバグが発生しやすくなる可能性があります。 変数の存続期間はできるだけ短くし、ローカル変数を再利用せずにコードを簡潔にすることをお勧めします。 例: 'void x() {\n        String s = \"one\";\n        System.out.println(\"s = \" + s);\n        s = \"two\"; //ローカル変数 's' の再利用\n        System.out.println(\"s = \" + s);\n    }'",
                  "markdown": "「再利用」されており、元の用途とは無関係な新しい値で値を上書きしているローカル変数を報告します。\n\nこのようなローカル変数の再利用は混乱を招く可能性があります。ローカル変数の意図が使用するたびに変わっている可能性があるためです。 また、コードの変更により、上書きされたと見なされている値が実際には存続しているように見える場合にバグが発生しやすくなる可能性があります。 変数の存続期間はできるだけ短くし、ローカル変数を再利用せずにコードを簡潔にすることをお勧めします。\n\n例:\n\n\n        void x() {\n            String s = \"one\";\n            System.out.println(\"s = \" + s);\n            s = \"two\"; //ローカル変数 's' の再利用\n            System.out.println(\"s = \" + s);\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReuseOfLocalVariable",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/データフロー",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanMethodNameMustStartWithQuestion",
                "shortDescription": {
                  "text": "疑問詞で始まるべきブールメソッド名"
                },
                "fullDescription": {
                  "text": "名前が疑問詞で始まっていないブールメソッドを報告します。 ライブラリメソッドをオーバーライドするブールメソッドは、このインスペクションでは無視されます。 例: 'boolean empty(List<String> list) {\n  return list.isEmpty();\n}' このようなメソッドの名前を変更するクイックフィックスは、エディターでのみ使用できます。 インスペクションの構成: ブールメソッド名を開始するために使用できる疑問詞を指定するには、「ブールメソッド名の接頭辞」リストを使用します。 戻り値の型が 'java.lang.Boolean' のメソッドを無視するには、「戻り値の型が 'java.lang.Boolean' のメソッドを無視する」オプションを使用します。 アノテーション型 ('@interface') のブールメソッドを無視するには、「@interface のブールメソッドを無視する」オプションを使用します。 スーパーを持つメソッドを無視するには、「スーパーメソッドをオーバーライド/実装するメソッドを無視」を使用します。",
                  "markdown": "名前が疑問詞で始まっていないブールメソッドを報告します。\n\nライブラリメソッドをオーバーライドするブールメソッドは、このインスペクションでは無視されます。\n\n**例:**\n\n    boolean empty(List<String> list) {\n      return list.isEmpty();\n    }\n\nこのようなメソッドの名前を変更するクイックフィックスは、エディターでのみ使用できます。\n\nインスペクションの構成:\n\n* ブールメソッド名を開始するために使用できる疑問詞を指定するには、「**ブールメソッド名の接頭辞**」リストを使用します。\n* 戻り値の型が `java.lang.Boolean` のメソッドを無視するには、「**戻り値の型が 'java.lang.Boolean' のメソッドを無視する**」オプションを使用します。\n* アノテーション型 (`@interface`) のブールメソッドを無視するには、「**@interface のブールメソッドを無視する**」オプションを使用します。\n* スーパーを持つメソッドを無視するには、「**スーパーメソッドをオーバーライド/実装するメソッドを無視**」を使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanMethodNameMustStartWithQuestion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規則/メソッド",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousToArrayCall",
                "shortDescription": {
                  "text": "疑わしい 'Collection.toArray()' 呼び出し"
                },
                "fullDescription": {
                  "text": "疑わしい 'Collection.toArray()' の呼び出しを報告します。 次のような呼び出しは疑わしいと見なされます。 配列引数の型が、結果をキャストしている配列の型と同じでない場合。 配列引数の型が、コレクション宣言の型パラメーターと一致していない場合。 例: 'void m1(List list) {\n  Number[] ns = (Number[]) list.toArray(new String[0]);\n}\n\nvoid m2(List<Number> list) {\n  Number[] ns = list.toArray(new String[0]);\n}'",
                  "markdown": "疑わしい `Collection.toArray()` の呼び出しを報告します。\n\n次のような呼び出しは疑わしいと見なされます。\n\n* 配列引数の型が、結果をキャストしている配列の型と同じでない場合。\n* 配列引数の型が、コレクション宣言の型パラメーターと一致していない場合。\n\n**例:**\n\n\n    void m1(List list) {\n      Number[] ns = (Number[]) list.toArray(new String[0]);\n    }\n\n    void m2(List<Number> list) {\n      Number[] ns = list.toArray(new String[0]);\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousToArrayCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringToUpperWithoutLocale",
                "shortDescription": {
                  "text": "ロケールなしの 'String.toUpperCase()' または 'toLowerCase()' への呼び出し"
                },
                "fullDescription": {
                  "text": "'java.util.Locale' を指定していない 'String' オブジェクトに対する 'toUpperCase()' または 'toLowerCase()' の呼び出しを報告します。 このような場合はデフォルトのシステムロケールが使用されるため、国際化環境で問題が発生する可能性があります。 たとえば、'\"i\".toUpperCase().equals(\"I\")' というコードは、トルコ語とアゼルバイジャン語のロケールでは 'false' を返します。ここで、ドット有りとドット無しの 'i' は別々の文字です。 トルコ語のロケールで実行中に 'i' を含む英語の文字列に対して 'toUpperCase()' を呼び出すと、誤った結果が返されます。 また、HTML タグのようにロケールに依存しないものとして扱うべき文字列を処理する際にエラーが発生する可能性があります。",
                  "markdown": "`java.util.Locale` を指定していない `String` オブジェクトに対する `toUpperCase()` または `toLowerCase()` の呼び出しを報告します。 このような場合はデフォルトのシステムロケールが使用されるため、国際化環境で問題が発生する可能性があります。\n\n\nたとえば、`\"i\".toUpperCase().equals(\"I\")` というコードは、トルコ語とアゼルバイジャン語のロケールでは `false` を返します。ここで、ドット有りとドット無しの 'i' は別々の文字です。 トルコ語のロケールで実行中に 'i' を含む英語の文字列に対して `toUpperCase()` を呼び出すと、誤った結果が返されます。 また、HTML タグのようにロケールに依存しないものとして扱うべき文字列を処理する際にエラーが発生する可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringToUpperCaseOrToLowerCaseWithoutLocale",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExplicitToImplicitClassMigration",
                "shortDescription": {
                  "text": "明示的なクラス宣言は暗黙的に宣言されたクラスに変換できます"
                },
                "fullDescription": {
                  "text": "暗黙的に宣言されているクラスに変換できる普通のクラスを報告します 例: 'public class Sample {\n      public static void main(String[] args) {\n          System.out.println(\"Hello, world!\");\n      }\n  }' クイックフィックス適用後: 'public static void main(String[] args) {\n      System.out.println(\"Hello, world!\");\n  }' 2024.1 の新機能です このインスペクションは Java 21-preview 以降で使用できる Java の機能 '暗黙的に宣言されたクラス' に依存しています。",
                  "markdown": "暗黙的に宣言されているクラスに変換できる普通のクラスを報告します\n\n**例:**\n\n\n      public class Sample {\n          public static void main(String[] args) {\n              System.out.println(\"Hello, world!\");\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      public static void main(String[] args) {\n          System.out.println(\"Hello, world!\");\n      }\n\n2024.1 の新機能です\n\nこのインスペクションは Java 21-preview 以降で使用できる Java の機能 '暗黙的に宣言されたクラス' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExplicitToImplicitClassMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 21",
                      "index": 75,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizationOnLocalVariableOrMethodParameter",
                "shortDescription": {
                  "text": "ローカル変数またはメソッドパラメーターの同期"
                },
                "fullDescription": {
                  "text": "ローカル変数またはパラメーターでの同期を報告します。 このような同期が行われている場合、正確な演算を保証することは非常に困難です。 このようなコードは synchronized ラッパークラスでアクセスを制御するか、フィールドで同期を行うことで改善できる可能性があります。 例: 'void bar() {\n    final Object lock = new Object();\n    synchronized (lock) { }\n  }'",
                  "markdown": "ローカル変数またはパラメーターでの同期を報告します。\n\n\nこのような同期が行われている場合、正確な演算を保証することは非常に困難です。\nこのようなコードは synchronized ラッパークラスでアクセスを制御するか、フィールドで同期を行うことで改善できる可能性があります。\n\n**例:**\n\n\n      void bar() {\n        final Object lock = new Object();\n        synchronized (lock) { }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizationOnLocalVariableOrMethodParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedMethodCall",
                "shortDescription": {
                  "text": "ネストしたメソッド呼び出し"
                },
                "fullDescription": {
                  "text": "別のメソッド呼び出しのパラメーターとして使用されているメソッド呼び出しを報告します。 このクイックフィックスは変数を導入し、コードを単純化してデバッグを容易にします。 例: 'public int y() { return 1; }\n  public int f(int x) { return 2 * x; }\n\n  public void foo() {\n      int x = f(y());\n  }' クイックフィックス適用後: 'public int y() { return 1; }\n  public int f(int x) { return 2 * x; }\n\n  public void foo() {\n      int y = y();\n      int x = f(y);\n  }' 報告対象を切り替えるには、インスペクションのオプションを使用します。 フィールドイニシャライザーでのメソッド呼び出し static メソッドの呼び出し 単純な getter の呼び出し",
                  "markdown": "別のメソッド呼び出しのパラメーターとして使用されているメソッド呼び出しを報告します。\n\nこのクイックフィックスは変数を導入し、コードを単純化してデバッグを容易にします。\n\n**例:**\n\n\n      public int y() { return 1; }\n      public int f(int x) { return 2 * x; }\n\n      public void foo() {\n          int x = f(y());\n      }\n\nクイックフィックス適用後:\n\n\n      public int y() { return 1; }\n      public int f(int x) { return 2 * x; }\n\n      public void foo() {\n          int y = y();\n          int x = f(y);\n      }\n\n\n報告対象を切り替えるには、インスペクションのオプションを使用します。\n\n* フィールドイニシャライザーでのメソッド呼び出し\n* static メソッドの呼び出し\n* 単純な getter の呼び出し"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalMethod",
                "shortDescription": {
                  "text": "メソッドはオーバーライドできません"
                },
                "fullDescription": {
                  "text": "'final' で宣言されているメソッドを報告します。 このようなメソッドはオーバーライド不可能であり、オブジェクト指向設計が不十分な可能性があります。 一部のコーディング標準は、'final' メソッドを推奨していません。",
                  "markdown": "`final` で宣言されているメソッドを報告します。 このようなメソッドはオーバーライド不可能であり、オブジェクト指向設計が不十分な可能性があります。 一部のコーディング標準は、`final` メソッドを推奨していません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegatedConditionalExpression",
                "shortDescription": {
                  "text": "否定された条件式"
                },
                "fullDescription": {
                  "text": "構文は混乱を招く可能性がある、前置式で否定されている条件式を報告します。 外側の否定を両方の分岐に反映するクイックフィックスがあります。 例: '!(i == 1 ? a : b)' クイックフィックス適用後: 'i == 1 ? !a : !b'",
                  "markdown": "構文は混乱を招く可能性がある、前置式で否定されている条件式を報告します。\n\n外側の否定を両方の分岐に反映するクイックフィックスがあります。\n\n例:\n\n\n      !(i == 1 ? a : b)\n\nクイックフィックス適用後:\n\n\n      i == 1 ? !a : !b\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NegatedConditionalExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithTooManyTransitiveDependents",
                "shortDescription": {
                  "text": "推移的な被依存関係が多すぎるクラス"
                },
                "fullDescription": {
                  "text": "他のクラスからの直接的または間接的な被依存関係が多すぎるクラスを報告します。 このようなクラスに修正を加えると他の多くのクラスを変更する必要が生じるため、コストが高くなる可能性があります。 トップレベルのクラスのみが報告されます。 クラスで許容される直接的または間接的な被依存関係数の最大値を指定するには、「推移的被依存関係の最大数」フィールドを使用します。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "他のクラスからの直接的または間接的な被依存関係が多すぎるクラスを報告します。\n\nこのようなクラスに修正を加えると他の多くのクラスを変更する必要が生じるため、コストが高くなる可能性があります。\n\nトップレベルのクラスのみが報告されます。\n\nクラスで許容される直接的または間接的な被依存関係数の最大値を指定するには、「**推移的被依存関係の最大数**」フィールドを使用します。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyTransitiveDependents",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依存関係の問題",
                      "index": 86,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CompareToUsesNonFinalVariable",
                "shortDescription": {
                  "text": "'compareTo()' で参照される非 final のフィールド"
                },
                "fullDescription": {
                  "text": "'compareTo()' 実装にある非 'final' フィールドへのアクセスを報告します。 このようなアクセスを行うと、'compareTo()' がオブジェクトのライフサイクルのさまざまな時点で異なる結果を返す可能性があります。その結果、'java.util.TreeSet' などの標準コレクションクラスを使用する際に問題が発生する可能性があります。 フィールドへの書き込みアクセス権がない場合にのみ、フィールドを 'final' にするクイックフィックスを使用できます。それ以外の場合、クイックフィックスは提案されません。 例: 'class Foo implements Comparable<Foo>{\n    private int index;\n    Foo(int idx) {\n      index = idx;\n    }\n    @Override\n    public int compareTo(Foo foo) {\n     return Integer.compare(this.index, foo.index);\n    }\n  }' クイックフィックス適用後: 'class Foo implements Comparable<Foo>{\n    private final int index;\n    Foo(int idx) {\n      index = idx;\n    }\n    @Override\n    public int compareTo(Foo foo) {\n      return Integer.compare(this.index, foo.index);\n    }\n  }'",
                  "markdown": "`compareTo()` 実装にある非 `final` フィールドへのアクセスを報告します。\n\n\nこのようなアクセスを行うと、`compareTo()` がオブジェクトのライフサイクルのさまざまな時点で異なる結果を返す可能性があります。その結果、`java.util.TreeSet` などの標準コレクションクラスを使用する際に問題が発生する可能性があります。\n\n\nフィールドへの書き込みアクセス権がない場合にのみ、フィールドを `final` にするクイックフィックスを使用できます。それ以外の場合、クイックフィックスは提案されません。\n\n**例:**\n\n\n      class Foo implements Comparable<Foo>{\n        private int index;\n        Foo(int idx) {\n          index = idx;\n        }\n        @Override\n        public int compareTo(Foo foo) {\n         return Integer.compare(this.index, foo.index);\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo implements Comparable<Foo>{\n        private final int index;\n        Foo(int idx) {\n          index = idx;\n        }\n        @Override\n        public int compareTo(Foo foo) {\n          return Integer.compare(this.index, foo.index);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CompareToUsesNonFinalVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousSystemArraycopy",
                "shortDescription": {
                  "text": "疑わしい 'System.arraycopy()' 呼び出し"
                },
                "fullDescription": {
                  "text": "疑わしい 'System.arraycopy()' の呼び出しを報告します。 次に当てはまる場合に疑わしい呼び出しと見なされます。 コピー元とコピー先が配列型ではない コピー元とコピー先の型が異なっている コピー対象チャンクの長さが 'src.length - srcPos' より大きい コピー対象チャンクの長さが 'dest.length - destPos' より大きい コピー元とコピー先が同じ配列の場合に範囲が常に重なっている 例: 'void foo() {\n    int[] src = new int[] { 1, 2, 3, 4 };\n    System.arraycopy(src, 0, src, 1, 2); // 警告: 範囲が重なる同じ配列にコピーしています\n  }'",
                  "markdown": "疑わしい `System.arraycopy()` の呼び出しを報告します。\n\n次に当てはまる場合に疑わしい呼び出しと見なされます。\n\n* コピー元とコピー先が配列型ではない\n* コピー元とコピー先の型が異なっている\n* コピー対象チャンクの長さが `src.length - srcPos` より大きい\n* コピー対象チャンクの長さが `dest.length - destPos` より大きい\n* コピー元とコピー先が同じ配列の場合に範囲が常に重なっている\n\n**例:**\n\n\n      void foo() {\n        int[] src = new int[] { 1, 2, 3, 4 };\n        System.arraycopy(src, 0, src, 1, 2); // 警告: 範囲が重なる同じ配列にコピーしています\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousSystemArraycopy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavacQuirks",
                "shortDescription": {
                  "text": "Javac 特有の問題"
                },
                "fullDescription": {
                  "text": "Javac に関する既知の問題、パフォーマンスの問題、および非互換性を報告します。 たとえば、型推論は大量のネストした呼び出しを処理する必要がある場合は速度が低下します。 次のコードでは、可変長引数メソッドの呼び出しに 50 個以上の poly 引数があるため、警告が発生します。 'Arrays.asList(\n      Arrays.asList(\"a1\", \"b1\"),\n      Arrays.asList(\"a2\", \"b2\"),\n      ...\n      Arrays.asList(\"a100\", \"b100\"));' クイックフィックスを使用すると明示的な型引数が追加され、コンパイルと IDE の処理速度が大幅にアップします。 '//noinspection RedundantTypeArguments\n  Arrays.<List<String>>asList(\n      Arrays.asList(\"a1\", \"b1\"),\n      Arrays.asList(\"a2\", \"b2\"),\n      ...\n      Arrays.asList(\"a100\", \"b100\"));'",
                  "markdown": "Javac に関する既知の問題、パフォーマンスの問題、および非互換性を報告します。 たとえば、型推論は大量のネストした呼び出しを処理する必要がある場合は速度が低下します。\n\n次のコードでは、可変長引数メソッドの呼び出しに 50 個以上の poly 引数があるため、警告が発生します。\n\n\n      Arrays.asList(\n          Arrays.asList(\"a1\", \"b1\"),\n          Arrays.asList(\"a2\", \"b2\"),\n          ...\n          Arrays.asList(\"a100\", \"b100\"));\n\nクイックフィックスを使用すると明示的な型引数が追加され、コンパイルと IDE の処理速度が大幅にアップします。\n\n\n      //noinspection RedundantTypeArguments\n      Arrays.<List<String>>asList(\n          Arrays.asList(\"a1\", \"b1\"),\n          Arrays.asList(\"a2\", \"b2\"),\n          ...\n          Arrays.asList(\"a100\", \"b100\"));\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavacQuirks",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コンパイラー関連の問題",
                      "index": 87,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatement",
                "shortDescription": {
                  "text": "'switch' ステートメント"
                },
                "fullDescription": {
                  "text": "'switch' ステートメントを報告します。 多くの場合 (常にそうとは限りませんが)、'switch' ステートメントはオブジェクト指向設計が不十分であることを示しています。 例: 'switch (i) {\n    // code\n  }'",
                  "markdown": "`switch` ステートメントを報告します。\n\n多くの場合 (常にそうとは限りませんが)、`switch` ステートメントはオブジェクト指向設計が不十分であることを示しています。\n\n例:\n\n\n      switch (i) {\n        // code\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SwitchStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbsoluteAlignmentInUserInterface",
                "shortDescription": {
                  "text": "AWT/Swing コードでの絶対配置"
                },
                "fullDescription": {
                  "text": "AWT および Swing の絶対位置指定定数が使用されている箇所を報告します。 国際化されたアプリケーションはロケールコンポーネントの方向設定を尊重するため、相対的な位置指定を使用します。 例: 'JPanel panel = new JPanel(new BorderLayout(2, 2));\n  JLabel label = new JLabel(\"Hello World\");\n  panel.add(label, BorderLayout.NORTH);' クイックフィックス適用後: 'JPanel panel = new JPanel(new BorderLayout(2, 2));\n  JLabel label = new JLabel(\"Hello World\");\n  panel.add(label, BorderLayout.PAGE_START);'",
                  "markdown": "AWT および Swing の絶対位置指定定数が使用されている箇所を報告します。 国際化されたアプリケーションはロケールコンポーネントの方向設定を尊重するため、相対的な位置指定を使用します。\n\n**例:**\n\n\n      JPanel panel = new JPanel(new BorderLayout(2, 2));\n      JLabel label = new JLabel(\"Hello World\");\n      panel.add(label, BorderLayout.NORTH);\n\nクイックフィックス適用後:\n\n\n      JPanel panel = new JPanel(new BorderLayout(2, 2));\n      JLabel label = new JLabel(\"Hello World\");\n      panel.add(label, BorderLayout.PAGE_START);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbsoluteAlignmentInUserInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringBufferReplaceableByString",
                "shortDescription": {
                  "text": "'String' に置換できる 'StringBuilder'"
                },
                "fullDescription": {
                  "text": "単一の 'String' 連結に置換できる 'StringBuffer'、'StringBuilder'、または 'StringJoiner' が使用されていることを報告します。 'String' 連結を使用すると、コードが単純明快になります。 このインスペクションは、提案した置換によって重大なパフォーマンス上の問題が最新の JVM で発生しない限り報告を行います。 多くの場合は、'String' 連結によってパフォーマンスが向上します。 例: 'StringBuilder result = new StringBuilder();\n  result.append(\"i = \");\n  result.append(i);\n  result.append(\";\");\n  return result.toString();' クイックフィックス適用後: 'String result = \"i = \" + i + \";\";\n  return result;'",
                  "markdown": "単一の `String` 連結に置換できる `StringBuffer`、`StringBuilder`、または `StringJoiner` が使用されていることを報告します。\n\n`String` 連結を使用すると、コードが単純明快になります。\n\n\nこのインスペクションは、提案した置換によって重大なパフォーマンス上の問題が最新の JVM で発生しない限り報告を行います。 多くの場合は、`String` 連結によってパフォーマンスが向上します。\n\n**例:**\n\n\n      StringBuilder result = new StringBuilder();\n      result.append(\"i = \");\n      result.append(i);\n      result.append(\";\");\n      return result.toString();\n\nクイックフィックス適用後:\n\n\n      String result = \"i = \" + i + \";\";\n      return result;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringBufferReplaceableByString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SourceToSinkFlow",
                "shortDescription": {
                  "text": "安全なメソッドに渡されている安全でない文字列"
                },
                "fullDescription": {
                  "text": "安全でないオブジェクトが '@Untainted' アノテーションが付いたパラメーターのあるメソッドに渡され、アノテーション付きのメソッドから返されているか、アノテーション付きのフィールド、パラメーター、またはローカル変数に割り当てられている場合に報告します。 フィールドの Kotlin 'set' および 'get' メソッドはエントリポイントとしてサポートされていません。 (同じクラス内の) 安全なオブジェクトには次のものがあります。 文字列リテラル、インターフェースインスタンス、または列挙型オブジェクト '@Untainted' が付いているメソッドの呼び出しの結果 文字列リテラルのみで割り当てられ、安全なイニシャライザーを持つ private フィールド 安全なイニシャライザーを持つ final フィールド '@Untainted' が付いており、安全でないオブジェクトから割り当てられていないローカル変数またはパラメーター このフィールド、ローカル変数、またはパラメーターは、メソッドに引数として渡したり、修飾子として使用したりすることはできず、プリミティブ、そのラッパー、または変更不可である必要があります。 また、static final フィールドは安全と見なされます。 解析は 1 つのファイル内でのみ実行されます。 他のクラスの依存関係を処理するには、オプションを使用します。 解析は private または static にまで拡張されますが、深さの伝播に制限があります。 例: 'void doSmth(boolean b) {\n    String s = safe();\n    String s1 = \"other\";\n    if (b) s1 = s;\n    sink(s);\n  }\n\n  String sink(@Untainted String s) {}'\n ここでは 's' に対する安全でない文字列代入がないため、警告は発生しません。 別の例: 'void doSmth(boolean b) {\n    String s = safe();\n    String s1 = \"other\";\n    s1 = foo();\n    if (b) s = s1;\n    sink(s);        // ここで警告が発生します\n  }\n  \n  String foo();\n\n  String sink(@Untainted String s) {}'\n ここでは 'foo' 呼び出しの結果を代入した後の 's1' の状態が不明であるため、警告が発生します。 2021.2 の新機能です",
                  "markdown": "安全でないオブジェクトが `@Untainted` アノテーションが付いたパラメーターのあるメソッドに渡され、アノテーション付きのメソッドから返されているか、アノテーション付きのフィールド、パラメーター、またはローカル変数に割り当てられている場合に報告します。 フィールドの Kotlin `set` および `get` メソッドはエントリポイントとしてサポートされていません。\n\n\n(同じクラス内の) 安全なオブジェクトには次のものがあります。\n\n* 文字列リテラル、インターフェースインスタンス、または列挙型オブジェクト\n* `@Untainted` が付いているメソッドの呼び出しの結果\n* 文字列リテラルのみで割り当てられ、安全なイニシャライザーを持つ private フィールド\n* 安全なイニシャライザーを持つ final フィールド\n* `@Untainted` が付いており、安全でないオブジェクトから割り当てられていないローカル変数またはパラメーター\nこのフィールド、ローカル変数、またはパラメーターは、メソッドに引数として渡したり、修飾子として使用したりすることはできず、プリミティブ、そのラッパー、または変更不可である必要があります。\n\nまた、static final フィールドは安全と見なされます。\n\n\n解析は 1 つのファイル内でのみ実行されます。 他のクラスの依存関係を処理するには、オプションを使用します。\n解析は private または static にまで拡張されますが、深さの伝播に制限があります。\n\n\n例:\n\n\n      void doSmth(boolean b) {\n        String s = safe();\n        String s1 = \"other\";\n        if (b) s1 = s;\n        sink(s);\n      }\n\n      String sink(@Untainted String s) {}\n\n\nここでは `s` に対する安全でない文字列代入がないため、警告は発生しません。 別の例:\n\n\n      void doSmth(boolean b) {\n        String s = safe();\n        String s1 = \"other\";\n        s1 = foo();\n        if (b) s = s1;\n        sink(s);        // ここで警告が発生します\n      }\n      \n      String foo();\n\n      String sink(@Untainted String s) {}\n\n\nここでは `foo` 呼び出しの結果を代入した後の `s1` の状態が不明であるため、警告が発生します。\n\n2021.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "tainting",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Security"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RecordCanBeClass",
                "shortDescription": {
                  "text": "レコードはクラスに変換できます"
                },
                "fullDescription": {
                  "text": "レコードクラスを報告し、普通のクラスに変換することを提案します。 このインスペクションは、Java レコードにクイックフィックスを適用し、そのレコードを旧バージョンの Java を使用しているコードベースに移動することを可能にします。 ただし、結果的に作成されるクラスは、元のレコードと完全に同等のものにはなりません。ご注意ください。 結果的に作成されるクラスは、'java.lang.Record' を拡張しなくなるため、'instanceof Record' は 'false' を返します。 'Class.isRecord()' や 'Class.getRecordComponents()' のようなリフレクションのメソッドは、異なる結果を出力します。 レコードの 'hashCode' を計算する数式が意図的に指定されていないため、生成される 'hashCode()' の実装は異なる結果を返す可能性があります。 レコードをシリアル化するメカニズムは普通のクラスのそれとは異なります。 詳細は、Java Object Serialization Specificationを参照してください。 例: 'record Point(int x, int y) {}' クイックフィックス適用後: 'final class Point {\n    private final int x;\n    private final int y;\n\n    Point(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    public int x() { return x; }\n\n    public int y() { return y; }\n\n    @Override\n    public boolean equals(Object obj) {\n      if (obj == this) return true;\n      if (obj == null || obj.getClass() != this.getClass()) return false;\n      var that = (Point)obj;\n      return this.x == that.x &&\n             this.y == that.y;\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"Point[\" +\n             \"x=\" + x + \", \" +\n             \"y=\" + y + ']';\n    }\n  }' 2020.3 の新機能です このインスペクションは Java 16 以降で使用できる Java の機能 'レコード' に依存しています。",
                  "markdown": "レコードクラスを報告し、普通のクラスに変換することを提案します。\n\nこのインスペクションは、Java レコードにクイックフィックスを適用し、そのレコードを旧バージョンの Java を使用しているコードベースに移動することを可能にします。\n\n\nただし、結果的に作成されるクラスは、元のレコードと完全に同等のものにはなりません。ご注意ください。\n\n* 結果的に作成されるクラスは、`java.lang.Record` を拡張しなくなるため、`instanceof Record` は `false` を返します。\n* `Class.isRecord()` や `Class.getRecordComponents()` のようなリフレクションのメソッドは、異なる結果を出力します。\n* レコードの `hashCode` を計算する数式が意図的に指定されていないため、生成される `hashCode()` の実装は異なる結果を返す可能性があります。\n* レコードをシリアル化するメカニズムは普通のクラスのそれとは異なります。 詳細は、*Java Object Serialization Specification*を参照してください。\n\n例:\n\n\n      record Point(int x, int y) {}\n\nクイックフィックス適用後:\n\n\n      final class Point {\n        private final int x;\n        private final int y;\n\n        Point(int x, int y) {\n          this.x = x;\n          this.y = y;\n        }\n\n        public int x() { return x; }\n\n        public int y() { return y; }\n\n        @Override\n        public boolean equals(Object obj) {\n          if (obj == this) return true;\n          if (obj == null || obj.getClass() != this.getClass()) return false;\n          var that = (Point)obj;\n          return this.x == that.x &&\n                 this.y == that.y;\n        }\n\n        @Override\n        public int hashCode() {\n          return Objects.hash(x, y);\n        }\n\n        @Override\n        public String toString() {\n          return \"Point[\" +\n                 \"x=\" + x + \", \" +\n                 \"y=\" + y + ']';\n        }\n      }\n\n2020.3 の新機能です\n\nこのインスペクションは Java 16 以降で使用できる Java の機能 'レコード' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RecordCanBeClass",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLambdaParameterType",
                "shortDescription": {
                  "text": "冗長なラムダパラメーターの型"
                },
                "fullDescription": {
                  "text": "ラムダの仮パラメーター型で、コンテキストから推論可能であるために冗長となっているものを報告します。 例: 'Map<String, Integer> map = ...\n  map.forEach((String s, Integer i) -> log.info(s + \"=\" + i));' クイックフィックスを使用すると、ラムダからパラメーターの型を除去されます。 'Map<String, Integer> map = ...\n  map.forEach((s, i) -> log.info(s + \"=\" + i));'",
                  "markdown": "ラムダの仮パラメーター型で、コンテキストから推論可能であるために冗長となっているものを報告します。\n\n**例:**\n\n\n      Map<String, Integer> map = ...\n      map.forEach((String s, Integer i) -> log.info(s + \"=\" + i));\n\nクイックフィックスを使用すると、ラムダからパラメーターの型を除去されます。\n\n\n      Map<String, Integer> map = ...\n      map.forEach((s, i) -> log.info(s + \"=\" + i));\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantLambdaParameterType",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MalformedFormatString",
                "shortDescription": {
                  "text": "不正な形式の書式設定文字列"
                },
                "fullDescription": {
                  "text": "標準の Java 構文に準拠していない書式設定文字列を報告します。 このインスペクションはコンパイル時定数が 'java.util.Formatter'、'java.lang.String'、'java.io.PrintWriter'、または 'java.io.PrintStream' の対応するメソッドの引数として使用されている場合、それをデフォルトで書式設定文字列と見なします。 例: 'String.format(\"x = %d, y = %d\", 42);' 文字列書式設定に関連する追加のクラスとメソッドをマークするには、インスペクションの設定を使用します。 代わりに、'org.intellij.lang.annotations.PrintFormat' アノテーションを使用して、文字列書式設定メソッドのパラメーターをマークできます。 この場合、書式設定引数パラメーターは、書式設定文字列の直後にある最後のメソッドパラメーターである必要があります。 例: 'void myFormatMethod(int mode, @PrintFormat String formatString, Object... args) {...}' このようにアノテーションが付けられたメソッドも、このインスペクションによって認識されます。",
                  "markdown": "標準の Java 構文に準拠していない書式設定文字列を報告します。\n\nこのインスペクションはコンパイル時定数が `java.util.Formatter`、`java.lang.String`、`java.io.PrintWriter`、または `java.io.PrintStream` の対応するメソッドの引数として使用されている場合、それをデフォルトで書式設定文字列と見なします。\n\n**例:**\n\n\n      String.format(\"x = %d, y = %d\", 42);\n\n文字列書式設定に関連する追加のクラスとメソッドをマークするには、インスペクションの設定を使用します。\n\n代わりに、`org.intellij.lang.annotations.PrintFormat` アノテーションを使用して、文字列書式設定メソッドのパラメーターをマークできます。 この場合、書式設定引数パラメーターは、書式設定文字列の直後にある最後のメソッドパラメーターである必要があります。 例:\n\n\n      void myFormatMethod(int mode, @PrintFormat String formatString, Object... args) {...}\n\n\nこのようにアノテーションが付けられたメソッドも、このインスペクションによって認識されます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MalformedFormatString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalExpression",
                "shortDescription": {
                  "text": "条件式"
                },
                "fullDescription": {
                  "text": "三項条件演算子の使用を報告し、'if'/'else' ステートメントに置換することを提案します。 一部のコーディング標準では、条件演算子の使用は禁止されています。 例: 'Object result = (condition) ? foo() : bar();' クイックフィックス適用後: 'Object result;\n  if (condition) {\n    comp = foo();\n  }\n  else {\n    comp = bar();\n  }' インスペクションの構成: 単純な代入や return を無視し、以下の構文を許可するには、「単純な代入と return を無視する」オプションを使用します。 'String s = (foo == null) ? \"\" : foo.toString();' if ステートメントに自動置換できないコンテキスト (条件式が 'super()' コンストラクターの呼び出しの引数として使用されている場合など) で条件式を無視するには、「if ステートメントが使用できない場所を無視する」オプションを使用します。",
                  "markdown": "三項条件演算子の使用を報告し、`if`/`else` ステートメントに置換することを提案します。\n\n一部のコーディング標準では、条件演算子の使用は禁止されています。\n\n例:\n\n\n      Object result = (condition) ? foo() : bar();\n\nクイックフィックス適用後:\n\n\n      Object result;\n      if (condition) {\n        comp = foo();\n      }\n      else {\n        comp = bar();\n      }\n\nインスペクションの構成:\n\n単純な代入や return を無視し、以下の構文を許可するには、「**単純な代入と return を無視する**」オプションを使用します。\n\n\n      String s = (foo == null) ? \"\" : foo.toString();\n\n\nif ステートメントに自動置換できないコンテキスト (条件式が `super()` コンストラクターの呼び出しの引数として使用されている場合など) で条件式を無視するには、「**if ステートメントが使用できない場所を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConditionalExpression",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousReturnByteInputStream",
                "shortDescription": {
                  "text": "'InputStream.read()' から返されている疑わしいバイト値"
                },
                "fullDescription": {
                  "text": "'InputStream.read()' メソッドを実装しているメソッドから返されている 'byte' 型の式を報告します。 byte 型の式には '-128' から '127' までの値が含まれますが、'InputStream.read()' は '0' から '255' までの範囲の値を返す必要があるため、これは疑わしいです。 クイックフィックスを使用するとビットマスク '0xFF' が適用され、式が符号なしの 'byte' に変換されます。 例: 'class MyInputStream extends InputStream {\n  int pos = 0;\n  byte[] data;\n\n  MyInputStream(byte[] input) {\n    data = input;\n  }\n\n  @Override\n  public int read() {\n    if (pos == data.length) {\n      return -1;\n    }\n    return data[pos++]; // 問題あり\n  }\n}' クイックフィックス適用後: 'class MyInputStream extends InputStream {\n  int pos = 0;\n  byte[] data;\n\n  MyInputStream(byte[] input) {\n    data = input;\n  }\n\n  @Override\n  public int read() {\n    if (pos == data.length) {\n      return -1;\n    }\n    return data[pos++] & 0xFF;\n  }\n}' 2023.2 の新機能です",
                  "markdown": "`InputStream.read()` メソッドを実装しているメソッドから返されている `byte` 型の式を報告します。\n\n\nbyte 型の式には `-128` から `127` までの値が含まれますが、`InputStream.read()` は `0` から `255` までの範囲の値を返す必要があるため、これは疑わしいです。\nクイックフィックスを使用するとビットマスク `0xFF` が適用され、式が符号なしの `byte` に変換されます。\n\n**例:**\n\n\n    class MyInputStream extends InputStream {\n      int pos = 0;\n      byte[] data;\n\n      MyInputStream(byte[] input) {\n        data = input;\n      }\n\n      @Override\n      public int read() {\n        if (pos == data.length) {\n          return -1;\n        }\n        return data[pos++]; // 問題あり\n      }\n    }\n\nクイックフィックス適用後:\n\n\n    class MyInputStream extends InputStream {\n      int pos = 0;\n      byte[] data;\n\n      MyInputStream(byte[] input) {\n        data = input;\n      }\n\n      @Override\n      public int read() {\n        if (pos == data.length) {\n          return -1;\n        }\n        return data[pos++] & 0xFF;\n      }\n    }\n\n2023.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousReturnByteInputStream",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadYield",
                "shortDescription": {
                  "text": "'Thread.yield()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'Thread.yield()' の呼び出しを報告します。 'yield()' の動作は不明確であり、プラットフォームに依存します。そのため、このメソッドの使用が適切な場合はめったにありません。 この呼び出しを使用する場合は、詳細なプロファイリングやベンチマークと組み合わせて、実際に望ましい効果が得られるようにする必要があります。 例: 'public static void main(String[] args) {\n    Runnable r = () -> {\n      for (int i = 0; i < 10; i++) {\n        System.out.println(i);\n        Thread.yield();\n      }\n    };\n    new Thread(r).start();\n    new Thread(r).start();\n  }'",
                  "markdown": "`Thread.yield()` の呼び出しを報告します。\n\n\n`yield()` の動作は不明確であり、プラットフォームに依存します。そのため、このメソッドの使用が適切な場合はめったにありません。\nこの呼び出しを使用する場合は、詳細なプロファイリングやベンチマークと組み合わせて、実際に望ましい効果が得られるようにする必要があります。\n\n**例:**\n\n\n      public static void main(String[] args) {\n        Runnable r = () -> {\n          for (int i = 0; i < 10; i++) {\n            System.out.println(i);\n            Thread.yield();\n          }\n        };\n        new Thread(r).start();\n        new Thread(r).start();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadYield",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfClone",
                "shortDescription": {
                  "text": "'clone()' または 'Cloneable' の使用"
                },
                "fullDescription": {
                  "text": "'clone()' メソッドの実装と呼び出しに加えて、'java.lang.Cloneable' インターフェースが使用されていることを報告します。 一部のコーディング標準は 'clone()' の使用を禁止しており、代わりにコピーコンストラクターか 'static' ファクトリメソッドを使用することを推奨しています。 配列に対する 'clone()' の呼び出しは正確かつコンパクトな配列のコピー方法であるため、インスペクションでは無視されます。 例: 'class Copy implements Cloneable /*警告*/ {\n\n    public Copy clone() /*警告*/ {\n      try {\n        return (Copy) super.clone(); // 警告\n      } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n      }\n    }\n  }'",
                  "markdown": "`clone()` メソッドの実装と呼び出しに加えて、`java.lang.Cloneable` インターフェースが使用されていることを報告します。\n\n一部のコーディング標準は `clone()` の使用を禁止しており、代わりにコピーコンストラクターか `static` ファクトリメソッドを使用することを推奨しています。\n\n配列に対する `clone()` の呼び出しは正確かつコンパクトな配列のコピー方法であるため、インスペクションでは無視されます。\n\n**例:**\n\n\n      class Copy implements Cloneable /*警告*/ {\n\n        public Copy clone() /*警告*/ {\n          try {\n            return (Copy) super.clone(); // 警告\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfClone",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クローン関連の問題",
                      "index": 79,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingFinalNewline",
                "shortDescription": {
                  "text": "最後の改行がありません"
                },
                "fullDescription": {
                  "text": "JAR ファイルの仕様で要求されているように、マニフェストファイルの最後に改行がない場合に報告します。",
                  "markdown": "JAR ファイルの仕様で要求されているように、マニフェストファイルの最後に改行がない場合に報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MissingFinalNewline",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "マニフェスト",
                      "index": 90,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaCanBeMethodCall",
                "shortDescription": {
                  "text": "メソッド呼び出しに置換可能なラムダ"
                },
                "fullDescription": {
                  "text": "JDK メソッドへの呼び出しに置換できるラムダ式を報告します。 たとえば、型が 'Function<T, T>' の式 'x -> x' は、'Function.identity()' の呼び出しに置換できます。 2017.1 の新機能です このインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。",
                  "markdown": "JDK メソッドへの呼び出しに置換できるラムダ式を報告します。\n\nたとえば、型が `Function<T, T>` の式 `x -> x` は、`Function.identity()` の呼び出しに置換できます。\n\n2017.1 の新機能です\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LambdaCanBeMethodCall",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedTryStatement",
                "shortDescription": {
                  "text": "ネストした 'try' ステートメント"
                },
                "fullDescription": {
                  "text": "ネストした 'try' ステートメントを報告します。 ネストした 'try' ステートメントを使用するとコードが不明瞭になる可能性があるため、その 'catch' および 'finally' セクションをマージする必要があるかもしれません。",
                  "markdown": "ネストした `try` ステートメントを報告します。\n\nネストした `try` ステートメントを使用するとコードが不明瞭になる可能性があるため、その `catch` および `finally` セクションをマージする必要があるかもしれません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedTryStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EndlessStream",
                "shortDescription": {
                  "text": "無限ストリームを消費する非短絡操作"
                },
                "fullDescription": {
                  "text": "無限ストリームを消費する非短絡操作を報告します。 このような演算は、例外をスローしなければ完了できません。 例: 'Stream.iterate(0, i -> i + 1).collect(Collectors.toList())' このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "無限ストリームを消費する非短絡操作を報告します。 このような演算は、例外をスローしなければ完了できません。\n\n例:\n\n\n      Stream.iterate(0, i -> i + 1).collect(Collectors.toList())\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EndlessStream",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonStaticFinalLogger",
                "shortDescription": {
                  "text": "非定数のロガー"
                },
                "fullDescription": {
                  "text": "'static' や 'final' で宣言されていないロガーフィールドを報告します。 すべてのクラスのロガーが事実上不変であり、そのクラスにバインドされていれば、アプリケーションに統一したロギングの実装を提供する作業が簡単になります。 ロガーの修飾子を 'static final' に変更するクイックフィックスが提供されています。 例: 'public class Significant {\n    private Logger LOG = Logger.getLogger(Critical.class);\n  }' クイックフィックス適用後: 'public class Significant {\n    private static final Logger LOG = Logger.getLogger(Critical.class);\n  }' インスペクションの構成: ロガークラス名を指定するには、ロガークラス名 テーブルを使用します。 このインスペクションは 'static' かつ 'final' ではなく、その型が指定されたクラス名の型に等しいフィールドを報告します。",
                  "markdown": "`static` や `final` で宣言されていないロガーフィールドを報告します。 すべてのクラスのロガーが事実上不変であり、そのクラスにバインドされていれば、アプリケーションに統一したロギングの実装を提供する作業が簡単になります。\n\nロガーの修飾子を `static final` に変更するクイックフィックスが提供されています。\n\n**例:**\n\n\n      public class Significant {\n        private Logger LOG = Logger.getLogger(Critical.class);\n      }\n\nクイックフィックス適用後:\n\n\n      public class Significant {\n        private static final Logger LOG = Logger.getLogger(Critical.class);\n      }\n\n\nインスペクションの構成:\n\n* ロガークラス名を指定するには、**ロガークラス名** テーブルを使用します。 このインスペクションは `static` かつ `final` ではなく、その型が指定されたクラス名の型に等しいフィールドを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonConstantLogger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ログ関連",
                      "index": 91,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Singleton",
                "shortDescription": {
                  "text": "シングルトン"
                },
                "fullDescription": {
                  "text": "シングルトンクラスを報告します。 シングルトンクラスは、クラスから 1 つのインスタンスのみをインスタンス化できるように宣言されたものです。 シングルトンクラスはテストを複雑化します。また、シングルトングラスが存在しているということは、オブジェクト指向設計に不備がある可能性があります。 例: 'class Singleton {\n    private static final Singleton ourInstance = new Singleton();\n\n    private Singleton() {\n    }\n\n    public Singleton getInstance() {\n        return ourInstance;\n    }\n  }'",
                  "markdown": "シングルトンクラスを報告します。\n\nシングルトンクラスは、クラスから 1 つのインスタンスのみをインスタンス化できるように宣言されたものです。 シングルトンクラスはテストを複雑化します。また、シングルトングラスが存在しているということは、オブジェクト指向設計に不備がある可能性があります。\n\n**例:**\n\n\n      class Singleton {\n        private static final Singleton ourInstance = new Singleton();\n\n        private Singleton() {\n        }\n\n        public Singleton getInstance() {\n            return ourInstance;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Singleton",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalUtilityClass",
                "shortDescription": {
                  "text": "'final' でないユーティリティクラス"
                },
                "fullDescription": {
                  "text": "'final' または 'abstract' でないユーティリティクラスを報告します。 ユーティリティクラスでは、すべてのフィールドとメソッドが 'static' で宣言されています。 ユーティリティクラスを 'final' にすると、誤ってスーパークラス化されることを防ぐことができます。 例: 'public class UtilityClass {\n    public static void foo() {}\n  }' クイックフィックス適用後: 'public final class UtilityClass {\n    public static void foo() {}\n  }'",
                  "markdown": "`final` または `abstract` でないユーティリティクラスを報告します。\n\nユーティリティクラスでは、すべてのフィールドとメソッドが `static` で宣言されています。\nユーティリティクラスを `final` にすると、誤ってスーパークラス化されることを防ぐことができます。\n\n**例:**\n\n\n      public class UtilityClass {\n        public static void foo() {}\n      }\n\nクイックフィックス適用後:\n\n\n      public final class UtilityClass {\n        public static void foo() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalUtilityClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FuseStreamOperations",
                "shortDescription": {
                  "text": "Stream API チェーンに統合できる後続のステップ"
                },
                "fullDescription": {
                  "text": "Stream API チェーンの外にある変換処理で、チェーンの中に組み入れ可能なものを検出します。 例: 'List<String> list = stream.collect(Collectors.toList());\n  list.sort(null);\n  return list.toArray(new String[list.size()]);' 変換後: 'return stream.sorted().toArray(String[]::new);' 変換後の Stream チェーンでは、明示的な 'ArrayList' が 'Collectors.toList()' に、あるいは明示的な 'HashSet' が 'Collectors.toSet()' に置換されている場合があるため、注意が必要です。 現在のライブラリ実装では、これらのコレクションを内部的に使用しています。 ただし、この手法はあまり信頼性が高くないため、将来的にはコードのセマンティクスを変更する可能性があります。 不安な場合は、'toList()' または 'toSet()' コレクターを提案しない オプションを使用して、'toList' および 'toSet' コレクターではなく、'Collectors.toCollection()' を提案させるようにしてください。 このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "Stream API チェーンの外にある変換処理で、チェーンの中に組み入れ可能なものを検出します。\n\n例:\n\n\n      List<String> list = stream.collect(Collectors.toList());\n      list.sort(null);\n      return list.toArray(new String[list.size()]);\n\n変換後:\n\n\n      return stream.sorted().toArray(String[]::new);\n\n\n変換後の Stream チェーンでは、明示的な `ArrayList` が `Collectors.toList()` に、あるいは明示的な `HashSet` が `Collectors.toSet()` に置換されている場合があるため、注意が必要です。 現在のライブラリ実装では、これらのコレクションを内部的に使用しています。 ただし、この手法はあまり信頼性が高くないため、将来的にはコードのセマンティクスを変更する可能性があります。\n\n不安な場合は、**'toList()' または 'toSet()' コレクターを提案しない** オプションを使用して、`toList` および `toSet` コレクターではなく、`Collectors.toCollection()` を提案させるようにしてください。\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FuseStreamOperations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalExpressionWithIdenticalBranches",
                "shortDescription": {
                  "text": "同一の分岐を持つ条件式"
                },
                "fullDescription": {
                  "text": "内容がまったく同じ 'then' および 'else' 分岐を含む条件式を報告します。 このような式は、ほぼ確実にバグを誘発します。 このインスペクションは、条件式を簡潔にする修正を提供します。 例: 'int y = x == 10 ? 4 : 4;' クイックフィックス適用後: 'int y = 4;'",
                  "markdown": "内容がまったく同じ `then` および `else` 分岐を含む条件式を報告します。\n\nこのような式は、ほぼ確実にバグを誘発します。 このインスペクションは、条件式を簡潔にする修正を提供します。\n\n例:\n\n\n      int y = x == 10 ? 4 : 4;\n\nクイックフィックス適用後:\n\n\n      int y = 4;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConditionalExpressionWithIdenticalBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DefaultNotLastCaseInSwitch",
                "shortDescription": {
                  "text": "'default' が 'switch' の最後ではない"
                },
                "fullDescription": {
                  "text": "'default' 分岐が別のケースの前にある 'switch' ステートメントまたは式を報告します。 このようなコンストラクトは不要な混乱を招きます。 可能な場合は、'default' 分岐を最後に移動するクイックフィックスが提供されます。 例: 'switch (n) {\n      default:\n          System.out.println();\n          break;\n      case 1:\n          break;\n  }' クイックフィックス適用後: 'switch (n) {\n    case 1:\n        break;\n    default:\n        System.out.println();\n        break;\n  }'",
                  "markdown": "`default` 分岐が別のケースの前にある `switch` ステートメントまたは式を報告します。 このようなコンストラクトは不要な混乱を招きます。 可能な場合は、`default` 分岐を最後に移動するクイックフィックスが提供されます。\n\n**例:**\n\n\n      switch (n) {\n          default:\n              System.out.println();\n              break;\n          case 1:\n              break;\n      }\n\nクイックフィックス適用後:\n\n\n      switch (n) {\n        case 1:\n            break;\n        default:\n            System.out.println();\n            break;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DefaultNotLastCaseInSwitch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NullThrown",
                "shortDescription": {
                  "text": "'null' のスロー"
                },
                "fullDescription": {
                  "text": "'throw' ステートメントの引数として使用されている 'null' リテラルを報告します。 このようなコンストラクトは、一般的にプログラムでスローすべきでない 'java.lang.NullPointerException' を発生させます。",
                  "markdown": "`throw` ステートメントの引数として使用されている `null` リテラルを報告します。\n\nこのようなコンストラクトは、一般的にプログラムでスローすべきでない `java.lang.NullPointerException` を発生させます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NullThrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LocalCanBeFinal",
                "shortDescription": {
                  "text": "ローカル変数またはパラメーターは 'final' にできます"
                },
                "fullDescription": {
                  "text": "パラメーターまたはローカル変数で、その宣言に 'final' 修飾子が追加されている可能性があるものを報告します。 例: 'ArrayList<Integer> list = new ArrayList();\n  fill(list);\n  return list;' クイックフィックス適用後: 'final ArrayList<Integer> list = new ArrayList();\n  fill(list);\n  return list;' パラメーターまたはローカル変数を報告する必要があるかどうかを定義するには、インスペクションのオプションを使用します。",
                  "markdown": "パラメーターまたはローカル変数で、その宣言に `final` 修飾子が追加されている可能性があるものを報告します。\n\n例:\n\n\n      ArrayList<Integer> list = new ArrayList();\n      fill(list);\n      return list;\n\nクイックフィックス適用後:\n\n\n      final ArrayList<Integer> list = new ArrayList();\n      fill(list);\n      return list;\n\n\nパラメーターまたはローカル変数を報告する必要があるかどうかを定義するには、インスペクションのオプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LocalCanBeFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldMayBeStatic",
                "shortDescription": {
                  "text": "'static' にできるフィールド"
                },
                "fullDescription": {
                  "text": "安全に 'static' にできるインスタンス変数を報告します。 定数を使用して 'final' 宣言されているフィールドは static にできます。 例: 'public final String str = \"sample\";' このインスペクションは暗黙的に書き込める final フィールドを報告しません。 暗黙的なフィールドの書き込みを想定するアノテーションのリストを変更するには、「アノテーション」ボタンを使用します。",
                  "markdown": "安全に `static` にできるインスタンス変数を報告します。 定数を使用して `final` 宣言されているフィールドは static にできます。\n\n**例:**\n\n\n      public final String str = \"sample\";\n\n\nこのインスペクションは暗黙的に書き込める final フィールドを報告しません。 暗黙的なフィールドの書き込みを想定するアノテーションのリストを変更するには、「アノテーション」ボタンを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayEquals",
                "shortDescription": {
                  "text": "配列での 'equals()' 呼び出し"
                },
                "fullDescription": {
                  "text": "2 つの配列を比較している 'equals()' 呼び出しを報告します。 配列に対して 'equals()' を呼び出すと識別子が比較されます。これは '==' を使用するのと同じです。 2 つの配列の内容を比較するには 'Arrays.equals()' を、多次元配列を比較する場合は 'Arrays.deepEquals()' を使用してください。 例: 'void sample(int[] first, int[] second){\n    if (first.equals(second)) return;\n  }' クイックフィックス適用後: 'void sample(int[] first, int[] second){\n    if (Arrays.equals(first, second)) return;\n  }'",
                  "markdown": "2 つの配列を比較している `equals()` 呼び出しを報告します。\n\n配列に対して `equals()` を呼び出すと識別子が比較されます。これは `==` を使用するのと同じです。\n2 つの配列の内容を比較するには `Arrays.equals()` を、多次元配列を比較する場合は `Arrays.deepEquals()` を使用してください。\n\n**例:**\n\n\n      void sample(int[] first, int[] second){\n        if (first.equals(second)) return;\n      }\n\nクイックフィックス適用後:\n\n\n      void sample(int[] first, int[] second){\n        if (Arrays.equals(first, second)) return;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProblematicVarargsMethodOverride",
                "shortDescription": {
                  "text": "非可変引数メソッドが可変引数メソッドをオーバーライド"
                },
                "fullDescription": {
                  "text": "可変長引数 (別名: varargs) メソッドをオーバーライドしているものの、可変長引数パラメーターを配列パラメーターに置換しているメソッドを報告します。 このようなコードは有効ですが、混乱を招く可能性があるため、避けるべきです。",
                  "markdown": "可変長引数 (別名: varargs) メソッドをオーバーライドしているものの、可変長引数パラメーターを配列パラメーターに置換しているメソッドを報告します。 このようなコードは有効ですが、混乱を招く可能性があるため、避けるべきです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProblematicVarargsMethodOverride",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MisspelledHeader",
                "shortDescription": {
                  "text": "不明またはスペルが間違っているヘッダー名"
                },
                "fullDescription": {
                  "text": "不明なスペルミスがあると思われるヘッダー名を報告し、使用可能なヘッダー名を提供します。",
                  "markdown": "不明なスペルミスがあると思われるヘッダー名を報告し、使用可能なヘッダー名を提供します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MisspelledHeader",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "マニフェスト",
                      "index": 90,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OnlyOneElementUsed",
                "shortDescription": {
                  "text": "1 つの要素のみを使用"
                },
                "fullDescription": {
                  "text": "作成時に 1 つの要素だけが照会されている、リスト、配列、および文字列を報告します。 そのような式はリファクタリングの後に現れる可能性があり、通常はアクセスされている要素に置換できます。 例: 'System.out.println(new int[] {1,2,3,4,5}[2]);' クイックフィックス適用後: 'System.out.println(3);' 2022.3 の新機能です",
                  "markdown": "作成時に 1 つの要素だけが照会されている、リスト、配列、および文字列を報告します。 そのような式はリファクタリングの後に現れる可能性があり、通常はアクセスされている要素に置換できます。\n\n例:\n\n\n      System.out.println(new int[] {1,2,3,4,5}[2]);\n\nクイックフィックス適用後:\n\n\n      System.out.println(3);\n\n2022.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OnlyOneElementUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AtomicFieldUpdaterIssues",
                "shortDescription": {
                  "text": "一貫性のない 'AtomicFieldUpdater' 宣言"
                },
                "fullDescription": {
                  "text": "'AtomicLongFieldUpdater'、'AtomicIntegerFieldUpdater'、または 'AtomicReferenceFieldUpdater' フィールド ('java.util.concurrent.atomic' パッケージ) に関する問題を報告します。 報告対象の問題はアトミックフィールドアップデーターで発生しうる実行時の問題と同じで、指定フィールドが見つからない、指定フィールドにアクセスできない、指定フィールドの型が間違っている等です。 例: 'class A {\n    private static volatile int value = 0;\n    private static final AtomicIntegerFieldUpdater updater =\n    AtomicIntegerFieldUpdater.newUpdater((A.class), \"value\"); // 警告: フィールド 'value' には 'static' 修飾子が付いています\n  }' 'class B {\n    private static final AtomicIntegerFieldUpdater updater =\n      AtomicIntegerFieldUpdater.newUpdater(B.class, \"value\"); // 警告: 'value' という名前のフィールドはクラス 'B' にはありません\n  }'",
                  "markdown": "`AtomicLongFieldUpdater`、`AtomicIntegerFieldUpdater`、または `AtomicReferenceFieldUpdater` フィールド (`java.util.concurrent.atomic` パッケージ) に関する問題を報告します。\n\n報告対象の問題はアトミックフィールドアップデーターで発生しうる実行時の問題と同じで、指定フィールドが見つからない、指定フィールドにアクセスできない、指定フィールドの型が間違っている等です。\n\n**例:**\n\n*\n\n\n        class A {\n          private static volatile int value = 0;\n          private static final AtomicIntegerFieldUpdater updater =\n          AtomicIntegerFieldUpdater.newUpdater((A.class), \"value\"); // 警告: フィールド 'value' には 'static' 修飾子が付いています\n        }\n        \n*\n\n\n        class B {\n          private static final AtomicIntegerFieldUpdater updater =\n            AtomicIntegerFieldUpdater.newUpdater(B.class, \"value\"); // 警告: 'value' という名前のフィールドはクラス 'B' にはありません\n        }\n        \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AtomicFieldUpdaterIssues",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BadExceptionThrown",
                "shortDescription": {
                  "text": "禁止対象例外のスロー"
                },
                "fullDescription": {
                  "text": "不適切な例外をスローしている 'throw' ステートメントを報告します。 たとえば、 'java.lang.Exception' や 'java.io.IOException' などの一般的すぎる例外は不適切な可能性があります。 例: 'void setup(Mode mode) {\n      if (mode == null)\n          throw new RuntimeException(\"Problem during setup\"); // 警告: 禁止対象例外 'RuntimeException' がスローされています\n      ...\n  }' 報告対象の例外を指定するには、禁止対象例外 リストを使用します。",
                  "markdown": "不適切な例外をスローしている `throw` ステートメントを報告します。 たとえば、 `java.lang.Exception` や `java.io.IOException` などの一般的すぎる例外は不適切な可能性があります。\n\n**例:**\n\n\n      void setup(Mode mode) {\n          if (mode == null)\n              throw new RuntimeException(\"Problem during setup\"); // 警告: 禁止対象例外 'RuntimeException' がスローされています\n          ...\n      }\n\n報告対象の例外を指定するには、**禁止対象例外** リストを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProhibitedExceptionThrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryBoxing",
                "shortDescription": {
                  "text": "不要なボクシング"
                },
                "fullDescription": {
                  "text": "オブジェクトのプリミティブ値をラップしている明示的なボクシングを報告します。 Java 5 以降では明示的な手動ボクシングは不要であり、安全に除去できます。 例: 'Integer i = new Integer(1);' → 'Integer i = Integer.valueOf(1);' 'int i = Integer.valueOf(1);' → 'int i = 1;' ボクシングされた値が暗黙的または明示的に即座にアンボクシングされている場合など、本当に不必要なボクシングのみを報告するには、「本当に不必要にボクシングされた式だけを報告する」オプションを使用します。 このような場合、ボクシングとアンボクシングのステップ全体を除去できます。 このインスペクションは、単純かつ明示的なボクシングを報告しません。 このインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以上の場合にのみ報告します。",
                  "markdown": "オブジェクトのプリミティブ値をラップしている明示的なボクシングを報告します。\n\nJava 5 以降では明示的な手動ボクシングは不要であり、安全に除去できます。\n\n**例:**\n\n* `Integer i = new Integer(1);` → `Integer i = Integer.valueOf(1);`\n* `int i = Integer.valueOf(1);` → `int i = 1;`\n\n\nボクシングされた値が暗黙的または明示的に即座にアンボクシングされている場合など、本当に不必要なボクシングのみを報告するには、「**本当に不必要にボクシングされた式だけを報告する**」オプションを使用します。\nこのような場合、ボクシングとアンボクシングのステップ全体を除去できます。 このインスペクションは、単純かつ明示的なボクシングを報告しません。\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以上の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryBoxing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageNamingConvention",
                "shortDescription": {
                  "text": "パッケージの命名規則"
                },
                "fullDescription": {
                  "text": "名前が短すぎる、長すぎる、または指定した正規表現パターンに従っていないパッケージを報告します。 例: 'package io;' パッケージ名の最小の長さ、最大の長さ、および有効なパッケージ名に一致する正規表現 (正規表現は、'java.util.regex' の標準的な形式で指定) を指定するには、オプションを使用します。",
                  "markdown": "名前が短すぎる、長すぎる、または指定した正規表現パターンに従っていないパッケージを報告します。\n\n**例:**\n\n\n      package io;\n\n\nパッケージ名の最小の長さ、最大の長さ、および有効なパッケージ名に一致する正規表現 (正規表現は、`java.util.regex` の標準的な形式で指定) を指定するには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規約",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Anonymous2MethodRef",
                "shortDescription": {
                  "text": "メソッド参照に置換可能な匿名型"
                },
                "fullDescription": {
                  "text": "メソッド参照に置換できる匿名クラスを報告します。 匿名クラスがアンバウンドのメソッド参照に変換されると、Java ランタイムが後続の呼び出しで同じメソッド参照のオブジェクトを再利用することができます。 一方、匿名クラスが使用される際には毎回別のオブジェクトが作成されます。 そのため、匿名クラスインスタンスが 'HashMap' キーとして使用されているようなまれなケースでは、このクイックフィックスを適用した際にセマンティクスが変更される可能性があります。 例: 'Runnable r = new Runnable() {\n    @Override\n    public void run() {\n      System.out.println();\n    }\n  };' クイックフィックス適用後: 'Runnable r = System.out::println;' '@FunctionalInterface' アノテーションが付いていないインターフェースに対してこのインスペクションを有効にするには、「インターフェースに @FunctionalInterface アノテーションがない場合に報告する」オプションを使用します。 このインスペクションは Java 8 以降で使用できる Java の機能 'メソッド参照' に依存しています。",
                  "markdown": "メソッド参照に置換できる匿名クラスを報告します。\n\n\n匿名クラスがアンバウンドのメソッド参照に変換されると、Java ランタイムが後続の呼び出しで同じメソッド参照のオブジェクトを再利用することができます。 一方、匿名クラスが使用される際には毎回別のオブジェクトが作成されます。 そのため、匿名クラスインスタンスが `HashMap` キーとして使用されているようなまれなケースでは、このクイックフィックスを適用した際にセマンティクスが変更される可能性があります。\n\n**例:**\n\n\n      Runnable r = new Runnable() {\n        @Override\n        public void run() {\n          System.out.println();\n        }\n      };\n\nクイックフィックス適用後:\n\n\n      Runnable r = System.out::println;\n\n`@FunctionalInterface` アノテーションが付いていないインターフェースに対してこのインスペクションを有効にするには、「**インターフェースに @FunctionalInterface アノテーションがない場合に報告する**」オプションを使用します。\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'メソッド参照' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Anonymous2MethodRef",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicMethodNotExposedInInterface",
                "shortDescription": {
                  "text": "インターフェースに公開されていない 'public' メソッド"
                },
                "fullDescription": {
                  "text": "インターフェースで公開されていないクラスの 'public' メソッドを報告します。 インターフェイスを介してすべての 'public' メソッドを公開することは、疎結合を維持するうえで重要です。また、特定のコンポーネントベースのプログラミングスタイルで必要になる場合があります。 例: 'interface Person {\n  String getName();\n}\n\nclass PersonImpl implements Person {\n  private String name;\n\n  // ok: メソッドはインターフェースで公開されています\n  @Override\n  public String getName() {\n    return name;\n  }\n\n  // 警告: メソッドは public ですが\n  // インターフェースでは公開されていません\n  public void setName() {\n    this.name = name;\n  }\n}' 特別なアノテーションを指定するには、「次のアノテーションが付いている場合は無視」リストを使用します。 ここで指定されたアノテーションが付いているメソッドは、このインスペクションでは無視されます。 プロジェクトのインターフェイスを実装していないクラスのメソッドを無視するには、「包含クラスが非ライブラリインターフェースを実装していない場合は無視する 」オプションを使用します。",
                  "markdown": "インターフェースで公開されていないクラスの `public` メソッドを報告します。\n\nインターフェイスを介してすべての `public` メソッドを公開することは、疎結合を維持するうえで重要です。また、特定のコンポーネントベースのプログラミングスタイルで必要になる場合があります。\n\n例:\n\n\n    interface Person {\n      String getName();\n    }\n\n    class PersonImpl implements Person {\n      private String name;\n\n      // ok: メソッドはインターフェースで公開されています\n      @Override\n      public String getName() {\n        return name;\n      }\n\n      // 警告: メソッドは public ですが\n      // インターフェースでは公開されていません\n      public void setName() {\n        this.name = name;\n      }\n    }\n\n\n特別なアノテーションを指定するには、「**次のアノテーションが付いている場合は無視**」リストを使用します。 ここで指定されたアノテーションが付いているメソッドは、このインスペクションでは無視されます。\n\n\nプロジェクトのインターフェイスを実装していないクラスのメソッドを無視するには、「**包含クラスが非ライブラリインターフェースを実装していない場合は無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicMethodNotExposedInInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableHasSerialVersionUIDField",
                "shortDescription": {
                  "text": "'serialVersionUID' のない Serializable クラス"
                },
                "fullDescription": {
                  "text": "'Serializable' を実装し、'serialVersionUID' フィールドを宣言していないクラスを報告します。 'serialVersionUID' フィールドがない状態でクラスを変更すると、以前にシリアル化されたバージョンが読み取れなくなります。 例: 'class Main implements Serializable {\n  }' クイックフィックス適用後: 'class Main implements Serializable {\n    private static final long serialVersionUID = -1446398935944895849L;\n  }' JDK 14 以上の言語レベルを使用している場合、このクイックフィックスは 'java.io.Serial' アノテーションも追加します。 このインスペクションは、次のオプションを使用して構成できます。 このインスペクションで継承先を報告対象外とするクラスをリストする。 これは、スーパークラスの 'Serializable' を継承しているものの、シリアル化を目的としていないクラスを対象としています。 'Serializable' 匿名クラスを無視するかどうか。",
                  "markdown": "`Serializable` を実装し、`serialVersionUID` フィールドを宣言していないクラスを報告します。\n\n\n`serialVersionUID` フィールドがない状態でクラスを変更すると、以前にシリアル化されたバージョンが読み取れなくなります。\n\n**例:**\n\n\n      class Main implements Serializable {\n      }\n\nクイックフィックス適用後:\n\n\n      class Main implements Serializable {\n        private static final long serialVersionUID = -1446398935944895849L;\n      }\n\nJDK 14 以上の言語レベルを使用している場合、このクイックフィックスは `java.io.Serial` アノテーションも追加します。\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* このインスペクションで継承先を報告対象外とするクラスをリストする。 これは、スーパークラスの `Serializable` を継承しているものの、シリアル化を目的としていないクラスを対象としています。\n* `Serializable` 匿名クラスを無視するかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "serial",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowableNotThrown",
                "shortDescription": {
                  "text": "スローされていない 'Throwable'"
                },
                "fullDescription": {
                  "text": "'Throwable' またはそのサブクラスのインスタンス化で、作成される 'Throwable' が実際にスローされていない場合に報告します。 また、このインスペクションは 'Throwable' またはそのサブクラスのインスタンスを返すメソッド呼び出しがあり、そのメソッド呼び出しの結果がスローされない場合にも報告します。 Error Prone または AssertJ の '@CanIgnoreReturnValue' アノテーションが付いたメソッドの呼び出しは報告されません。 例: 'void check(String s) {\n        if (s == null) {\n            new NullPointerException(\"s\");\n        }\n        // ...\n    }'",
                  "markdown": "`Throwable` またはそのサブクラスのインスタンス化で、作成される `Throwable` が実際にスローされていない場合に報告します。 また、このインスペクションは `Throwable` またはそのサブクラスのインスタンスを返すメソッド呼び出しがあり、そのメソッド呼び出しの結果がスローされない場合にも報告します。\n\nError Prone または AssertJ の `@CanIgnoreReturnValue` アノテーションが付いたメソッドの呼び出しは報告されません。\n\n**例:**\n\n\n        void check(String s) {\n            if (s == null) {\n                new NullPointerException(\"s\");\n            }\n            // ...\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowableNotThrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CapturingCleaner",
                "shortDescription": {
                  "text": "オブジェクト参照をキャプチャしているクリーナー"
                },
                "fullDescription": {
                  "text": "登録されている参照をキャプチャしている 'Cleaner.register()' に渡されている 'Runnable' を報告します。 参照がキャプチャされた場合、参照は到達不可能なファントムになり、クリーニングアクションは呼び出されません。 この問題は以下が原因で起こる可能性があります。 非 static のメソッド、フィールド、または 'this' 自体を使用しているラムダ バージョン 18 までの Java で非 static の内部クラス (匿名であるかどうかは不問) が常にこの参照をキャプチャしている インスタンスメソッドの参照 非 static 内部クラスから外部クラスの非 static メンバーへのアクセス 以下は報告されるコードのサンプルです。 'int fileDescriptor;\n  Cleaner.Cleanable cleanable = Cleaner.create().register(this, () -> {\n    System.out.println(\"adsad\");\n    //this が fileDescriptor 経由でキャプチャされています\n    fileDescriptor = 0;\n  });' このインスペクションは、プロジェクトまたはモジュールの言語レベルが 9 以上の場合にのみ報告します。 2018.1 の新機能です",
                  "markdown": "登録されている参照をキャプチャしている `Cleaner.register()` に渡されている `Runnable` を報告します。 参照がキャプチャされた場合、参照は到達不可能なファントムになり、クリーニングアクションは呼び出されません。\n\nこの問題は以下が原因で起こる可能性があります。\n\n* 非 static のメソッド、フィールド、または `this` 自体を使用しているラムダ\n* バージョン 18 までの Java で非 static の内部クラス (匿名であるかどうかは不問) が常にこの参照をキャプチャしている\n* インスタンスメソッドの参照\n* 非 static 内部クラスから外部クラスの非 static メンバーへのアクセス\n\n以下は報告されるコードのサンプルです。\n\n\n      int fileDescriptor;\n      Cleaner.Cleanable cleanable = Cleaner.create().register(this, () -> {\n        System.out.println(\"adsad\");\n        //this が fileDescriptor 経由でキャプチャされています\n        fileDescriptor = 0;\n      });\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 9 以上の場合にのみ報告します。\n\n2018.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CapturingCleaner",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadStartInConstruction",
                "shortDescription": {
                  "text": "オブジェクト構築中の 'Thread.start()' の呼び出し"
                },
                "fullDescription": {
                  "text": "オブジェクトを構築中の 'java.lang.Thread' またはそのサブクラスでの 'start()' の呼び出しを報告します。 このようなコンストラクトは便利な場合もありますが、継承の問題があるため、避ける必要があります。 オブジェクトの構築中にスレッドを起動するクラスのサブクラスは、自身の初期化ロジックを完了することなくスレッドを起動します。 このインスペクションは、スレッドを開始するクラスが 'final' で宣言されているかどうかを報告しません。 例: 'class MyThread extends Thread {\n    MyThread() {\n      start();\n    }\n  }'",
                  "markdown": "オブジェクトを構築中の `java.lang.Thread` またはそのサブクラスでの `start()` の呼び出しを報告します。\n\n\nこのようなコンストラクトは便利な場合もありますが、継承の問題があるため、避ける必要があります。\nオブジェクトの構築中にスレッドを起動するクラスのサブクラスは、自身の初期化ロジックを完了することなくスレッドを起動します。\n\nこのインスペクションは、スレッドを開始するクラスが `final` で宣言されているかどうかを報告しません。\n\n**例:**\n\n\n      class MyThread extends Thread {\n        MyThread() {\n          start();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadStartDuringObjectConstruction",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestCaseWithNoTestMethods",
                "shortDescription": {
                  "text": "テストがないテストクラス"
                },
                "fullDescription": {
                  "text": "テストメソッドを持たない非 'abstract' テストケースを報告します。 このようなテストケースは一般的にコードが未完成であることを意味しているか、除去すべきリファクタリングの残存物である可能性があります。 例: 'public class CrucialTest {\n    @Before\n    public void setUp() {\n      System.out.println(\"setting up\");\n    }\n  }' テストメソッドを持つスーパークラスを含むテストケースを無視するには、「テストメソッドを持つスーパークラスを含むテストケースを無視」オプションを使用します。",
                  "markdown": "テストメソッドを持たない非 `abstract` テストケースを報告します。 このようなテストケースは一般的にコードが未完成であることを意味しているか、除去すべきリファクタリングの残存物である可能性があります。\n\n例:\n\n\n      public class CrucialTest {\n        @Before\n        public void setUp() {\n          System.out.println(\"setting up\");\n        }\n      }\n\n\nテストメソッドを持つスーパークラスを含むテストケースを無視するには、「**テストメソッドを持つスーパークラスを含むテストケースを無視**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnitTestCaseWithNoTests",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語/テストフレームワーク",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementWithTooManyBranches",
                "shortDescription": {
                  "text": "最大の 'switch' 分岐"
                },
                "fullDescription": {
                  "text": "'case' ラベルが多すぎる 'switch' ステートメントまたは式を報告します。 このような長い switch ステートメントは混乱を招く可能性があり、リファクタリングする必要があると思われます。 問題にならない場合もあります (定義域が非常に複雑で、多くの定数を持つ列挙型である場合など)。 例: 'switch (x) {\n        case 1 -> {}\n        case 2 -> {}\n        case 3 -> {}\n        case 4 -> {}\n        case 5 -> {}\n        case 6 -> {}\n        case 7 -> {}\n        case 8 -> {}\n        case 9 -> {}\n        case 10 -> {}\n        case 11,12,13 -> {}\n        default -> {}\n    }' 期待される 'case' ラベルの最大数を指定するには、「最大分岐数」フィールドを使用します。",
                  "markdown": "`case` ラベルが多すぎる `switch` ステートメントまたは式を報告します。\n\nこのような長い switch ステートメントは混乱を招く可能性があり、リファクタリングする必要があると思われます。\n問題にならない場合もあります (定義域が非常に複雑で、多くの定数を持つ列挙型である場合など)。\n\n例:\n\n\n        switch (x) {\n            case 1 -> {}\n            case 2 -> {}\n            case 3 -> {}\n            case 4 -> {}\n            case 5 -> {}\n            case 6 -> {}\n            case 7 -> {}\n            case 8 -> {}\n            case 9 -> {}\n            case 10 -> {}\n            case 11,12,13 -> {}\n            default -> {}\n        }\n\n期待される `case` ラベルの最大数を指定するには、「**最大分岐数**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SwitchStatementWithTooManyBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedArrayReadWrite",
                "shortDescription": {
                  "text": "不適切な配列読み書きの組み合わせ"
                },
                "fullDescription": {
                  "text": "内容が読み取られているが更新されていない配列、または更新されているが読み取られていない配列を報告します。 このような一貫性のない読み取りと書き込みは無意味であり、デッドコード、不完全なコード、または間違ったコードである可能性が高いです。 例: 'final int[] bar = new int[3];\n  bar[2] = 3;'",
                  "markdown": "内容が読み取られているが更新されていない配列、または更新されているが読み取られていない配列を報告します。 このような一貫性のない読み取りと書き込みは無意味であり、デッドコード、不完全なコード、または間違ったコードである可能性が高いです。\n\n**例:**\n\n\n      final int[] bar = new int[3];\n      bar[2] = 3;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedReadAndWriteOfArray",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarilyQualifiedStaticUsage",
                "shortDescription": {
                  "text": "不必要に修飾された static アクセス"
                },
                "fullDescription": {
                  "text": "クラス名で不必要に修飾されている static メンバーの使用箇所を報告します。 static メンバーが外部クラス、または外部クラスの super クラスにある場合は、クラスでの修飾は不要です。 そのような修飾は安全に除去できます。 例: 'class Foo {\n    static void foo() {}\n    static int x;\n\n    void bar() {\n      Foo.foo();\n      System.out.println(Foo.x);\n    }\n\n    static void baz() { Foo.foo(); }\n  }' クイックフィックス適用後: 'class Foo {\n    static void foo() {}\n    static int x;\n\n    void bar() {\n      foo();\n      System.out.println(x);\n    }\n\n    static void baz() { foo(); }\n  }' 報告対象を切り替えるには、インスペクションのオプションを使用します。 static フィールドのアクセス: 'void bar() { System.out.println(Foo.x); }' static メソッドの呼び出し: 'void bar() { Foo.foo(); }' また、static コンテキスト内にある static メンバーの使用箇所のみを報告するようにインスペクションを構成することもできます。 その場合は、'static void baz() { Foo.foo(); }' のみが報告されます。",
                  "markdown": "クラス名で不必要に修飾されている static メンバーの使用箇所を報告します。\n\n\nstatic メンバーが外部クラス、または外部クラスの super クラスにある場合は、クラスでの修飾は不要です。 そのような修飾は安全に除去できます。\n\n**例:**\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          Foo.foo();\n          System.out.println(Foo.x);\n        }\n\n        static void baz() { Foo.foo(); }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          foo();\n          System.out.println(x);\n        }\n\n        static void baz() { foo(); }\n      }\n\n\n報告対象を切り替えるには、インスペクションのオプションを使用します。\n\n* static フィールドのアクセス:  \n  `void bar() { System.out.println(Foo.x); }`\n\n* static メソッドの呼び出し:  \n  `void bar() { Foo.foo(); }`\n\n\nまた、static コンテキスト内にある static メンバーの使用箇所のみを報告するようにインスペクションを構成することもできます。 その場合は、`static void baz() { Foo.foo(); }` のみが報告されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessarilyQualifiedStaticUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoopConditionNotUpdatedInsideLoop",
                "shortDescription": {
                  "text": "ループ内で更新されないループ変数"
                },
                "fullDescription": {
                  "text": "ループ条件で使用されているものの、ループ内で更新されていない変数とパラメーターを報告します。 このような変数やパラメーターは実行時に無限ループを引き起こす可能性があり、多くの場合は誤って使用されています。 例: 'void loopDoesNotLoop(boolean b) {\n    while (b) {\n      System.out.println();\n      break;\n    }\n  }' インスペクションの構成: 条件式を間接的に更新できる場合は (例: 呼び出されたメソッドを使用して更新する、または別のスレッドから同時に更新する)、「可能な場合にローカルでない変更を無視する」オプションを使用すればこのインスペクションを無効化できます。",
                  "markdown": "ループ条件で使用されているものの、ループ内で更新されていない変数とパラメーターを報告します。\n\nこのような変数やパラメーターは実行時に無限ループを引き起こす可能性があり、多くの場合は誤って使用されています。\n\n例:\n\n\n      void loopDoesNotLoop(boolean b) {\n        while (b) {\n          System.out.println();\n          break;\n        }\n      }\n\nインスペクションの構成:\n\n\n条件式を間接的に更新できる場合は (例: 呼び出されたメソッドを使用して更新する、または別のスレッドから同時に更新する)、「**可能な場合にローカルでない変更を無視する**」オプションを使用すればこのインスペクションを無効化できます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoopConditionNotUpdatedInsideLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CollectionsMustHaveInitialCapacity",
                "shortDescription": {
                  "text": "初期容量のないコレクション"
                },
                "fullDescription": {
                  "text": "初期容量を指定せずに新しい 'Collection' オブジェクトがインスタンス化されようとしていることを報告します。 初期容量が指定されていない場合はデフォルトの容量が使用されますが、これが最適であることはめったにありません。 コレクションの初期容量を指定しなかった場合、初期容量を超えた時点で空き領域を再割り当てしてメモリをコピーする必要がある場合にパフォーマンスに問題が生じる可能性があります。 このインスペクションは、インスペクションの設定に記載されているクラスの割り当てをチェックします。 例: 'new HashMap<String, String>();' このインスペクションは、次のオプションを使用して構成できます。 チェック対象のコレクションクラスをリストする。 フィールドイニシャライザーを無視するかどうか。",
                  "markdown": "初期容量を指定せずに新しい `Collection` オブジェクトがインスタンス化されようとしていることを報告します。\n\n\n初期容量が指定されていない場合はデフォルトの容量が使用されますが、これが最適であることはめったにありません。 コレクションの初期容量を指定しなかった場合、初期容量を超えた時点で空き領域を再割り当てしてメモリをコピーする必要がある場合にパフォーマンスに問題が生じる可能性があります。\nこのインスペクションは、インスペクションの設定に記載されているクラスの割り当てをチェックします。\n\n**例:**\n\n\n      new HashMap<String, String>();\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* チェック対象のコレクションクラスをリストする。\n* フィールドイニシャライザーを無視するかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionWithoutInitialCapacity",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemGetProperty",
                "shortDescription": {
                  "text": "'System.getProperty(str)' への呼び出しは単純化できます"
                },
                "fullDescription": {
                  "text": "'System.getProperty(str)' メソッドの使用箇所を報告し、以下の 2 つの場合に修正を提案します。 'System.getProperty(\"path.separator\")' -> 'File.pathSeparator' 'System.getProperty(\"line.separator\")' -> 'System.lineSeparator()' 2 つ目の修正ではエラーが発生しにくくなるだけでなく、速度の改善も期待できます。'System.getProperty(\"line.separator\")' が毎回プロパティ (実装に応じて Hashtable または CHM) を呼び出すのに対し、'System.lineSeparator()' はキャッシュされた値を返すためです。",
                  "markdown": "`System.getProperty(str)` メソッドの使用箇所を報告し、以下の 2 つの場合に修正を提案します。\n\n* `System.getProperty(\"path.separator\")` -\\> `File.pathSeparator`\n* `System.getProperty(\"line.separator\")` -\\> `System.lineSeparator()`\n\n2 つ目の修正ではエラーが発生しにくくなるだけでなく、速度の改善も期待できます。`System.getProperty(\"line.separator\")` が毎回プロパティ (実装に応じて Hashtable または CHM) を呼び出すのに対し、`System.lineSeparator()` はキャッシュされた値を返すためです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SystemGetProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DoubleCheckedLocking",
                "shortDescription": {
                  "text": "ダブルチェックロック"
                },
                "fullDescription": {
                  "text": "ダブルチェックロックを報告します。 ダブルチェックロックは同期コストを避けながら、オンデマンドかつスレッドセーフな方法でフィールドを初期化しようとします。 残念ながら、'volatile' で宣言されていないフィールドで使用される場合はスレッドセーフではありません。 Java 1.4 以前を使用している場合、'volatile' フィールドを使用していてもダブルチェックロックは機能しません。 この問題の詳細な説明については、上記のリンク先の記事をご覧ください。 正しくないダブルチェックロックの例: 'class Foo {\n    private Helper helper = null;\n    public Helper getHelper() {\n      if (helper == null)\n        synchronized(this) {\n          if (helper == null) helper = new Helper();\n        }\n        return helper;\n      }\n    }\n    // 他の関数とメンバー...\n  }'",
                  "markdown": "[ダブルチェックロック](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html)を報告します。\n\n\nダブルチェックロックは同期コストを避けながら、オンデマンドかつスレッドセーフな方法でフィールドを初期化しようとします。\n残念ながら、`volatile` で宣言されていないフィールドで使用される場合はスレッドセーフではありません。\nJava 1.4 以前を使用している場合、`volatile` フィールドを使用していてもダブルチェックロックは機能しません。\nこの問題の詳細な説明については、上記のリンク先の記事をご覧ください。\n\n正しくないダブルチェックロックの例:\n\n\n      class Foo {\n        private Helper helper = null;\n        public Helper getHelper() {\n          if (helper == null)\n            synchronized(this) {\n              if (helper == null) helper = new Helper();\n            }\n            return helper;\n          }\n        }\n        // 他の関数とメンバー...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DoubleCheckedLocking",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassOnlyUsedInOneModule",
                "shortDescription": {
                  "text": "他のモジュールからのみ使用されるクラス"
                },
                "fullDescription": {
                  "text": "以下の条件に当てはまるクラスを報告します。 所属モジュール内の他のクラスに依存していない 別モジュールのクラスに依存している 該当する別モジュールのクラスにとって唯一の依存関係である このようなクラスは依存先のモジュールに移動できます。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "以下の条件に当てはまるクラスを報告します。\n\n* 所属モジュール内の他のクラスに依存していない\n* 別モジュールのクラスに依存している\n* 該当する別モジュールのクラスにとって唯一の依存関係である\n\nこのようなクラスは依存先のモジュールに移動できます。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassOnlyUsedInOneModule",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/モジュール化関連の問題",
                      "index": 65,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TryStatementWithMultipleResources",
                "shortDescription": {
                  "text": "分割可能な複数のリソースを含む 'try' ステートメント"
                },
                "fullDescription": {
                  "text": "複数のリソースを持つ 'try' ステートメントで、自動的に複数の try-with-resource ステートメントに分割できるものを報告します。 この変換は、リファクタリングを続けて行うときに便利な場合があります (ネストした 'try' ステートメントを別のメソッドに抽出する場合など)。 例: 'try (FileInputStream in = new FileInputStream(\"in.txt\");\n     FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n     /*読み込みと書き込み*/\n  }' クイックフィックス適用後: 'try (FileInputStream in = new FileInputStream(\"in.txt\")) {\n    try (FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n      /*読み込みと書き込み*/\n    }\n  }'",
                  "markdown": "複数のリソースを持つ `try` ステートメントで、自動的に複数の try-with-resource ステートメントに分割できるものを報告します。\n\nこの変換は、リファクタリングを続けて行うときに便利な場合があります (ネストした `try` ステートメントを別のメソッドに抽出する場合など)。\n\n例:\n\n\n      try (FileInputStream in = new FileInputStream(\"in.txt\");\n         FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n         /*読み込みと書き込み*/\n      }\n\nクイックフィックス適用後:\n\n\n      try (FileInputStream in = new FileInputStream(\"in.txt\")) {\n        try (FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n          /*読み込みと書き込み*/\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TryStatementWithMultipleResources",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneableImplementsClone",
                "shortDescription": {
                  "text": "'clone()' メソッドのない Cloneable クラス"
                },
                "fullDescription": {
                  "text": "'clone()' メソッドをオーバーライドしない 'Cloneable' インターフェースを実装しているクラスを報告します。 このようなクラスは 'public' ではなく 'protected' であり、クラスのミュータブルな状態をコピーしない 'clone()' のデフォルトの実装を使用します。 基本的な 'clone()' メソッドを生成するクイックフィックスを使用できます。このようなメソッドは、'Cloneable' クラスに必要な適切に機能する 'clone()' メソッドの基礎として使用できます。 例: 'public class Data implements Cloneable {\n    private String[] names;\n  }' クイックフィックス適用後: 'public class Data implements Cloneable {\n    private String[] names;\n\n    @Override\n    public Data clone() {\n      try {\n        Data clone = (Data) super.clone();\n        // TODO: ここにミュータブルな状態をコピーし、クローンが元の内部を変更できないようにする\n        return clone;\n      } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n      }\n    }\n  }' 'Cloneable' クラスからの継承のために 'Cloneable' なクラスを無視するには、「継承のために Cloneable クラスを無視する」オプションを使用します。 スーパークラスの 'clone()' メソッドを呼び出すために 'Cloneable' の実装が必要なクラスを無視するには、「スーパークラスの clone() メソッドを呼び出すために Cloneable が必要な場合は無視する」オプションを使用します。",
                  "markdown": "`clone()` メソッドをオーバーライドしない `Cloneable` インターフェースを実装しているクラスを報告します。\n\nこのようなクラスは `public` ではなく `protected` であり、クラスのミュータブルな状態をコピーしない `clone()` のデフォルトの実装を使用します。\n\n基本的な `clone()` メソッドを生成するクイックフィックスを使用できます。このようなメソッドは、`Cloneable` クラスに必要な適切に機能する `clone()` メソッドの基礎として使用できます。\n\n**例:**\n\n\n      public class Data implements Cloneable {\n        private String[] names;\n      }\n\nクイックフィックス適用後:\n\n\n      public class Data implements Cloneable {\n        private String[] names;\n\n        @Override\n        public Data clone() {\n          try {\n            Data clone = (Data) super.clone();\n            // TODO: ここにミュータブルな状態をコピーし、クローンが元の内部を変更できないようにする\n            return clone;\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n\n`Cloneable` クラスからの継承のために `Cloneable` なクラスを無視するには、「**継承のために Cloneable クラスを無視する**」オプションを使用します。\n\nスーパークラスの `clone()` メソッドを呼び出すために `Cloneable` の実装が必要なクラスを無視するには、「**スーパークラスの clone() メソッドを呼び出すために Cloneable が必要な場合は無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneableClassWithoutClone",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クローン関連の問題",
                      "index": 79,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeMayBeWeakened",
                "shortDescription": {
                  "text": "弱化できる型"
                },
                "fullDescription": {
                  "text": "より抽象的な (より弱い) 型に変更できる変数とメソッドの戻り値の型を報告します。 そのような変更を行うとコードがより抽象的になり、再利用しやすくなります。 例: '// Type of parameter can be weakened to java.util.List\n  void processList(ArrayList<String> list) {\n    if (list.isEmpty()) return;\n    System.out.println(\"Processing\");\n    for (String s : list) {\n      System.out.println(\"String: \" + s);\n    }\n  }' 型がインターフェース型に弱化される可能性がある場合にのみ問題を報告するには、下にある「インターフェースへの弱化のみ」チェックボックスを有効にします。 'var' キーワード (Java 10 以降) を使用して宣言されたローカル変数を報告しないようにするには、下にある「'var' 宣言されている変数の弱化を提案しない」チェックボックスを有効にします。 停止クラスは停止クラスよりも低いクラスへの弱化が可能な場合でも弱化を防ぐことを意図しています。 このような弱化を防ぐことで、可読性が向上する場合があります。",
                  "markdown": "より抽象的な (より弱い) 型に変更できる変数とメソッドの戻り値の型を報告します。 そのような変更を行うとコードがより抽象的になり、再利用しやすくなります。\n\n例:\n\n\n      // Type of parameter can be weakened to java.util.List\n      void processList(ArrayList<String> list) {\n        if (list.isEmpty()) return;\n        System.out.println(\"Processing\");\n        for (String s : list) {\n          System.out.println(\"String: \" + s);\n        }\n      }\n\n\n型がインターフェース型に弱化される可能性がある場合にのみ問題を報告するには、下にある「**インターフェースへの弱化のみ**」チェックボックスを有効にします。\n\n\n'var' キーワード (Java 10 以降) を使用して宣言されたローカル変数を報告しないようにするには、下にある「**'var' 宣言されている変数の弱化を提案しない**」チェックボックスを有効にします。\n\n\n**停止クラス**は停止クラスよりも低いクラスへの弱化が可能な場合でも弱化を防ぐことを意図しています。\nこのような弱化を防ぐことで、可読性が向上する場合があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeMayBeWeakened",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OctalAndDecimalIntegersMixed",
                "shortDescription": {
                  "text": "同じ配列内の 8 進数と 10 進整数"
                },
                "fullDescription": {
                  "text": "単一の配列イニシャライザーに 8 進および 10 進整数リテラルが混在していることを報告します。 この状況は、数値のリストを配列イニシャライザーにコピーする際に発生する場合があります。 配列内の一部のメンバーがゼロ埋めされ、コンパイラーがそれらを 8 進数として解釈する可能性があります。 例: 'int[] elapsed = {1, 13, 052};' 先頭のゼロを除去するクイックフィックスを適用後: 'int[] elapsed = {1, 13, 52};' これが 8 進数である場合 (変数インラインの後など)、8 進数を 10 進数に変換する別のクイックフィックスを使用できます。 'int[] elapsed = {1, 13, 42};'",
                  "markdown": "単一の配列イニシャライザーに 8 進および 10 進整数リテラルが混在していることを報告します。 この状況は、数値のリストを配列イニシャライザーにコピーする際に発生する場合があります。 配列内の一部のメンバーがゼロ埋めされ、コンパイラーがそれらを 8 進数として解釈する可能性があります。\n\n**例:**\n\n    int[] elapsed = {1, 13, 052};\n\n先頭のゼロを除去するクイックフィックスを適用後:\n\n    int[] elapsed = {1, 13, 52};\n\nこれが 8 進数である場合 (変数インラインの後など)、8 進数を 10 進数に変換する別のクイックフィックスを使用できます。\n`int[] elapsed = {1, 13, 42};`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OctalAndDecimalIntegersInSameArray",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Deprecation",
                "shortDescription": {
                  "text": "非推奨 API の使用"
                },
                "fullDescription": {
                  "text": "非推奨のクラス、フィールド、メソッドの使用箇所を報告します。 非推奨の使用箇所を自動的に変換するクイックフィックスを使用できます (必要な情報を非推奨メンバーの Javadoc から抽出できる場合)。 例: 'class Interesting {\n\n    /**\n     * @deprecated {@link #newHotness()} を代わりに使用してください\n     */\n    @Deprecated\n    public void oldAndBusted() {}\n\n    public void newHotness() {}\n  }\n  class ElseWhere {\n    void x(Interesting i) {\n      i.oldAndBusted(); // ここで非推奨の警告が表示されます\n    }\n  }' クイックフィックス適用後: 'class Interesting {\n\n    /**\n     * @deprecated {@link #newHotness()} を代わりに使用してください\n     */\n    @Deprecated\n    public void oldAndBusted() {}\n\n    public void newHotness() {}\n  }\n  class ElseWhere {\n    void x(Interesting i) {\n      i.newHotness();\n    }\n  }' デフォルトでは、このインスペクションは回避不可能、または回避困難なものについては警告しません。 たとえば、以下のコードは報告されません。 'abstract class A { //ライブラリのコード\n     @Deprecated\n     abstract void m();\n  }\n  class B extends A { //プロジェクトのコード\n     @Override\n     void m() {\n        //doSmth;\n     }\n  }' インスペクションの構成: 非推奨メンバー、非推奨 abstract メソッドをオーバーライドしたメソッド、非 static の import ステートメント、非推奨クラスのメソッド、または同じトップクラスの中でこのインスペクションを無効化するには、オプションを使用します。",
                  "markdown": "非推奨のクラス、フィールド、メソッドの使用箇所を報告します。 非推奨の使用箇所を自動的に変換するクイックフィックスを使用できます (必要な情報を非推奨メンバーの Javadoc から抽出できる場合)。\n\n**例:**\n\n\n      class Interesting {\n\n        /**\n         * @deprecated {@link #newHotness()} を代わりに使用してください\n         */\n        @Deprecated\n        public void oldAndBusted() {}\n\n        public void newHotness() {}\n      }\n      class ElseWhere {\n        void x(Interesting i) {\n          i.oldAndBusted(); // ここで非推奨の警告が表示されます\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Interesting {\n\n        /**\n         * @deprecated {@link #newHotness()} を代わりに使用してください\n         */\n        @Deprecated\n        public void oldAndBusted() {}\n\n        public void newHotness() {}\n      }\n      class ElseWhere {\n        void x(Interesting i) {\n          i.newHotness();\n        }\n      }\n\nデフォルトでは、このインスペクションは回避不可能、または回避困難なものについては警告しません。 たとえば、以下のコードは報告されません。\n\n\n      abstract class A { //ライブラリのコード\n         @Deprecated\n         abstract void m();\n      }\n      class B extends A { //プロジェクトのコード\n         @Override\n         void m() {\n            //doSmth;\n         }\n      }\n\nインスペクションの構成:\n\n\n非推奨メンバー、非推奨 abstract メソッドをオーバーライドしたメソッド、非 static の import ステートメント、非推奨クラスのメソッド、または同じトップクラスの中でこのインスペクションを無効化するには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "deprecation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コード成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MisspelledMethodName",
                "shortDescription": {
                  "text": "大文字と小文字のみが異なるメソッド名"
                },
                "fullDescription": {
                  "text": "あるクラスに複数のメソッドがあり、それらの名前の大文字と小文字だけが異なっている場合を報告します。 このような名前は大きな混乱を招く可能性があります。 例: 'public int hashcode() { // 報告されます。hashCode が正しいのでは？\n    return 0;\n  }' このようなメソッドの名前を変更するクイックフィックスは、エディターでのみ使用できます。 スーパークラスのメソッドをオーバーライドまたは実装するメソッドを無視するには、「スーパーメソッドをオーバーライド/実装するメソッドを無視」オプションを使用します。",
                  "markdown": "あるクラスに複数のメソッドがあり、それらの名前の大文字と小文字だけが異なっている場合を報告します。 このような名前は大きな混乱を招く可能性があります。\n\n**例:**\n\n\n      public int hashcode() { // 報告されます。hashCode が正しいのでは？\n        return 0;\n      }\n\nこのようなメソッドの名前を変更するクイックフィックスは、エディターでのみ使用できます。\n\nスーパークラスのメソッドをオーバーライドまたは実装するメソッドを無視するには、「**スーパーメソッドをオーバーライド/実装するメソッドを無視**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodNamesDifferingOnlyByCase",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規則/メソッド",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableObjectBoundToHttpSession",
                "shortDescription": {
                  "text": "'HttpSession' にバインドされた非 Serializable オブジェクト"
                },
                "fullDescription": {
                  "text": "'javax.servlet.http.HttpSession.setAttribute()' または 'javax.servlet.http.HttpSession.putValue()' の引数として使用されている 'java.io.Serializable' を実装していないクラスのオブジェクトを報告します。 このようなオブジェクトは 'HttpSession' がパッシベーションまたは移行されている場合にはシリアル化されず、バグの診断が困難になる可能性があります。 このインスペクションは型 'java.util.Collection' および 'java.util.Map' のオブジェクトについて、型のパラメーターが非 'Serializable' でない限りは 'Serializable' であると仮定します。 例: 'void foo(HttpSession session) {\n      session.setAttribute(\"foo\", new NonSerializable());\n  }\n  static class NonSerializable {}'",
                  "markdown": "`javax.servlet.http.HttpSession.setAttribute()` または `javax.servlet.http.HttpSession.putValue()` の引数として使用されている `java.io.Serializable` を実装していないクラスのオブジェクトを報告します。\n\n\nこのようなオブジェクトは `HttpSession` がパッシベーションまたは移行されている場合にはシリアル化されず、バグの診断が困難になる可能性があります。\n\n\nこのインスペクションは型 `java.util.Collection` および `java.util.Map` のオブジェクトについて、型のパラメーターが非 `Serializable` でない限りは `Serializable` であると仮定します。\n\n**例:**\n\n\n      void foo(HttpSession session) {\n          session.setAttribute(\"foo\", new NonSerializable());\n      }\n      static class NonSerializable {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableObjectBoundToHttpSession",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionSignal",
                "shortDescription": {
                  "text": "'signalAll()' の代わりに 'signal()' を呼び出し"
                },
                "fullDescription": {
                  "text": "'java.util.concurrent.locks.Condition.signal()' の呼び出しを報告します。 このような呼び出しは便利な場合もありますが、ほとんどの場合は 'signalAll()' を使用するほうが適切かつ安全です。",
                  "markdown": "`java.util.concurrent.locks.Condition.signal()` の呼び出しを報告します。 このような呼び出しは便利な場合もありますが、ほとんどの場合は `signalAll()` を使用するほうが適切かつ安全です。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSignalInsteadOfSignalAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadLocalNotStaticFinal",
                "shortDescription": {
                  "text": "'static final' で宣言されていない 'ThreadLocal' フィールド"
                },
                "fullDescription": {
                  "text": "'static final' で宣言されていない 'java.lang.ThreadLocal' 型フィールドを報告します。 一般的に、'java.lang.ThreadLocal' インスタンスはスレッドの状態と関連付いています。 非 static で非 final の 'java.lang.ThreadLocal' フィールドは、インスタンスとスレッドの組み合わせの状態と関連付いています。 これは通常不要であり、多くの場合はメモリリークや誤動作を引き起こす可能性があるバグです。 フィールドを 'static final' にするクイックフィックスが提案されます。 例: 'private ThreadLocal tl = ThreadLocal.withInitial(() -> Boolean.TRUE);'",
                  "markdown": "`static final` で宣言されていない `java.lang.ThreadLocal` 型フィールドを報告します。\n\n\n一般的に、`java.lang.ThreadLocal` インスタンスはスレッドの状態と関連付いています。\n非 static で非 final の `java.lang.ThreadLocal` フィールドは、インスタンスとスレッドの組み合わせの状態と関連付いています。\nこれは通常不要であり、多くの場合はメモリリークや誤動作を引き起こす可能性があるバグです。\n\n\nフィールドを `static final` にするクイックフィックスが提案されます。\n\n\n**例:**\n\n\n      private ThreadLocal tl = ThreadLocal.withInitial(() -> Boolean.TRUE);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThreadLocalNotStaticFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AccessStaticViaInstance",
                "shortDescription": {
                  "text": "インスタンス参照を通した static メンバーへのアクセス"
                },
                "fullDescription": {
                  "text": "クラス自体ではなく、クラスインスタンスによる 'static' メソッドとフィールドの参照を報告します。 インスタンス変数を使用した static メンバーの参照は Java 言語の仕様で許可されてはいますが、コードが理解しにくくなってしまいます。メソッドの結果がインスタンスに依存していると読み手が解釈する可能性があるためです。 クイックフィックスを使用すると、インスタンス変数がクラス名に置換されます。 例: 'String s1 = s.valueOf(0);' クイックフィックス適用後: 'String s = String.valueOf(0);'",
                  "markdown": "クラス自体ではなく、クラスインスタンスによる `static` メソッドとフィールドの参照を報告します。\n\nインスタンス変数を使用した static メンバーの参照は Java 言語の仕様で許可されてはいますが、コードが理解しにくくなってしまいます。メソッドの結果がインスタンスに依存していると読み手が解釈する可能性があるためです。\n\nクイックフィックスを使用すると、インスタンス変数がクラス名に置換されます。\n\n例:\n\n\n      String s1 = s.valueOf(0);\n\nクイックフィックス適用後:\n\n\n      String s = String.valueOf(0);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessStaticViaInstance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicMethodWithoutLogging",
                "shortDescription": {
                  "text": "ロギングなしの 'public' メソッド"
                },
                "fullDescription": {
                  "text": "ロギングステートメントを含まない public メソッドを報告します。 このインスペクションは単純な getter と setter を報告しません。 例: 'public class Crucial {\n    private static final Logger LOG = LoggerFactory.getLogger(Crucial.class);\n    public void doImportantStuff() {\n      // このメソッドに関する警告\n    }\n\n    public void doOtherStuff() {\n      LOG.info(\"do other stuff\");\n    }\n  }' ロガークラス名を指定するには、以下の表を使用してください。 このインスペクションにより、指定したクラスのインスタンスメソッドを使用しない public メソッドが報告されます。",
                  "markdown": "ロギングステートメントを含まない public メソッドを報告します。 このインスペクションは単純な getter と setter を報告しません。\n\n例:\n\n\n      public class Crucial {\n        private static finalLogger LOG = LoggerFactory.getLogger(Crucial.class);\n        public void doImportantStuff() {\n          // このメソッドに関する警告\n        }\n\n        public void doOtherStuff() {\n          LOG.info(\"do other stuff\");\n        }\n      }\n\n\nロガークラス名を指定するには、以下の表を使用してください。\nこのインスペクションにより、指定したクラスのインスタンスメソッドを使用しない public メソッドが報告されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicMethodWithoutLogging",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ログ関連",
                      "index": 91,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNestingDepth",
                "shortDescription": {
                  "text": "ネストが深すぎる内部クラス"
                },
                "fullDescription": {
                  "text": "ネストした内部クラスの数が指定された最大値を超えているクラスを報告します。 他の内部クラスの中でネストしている内部クラスは混乱を招くため、リファクタリングが必要な可能性があります。 クラスで許容されるネストの深さの最大値を指定するには、「ネストの制限」フィールドを使用します。",
                  "markdown": "ネストした内部クラスの数が指定された最大値を超えているクラスを報告します。\n\n他の内部クラスの中でネストしている内部クラスは混乱を招くため、リファクタリングが必要な可能性があります。\n\nクラスで許容されるネストの深さの最大値を指定するには、「**ネストの制限**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassTooDeeplyNested",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラスメトリクス",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToNativeMethodWhileLocked",
                "shortDescription": {
                  "text": "ロックされた状態での 'native' メソッドの呼び出し"
                },
                "fullDescription": {
                  "text": "'synchronized' ブロックまたはメソッドに含まれる 'native' メソッドの呼び出しを報告します。 可能であれば 'native' メソッドの呼び出しを同期コンテキストから除外することをお勧めします。このような呼び出しは高コストなコンテキスト切り替えを誘発し、パフォーマンスの問題を引き起こす可能性があるためです。 例: 'native void nativeMethod();\n\n  void example(){\n    synchronized (lock){\n      nativeMethod();//警告\n    }\n  }'",
                  "markdown": "`synchronized` ブロックまたはメソッドに含まれる `native` メソッドの呼び出しを報告します。\n\n\n可能であれば `native` メソッドの呼び出しを同期コンテキストから除外することをお勧めします。このような呼び出しは高コストなコンテキスト切り替えを誘発し、パフォーマンスの問題を引き起こす可能性があるためです。\n\n**例:**\n\n\n      native void nativeMethod();\n\n      void example(){\n        synchronized (lock){\n          nativeMethod();//警告\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToNativeMethodWhileLocked",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Dependency",
                "shortDescription": {
                  "text": "不正なパッケージ依存関係"
                },
                "fullDescription": {
                  "text": "所定の依存関係ルールに従って、スコープ間の不正な依存関係を報告します。 依存関係ルールは、あるスコープから他のスコープでの使用を禁止するために使用できます。 検証ルールをカスタマイズするには、以下の「依存関係ルールの構成」ボタンを使用します。",
                  "markdown": "所定の依存関係ルールに従って、スコープ間の不正な依存関係を報告します。 依存関係ルールは、あるスコープから他のスコープでの使用を禁止するために使用できます。\n\n検証ルールをカスタマイズするには、以下の「**依存関係ルールの構成**」ボタンを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "Dependency",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestingDepth",
                "shortDescription": {
                  "text": "過度にネストしたメソッド"
                },
                "fullDescription": {
                  "text": "本文にネストが深すぎるステートメントが含まれているメソッドを報告します。 ステートメントのネストが深すぎるメソッドは混乱を招く可能性があるため、リファクタリングが必要かもしれません。 メソッドで許容されるネストの深さの最大値を指定するには、「ネストの深さ制限」フィールドを使用します。",
                  "markdown": "本文にネストが深すぎるステートメントが含まれているメソッドを報告します。\n\nステートメントのネストが深すぎるメソッドは混乱を招く可能性があるため、リファクタリングが必要かもしれません。\n\nメソッドで許容されるネストの深さの最大値を指定するには、「**ネストの深さ制限**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyNestedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メソッドメトリクス",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaParameterTypeCanBeSpecified",
                "shortDescription": {
                  "text": "ラムダパラメーターの型を指定可能"
                },
                "fullDescription": {
                  "text": "型指定のないラムダパラメーターを報告し、型宣言を追加することを提案します。 例: 'Function<String, Integer> length = a -> a.length();' クイックフィックス適用後: 'Function<String, Integer> length = (String a) -> a.length();' このインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。",
                  "markdown": "型指定のないラムダパラメーターを報告し、型宣言を追加することを提案します。\n\n例:\n\n\n      Function<String, Integer> length = a -> a.length();\n\nクイックフィックス適用後:\n\n\n      Function<String, Integer> length = (String a) -> a.length();\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LambdaParameterTypeCanBeSpecified",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TextLabelInSwitchStatement",
                "shortDescription": {
                  "text": "'switch' ステートメントのテキストラベル"
                },
                "fullDescription": {
                  "text": "'switch' ステートメントの中にあるラベル付きステートメントを報告します。 このような構文は意図的な場合もありますが、多くの場合はタイプミスによるものです。 例: 'switch (x) {\n      case 1:\n      case2:   //警告: テキストラベル 'case2:' が 'switch' ステートメントに使用されています\n      case 3:\n          break;\n  }'",
                  "markdown": "`switch` ステートメントの中にあるラベル付きステートメントを報告します。 このような構文は意図的な場合もありますが、多くの場合はタイプミスによるものです。\n\n**例:**\n\n\n      switch (x) {\n          case 1:\n          case2:   //警告: テキストラベル 'case2:' が 'switch' ステートメントに使用されています\n          case 3:\n              break;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TextLabelInSwitchStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageVisibleInnerClass",
                "shortDescription": {
                  "text": "パッケージ可視ネストクラス"
                },
                "fullDescription": {
                  "text": "アクセス修飾子なしで宣言されているネストしたクラス (package-private とも呼ばれる) を報告します。 例: 'public class Outer {\n    static class Nested {}  // 警告\n    class Inner {}          // 警告\n    enum Mode {}            // 設定に応じて警告\n    interface I {}          // 設定に応じて警告\n  }' インスペクションの構成: package-private の内部列挙型を無視するには、「パッケージ可視の内部列挙型を無視する」オプションを使用します。 package-private の内部インターフェースを無視するには、「パッケージ可視の内部インターフェースを無視する」オプションを使用します。",
                  "markdown": "アクセス修飾子なしで宣言されているネストしたクラス (package-private とも呼ばれる) を報告します。\n\n**例:**\n\n\n      public class Outer {\n        static class Nested {}  // 警告\n        class Inner {}          // 警告\n        enum Mode {}            // 設定に応じて警告\n        interface I {}          // 設定に応じて警告\n      }\n\nインスペクションの構成:\n\n* package-private の内部列挙型を無視するには、「**パッケージ可視の内部列挙型を無視する**」オプションを使用します。\n* package-private の内部インターフェースを無視するには、「**パッケージ可視の内部インターフェースを無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageVisibleInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/カプセル化",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryUnaryMinus",
                "shortDescription": {
                  "text": "不要な単項マイナス"
                },
                "fullDescription": {
                  "text": "不要な単項マイナスを報告します。 このような式は理解しにくく、間違いがある可能性があります。 例: 'void unaryMinus(int i) {\n    int x = - -i;\n  }' この場合、次のクイックフィックスが提案されます。 'i' 変数の前の '-' 演算子を除去: 'void unaryMinus(int i) {\n    int x = i;\n  }' '-' 演算子を前置インクリメント演算に置換: 'void unaryMinus(int i) {\n    int x = --i;\n  }' 別の例: 'void unaryMinus(int i) {\n    i += - 8;\n  }' クイックフィックス適用後: 'void unaryMinus(int i) {\n    i -= 8;\n  }'",
                  "markdown": "不要な単項マイナスを報告します。 このような式は理解しにくく、間違いがある可能性があります。\n\n**例:**\n\n    void unaryMinus(int i) {\n        int x = - -i;\n      }\n\nこの場合、次のクイックフィックスが提案されます。\n\n* `i` 変数の前の `-` 演算子を除去:\n\n      void unaryMinus(int i) {\n          int x = i;\n        }\n\n* `-` 演算子を前置インクリメント演算に置換:\n\n      void unaryMinus(int i) {\n          int x = --i;\n        }\n\n**別の例:**\n\n    void unaryMinus(int i) {\n        i += - 8;\n      }\n\nクイックフィックス適用後:\n\n    void unaryMinus(int i) {\n        i -= 8;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryUnaryMinus",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WriteOnlyObject",
                "shortDescription": {
                  "text": "書き込み専用オブジェクト"
                },
                "fullDescription": {
                  "text": "更新されるだけで、照会されることのないオブジェクトを報告します。 このインスペクションは、一部のライブラリメソッドについて推論または事前にアノテーションを付与可能なメソッドのミューテーション契約に依存しています。 このインスペクションは、コレクション、マップ、文字列ビルダーを報告しません。これらの型は他のより詳細なインスペクションによって報告されます。 例: 'AtomicReference<String> ref = new AtomicReference<>();\n  ref.set(\"hello\"); // ref は再度使用されません' 純度が不明なコンストラクターまたはメソッドにより作成されるオブジェクトを処理するかどうかを制御するには、「ピュアでないコンストラクターを無視する」オプションを使用します。 このオプションをチェックしないと、オブジェクト参照が構築中に意図的にリークされる場合に誤検知が発生する可能性があります。 2021.2 の新機能です",
                  "markdown": "更新されるだけで、照会されることのないオブジェクトを報告します。\n\nこのインスペクションは、一部のライブラリメソッドについて推論または事前にアノテーションを付与可能なメソッドのミューテーション契約に依存しています。 このインスペクションは、コレクション、マップ、文字列ビルダーを報告しません。これらの型は他のより詳細なインスペクションによって報告されます。\n\n例:\n\n\n      AtomicReference<String> ref = new AtomicReference<>();\n      ref.set(\"hello\"); // ref は再度使用されません\n\n\n純度が不明なコンストラクターまたはメソッドにより作成されるオブジェクトを処理するかどうかを制御するには、「**ピュアでないコンストラクターを無視する**」オプションを使用します。\nこのオプションをチェックしないと、オブジェクト参照が構築中に意図的にリークされる場合に誤検知が発生する可能性があります。\n**2021.2 の新機能です**"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WriteOnlyObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodMayBeStatic",
                "shortDescription": {
                  "text": "'static' にできるメソッド"
                },
                "fullDescription": {
                  "text": "安全に 'static' にできるメソッドを報告します。 メソッドを極力 static にすることで、メモリ消費を抑制し、コードの品質を向上させることができます。 次の条件を満たす場合にメソッドを 'static' にできます。 'synchronized'、'native' または 'abstract' ではない。 包含クラス内の非 static メソッドおよび非 static フィールドを参照していない。 オーバーライドではなく、サブクラスでオーバーライドされていない。 このインスペクションは、次のオプションを使用して構成できます。 このインスペクションのパフォーマンスを向上させるため、'private' および 'final' メソッドのみを報告するかどうか。 空のメソッドを無視するかどうか。 Java 8 以降を使用する際にインターフェースのデフォルトメソッドを無視するかどうか。 クイックフィックスでインスタンス修飾子を 'static' なメソッド呼び出し内のクラス参照に置換するかどうか。オプションが有効な場合、'myClass.m()' の呼び出しは 'MyClass.m()' に置換されます。",
                  "markdown": "安全に `static` にできるメソッドを報告します。 メソッドを極力 static にすることで、メモリ消費を抑制し、コードの品質を向上させることができます。\n\n次の条件を満たす場合にメソッドを `static` にできます。\n\n* `synchronized`、`native` または `abstract` ではない。\n* 包含クラス内の非 static メソッドおよび非 static フィールドを参照していない。\n* オーバーライドではなく、サブクラスでオーバーライドされていない。\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* このインスペクションのパフォーマンスを向上させるため、`private` および `final` メソッドのみを報告するかどうか。\n* 空のメソッドを無視するかどうか。\n* Java 8 以降を使用する際にインターフェースのデフォルトメソッドを無視するかどうか。\n* クイックフィックスでインスタンス修飾子を `static` なメソッド呼び出し内のクラス参照に置換するかどうか。オプションが有効な場合、`myClass.m()` の呼び出しは `MyClass.m()` に置換されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestMethodWithoutAssertion",
                "shortDescription": {
                  "text": "アサーションのないテストメソッド"
                },
                "fullDescription": {
                  "text": "アサーションを含まないテストメソッドを報告します。 このようなメソッドがある場合、テストケースが不完全であるか脆弱である可能性があります。 例: 'public class ExtensiveTest {\n\n    @Test\n    public void testAlive() {\n      System.out.println(\"nothing\");\n    }\n  }' インスペクションの構成: アサーションとして修飾すべき完全修飾クラス名とメソッド名の正規表現の組み合わせを指定するには、このテーブルを使用します。 クラス名はサブクラスとも一致します。 'assert' キーワードを使用する Java 'assert' ステートメントをアサーションと見なすかどうかを指定するには、「'assert' キーワードをアサーションと見なす」オプションを使用します。 例外を宣言しているテストメソッドを無視するには、「例外を宣言するテストメソッドを無視」オプションを使用します。 これは、失敗時に例外をスローするためにアサーションが不要なテストがある場合に役立ちます。",
                  "markdown": "アサーションを含まないテストメソッドを報告します。 このようなメソッドがある場合、テストケースが不完全であるか脆弱である可能性があります。\n\n**例:**\n\n\n      public class ExtensiveTest {\n\n        @Test\n        public void testAlive() {\n          System.out.println(\"nothing\");\n        }\n      }\n\n\nインスペクションの構成:\n\n* アサーションとして修飾すべき完全修飾クラス名とメソッド名の正規表現の組み合わせを指定するには、このテーブルを使用します。 クラス名はサブクラスとも一致します。\n* `assert` キーワードを使用する Java `assert` ステートメントをアサーションと見なすかどうかを指定するには、「**'assert' キーワードをアサーションと見なす**」オプションを使用します。\n* 例外を宣言しているテストメソッドを無視するには、「**例外を宣言するテストメソッドを無視**」オプションを使用します。 これは、失敗時に例外をスローするためにアサーションが不要なテストがある場合に役立ちます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TestMethodWithoutAssertion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語/テストフレームワーク",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SocketResource",
                "shortDescription": {
                  "text": "安全に閉じられていないソケット"
                },
                "fullDescription": {
                  "text": "安全に閉じられていないソケットリソースを報告します。 このインスペクションで報告されるソケットリソースは、'java.net.Socket'、'java.net.DatagramSocket'、'java.net.ServerSocket' です。 デフォルトでは、このインスペクションは名前に 'close' または 'cleanup' を含む任意のメソッドでリソースを閉じることができると想定しています。 例: 'byte[] getMessage(ServerSocket socket) throws IOException {\n    Socket client = socket.accept(); //ソケットが閉じていません\n    return client.getInputStream().readAllBytes();\n  }' このインスペクションは、次のオプションを使用して構成できます。 'try' ブロック内でソケットを開くことを許可するかどうか。 このスタイルは try ブロックの前でリソースを開く場合よりも冗長であるため、あまり望ましくありません。 リソースが引数として渡されている任意のメソッド呼び出しでリソースを閉じることができるかどうか。",
                  "markdown": "安全に閉じられていないソケットリソースを報告します。 このインスペクションで報告されるソケットリソースは、`java.net.Socket`、`java.net.DatagramSocket`、`java.net.ServerSocket` です。\n\n\nデフォルトでは、このインスペクションは名前に 'close' または 'cleanup' を含む任意のメソッドでリソースを閉じることができると想定しています。\n\n**例:**\n\n\n      byte[] getMessage(ServerSocket socket) throws IOException {\n        Socket client = socket.accept(); //ソケットが閉じていません\n        return client.getInputStream().readAllBytes();\n      }\n\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* `try` ブロック内でソケットを開くことを許可するかどうか。 このスタイルは try ブロックの前でリソースを開く場合よりも冗長であるため、あまり望ましくありません。\n* リソースが引数として渡されている任意のメソッド呼び出しでリソースを閉じることができるかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SocketOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/リソース管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeParameterHidesVisibleType",
                "shortDescription": {
                  "text": "表示可能な型を非表示にする型パラメーター"
                },
                "fullDescription": {
                  "text": "現在のスコープ内で可視である型と同じ名前の型パラメーターを報告します。 このようなパラメーター名は混乱を招く可能性があります。 例: 'abstract class MyList<T> extends AbstractList<T> {\n    private List<T> elements;\n    // 型パラメーター 'T' は型パラメーター 'T' を不可視にします\n    public <T> T[] toArray(T[] array) {\n        return elements.toArray(array);\n    }\n}'",
                  "markdown": "現在のスコープ内で可視である型と同じ名前の型パラメーターを報告します。 このようなパラメーター名は混乱を招く可能性があります。\n\n例:\n\n\n      abstract class MyList<T> extends AbstractList<T> {\n        private List<T> elements;\n        // 型パラメーター 'T' は型パラメーター 'T' を不可視にします\n        public <T> T[] toArray(T[] array) {\n            return elements.toArray(array);\n        }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeParameterHidesVisibleType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringTokenizerDelimiter",
                "shortDescription": {
                  "text": "'StringTokenizer' の重複した区切り文字"
                },
                "fullDescription": {
                  "text": "'StringTokenizer()' または 'nextToken()' メソッド呼び出しのうち、区切り文字の引数に重複した文字が含まれているものを報告します。 例: 'void printTokens(String text) {\n    StringTokenizer tokenizer = new StringTokenizer(text, \"\\n\\n\");\n    while (tokenizer.hasMoreTokens()) {\n      System.out.println(tokenizer.nextToken());\n    }\n  }' クイックフィックス適用後: 'void printTokens(String text) {\n    StringTokenizer tokenizer = new StringTokenizer(text, \"\\n\");\n    while (tokenizer.hasMoreTokens()) {\n      System.out.println(tokenizer.nextToken());\n    }\n  }'",
                  "markdown": "` StringTokenizer()` または ` nextToken()` メソッド呼び出しのうち、区切り文字の引数に重複した文字が含まれているものを報告します。\n\n**例:**\n\n\n      void printTokens(String text) {\n        StringTokenizer tokenizer = new StringTokenizer(text, \"\\n\\n\");\n        while (tokenizer.hasMoreTokens()) {\n          System.out.println(tokenizer.nextToken());\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      void printTokens(String text) {\n        StringTokenizer tokenizer = new StringTokenizer(text, \"\\n\");\n        while (tokenizer.hasMoreTokens()) {\n          System.out.println(tokenizer.nextToken());\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringTokenizerDelimiter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MaskedAssertion",
                "shortDescription": {
                  "text": "'catch' で抑止されたアサーション"
                },
                "fullDescription": {
                  "text": "外側の catch ブロックにより抑止されている 'assert' ステートメントとテストフレームワークのアサーションを報告します。 スローされる 'AssertionError' がキャッチされて警告なしに無視されるため、このようなアサーションが失敗することはありません。 例 1: 'void javaAssertion() {\n    try {\n      ...\n      assert 1 == 2;\n    } catch (AssertionError e) {\n      // アサーションは確認なしに無視されます\n    }\n  }' 例 2: '@Test\n  void testWithAssertJ() {\n    try {\n      ...\n      assertThat(1).as(\"test\").isEqualTo(2);\n    } catch (AssertionError e) {\n      // アサーションは確認なしに無視されます\n    }\n  }' 例 3: '@Test\n  void testWithJunit() {\n    try {\n      ...\n      assertEquals(1, 2);\n    } catch (AssertionError e) {\n      // アサーションは確認なしに無視されます\n    }\n  }' 2020.3 の新機能です",
                  "markdown": "外側の catch ブロックにより抑止されている `assert` ステートメントとテストフレームワークのアサーションを報告します。 スローされる `AssertionError` がキャッチされて警告なしに無視されるため、このようなアサーションが失敗することはありません。\n\n**例 1:**\n\n\n      void javaAssertion() {\n        try {\n          ...\n          assert 1 == 2;\n        } catch (AssertionError e) {\n          // アサーションは確認なしに無視されます\n        }\n      }\n\n**例 2:**\n\n\n      @Test\n      void testWithAssertJ() {\n        try {\n          ...\n          assertThat(1).as(\"test\").isEqualTo(2);\n        } catch (AssertionError e) {\n          // アサーションは確認なしに無視されます\n        }\n      }\n\n**例 3:**\n\n\n      @Test\n      void testWithJunit() {\n        try {\n          ...\n          assertEquals(1, 2);\n        } catch (AssertionError e) {\n          // アサーションは確認なしに無視されます\n        }\n      }\n\n2020.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MaskedAssertion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/テストフレームワーク",
                      "index": 96,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReflectionForUnavailableAnnotation",
                "shortDescription": {
                  "text": "ソースのみのアノテーションへのリフレクションアクセス"
                },
                "fullDescription": {
                  "text": "非実行時アノテーションの存在を再帰的にチェックしている試みを報告します。 'Class.isAnnotationPresent()' を使用して、保持ポリシーが'SOURCE' または 'CLASS' (デフォルト) に設定されているアノテーションをテストすると、常に否定的な結果になります。 この間違いは見落としがちです。 例: '{\n    getClass().isAnnotationPresent(SourceAnnotation.class); //常に false\n  }\n\n  @Retention(RetentionPolicy.SOURCE)\n  @interface SourceAnnotation {}' このインスペクションは Java 5 以降で使用できる Java の機能 'アノテーション' に依存しています。",
                  "markdown": "非実行時アノテーションの存在を再帰的にチェックしている試みを報告します。\n\n`Class.isAnnotationPresent()` を使用して、保持ポリシーが`SOURCE` または `CLASS` (デフォルト) に設定されているアノテーションをテストすると、常に否定的な結果になります。 この間違いは見落としがちです。\n\n**例:**\n\n\n      {\n        getClass().isAnnotationPresent(SourceAnnotation.class); //常に false\n      }\n\n      @Retention(RetentionPolicy.SOURCE)\n      @interface SourceAnnotation {}\n\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 'アノテーション' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReflectionForUnavailableAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstantiatingObjectToGetClassObject",
                "shortDescription": {
                  "text": "'Class' オブジェクトを取得するためにオブジェクトをインスタンス化"
                },
                "fullDescription": {
                  "text": "クラスオブジェクトを取得するためにクラスをインスタンス化しているコードを報告します。 クラスオブジェクトに直接名前でアクセスすると、パフォーマンスが向上します。 例: 'Class<?> c = new Sample().getClass();' クイックフィックス適用後: 'Class<?> c = Sample.class;'",
                  "markdown": "クラスオブジェクトを取得するためにクラスをインスタンス化しているコードを報告します。\n\nクラスオブジェクトに直接名前でアクセスすると、パフォーマンスが向上します。\n\n**例:**\n\n\n      Class<?> c = new Sample().getClass();\n\nクイックフィックス適用後:\n\n\n      Class<?> c = Sample.class;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstantiatingObjectToGetClassObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithMultipleLoggers",
                "shortDescription": {
                  "text": "複数のロガーを持つクラス"
                },
                "fullDescription": {
                  "text": "複数のロガーが宣言されているクラスを報告します。 アプリケーションのロギング実装を統一するには、すべてのクラスに単一の専用のロガーを持たせることが重要です。 例: 'public class Critical {\n    protected static final Logger LOG = Logger.getLogger(Critical.class);\n\n    protected static final Logger myLogger = Logger.getLogger(getClass());\n  }' ロガークラス名を指定するには、以下の表を使用してください。 指定されたクラスのいずれかの型を持つ複数のフィールドを宣言しているクラスが、このインスペクションによって報告されます。",
                  "markdown": "複数のロガーが宣言されているクラスを報告します。 アプリケーションのロギング実装を統一するには、すべてのクラスに単一の専用のロガーを持たせることが重要です。\n\n例:\n\n\n      public class Critical {\n        protected static final Logger LOG = Logger.getLogger(Critical.class);\n\n        protected static final Logger myLogger = Logger.getLogger(getClass());\n      }\n\n\nロガークラス名を指定するには、以下の表を使用してください。\n指定されたクラスのいずれかの型を持つ複数のフィールドを宣言しているクラスが、このインスペクションによって報告されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithMultipleLoggers",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ログ関連",
                      "index": 91,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ShiftOutOfRange",
                "shortDescription": {
                  "text": "不適切な定数によるシフト演算"
                },
                "fullDescription": {
                  "text": "シフト値が常に一定であり、有効な範囲から外れているシフト演算を報告します。 '0..31' の範囲を外れている整数のシフト演算と、'0..63' の範囲を外れている long のシフト演算が報告されます。 負の値または過度に大きな値によるシフトは、ほぼ確実にコーディングの誤りです。 例: 'int shiftSize = 32;\n  // 警告: 32 ビットのシフトは 0 ビットのシフトと同じであり、まったくシフトしません。\n  int mask = (1 << shiftSize) - 1;'",
                  "markdown": "シフト値が常に一定であり、有効な範囲から外れているシフト演算を報告します。\n\n`0..31` の範囲を外れている整数のシフト演算と、`0..63` の範囲を外れている long のシフト演算が報告されます。 負の値または過度に大きな値によるシフトは、ほぼ確実にコーディングの誤りです。\n\n**例:**\n\n\n      int shiftSize = 32;\n      // 警告: 32 ビットのシフトは 0 ビットのシフトと同じであり、まったくシフトしません。\n      int mask = (1 << shiftSize) - 1;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ShiftOutOfRange",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ビット演算関連の問題",
                      "index": 97,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadRun",
                "shortDescription": {
                  "text": "'Thread.run()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'java.lang.Thread'、またはそのいずれかのサブクラスに対する 'run()' の呼び出しを報告します。 このような呼び出しは意図的な場合もありますが、一般的には誤りです。'run()' は新しいスレッドを開始しないためです。 コードを別スレッドで実行するには、'start()' を使用する必要があります。",
                  "markdown": "`java.lang.Thread`、またはそのいずれかのサブクラスに対する `run()` の呼び出しを報告します。\n\n\nこのような呼び出しは意図的な場合もありますが、一般的には誤りです。`run()` は新しいスレッドを開始しないためです。\nコードを別スレッドで実行するには、`start()` を使用する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadRun",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EscapedSpace",
                "shortDescription": {
                  "text": "終了していない '\\s' エスケープシーケンスの使用"
                },
                "fullDescription": {
                  "text": "テキストブロックの行末以外の場所、または連続する複数のエスケープされた空白内にある '\\s' エスケープシーケンスを報告します。 特に文字列が正規表現として解釈されている場合、このような使い方は混乱を招くか、誤りである可能性があります。 '\\s' エスケープシーケンスは、通常の空白がトリムされるテキストブロック行の最後にある空白をエンコードすることを意図したものです。 他の場所や通常の文字列、または char リテラルでは、'\\s' は通常の空白文字 ('\" \"') と同等です。 例: 'if (str.matches(\"\\s+\")) {...}' この場合、(すべての空白文字と一致する) '\"\\\\s+\"' が意図されていた可能性があります。 そうでない場合、'str.matches(\" +\")' を使用したほうが混乱を招く可能性が低くなります。 '\\s' エスケープを空白文字に置換するクイックフィックスが提供されます。 2022.3 の新機能です このインスペクションは Java 15 以降で使用できる Java の機能 ''\\s' エスケープシーケンス' に依存しています。",
                  "markdown": "テキストブロックの行末以外の場所、または連続する複数のエスケープされた空白内にある `\\s` エスケープシーケンスを報告します。 特に文字列が正規表現として解釈されている場合、このような使い方は混乱を招くか、誤りである可能性があります。 `\\s` エスケープシーケンスは、通常の空白がトリムされるテキストブロック行の最後にある空白をエンコードすることを意図したものです。 他の場所や通常の文字列、または char リテラルでは、`\\s` は通常の空白文字 (`\" \"`) と同等です。\n\n**例:**\n\n\n      if (str.matches(\"\\s+\")) {...}\n\nこの場合、(すべての空白文字と一致する) `\"\\\\s+\"` が意図されていた可能性があります。 そうでない場合、`str.matches(\" +\")` を使用したほうが混乱を招く可能性が低くなります。\n\n\n`\\s` エスケープを空白文字に置換するクイックフィックスが提供されます。\n\n2022.3 の新機能です\n\nこのインスペクションは Java 15 以降で使用できる Java の機能 ''\\\\s' エスケープシーケンス' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EscapedSpace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsThrowable",
                "shortDescription": {
                  "text": "クラスが直接 'Throwable' を拡張しています"
                },
                "fullDescription": {
                  "text": "'java.lang.Throwable' を直接拡張しているクラスを報告します。 'java.lang.Throwable' を直接拡張することは、一般的に良いプラクティスとは言えません。 通常は 'java.lang.RuntimeException' か 'java.lang.Exception' (または特殊なケースでは 'java.lang.Error') を拡張するだけで十分です。 例: 'class EnigmaThrowable extends Throwable {} // 警告: クラス 'EnigmaThrowable' が 'java.lang.Throwable' を直接 extend しています'",
                  "markdown": "`java.lang.Throwable` を直接拡張しているクラスを報告します。\n\n`java.lang.Throwable` を直接拡張することは、一般的に良いプラクティスとは言えません。\n通常は `java.lang.RuntimeException` か `java.lang.Exception` (または特殊なケースでは `java.lang.Error`) を拡張するだけで十分です。\n\n**例:**\n\n\n      class EnigmaThrowable extends Throwable {} // 警告: クラス 'EnigmaThrowable' が 'java.lang.Throwable' を直接 extend しています\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExtendsThrowable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AutoBoxing",
                "shortDescription": {
                  "text": "オートボクシング"
                },
                "fullDescription": {
                  "text": "オートボクシング変換 (プリミティブ値をオブジェクトに自動ラッピング) の影響を受ける式を報告します。 オブジェクトをプリミティブの代わりに使用しないようにしてください。 使用した場合、パフォーマンスに大きな影響を与える可能性があります。 例: 'Integer x = 42;' クイックフィックスを使用すると、変換が明示的になります。 'Integer x = Integer.valueOf(42);' オートボクシングは Java 5 で登場しました。 このインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。",
                  "markdown": "オートボクシング変換 (プリミティブ値をオブジェクトに自動ラッピング) の影響を受ける式を報告します。 オブジェクトをプリミティブの代わりに使用しないようにしてください。 使用した場合、パフォーマンスに大きな影響を与える可能性があります。\n\n**例:**\n\n    Integer x = 42;\n\nクイックフィックスを使用すると、変換が明示的になります。\n\n    Integer x = Integer.valueOf(42);\n\n\n*オートボクシング*は Java 5 で登場しました。\nこのインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AutoBoxing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InterfaceNeverImplemented",
                "shortDescription": {
                  "text": "具象サブクラスを持たないインターフェース"
                },
                "fullDescription": {
                  "text": "具象サブクラスがないインターフェースを報告します。 インスペクションの構成: アノテーションを追加するには、以下のリストを使用します。 ここに追加したアノテーションを付けて宣言されているインターフェースは、このインスペクションでは無視されます。 定数フィールドのみを宣言するインターフェースを無視するには、以下のチェックボックスを使用します。 このようなインターフェースは、実装がなくても使用できる場合があります。",
                  "markdown": "具象サブクラスがないインターフェースを報告します。\n\nインスペクションの構成:\n\n* アノテーションを追加するには、以下のリストを使用します。 ここに追加したアノテーションを付けて宣言されているインターフェースは、このインスペクションでは無視されます。\n* 定数フィールドのみを宣言するインターフェースを無視するには、以下のチェックボックスを使用します。 このようなインターフェースは、実装がなくても使用できる場合があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InterfaceNeverImplemented",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ContinueStatement",
                "shortDescription": {
                  "text": "'continue' ステートメント"
                },
                "fullDescription": {
                  "text": "'continue' ステートメントを報告します。 'continue' ステートメントはリファクタリングを複雑にし、混乱を招く可能性があります。 例: 'void foo(List<String> strs) {\n    for (String str : strs) {\n      if (str.contains(\"skip\")) continue;\n      handleStr(str);\n    }\n  }'",
                  "markdown": "`continue` ステートメントを報告します。\n\n`continue` ステートメントはリファクタリングを複雑にし、混乱を招く可能性があります。\n\n例:\n\n\n      void foo(List<String> strs) {\n        for (String str : strs) {\n          if (str.contains(\"skip\")) continue;\n          handleStr(str);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ContinueStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadDeathRethrown",
                "shortDescription": {
                  "text": "再スローされない 'ThreadDeath' "
                },
                "fullDescription": {
                  "text": "'java.lang.ThreadDeath' をキャッチし、例外を再スローしていない 'try' ステートメントを報告します。 例: 'try {\n    executeInParallel(request);\n  } catch (ThreadDeath ex) { // 警告: ThreadDeath 'ex' は再スローされません\n    return false;\n  }'",
                  "markdown": "`java.lang.ThreadDeath` をキャッチし、例外を再スローしていない `try` ステートメントを報告します。\n\n**例:**\n\n\n      try {\n        executeInParallel(request);\n      } catch (ThreadDeath ex) { // 警告: ThreadDeath 'ex' は再スローされません\n        return false;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThreadDeathNotRethrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MisorderedAssertEqualsArguments",
                "shortDescription": {
                  "text": "誤った 'assertEquals()' 引数"
                },
                "fullDescription": {
                  "text": "expected (期待値) 引数と actual (実測値) 引数の順序が間違っている 'assertEquals()' の呼び出しを報告します。 JUnit 3、4、および 5 の場合、正しい順序は '(expected, actual)' です。 TestNG の場合、正しい順序は '(actual, expected)' です。 このような呼び出しは合格するアサーションでは正常に動作しますが、失敗時には誤解を招くエラーを報告する可能性があります。 クイックフィックスを使用すると、引数の順序を反転できます。 例 (JUnit): 'assertEquals(actual, expected)' クイックフィックス適用後: 'assertEquals(expected, actual)'",
                  "markdown": "expected (期待値) 引数と actual (実測値) 引数の順序が間違っている `assertEquals()` の呼び出しを報告します。\n\n\nJUnit 3、4、および 5 の場合、正しい順序は `(expected, actual)` です。\nTestNG の場合、正しい順序は `(actual, expected)` です。\n\n\nこのような呼び出しは合格するアサーションでは正常に動作しますが、失敗時には誤解を招くエラーを報告する可能性があります。\nクイックフィックスを使用すると、引数の順序を反転できます。\n\n**例 (JUnit):**\n\n\n      assertEquals(actual, expected)\n\nクイックフィックス適用後:\n\n\n      assertEquals(expected, actual)\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MisorderedAssertEqualsArguments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/テストフレームワーク",
                      "index": 96,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticVariableInitialization",
                "shortDescription": {
                  "text": "未初期化の可能性がある static フィールド"
                },
                "fullDescription": {
                  "text": "クラス初期化時に初期化されていない可能性のある 'static' 変数を報告します。 例: 'class Foo {\n    public static int bar;\n\n    static { }\n  }' このインスペクションは非常に保守的なデータフローアルゴリズムを使用しており、'static' 変数を初期化されていないものとして誤って報告する場合があります。 初期化されているものとして報告される変数は、常に初期化されます。 初期化されていないプリミティブフィールドを無視するには、「プリミティブフィールドを無視」オプションを使用します。",
                  "markdown": "クラス初期化時に初期化されていない可能性のある `static` 変数を報告します。\n\n**例:**\n\n\n      class Foo {\n        public static int bar;\n\n        static { }\n      }\n\nこのインスペクションは非常に保守的なデータフローアルゴリズムを使用しており、`static` 変数を初期化されていないものとして誤って報告する場合があります。 初期化されているものとして報告される変数は、常に初期化されます。\n\n初期化されていないプリミティブフィールドを無視するには、「**プリミティブフィールドを無視**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticVariableMayNotBeInitialized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初期化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantAssertCondition",
                "shortDescription": {
                  "text": "'assert' ステートメントの定数条件"
                },
                "fullDescription": {
                  "text": "条件が定数の 'assert' ステートメントを報告します。 定数条件の 'assert' ステートメントは常に失敗するか、常に成功します。 このようなステートメントはリファクタリングの結果として残っている可能性があり、意図されたものではないと思われます。 例: 'void foo() {\n        assert true;\n    }' このインスペクションは Java 1.4 以降で使用できる Java の機能 'アサーション' に依存しています。",
                  "markdown": "条件が定数の `assert` ステートメントを報告します。 定数条件の `assert` ステートメントは常に失敗するか、常に成功します。 このようなステートメントはリファクタリングの結果として残っている可能性があり、意図されたものではないと思われます。\n\n**例:**\n\n\n        void foo() {\n            assert true;\n        }\n\nこのインスペクションは Java 1.4 以降で使用できる Java の機能 'アサーション' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantAssertCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaReflectionInvocation",
                "shortDescription": {
                  "text": "リフレクション呼び出し引数の不一致"
                },
                "fullDescription": {
                  "text": "'Method.invoke()' と 'Constructor.newInstance()' に渡された引数が、'Class.getMethod()' と 'Class.getConstructor()' で指定したシグネチャーと一致しないケースを報告します。 例: 'Method m = myObj.getClass().getMethod(\"myMethod\", int.class);\n  // 引数は int 値である必要あります\n  m.invoke(myObj, \"abc\");' 2017.2 の新機能です",
                  "markdown": "`Method.invoke()` と `Constructor.newInstance()` に渡された引数が、`Class.getMethod()` と `Class.getConstructor()` で指定したシグネチャーと一致しないケースを報告します。\n\n例:\n\n\n      Method m = myObj.getClass().getMethod(\"myMethod\", int.class);\n      // 引数は **int** 値である必要あります\n      m.invoke(myObj, \"abc\");\n\n2017.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaReflectionInvocation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/リフレクションアクセス",
                      "index": 98,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CaughtExceptionImmediatelyRethrown",
                "shortDescription": {
                  "text": "直ちに再スローされているキャッチ済み例外"
                },
                "fullDescription": {
                  "text": "何も処理を実行せず、キャッチした例外をすぐに再スローしている 'catch' ブロックを報告します。 このような 'catch' ブロックは不要であり、エラー処理をしません。 例: 'try {\n            new FileInputStream(\"\");\n        } catch (FileNotFoundException e) {\n            throw e;\n        }'",
                  "markdown": "何も処理を実行せず、キャッチした例外をすぐに再スローしている `catch` ブロックを報告します。 このような `catch` ブロックは不要であり、エラー処理をしません。\n\n**例:**\n\n\n            try {\n                new FileInputStream(\"\");\n            } catch (FileNotFoundException e) {\n                throw e;\n            }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CaughtExceptionImmediatelyRethrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneCallsConstructors",
                "shortDescription": {
                  "text": "コンストラクターでオブジェクトをインスタンス化している 'clone()'"
                },
                "fullDescription": {
                  "text": "'clone()' メソッドにあるオブジェクトコンストラクターの呼び出しを報告します。 後でサブクラス化できるようにオブジェクトを直接作成するのではなく、'clone()' を呼び出して 'clone()' メソッド内のオブジェクトをインスタンス化することをお勧めします。 このインスペクションは、'final'クラスで 'final' または 'clone()' メソッドとして宣言されている 'clone()' メソッドは報告しません。",
                  "markdown": "`clone()` メソッドにあるオブジェクトコンストラクターの呼び出しを報告します。\n\n後でサブクラス化できるようにオブジェクトを直接作成するのではなく、`clone()` を呼び出して `clone()` メソッド内のオブジェクトをインスタンス化することをお勧めします。\nこのインスペクションは、`final`クラスで `final` または `clone()` メソッドとして宣言されている `clone()` メソッドは報告しません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneCallsConstructors",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クローン関連の問題",
                      "index": 79,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryModuleDependencyInspection",
                "shortDescription": {
                  "text": "不要なモジュール依存関係"
                },
                "fullDescription": {
                  "text": "使用されていないモジュールの依存関係を報告します。 クイックフィックスを使用すると、このような未使用の依存関係が安全に除去されます。",
                  "markdown": "使用されていないモジュールの依存関係を報告します。 クイックフィックスを使用すると、このような未使用の依存関係が安全に除去されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryModuleDependencyInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayHashCode",
                "shortDescription": {
                  "text": "配列での 'hashCode()' 呼び出し"
                },
                "fullDescription": {
                  "text": "配列の誤ったハッシュコード計算を報告します。 配列のハッシュコードを正しく計算するには、次のコードを使用してください。 線形配列の場合は 'Arrays.hashcode()' 多次元配列の場合は 'Arrays.deepHashcode()' 入力値の並びに配列が含まれている場合は、これらのメソッドを 'Objects.hash(string, Arrays.hashcode(array))' のように 'Objects.hash()' と共に使用する必要があります。",
                  "markdown": "配列の誤ったハッシュコード計算を報告します。\n\n配列のハッシュコードを正しく計算するには、次のコードを使用してください。\n\n* 線形配列の場合は `Arrays.hashcode()`\n* 多次元配列の場合は `Arrays.deepHashcode()`\n\n入力値の並びに配列が含まれている場合は、これらのメソッドを `Objects.hash(string, Arrays.hashcode(array))` のように `Objects.hash()` と共に使用する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayHashCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArraysAsListWithZeroOrOneArgument",
                "shortDescription": {
                  "text": "引数が少なすぎる 'Arrays.asList()' の呼び出し"
                },
                "fullDescription": {
                  "text": "引数が最大でも 1 つしかない 'Arrays.asList()' の呼び出しを報告します。 JDK 9 以降ではこのような呼び出しを 'Collections.singletonList()'、'Collections.emptyList()'、または 'List.of()' に置換してメモリを節約できます。 具体的には、引数のない 'Collections.emptyList()' と 'List.of()' が常に共有のインスタンスを返すのに対し、引数のない 'Arrays.asList()' は呼び出されるたびに新しいオブジェクトを作成します。 注意: 'Collections.singletonList()' と 'List.of()' が返すリストはイミュータブルであるのに対し、'Arrays.asList()' が返すリストでは 'set()' メソッドを呼び出すことができます。 このため、まれにコードが機能しなくなる場合があります。 例: 'List<String> empty = Arrays.asList();\n  List<String> one = Arrays.asList(\"one\");' クイックフィックス適用後: 'List<String> empty = Collections.emptyList();\n  List<String> one = Collections.singletonList(\"one\");'",
                  "markdown": "引数が最大でも 1 つしかない `Arrays.asList()` の呼び出しを報告します。\n\n\nJDK 9 以降ではこのような呼び出しを `Collections.singletonList()`、`Collections.emptyList()`、または `List.of()` に置換してメモリを節約できます。\n\n具体的には、引数のない `Collections.emptyList()` と `List.of()` が常に共有のインスタンスを返すのに対し、引数のない `Arrays.asList()` は呼び出されるたびに新しいオブジェクトを作成します。\n\n注意: `Collections.singletonList()` と `List.of()` が返すリストはイミュータブルであるのに対し、`Arrays.asList()` が返すリストでは `set()` メソッドを呼び出すことができます。\nこのため、まれにコードが機能しなくなる場合があります。\n\n**例:**\n\n\n      List<String> empty = Arrays.asList();\n      List<String> one = Arrays.asList(\"one\");\n\nクイックフィックス適用後:\n\n\n      List<String> empty = Collections.emptyList();\n      List<String> one = Collections.singletonList(\"one\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArraysAsListWithZeroOrOneArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitNotInLoop",
                "shortDescription": {
                  "text": "ループ内で呼び出されていない 'wait()'"
                },
                "fullDescription": {
                  "text": "ループ内で行われていない 'wait()' の呼び出しを報告します。 'wait()' は通常、ある条件が true になるまでスレッドを一時停止するために使用されます。 このようなスレッドは別の理由で呼び起こされている可能性があるため、'wait()' を呼び出した後は条件を確認する必要があります。 これを実現するには、ループを使用するのが簡単です。 例: 'class BoundedCounter {\n    private int count;\n    synchronized void inc() throws InterruptedException {\n      if (count >= 10) wait();\n      ++count;\n    }\n  }' 次のようなコードが適切です: 'class BoundedCounter {\n    private int count;\n    synchronized void inc() throws InterruptedException {\n      while (count >= 10) wait();\n      ++count;\n    }\n  }'",
                  "markdown": "ループ内で行われていない `wait()` の呼び出しを報告します。\n\n\n`wait()` は通常、ある条件が true になるまでスレッドを一時停止するために使用されます。\nこのようなスレッドは別の理由で呼び起こされている可能性があるため、`wait()` を呼び出した後は条件を確認する必要があります。\nこれを実現するには、ループを使用するのが簡単です。\n\n**例:**\n\n\n      class BoundedCounter {\n        private int count;\n        synchronized void inc() throws InterruptedException {\n          if (count >= 10) wait();\n          ++count;\n        }\n      }\n\n次のようなコードが適切です:\n\n\n      class BoundedCounter {\n        private int count;\n        synchronized void inc() throws InterruptedException {\n          while (count >= 10) wait();\n          ++count;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitNotInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExternalizableWithSerializationMethods",
                "shortDescription": {
                  "text": "'readObject()' または 'writeObject()' を持つ Externalizable クラス"
                },
                "fullDescription": {
                  "text": "'readObject()' または 'writeObject()' メソッドを定義している 'Externalizable' クラスを報告します。 このようなメソッドは、'Externalizable' オブジェクトのシリアル化では呼び出されません。 例: 'abstract class Crucial implements Externalizable {\n    int value;\n    private void readObject(ObjectInputStream in) {\n      value = in.readInt();\n    }\n  }'",
                  "markdown": "`readObject()` または `writeObject()` メソッドを定義している `Externalizable` クラスを報告します。 このようなメソッドは、`Externalizable` オブジェクトのシリアル化では呼び出されません。\n\n**例:**\n\n\n      abstract class Crucial implements Externalizable {\n        int value;\n        private void readObject(ObjectInputStream in) {\n          value = in.readInt();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExternalizableClassWithSerializationMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnstableApiUsage",
                "shortDescription": {
                  "text": "不安定な API の使用"
                },
                "fullDescription": {
                  "text": "いずれかのアノテーションで不安定とマークされている API が使用されていることを報告します。 このような API は将来のバージョンで変更または除去され、それを使用したコードが壊れてしまう可能性があります。 不安定な API をマークするために使用されているアノテーションを以下のリストに表示しています。 デフォルトでは、このインスペクションは不安定な API の宣言が同じプロジェクトのソースにある場合はその使用箇所を無視します。 この場合は、API を変更するときに使用箇所を更新することができます。 ただし、大きなプロジェクトでは不便な場合があるため、「このプロジェクトで宣言された API を無視する」オプションをオフにして、プロジェクトソースとプロジェクトライブラリの両方で宣言されている不安定な API の使用箇所を報告することができます。",
                  "markdown": "いずれかのアノテーションで不安定とマークされている API が使用されていることを報告します。 このような API は将来のバージョンで変更または除去され、それを使用したコードが壊れてしまう可能性があります。\n\n不安定な API をマークするために使用されているアノテーションを以下のリストに表示しています。\n\nデフォルトでは、このインスペクションは不安定な API の宣言が同じプロジェクトのソースにある場合はその使用箇所を無視します。 この場合は、API を変更するときに使用箇所を更新することができます。\nただし、大きなプロジェクトでは不便な場合があるため、「**このプロジェクトで宣言された API を無視する**」オプションをオフにして、プロジェクトソースとプロジェクトライブラリの両方で宣言されている不安定な API の使用箇所を報告することができます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnstableApiUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SafeLock",
                "shortDescription": {
                  "text": "獲得されたが安全に解除されていないロック"
                },
                "fullDescription": {
                  "text": "'try' ブロックの前で取得されていない、または対応する 'finally' ブロックでロックが解除されていない 'java.util.concurrent.locks.Lock' リソースを報告します。 リソースを閉じる前に例外がスローされている場合、思わぬリソースリークが発生する可能性があります。 例: 'lock.lock(); // 'finally' ブロックがないため、報告されます\n  try {\n    doSmthWithLock();\n  } catch (IOException e) {\n    throw new UncheckedIOException(e);\n  }\n  lock.unlock();'",
                  "markdown": "`try` ブロックの前で取得されていない、または対応する `finally` ブロックでロックが解除されていない `java.util.concurrent.locks.Lock` リソースを報告します。 リソースを閉じる前に例外がスローされている場合、思わぬリソースリークが発生する可能性があります。\n\n**例:**\n\n\n      lock.lock(); // 'finally' ブロックがないため、報告されます\n      try {\n        doSmthWithLock();\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n      lock.unlock();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LockAcquiredButNotSafelyReleased",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaLangInvokeHandleSignature",
                "shortDescription": {
                  "text": "MethodHandle/VarHandle 型の不一致"
                },
                "fullDescription": {
                  "text": "どのメソッドまたはフィールドにも一致しない 'MethodHandle' および 'VarHandle' ファクトリメソッド呼び出しを報告します。 また、'MethodHandle' シグネチャーと一致しない 'MethodHandle.invoke()' および類似するメソッドの引数と、'VarHandle' の型と一致しない 'VarHandle.set()' の引数を報告します。 例:   MethodHandle mh = MethodHandles.lookup().findVirtual(\n      MyClass.class, \"foo\", MethodType.methodType(void.class, int.class));\n  // 引数は int 値である必要があります\n  mh.invoke(myObj, \"abc\");\n   // 引数は String.class である必要があります \n  VarHandle vh = MethodHandles.lookup().findVarHandle(\n      MyClass.class, \"text\", int.class);\n   VarHandle vh = MethodHandles.lookup().findVarHandle(\n      MyClass.class, \"text\", String.class);\n  // 引数は String 値 である必要があります\n  vh.set(myObj, 42);\n 2017.2 の新機能です",
                  "markdown": "どのメソッドまたはフィールドにも一致しない `MethodHandle` および `VarHandle` ファクトリメソッド呼び出しを報告します。\n\nまた、`MethodHandle` シグネチャーと一致しない `MethodHandle.invoke()` および類似するメソッドの引数と、`VarHandle` の型と一致しない `VarHandle.set()` の引数を報告します。\n\n\n例:\n\n```\n  MethodHandle mh = MethodHandles.lookup().findVirtual(\n      MyClass.class, \"foo\", MethodType.methodType(void.class, int.class));\n  // 引数は int 値である必要があります\n  mh.invoke(myObj, \"abc\");\n```\n\n```\n  // 引数は String.class である必要があります \n  VarHandle vh = MethodHandles.lookup().findVarHandle(\n      MyClass.class, \"text\", int.class);\n```\n\n```\n  VarHandle vh = MethodHandles.lookup().findVarHandle(\n      MyClass.class, \"text\", String.class);\n  // 引数は String 値 である必要があります\n  vh.set(myObj, 42);\n```\n\n\n2017.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaLangInvokeHandleSignature",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/リフレクションアクセス",
                      "index": 98,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaUnfriendlyMethodOverload",
                "shortDescription": {
                  "text": "ラムダ式には好ましくないメソッドのオーバーロード"
                },
                "fullDescription": {
                  "text": "オーバーロードメソッドで、抽象メソッドのシグネチャーが競合している関数型インターフェースを使用しているものを報告します。 このようなオーバーロードはあいまいさをもたらし、呼び出し元にラムダを特定の型にキャストするか、ラムダパラメーターの型を明示的に指定することを要求します。 あいまいさを排除するため、オーバーロードメソッドには別々の名前を付けることをお勧めします。 例: 'interface MyExecutor {\n    void execute(Supplier<?> supplier);\n    void execute(Callable<?> callable);\n  }' ここで、'Supplier' と 'Callable' はパラメーターを受け取らず、非 void の値を返す単一の抽象メソッドを持つ関数型インターフェースです。 その結果、明示的なキャストが使用されない限り、ラムダの型を呼び出しサイトで推測することはできません。",
                  "markdown": "オーバーロードメソッドで、抽象メソッドのシグネチャーが競合している関数型インターフェースを使用しているものを報告します。\n\nこのようなオーバーロードはあいまいさをもたらし、呼び出し元にラムダを特定の型にキャストするか、ラムダパラメーターの型を明示的に指定することを要求します。\nあいまいさを排除するため、オーバーロードメソッドには別々の名前を付けることをお勧めします。\n\n例:\n\n\n      interface MyExecutor {\n        void execute(Supplier<?> supplier);\n        void execute(Callable<?> callable);\n      }\n\n\nここで、`Supplier` と `Callable` はパラメーターを受け取らず、非 void の値を返す単一の抽象メソッドを持つ関数型インターフェースです。\nその結果、明示的なキャストが使用されない限り、ラムダの型を呼び出しサイトで推測することはできません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LambdaUnfriendlyMethodOverload",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規則/メソッド",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnThis",
                "shortDescription": {
                  "text": "'this' のリターン"
                },
                "fullDescription": {
                  "text": "'this' を返却するメソッドを報告します。 このような返却は有効ですが、多くの場合は不要です。また、このようなメソッドは一般的に同様のメソッドを連鎖して呼び出す場合 ('buffer.append(\"foo\").append(\"bar\").append(\"baz\")' など) に使用されることが想定されています。 このような連鎖は多くのコーディング標準で認められていません。 例: 'public Builder append(String str) {\n    // [...]\n    return this;\n  }'",
                  "markdown": "`this` を返却するメソッドを報告します。\n\n\nこのような返却は有効ですが、多くの場合は不要です。また、このようなメソッドは一般的に同様のメソッドを連鎖して呼び出す場合 (`buffer.append(\"foo\").append(\"bar\").append(\"baz\")` など) に使用されることが想定されています。\nこのような連鎖は多くのコーディング標準で認められていません。\n\n**例:**\n\n\n      public Builder append(String str) {\n        // [...]\n        return this;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReturnOfThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CanBeFinal",
                "shortDescription": {
                  "text": "宣言に 'final' 修飾子を指定できます"
                },
                "fullDescription": {
                  "text": "フィールド、メソッド、またはクラスで、その宣言に 'final' 修飾子が追加されている可能性があるものを報告します。 final クラスの拡張、final メソッドのオーバーライド、final フィールドの再代入は不可能です。 例: 'public class Person {\n    private String name;\n\n    Person(String name) {\n      this.name = name;\n    }\n\n    public String getName() {\n      return name;\n    }\n\n    public String toString() {\n      return getName();\n    }\n  }' クイックフィックス適用後: 'public final class Person {\n    private final String name;\n\n    Person(String name) {\n      this.name = name;\n    }\n\n    public final String getName() {\n      return name;\n    }\n\n    public final String toString() {\n      return getName();\n    }\n  }' 報告対象の宣言を定義するには、「クラスを報告する」オプションおよび「メソッドを報告する」オプションを使用します。",
                  "markdown": "フィールド、メソッド、またはクラスで、その宣言に `final` 修飾子が追加されている可能性があるものを報告します。\n\nfinal クラスの拡張、final メソッドのオーバーライド、final フィールドの再代入は不可能です。\n\n**例:**\n\n\n      public class Person {\n        private String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n\n        public String toString() {\n          return getName();\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public final class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public final String getName() {\n          return name;\n        }\n\n        public final String toString() {\n          return getName();\n        }\n      }\n\n報告対象の宣言を定義するには、「**クラスを報告する** 」オプションおよび「**メソッドを報告する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CanBeFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableRecordContainsIgnoredMembers",
                "shortDescription": {
                  "text": "'record' に無視対象のメンバーが含まれています"
                },
                "fullDescription": {
                  "text": "'record' クラスで定義されているシリアル化メソッドまたはフィールドを報告します。 報告対象のシリアル化メソッドには、'writeObject()'、'readObject()'、'readObjectNoData()'、'writeExternal()'、'readExternal()' およびフィールド 'serialPersistentFields' が含まれます。 このようなメンバーは、レコードのシリアル化または逆シリアル化には使用されないため不要です。 例: 'record R1() implements Serializable {\n    // このフィールドはレコードをシリアル化中には無視されます\n    @Serial\n    private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];\n\n    // このメソッドはレコードをシリアル化中には無視されます\n    @Serial\n    private void writeObject(ObjectOutputStream out) throws IOException {\n    }\n  }' 'record R2() implements Externalizable {\n    // このメソッドはレコードをシリアル化中には無視されます\n    @Override\n    public void writeExternal(ObjectOutput out) throws IOException {\n    }\n\n    // このメソッドはレコードをシリアル化中には無視されます\n    @Override\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n    }\n  }' 2020.3 の新機能です このインスペクションは Java 16 以降で使用できる Java の機能 'レコード' に依存しています。",
                  "markdown": "`record` クラスで定義されているシリアル化メソッドまたはフィールドを報告します。 報告対象のシリアル化メソッドには、`writeObject()`、`readObject()`、`readObjectNoData()`、`writeExternal()`、`readExternal()` およびフィールド `serialPersistentFields` が含まれます。 このようなメンバーは、レコードのシリアル化または逆シリアル化には使用されないため不要です。\n\n**例:**\n\n\n      record R1() implements Serializable {\n        // このフィールドはレコードをシリアル化中には無視されます\n        @Serial\n        private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];\n\n        // このメソッドはレコードをシリアル化中には無視されます\n        @Serial\n        private void writeObject(ObjectOutputStream out) throws IOException {\n        }\n      }\n\n\n      record R2() implements Externalizable {\n        // このメソッドはレコードをシリアル化中には無視されます\n        @Override\n        public void writeExternal(ObjectOutput out) throws IOException {\n        }\n\n        // このメソッドはレコードをシリアル化中には無視されます\n        @Override\n        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        }\n      }\n\n2020.3 の新機能です\n\nこのインスペクションは Java 16 以降で使用できる Java の機能 'レコード' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableRecordContainsIgnoredMembers",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryLabelOnBreakStatement",
                "shortDescription": {
                  "text": "'break' ステートメントの不要なラベル"
                },
                "fullDescription": {
                  "text": "不要なラベル付きの 'break' ステートメントを報告します。 このようなラベルは制御フローを変更しませんが、コードの追跡を困難にします。 例: 'label:\n  for(int i = 0; i < 10; i++) {\n    if (shouldBreak()) break label;\n    //doSmth\n  }' クイックフィックス適用後: 'label:\n  for(int i = 0; i < 10; i++) {\n    if (shouldBreak()) break;\n    //doSmth\n  }'",
                  "markdown": "不要なラベル付きの `break` ステートメントを報告します。 このようなラベルは制御フローを変更しませんが、コードの追跡を困難にします。\n\n**例:**\n\n\n      label:\n      for(int i = 0; i < 10; i++) {\n        if (shouldBreak()) break label;\n        //doSmth\n      }\n\nクイックフィックス適用後:\n\n\n      label:\n      for(int i = 0; i < 10; i++) {\n        if (shouldBreak()) break;\n        //doSmth\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryLabelOnBreakStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NakedNotify",
                "shortDescription": {
                  "text": "対応する状態変更のない 'notify()' または 'notifyAll()'"
                },
                "fullDescription": {
                  "text": "'Object.notify()' または 'Object.notifyAll()' の呼び出しで、検出可能な状態変化が発生していないものを報告します。 通常、'Object.notify()' と 'Object.notifyAll()' は、状態変化が発生したことを他のスレッドに通知するために使用されます。 この状態変更は、'Object.notify()' または 'Object.notifyAll()' の呼び出しを含む同期コンテキストで、呼び出しの前に発生する必要があります。 このような状態変化がないことは必ずしも間違っているわけではありませんが、調査する価値があるのは間違いありません。 例: 'synchronized (this) {\n    notify();\n  }\n  // 状態変化なし\n  synchronized (this) {\n    notify(); // この notify は冗長である可能性があります\n  }'",
                  "markdown": "`Object.notify()` または `Object.notifyAll()` の呼び出しで、検出可能な状態変化が発生していないものを報告します。\n\n\n通常、`Object.notify()` と `Object.notifyAll()` は、状態変化が発生したことを他のスレッドに通知するために使用されます。 この状態変更は、`Object.notify()` または `Object.notifyAll()` の呼び出しを含む同期コンテキストで、呼び出しの前に発生する必要があります。 このような状態変化がないことは必ずしも間違っているわけではありませんが、調査する価値があるのは間違いありません。\n\n**例:**\n\n\n      synchronized (this) {\n        notify();\n      }\n      // 状態変化なし\n      synchronized (this) {\n        notify(); // この notify は冗長である可能性があります\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NakedNotify",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassCoupling",
                "shortDescription": {
                  "text": "過度に結合されたクラス"
                },
                "fullDescription": {
                  "text": "他のクラスへの参照が多すぎるクラスを報告します。 結合が多すぎるクラスは非常に脆弱な場合があるため、より小さな複数のクラスに分割する必要があるかもしれません。 インスペクションの構成: クラスで許容される結合数の最大値を指定するには、「クラス結合の制限」フィールドを使用します。 システムクラスへの参照 ('java.' または 'javax.' パッケージ内のもの) をカウントするかどうかを指定するには、「Java システムクラスへの結合を含める」オプションを使用します。 任意のライブラリへの参照をカウントするかどうかを指定するには、「ライブラリクラスへの結合を含める」オプションを使用します。",
                  "markdown": "他のクラスへの参照が多すぎるクラスを報告します。\n\n結合が多すぎるクラスは非常に脆弱な場合があるため、より小さな複数のクラスに分割する必要があるかもしれません。\n\nインスペクションの構成:\n\n* クラスで許容される結合数の最大値を指定するには、「**クラス結合の制限**」フィールドを使用します。\n* システムクラスへの参照 (`java.` または `javax.` パッケージ内のもの) をカウントするかどうかを指定するには、「**Java システムクラスへの結合を含める**」オプションを使用します。\n* 任意のライブラリへの参照をカウントするかどうかを指定するには、「**ライブラリクラスへの結合を含める**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyCoupledClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラスメトリクス",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarilyQualifiedInnerClassAccess",
                "shortDescription": {
                  "text": "不必要に修飾された内部クラスへのアクセス"
                },
                "fullDescription": {
                  "text": "外側のクラスの名前で不必要に修飾されている内側のクラスへの参照を報告します。 このような修飾は安全に除去でき、場合によっては内側のクラスにインポートが追加されます。 例: 'class X {\n     X.Y foo;\n     class Y{}\n  }' クイックフィックス適用後: 'class X {\n     Y foo;\n     class Y{}\n  }' 内側のクラスへの参照を無視し、修飾子を除去してインポートを追加するには、「インポートが必要な参照を無視する」オプションを使用します。",
                  "markdown": "外側のクラスの名前で不必要に修飾されている内側のクラスへの参照を報告します。\n\nこのような修飾は安全に除去でき、場合によっては内側のクラスにインポートが追加されます。\n\n例:\n\n\n      class X {\n         X.Y foo;\n         class Y{}\n      }\n\nクイックフィックス適用後:\n\n\n      class X {\n         Y foo;\n         class Y{}\n      }\n\n内側のクラスへの参照を無視し、修飾子を除去してインポートを追加するには、「**インポートが必要な参照を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessarilyQualifiedInnerClassAccess",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptySynchronizedStatement",
                "shortDescription": {
                  "text": "空の 'synchronized' ステートメント"
                },
                "fullDescription": {
                  "text": "本体が空の 'synchronized' ステートメントを報告します。 空の 'synchronized' ステートメントは、他のスレッドが特定のリソースをリリースするのを待機する目的で使用されることがあります。 しかし、空の 'synchronized' ステートメントが終了した直後に同じリソースが再び取得されないという保証はありません。 適切に同期するためには、リソースを 'synchronized' ブロック内で使用する必要があります。 また、空の 'synchronized' ブロックがリファクタリングで冗長なコードを除去した後に現れる場合があります。 この場合は 'synchronized' ブロック自体が冗長であるため、除去する必要があります。 例: 'synchronized(lock) {}' 空の synchronized ステートメントを削除するクイックフィックスが提案されます。 このインスペクションは JSP ファイルでは無効になります。",
                  "markdown": "本体が空の `synchronized` ステートメントを報告します。\n\n\n空の `synchronized` ステートメントは、他のスレッドが特定のリソースをリリースするのを待機する目的で使用されることがあります。 しかし、空の `synchronized` ステートメントが終了した直後に同じリソースが再び取得されないという保証はありません。\n適切に同期するためには、リソースを `synchronized` ブロック内で使用する必要があります。\n\n\nまた、空の `synchronized` ブロックがリファクタリングで冗長なコードを除去した後に現れる場合があります。 この場合は `synchronized` ブロック自体が冗長であるため、除去する必要があります。\n\n例:\n\n\n      synchronized(lock) {}\n\n\n空の synchronized ステートメントを削除するクイックフィックスが提案されます。\n\n\nこのインスペクションは JSP ファイルでは無効になります。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptySynchronizedStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TextBlockMigration",
                "shortDescription": {
                  "text": "テキストブロックを使用できます"
                },
                "fullDescription": {
                  "text": "テキストブロックに置換して単純化できる 'String' 連結を報告します。 要件: '\\n' が 2 回以上出現している。 テキストボックスが連結されていない。 改行を含む単一リテラルをハイライトするには、「単一文字列リテラルを報告する」オプションを使用します。 クイックフィックスはこのオプションが無効な場合でも使用できます。 例: 'String html = \"<html>\\n\" +\n                \"    <body>\\n\" +\n                \"        <p>Hello, world</p>\\n\" +\n                \"    </body>\\n\" +\n                \"</html>\\n\";' クイックフィックス適用後: 'String html = \"\"\"\n                <html>\n                    <body>\n                        <p>Hello, world</p>\n                    </body>\n                </html>\n                \"\"\";' 2019.3 の新機能です このインスペクションは Java 15 以降で使用できる Java の機能 'テキストブロックリテラル' に依存しています。",
                  "markdown": "テキストブロックに置換して単純化できる `String` 連結を報告します。\n\n要件:\n\n* `\\n` が 2 回以上出現している。\n* テキストボックスが連結されていない。\n\n\n改行を含む単一リテラルをハイライトするには、「**単一文字列リテラルを報告する**」オプションを使用します。\nクイックフィックスはこのオプションが無効な場合でも使用できます。\n\n\n**例:**\n\n\n      String html = \"<html>\\n\" +\n                    \"    <body>\\n\" +\n                    \"        <p>Hello, world</p>\\n\" +\n                    \"    </body>\\n\" +\n                    \"</html>\\n\";\n\nクイックフィックス適用後:\n\n\n      String html = \"\"\"\n                    <html>\n                        <body>\n                            <p>Hello, world</p>\n                        </body>\n                    </html>\n                    \"\"\";\n\n2019.3 の新機能です\n\nこのインスペクションは Java 15 以降で使用できる Java の機能 'テキストブロックリテラル' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TextBlockMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 15",
                      "index": 100,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectAllocationInLoop",
                "shortDescription": {
                  "text": "ループ内でのオブジェクト割り当て"
                },
                "fullDescription": {
                  "text": "ループ内でのオブジェクトまたは配列の割り当てを報告します。 これは必ずしも問題ではありませんが、ループ内でのオブジェクト割り当てはメモリリークやパフォーマンスの問題を発見するのに絶好の場所です。 このインスペクションは次のコンストラクトを報告します。 'new' 演算子による明示的な割り当て 新しいオブジェクトを返却することが分かっているメソッド インスタンスバインドされたメソッドの参照 変数または 'this' 参照をキャプチャしているラムダ 例: '// 明示的な割り当て\n  for (Status status : Status.values()) {\n    declarationsMap.put(status, new ArrayList<>());\n  }\n\n  // ラムダが変数をキャプチャ\n  String message = \"Engine running.\";\n  for (Engine engine : engines) {\n      if (!isRunning(engine)) {\n          logger.warn(() -> {\n              return String.format(message);\n          });\n      }\n  }\n\n  // インスタンスバインドされたメソッドの参照\n  for(Node node : nodes) {\n    descriptor = node.getDescription();\n    descriptor.ifPresent(dynamicTestExecutor::execute);\n  }'",
                  "markdown": "ループ内でのオブジェクトまたは配列の割り当てを報告します。 これは必ずしも問題ではありませんが、ループ内でのオブジェクト割り当てはメモリリークやパフォーマンスの問題を発見するのに絶好の場所です。\n\n\nこのインスペクションは次のコンストラクトを報告します。\n\n* `new` 演算子による明示的な割り当て\n* 新しいオブジェクトを返却することが分かっているメソッド\n* インスタンスバインドされたメソッドの参照\n* 変数または `this` 参照をキャプチャしているラムダ\n\n**例:**\n\n\n      // 明示的な割り当て\n      for (Status status : Status.values()) {\n        declarationsMap.put(status, new ArrayList<>());\n      }\n\n      // ラムダが変数をキャプチャ\n      String message = \"Engine running.\";\n      for (Engine engine : engines) {\n          if (!isRunning(engine)) {\n              logger.warn(() -> {\n                  return String.format(message);\n              });\n          }\n      }\n\n      // インスタンスバインドされたメソッドの参照\n      for(Node node : nodes) {\n        descriptor = node.getDescription();\n        descriptor.ifPresent(dynamicTestExecutor::execute);\n      }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ObjectAllocationInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocLinkAsPlainText",
                "shortDescription": {
                  "text": "プレーンテキストとして指定されたリンク"
                },
                "fullDescription": {
                  "text": "Javadoc コメントにあるプレーンテキストのリンクを報告します。 クイックフィックスにより、リンクを '<a>' タグで囲むことが提案されます。 例: 'class Main {\n   /**\n    * https://en.wikipedia.org/\n    */\n    void foo() {}\n  }' クイックフィックス適用後: 'class Main {\n   /**\n    * <a href=\"https://en.wikipedia.org/\">https://en.wikipedia.org/</a>\n    */\n    void foo() {}\n  }' 2022.1 の新機能です",
                  "markdown": "Javadoc コメントにあるプレーンテキストのリンクを報告します。\n\n\nクイックフィックスにより、リンクを `<a>` タグで囲むことが提案されます。\n\n**例:**\n\n\n      class Main {\n       /**\n        * https://en.wikipedia.org/\n        */\n        void foo() {}\n      }\n\nクイックフィックス適用後:\n\n\n      class Main {\n       /**\n        * <a href=\"https://en.wikipedia.org/\">https://en.wikipedia.org/</a>\n        */\n        void foo() {}\n      }\n\n2022.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavadocLinkAsPlainText",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalClone",
                "shortDescription": {
                  "text": "セキュリティに考慮が必要な非 final な 'clone()'"
                },
                "fullDescription": {
                  "text": "'final' 修飾子のない 'clone()' メソッドを報告します。 'clone()' はコンストラクターを使用せずにオブジェクトをインスタンス化する目的で使用できます。そのため、'clone()' メソッドがオーバーライドできる場合はオブジェクトが破損したり、セキュリティ上の弱点を突かれたりする可能性があります。 これは、'clone()' メソッドまたはその外側のクラス自体を 'final' にすることで防ぐことができます。 例: 'class Main implements Cloneable {\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n      return super.clone();\n    }\n  }'",
                  "markdown": "`final` 修飾子のない `clone()` メソッドを報告します。\n\n\n`clone()` はコンストラクターを使用せずにオブジェクトをインスタンス化する目的で使用できます。そのため、`clone()` メソッドがオーバーライドできる場合はオブジェクトが破損したり、セキュリティ上の弱点を突かれたりする可能性があります。 これは、`clone()` メソッドまたはその外側のクラス自体を `final` にすることで防ぐことができます。\n\n**例:**\n\n\n      class Main implements Cloneable {\n        @Override\n        protected Object clone() throws CloneNotSupportedException {\n          return super.clone();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalClone",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChainedEquality",
                "shortDescription": {
                  "text": "イコール比較の連鎖"
                },
                "fullDescription": {
                  "text": "イコール比較の連鎖を報告します。 このような比較は混乱を招く可能性があります。たとえば、'a == b == c' は '(a == b) == c' と評価されますが、'a == b && a == c' が意図されている可能性があります。 例: 'boolean chainedEquality(boolean a, boolean b, boolean c) {\n    return a == b == c;\n  }' 丸括弧を使用すると、比較を混乱しにくくなります。 'boolean chainedEquality(boolean a, boolean b, boolean c) {\n    return (a == b) == c;\n  }'",
                  "markdown": "イコール比較の連鎖を報告します。\n\nこのような比較は混乱を招く可能性があります。たとえば、`a == b == c` は `(a == b) == c` と評価されますが、`a == b && a == c` が意図されている可能性があります。\n\n**例:**\n\n\n      boolean chainedEquality(boolean a, boolean b, boolean c) {\n        return a == b == c;\n      }\n\n丸括弧を使用すると、比較を混乱しにくくなります。\n\n\n      boolean chainedEquality(boolean a, boolean b, boolean c) {\n        return (a == b) == c;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ChainedEqualityComparisons",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SharedThreadLocalRandom",
                "shortDescription": {
                  "text": "共有される可能性がある 'ThreadLocalRandom' インスタンス"
                },
                "fullDescription": {
                  "text": "スレッド間で共有される可能性のある 'java.util.concurrent.ThreadLocalRandom' インスタンスを報告します。 'ThreadLocalRandom' はスレッドセーフではないため、スレッド間で共有すべきではありません。 このインスペクションは、メソッド引数として使用されるフィールドに代入されるインスタンス、またはローカル変数に代入されてスレッド間で共有される可能性がある匿名クラスまたはネストしたクラスで使用されるインスタンスを報告します。 'ThreadLocalRandom' は通常、'ThreadLocalRandom.current().nextInt(...)' (または 'nextDouble(...)' など) のように使用されます。 すべての使用箇所がこの形式である場合、'ThreadLocalRandom' インスタンスが複数のスレッドによって誤って使用されることはありません。 例: 'class Main {\n      void printRandomNumbersAsync() {\n        ThreadLocalRandom random = ThreadLocalRandom.current();\n        CompletableFuture.supplyAsync(() -> generateNumbers(random))\n          .thenAccept(numbers -> System.out.println(Arrays.toString(numbers)));\n      }\n\n      private int[] generateNumbers(Random random) {\n        return random.ints(1000, 0, 100).toArray();\n      }\n    }' 引数として 'ThreadLocalRandom' インスタンスに安全に渡されているメソッドをリスト表示するには、オプションを使用します。 メソッド名には正規表現を使用できます。",
                  "markdown": "スレッド間で共有される可能性のある `java.util.concurrent.ThreadLocalRandom` インスタンスを報告します。\n\n\n`ThreadLocalRandom` はスレッドセーフではないため、スレッド間で共有すべきではありません。\nこのインスペクションは、メソッド引数として使用されるフィールドに代入されるインスタンス、またはローカル変数に代入されてスレッド間で共有される可能性がある匿名クラスまたはネストしたクラスで使用されるインスタンスを報告します。\n\n\n`ThreadLocalRandom` は通常、`ThreadLocalRandom.current().nextInt(...)` (または `nextDouble(...)` など) のように使用されます。\nすべての使用箇所がこの形式である場合、`ThreadLocalRandom` インスタンスが複数のスレッドによって誤って使用されることはありません。\n\n**例:**\n\n\n        class Main {\n          void printRandomNumbersAsync() {\n            ThreadLocalRandom random = ThreadLocalRandom.current();\n            CompletableFuture.supplyAsync(() -> generateNumbers(random))\n              .thenAccept(numbers -> System.out.println(Arrays.toString(numbers)));\n          }\n\n          private int[] generateNumbers(Random random) {\n            return random.ints(1000, 0, 100).toArray();\n          }\n        }\n      \n\n引数として `ThreadLocalRandom` インスタンスに安全に渡されているメソッドをリスト表示するには、オプションを使用します。\nメソッド名には正規表現を使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SharedThreadLocalRandom",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WhileCanBeDoWhile",
                "shortDescription": {
                  "text": "'while' は 'do while' に置換できます"
                },
                "fullDescription": {
                  "text": "'do-while' ループを使用すると効率が上がる可能性がある 'while' ループを報告します。 ループの直前にあるコードがループ本体内のコードとまったく同じ 'while' ループがあります。 'do-while' ループに置換すると、重複するコードが除去されます。 そのような重複するコードがない 'while' ループの場合もエディター内でクイックフィックスが提供されますが、ハイライトされることはありません。 例: 'foo();\n  while (x) {\n      foo();\n  }' 上のコードは下のコードに置換できます。 'do {\n    foo();\n  } while (x);' 2024.1 の新機能です",
                  "markdown": "`do-while` ループを使用すると効率が上がる可能性がある `while` ループを報告します。\nループの直前にあるコードがループ本体内のコードとまったく同じ `while` ループがあります。\n`do-while` ループに置換すると、重複するコードが除去されます。\nそのような重複するコードがない `while` ループの場合もエディター内でクイックフィックスが提供されますが、ハイライトされることはありません。\n\n**例:**\n\n\n      foo();\n      while (x) {\n          foo();\n      }\n\n上のコードは下のコードに置換できます。\n\n\n      do {\n        foo();\n      } while (x);\n\n\n2024.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "WhileCanBeDoWhile",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractMethodOverridesConcreteMethod",
                "shortDescription": {
                  "text": "具象メソッドをオーバーライドする抽象メソッド"
                },
                "fullDescription": {
                  "text": "具体的なスーパーメソッドをオーバーライドしている 'abstract' メソッドを報告します。 'java.lang.Object' からオーバーライドされたメソッドは、このインスペクションでは報告されません。",
                  "markdown": "具体的なスーパーメソッドをオーバーライドしている `abstract` メソッドを報告します。\n\n`java.lang.Object` からオーバーライドされたメソッドは、このインスペクションでは報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractMethodOverridesConcreteMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LossyConversionCompoundAssignment",
                "shortDescription": {
                  "text": "複合代入内の失われる可能性がある暗黙的なキャスト"
                },
                "fullDescription": {
                  "text": "代入されている右オペランドの型が変数の型と互換性がない場合に複合代入を報告します。 このような複合代入では暗黙的なキャストが発生するため、変換によってデータが失われる可能性があります。 例: 'long c = 1;\n  c += 1.2;' クイックフィックス適用後: 'long c = 1;\n  c += (long) 1.2;' 2023.2 の新機能です",
                  "markdown": "代入されている右オペランドの型が変数の型と互換性がない場合に複合代入を報告します。\n\n\nこのような複合代入では暗黙的なキャストが発生するため、変換によってデータが失われる可能性があります。\n\n例:\n\n\n      long c = 1;\n      c += 1.2;\n\nクイックフィックス適用後:\n\n\n      long c = 1;\n      c += (long) 1.2;\n\n2023.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "lossy-conversions",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowFromFinallyBlock",
                "shortDescription": {
                  "text": "'finally' ブロック内の 'throw'"
                },
                "fullDescription": {
                  "text": "'finally' ブロック内の 'throw' ステートメントを報告します。 このような 'throw' ステートメントは意図的な場合もありますが、'try'-'catch' ブロックからスローされる例外を隠すため、デバッグ手順が複雑になる可能性があります。 例: 'class Fascinating {\n    void doTask(Task t) {\n      try {\n        t.activity();\n      } finally {\n        if (!t.finish()) {\n          throw new IllegalStateException();\n        }\n      }\n    }\n  }' 例外を宣言するメソッドへのメソッド呼び出しに対しても警告するには、「宣言された例外がスローされる可能性があるすべての場所を警告する」オプションを使用します。",
                  "markdown": "`finally` ブロック内の `throw` ステートメントを報告します。 このような `throw` ステートメントは意図的な場合もありますが、`try`-`catch` ブロックからスローされる例外を隠すため、デバッグ手順が複雑になる可能性があります。\n\n**例:**\n\n\n      class Fascinating {\n        void doTask(Task t) {\n          try {\n            t.activity();\n          } finally {\n            if (!t.finish()) {\n              throw new IllegalStateException();\n            }\n          }\n        }\n      }\n\n例外を宣言するメソッドへのメソッド呼び出しに対しても警告するには、「**宣言された例外がスローされる可能性があるすべての場所を警告する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowFromFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticNonFinalField",
                "shortDescription": {
                  "text": "'static'、非 'final' フィールド"
                },
                "fullDescription": {
                  "text": "非 'final' の 'static' フィールドを報告します。 'final' 修飾子を非 'final' 'static' フィールドに追加するクイックフィックスを使用できます。 このインスペクションはフィールドの可変性をチェックしません。 たとえば、'final' 修飾子をどこかで値が設定されているフィールドに追加すると、コンパイルエラーが発生します。 このインスペクションが 'public' フィールドのみを報告するようにするには、「'public' フィールドのみを報告する」オプションを使用します。",
                  "markdown": "非 `final` の `static` フィールドを報告します。\n\n`final` 修飾子を非 `final` `static` フィールドに追加するクイックフィックスを使用できます。\n\nこのインスペクションはフィールドの可変性をチェックしません。 たとえば、`final` 修飾子をどこかで値が設定されているフィールドに追加すると、コンパイルエラーが発生します。\n\n\nこのインスペクションが `public` フィールドのみを報告するようにするには、「**'public' フィールドのみを報告する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticNonFinalField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CodeBlock2Expr",
                "shortDescription": {
                  "text": "ステートメントラムダは式ラムダで置換可能"
                },
                "fullDescription": {
                  "text": "式形式の本体を使用できるにも関わらず、コードブロックを使用しているラムダ式を報告します。 変換後のコードは、より簡潔で明瞭になります。 例: 'Comparable<String> c = o -> {return 0;};' クイックフィックス適用後: 'Comparable<String> c = o -> 0;' このインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。",
                  "markdown": "式形式の本体を使用できるにも関わらず、コードブロックを使用しているラムダ式を報告します。 変換後のコードは、より簡潔で明瞭になります。\n\n例:\n\n\n      Comparable<String> c = o -> {return 0;};\n\nクイックフィックス適用後:\n\n\n      Comparable<String> c = o -> 0;\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CodeBlock2Expr",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyForEach",
                "shortDescription": {
                  "text": "単純化可能な forEach() 呼び出し"
                },
                "fullDescription": {
                  "text": "より簡潔なメソッドに置換できる、または中間ステップを抽出できる 'forEach()' の呼び出しを報告します。 例: 'List<String> findNStrings(List<String> list, int n) {\n    List<String> other = new ArrayList<>();\n    list.forEach(s -> {\n      if(s.length() > n) other.add(s);\n    });\n    return other;\n  }' クイックフィックス適用後: 'List<String> findNStrings(List<String> list, int n) {\n    List<String> other = list.stream()\n      .filter(s -> s.length() > n)\n      .collect(Collectors.toList());\n    return other;\n  }' 2017.3 の新機能です このインスペクションは Java 8 以降で使用できる Java の機能 'コレクション内のラムダメソッド' に依存しています。",
                  "markdown": "より簡潔なメソッドに置換できる、または中間ステップを抽出できる `forEach()` の呼び出しを報告します。\n\n**例:**\n\n\n      List<String> findNStrings(List<String> list, int n) {\n        List<String> other = new ArrayList<>();\n        list.forEach(s -> {\n          if(s.length() > n) other.add(s);\n        });\n        return other;\n      }\n\nクイックフィックス適用後:\n\n\n      List<String> findNStrings(List<String> list, int n) {\n        List<String> other = list.stream()\n          .filter(s -> s.length() > n)\n          .collect(Collectors.toList());\n        return other;\n      }\n\n2017.3 の新機能です\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'コレクション内のラムダメソッド' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifyForEach",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantFieldInitialization",
                "shortDescription": {
                  "text": "冗長なフィールドの初期化"
                },
                "fullDescription": {
                  "text": "明示的にデフォルト値に初期化されているフィールドを報告します。 例: 'class Foo {\n    int foo = 0;\n    List bar = null;\n  }' クイックフィックス適用後: 'class Foo {\n    int foo;\n    List bar;\n  }' 次のように明示的な 'null' による初期化のみを報告するには、インスペクションのオプションを使用します。 'class Foo {\n    int foo = 0;     // 警告なし\n    List bar = null; // 冗長なフィールドの初期化が警告されます\n  }'",
                  "markdown": "明示的にデフォルト値に初期化されているフィールドを報告します。\n\n**例:**\n\n\n      class Foo {\n        int foo = 0;\n        List bar = null;\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        int foo;\n        List bar;\n      }\n\n\n次のように明示的な `null` による初期化のみを報告するには、インスペクションのオプションを使用します。\n\n\n      class Foo {\n        int foo = 0;     // 警告なし\n        List bar = null; // 冗長なフィールドの初期化が警告されます\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantFieldInitialization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyMethod",
                "shortDescription": {
                  "text": "空のメソッド"
                },
                "fullDescription": {
                  "text": "除去できる空のメソッドを報告します。 メソッドが空とみなされるのは、メソッドそのものが空である場合、空のメソッドにオーバーライドまたは実装されている場合に限ります。 コメントと独自のパラメーターを使った 'super()' の呼び出しのみを含むメソッドも空と見なされます。 このインスペクションは、'javax.ejb.Init' や 'javax.ejb.Remove' といった EJB アノテーションなど、特別なアノテーションを持つメソッドを無視します。 クイックフィックスを使用すると、不要なメソッドが安全に除去されます。 インスペクションの構成: コメント付きのメソッドを空でないものとして扱うかどうかを選択するには、「コメントと javadoc をコンテンツと見なす」オプションを使用します。 このインスペクションで無視すべきその他のアノテーションを設定するには、「その他の特殊アノテーション」オプションを使用します。",
                  "markdown": "除去できる空のメソッドを報告します。\n\nメソッドが空とみなされるのは、メソッドそのものが空である場合、空のメソッドにオーバーライドまたは実装されている場合に限ります。 コメントと独自のパラメーターを使った `super()` の呼び出しのみを含むメソッドも空と見なされます。\n\nこのインスペクションは、`javax.ejb.Init` や `javax.ejb.Remove` といった EJB アノテーションなど、特別なアノテーションを持つメソッドを無視します。\n\nクイックフィックスを使用すると、不要なメソッドが安全に除去されます。\n\nインスペクションの構成:\n\n* コメント付きのメソッドを空でないものとして扱うかどうかを選択するには、「**コメントと javadoc をコンテンツと見なす**」オプションを使用します。\n* このインスペクションで無視すべきその他のアノテーションを設定するには、「**その他の特殊アノテーション**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Since15",
                "shortDescription": {
                  "text": "設定された言語レベルでは利用できない API の使用"
                },
                "fullDescription": {
                  "text": "構成されている言語レベルでは使用できない API が使用されていることを報告します。 このインスペクションは次の 3 つを行います。 言語レベルが Java 7 未満の場合にジェネリック化されたクラスの使用箇所をハイライトする。 デフォルトメソッドがオーバーライドされておらず、言語レベルが Java 8 未満の場合にハイライトする。 言語レベルがドキュメントで '@since' タグで指定されたものより低い場合に API の使用箇所をハイライトする。 プロジェクトまたはカスタムの言語レベルに関する API の使用を禁止するには、「API の使用を禁止」オプションを使用します。",
                  "markdown": "構成されている言語レベルでは使用できない API が使用されていることを報告します。 このインスペクションは次の 3 つを行います。\n\n* 言語レベルが Java 7 未満の場合にジェネリック化されたクラスの使用箇所をハイライトする。\n* デフォルトメソッドがオーバーライドされておらず、言語レベルが Java 8 未満の場合にハイライトする。\n* 言語レベルがドキュメントで `@since` タグで指定されたものより低い場合に API の使用箇所をハイライトする。\n\n\nプロジェクトまたはカスタムの言語レベルに関する API の使用を禁止するには、「**API の使用を禁止**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "Since15",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableEqualsExpression",
                "shortDescription": {
                  "text": "'equals()' 呼び出し前の不要な 'null' チェック"
                },
                "fullDescription": {
                  "text": "定数引数を使用した 'equals()' の呼び出しに先行する 'null' 比較を報告します。 例: 'if (s != null && s.equals(\"literal\")) {}' クイックフィックス適用後: 'if (\"literal\".equals(s)) {}' 'equals()' の引数が 'null' にならないことが確実な場合に非定数の引数を使用する 'equals()' の呼び出しを報告するには、インスペクションの設定を使用します。",
                  "markdown": "定数引数を使用した `equals()` の呼び出しに先行する `null` 比較を報告します。\n\n**例:**\n\n\n      if (s != null && s.equals(\"literal\")) {}\n\nクイックフィックス適用後:\n\n\n      if (\"literal\".equals(s)) {}\n\n\n`equals()` の引数が `null` にならないことが確実な場合に非定数の引数を使用する `equals()` の呼び出しを報告するには、インスペクションの設定を使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableEqualsExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonCommentSourceStatements",
                "shortDescription": {
                  "text": "長すぎるメソッド"
                },
                "fullDescription": {
                  "text": "ステートメント数が指定された最大値を超えているメソッドを報告します。 ステートメントが多すぎるメソッドは混乱を招く可能性があるため、リファクタリングが必要かもしれません。 次のステートメントはカウントの対象外です。 空のステートメント (セミコロン) ブロックステートメント 'for' ループの初期化ステートメント。すなわち、'for(int i = ...;...)' ステートメント内の 'int i = ...' 'for' ループの更新ステートメント。すなわち、'for(int i = ...;...; i += 2)' ステートメント内の 'i += 2' メソッドで許容されるステートメント数の最大値を指定するには、「メソッドごとの最大ステートメント数」フィールドを使用します。",
                  "markdown": "ステートメント数が指定された最大値を超えているメソッドを報告します。\n\nステートメントが多すぎるメソッドは混乱を招く可能性があるため、リファクタリングが必要かもしれません。\n\n次のステートメントはカウントの対象外です。\n\n* 空のステートメント (セミコロン)\n* ブロックステートメント\n* `for` ループの初期化ステートメント。すなわち、`for(int i = ...;...)` ステートメント内の `int i = ...`\n* `for` ループの更新ステートメント。すなわち、`for(int i = ...;...; i += 2)` ステートメント内の `i += 2`\n\nメソッドで許容されるステートメント数の最大値を指定するには、「**メソッドごとの最大ステートメント数**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyLongMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メソッドメトリクス",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfusingMainMethod",
                "shortDescription": {
                  "text": "紛らわしい 'main()' メソッド"
                },
                "fullDescription": {
                  "text": "バージョン 21 までの Java で名前が \"main\" であるものの、'public static void main(String[])' シグネチャーがないメソッドを報告します。 Java 21 プレビュー以降、インスペクションは package-private、protected、またはインスタンスの main メソッドではハイライトしません。 さらには、匿名またはローカルクラスにある main メソッドを報告します。 匿名およびローカルクラスは完全修飾名がないため、実行することはできません。 このようなメソッドは混乱を招く可能性があります。\"main\" という名前のメソッドはアプリケーションのエントリーポイントであると思われてしまうためです。 例: 'class Main {\n    void main(String[] args) {} // \"public static\" 修飾子がないため、ここで警告が表示されます\n  }' このようなメソッドの名前を変更するクイックフィックスは、エディターでのみ使用できます。",
                  "markdown": "バージョン 21 までの Java で名前が \"main\" であるものの、`public static void main(String[])` シグネチャーがないメソッドを報告します。 Java 21 プレビュー以降、インスペクションは package-private、protected、またはインスタンスの main メソッドではハイライトしません。 さらには、匿名またはローカルクラスにある main メソッドを報告します。 匿名およびローカルクラスは完全修飾名がないため、実行することはできません。\n\nこのようなメソッドは混乱を招く可能性があります。\"main\" という名前のメソッドはアプリケーションのエントリーポイントであると思われてしまうためです。\n\n**例:**\n\n\n      class Main {\n        void main(String[] args) {} // \"public static\" 修飾子がないため、ここで警告が表示されます\n      }\n\nこのようなメソッドの名前を変更するクイックフィックスは、エディターでのみ使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfusingMainMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReadObjectInitialization",
                "shortDescription": {
                  "text": "'readObject()' で初期化されない可能性のあるインスタンスフィールド"
                },
                "fullDescription": {
                  "text": "オブジェクトが 'readObject()' メソッドによって逆シリアル化された後に確実に初期化されないフィールドを報告します。 このインスペクションは、一時的なフィールドを報告しません。 注意: このインスペクションは非常に保守的な制御フローのアルゴリズムを使用しているため、フィールドが初期化されていないとして誤って報告される場合があります。 例: 'class DataObject implements Serializable {\n  String s; // s は readObject で初期化されていません\n  int i;\n\n  private void readObject(ObjectInputStream stream) throws IOException {\n    i = stream.readInt();\n  }\n}'",
                  "markdown": "オブジェクトが `readObject()` メソッドによって逆シリアル化された後に確実に初期化されないフィールドを報告します。\n\nこのインスペクションは、一時的なフィールドを報告しません。\n\n\n注意: このインスペクションは非常に保守的な制御フローのアルゴリズムを使用しているため、フィールドが初期化されていないとして誤って報告される場合があります。\n\n**例:**\n\n\n    class DataObject implements Serializable {\n      String s; // s は readObject で初期化されていません\n      int i;\n\n      private void readObject(ObjectInputStream stream) throws IOException {\n        i = stream.readInt();\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceVariableMayNotBeInitializedByReadObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonAtomicOperationOnVolatileField",
                "shortDescription": {
                  "text": "'volatile' フィールドでの非アトミック操作"
                },
                "fullDescription": {
                  "text": "volatile フィールドでの非アトミック操作を報告します。 非アトミック操作の例としては、インクリメント演算子を使用したフィールドの更新が挙げられます。 この操作には読み取りと書き込みが含まれますが、操作中には他の変更も起こる可能性があります。そのため、データが破損する場合があります。 この操作は 'synchronized' ブロックで囲むか、'java.util.concurrent.atomic' パッケージに含まれるいずれかのクラスを使用することでアトミックにすることができます。 例: 'private volatile int v = 1;\n\n  void foo() {\n    v = 2 * v;\n  }'",
                  "markdown": "volatile フィールドでの非アトミック操作を報告します。\n\n\n非アトミック操作の例としては、インクリメント演算子を使用したフィールドの更新が挙げられます。\nこの操作には読み取りと書き込みが含まれますが、操作中には他の変更も起こる可能性があります。そのため、データが破損する場合があります。\nこの操作は `synchronized` ブロックで囲むか、`java.util.concurrent.atomic` パッケージに含まれるいずれかのクラスを使用することでアトミックにすることができます。\n\n**例:**\n\n\n      private volatile int v = 1;\n\n      void foo() {\n        v = 2 * v;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonAtomicOperationOnVolatileField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "QuestionableName",
                "shortDescription": {
                  "text": "疑わしい名前"
                },
                "fullDescription": {
                  "text": "疑わしく、内容をよく表していない名前を持つ変数、メソッド、またはクラスを報告します。 このような名前はコードの理解に役立たず、一時的なものとして作成された後に放置されている可能性が高いものです。 例: 'int aa = 42;' エディター内でのみ、名前の変更クイックフィックスが提案されます。 報告対象の名前を指定するには、オプションを使用します。",
                  "markdown": "疑わしく、内容をよく表していない名前を持つ変数、メソッド、またはクラスを報告します。 このような名前はコードの理解に役立たず、一時的なものとして作成された後に放置されている可能性が高いものです。\n\n**例:**\n\n\n      int aa = 42;\n\nエディター内でのみ、名前の変更クイックフィックスが提案されます。\n\n\n報告対象の名前を指定するには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "QuestionableName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規約",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultipleVariablesInDeclaration",
                "shortDescription": {
                  "text": "1 つの宣言で複数の変数"
                },
                "fullDescription": {
                  "text": "1 つの宣言式で複数の変数が宣言されていることを報告し、各変数に対して個別の宣言式を作成することを提案します。 一部のコーディング標準では、このような宣言は禁止されています。 例: 'int x = 1, y = 2;' クイックフィックス適用後: 'int x = 1;\n  int y = 2;' インスペクションの構成: 以下の例のように、 'for' ループステートメントを初期化する際に複数の変数が宣言されていることを無視する場合は、「'for' ループの宣言を無視する」オプションを使用します。 'for (int i = 0, max = list.size(); i > max; i++) {}' 以下の例のように、1 つの宣言内で配列次元が異なる複数の変数が宣言されている場合にのみ警告を表示する場合は、「1 つの宣言内の異なる配列次元に対してのみ警告する」オプションを使用します。 'String s = \"\", array[];' 2019.2 の新機能です",
                  "markdown": "1 つの宣言式で複数の変数が宣言されていることを報告し、各変数に対して個別の宣言式を作成することを提案します。\n\n一部のコーディング標準では、このような宣言は禁止されています。\n\n例:\n\n\n      int x = 1, y = 2;\n\nクイックフィックス適用後:\n\n\n      int x = 1;\n      int y = 2;\n\nインスペクションの構成:\n\n* 以下の例のように、 'for' ループステートメントを初期化する際に複数の変数が宣言されていることを無視する場合は、「**'for' ループの宣言を無視する** 」オプションを使用します。\n\n\n        for (int i = 0, max = list.size(); i > max; i++) {}\n\n* 以下の例のように、1 つの宣言内で配列次元が異なる複数の変数が宣言されている場合にのみ警告を表示する場合は、「**1 つの宣言内の異なる配列次元に対してのみ警告する** 」オプションを使用します。\n\n\n        String s = \"\", array[];\n\n2019.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MultipleVariablesInDeclaration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IOResource",
                "shortDescription": {
                  "text": "安全に閉じられていない I/O リソース"
                },
                "fullDescription": {
                  "text": "安全に閉じられていない I/O リソースを報告します。 このインスペクションでチェックされる I/O リソースは、'java.io.InputStream'、'java.io.OutputStream'、'java.io.Reader'、'java.io.Writer'、'java.util.zip.ZipFile'、'java.io.Closeable'、'java.io.RandomAccessFile' です。 他の I/O リソースによってラップされている I/O リソースは報告されません。ラップされているリソースはラップしているリソースによって閉じられるためです。 デフォルトでは、このインスペクションは名前に 'close' または 'cleanup' を含む任意のメソッドでリソースを閉じることができると想定しています。 例: 'void save() throws IOException {\n    FileWriter writer = new FileWriter(\"filename.txt\"); //警告\n    writer.write(\"sample\");\n  }' このインスペクションは、次のオプションを使用して構成できます。 閉じる必要がなく、このインスペクションでは無視すべき I/O リソースクラスをリストします。 try ブロック内で I/O リソースを開くことを許可するかどうか。 このスタイルは try ブロックの前でリソースを開く場合よりも冗長であるため、あまり望ましくありません。 リソースが引数として渡されている任意のメソッド呼び出しでリソースを閉じることができるかどうか。",
                  "markdown": "安全に閉じられていない I/O リソースを報告します。 このインスペクションでチェックされる I/O リソースは、`java.io.InputStream`、`java.io.OutputStream`、`java.io.Reader`、`java.io.Writer`、`java.util.zip.ZipFile`、`java.io.Closeable`、`java.io.RandomAccessFile` です。\n\n\n他の I/O リソースによってラップされている I/O リソースは報告されません。ラップされているリソースはラップしているリソースによって閉じられるためです。\n\n\nデフォルトでは、このインスペクションは名前に 'close' または 'cleanup' を含む任意のメソッドでリソースを閉じることができると想定しています。\n\n**例:**\n\n\n      void save() throws IOException {\n        FileWriter writer = new FileWriter(\"filename.txt\"); //警告\n        writer.write(\"sample\");\n      }\n\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* 閉じる必要がなく、このインスペクションでは無視すべき I/O リソースクラスをリストします。\n* try ブロック内で I/O リソースを開くことを許可するかどうか。 このスタイルは try ブロックの前でリソースを開く場合よりも冗長であるため、あまり望ましくありません。\n* リソースが引数として渡されている任意のメソッド呼び出しでリソースを閉じることができるかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IOResourceOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/リソース管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UNCHECKED_WARNING",
                "shortDescription": {
                  "text": "未チェックの警告"
                },
                "fullDescription": {
                  "text": "javac コンパイラーによって未チェックの警告が出されるコードを報告します。 未チェックの警告が出るコードはすべて、実行時に 'ClassCastException' が発生する可能性があります。 例: 'List items = Arrays.asList(\"string\", \"string\");\n  List<Integer> numbers = Collections.unmodifiableList(items); // 未チェックの代入'",
                  "markdown": "javac コンパイラーによって未チェックの警告が出されるコードを報告します。 未チェックの警告が出るコードはすべて、実行時に `ClassCastException` が発生する可能性があります。\n\n例:\n\n\n      List items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // 未チェックの代入\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "unchecked",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コンパイラー関連の問題",
                      "index": 87,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLengthCheck",
                "shortDescription": {
                  "text": "冗長な配列の長さチェック"
                },
                "fullDescription": {
                  "text": "配列の反復処理が後に続いている不要な配列の長さチェックを報告します。 配列の長さがゼロの場合は反復処理がスキップされるため、明示的に長さをチェックする必要はありません。 例: 'void f(String[] array) {\n    if (array.length != 0) { // 不要なチェック\n      for (String str : array) {\n        System.out.println(str);\n      }\n    }\n  }' 長さチェックを解除または除去するクイックフィックスが提案されます。 'void f(String[] array) {\n    for (String str : array) {\n      System.out.println(str);\n    }\n  }' 2022.3 の新機能です",
                  "markdown": "配列の反復処理が後に続いている不要な配列の長さチェックを報告します。 配列の長さがゼロの場合は反復処理がスキップされるため、明示的に長さをチェックする必要はありません。\n\n例:\n\n\n      void f(String[] array) {\n        if (array.length != 0) { // 不要なチェック\n          for (String str : array) {\n            System.out.println(str);\n          }\n        }\n      }\n\n長さチェックを解除または除去するクイックフィックスが提案されます。\n\n\n      void f(String[] array) {\n        for (String str : array) {\n          System.out.println(str);\n        }\n      }\n\n2022.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantLengthCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DataFlowIssue",
                "shortDescription": {
                  "text": "null 許容性とデータフローの問題"
                },
                "fullDescription": {
                  "text": "データフロー解析に基づいて、常に null 許容性契約に違反している、例外をスローする可能性がある、または単に冗長であるコードコンストラクトを報告します。 例: 'if (array.length < index) {\n  System.out.println(array[index]);\n} // 配列のインデックスが常に範囲を超えている\n\nif (str == null) System.out.println(\"str is null\");\nSystem.out.println(str.trim());\n// 最後のステートメントが NPE をスローする可能性がある\n\n@NotNull\nInteger square(@Nullable Integer input) {\n    // メソッド契約に違反している\n    return input == null ? null : input * input;\n}' このインスペクションの動作は、nullability アノテーション、'@Contract' アノテーション、'@Range' アノテーションなどのさまざまなアノテーションで制御できます。 インスペクションの構成: null 許容値がアノテーションのないパラメーターを持つメソッドに引数として渡される場合、アノテーションのないフィールドに格納される場合、またはアノテーションのないメソッドから返される場合に警告を出すには、「null になる可能性のあるメソッド/フィールド/パラメーターに @Nullable アノテーションを付けることを提案」オプションを使用します。 この場合、このインスペクションは '@Nullable' アノテーションを伝播することを提案します。 また、「アノテーションの構成」ボタンを使用すると、null 許容性アノテーションを構成できます。 アノテーションなしのメンバーが null になる可能性があるため、非 null のコンテキストでは使用すべきではないと仮定するには、「アノテーションなしのメンバーとパラメーターを @Nullable として扱う」オプションを使用します。 null にできない (例: メソッド本体ですぐに逆参照されている) ものの、'null' リテラルが渡される呼び出しサイトがあるメソッドパラメーターを報告するには、「非 null が必要なパラメーターで null リテラルの引数を使用している場合に報告する」オプションを使用します。 '@Nullable' アノテーションがあるものの、常に null でない値を返すメソッドを報告するには、「常に null でない値を返す null 許容メソッドを報告する」オプションを使用します。 この場合は、アノテーションを '@NotNull' に変更することが推奨されます。 インスペクションによる 'assert' ステートメントの取り扱いを制御するには、「assert ステートメントを無視する」オプションを使用します。 このオプションは、デフォルトでは無効化されており、アサーションは実行されるものとして扱われます (-ea モード)。 このオプションが有効な場合、アサーションは完全に無視されます (-da モード)。 一部のコードパスでのみ発生する可能性がある問題を報告するかどうかを制御するには、「一部のコードパスでのみ発生する問題を報告する」オプションを使用します。 このオプションが無効な場合、「exception is possible」などの警告は報告されません。 このインスペクションは、「exception will definitely occur」などの警告のみを報告します。 このモードを使用すると、誤検知の数が大幅に減る場合があります。null 許容性アノテーションおよび契約アノテーションがコードに一貫して付けられていない場合は特に減ると思われます。 そのため、このモードは既存コードベースの最も重大な問題を発見するのに役立つことがあります。 IntelliJ IDEA 2022.3 より前は、このインスペクションは \"定数条件および例外\" インスペクションの一部でした。 現在、そのインスペクションは \"定数値\" と \"null 許容性とデータフローの問題\" の 2 つのインスペクションに分割されています。",
                  "markdown": "データフロー解析に基づいて、常に null 許容性契約に違反している、例外をスローする可能性がある、または単に冗長であるコードコンストラクトを報告します。\n\n例:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // 配列のインデックスが常に範囲を超えている\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // 最後のステートメントが NPE をスローする可能性がある\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // メソッド契約に違反している\n        return input == null ? null : input * input;\n    }\n\n\nこのインスペクションの動作は、[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) アノテーション、[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) アノテーション、`@Range` アノテーションなどのさまざまなアノテーションで制御できます。\n\nインスペクションの構成:\n\n* null 許容値がアノテーションのないパラメーターを持つメソッドに引数として渡される場合、アノテーションのないフィールドに格納される場合、またはアノテーションのないメソッドから返される場合に警告を出すには、「**null になる可能性のあるメソッド/フィールド/パラメーターに @Nullable アノテーションを付けることを提案** 」オプションを使用します。 この場合、このインスペクションは `@Nullable` アノテーションを伝播することを提案します。 また、「**アノテーションの構成**」ボタンを使用すると、null 許容性アノテーションを構成できます。\n* アノテーションなしのメンバーが null になる可能性があるため、非 null のコンテキストでは使用すべきではないと仮定するには、「**アノテーションなしのメンバーとパラメーターを @Nullable として扱う**」オプションを使用します。\n* null にできない (例: メソッド本体ですぐに逆参照されている) ものの、`null` リテラルが渡される呼び出しサイトがあるメソッドパラメーターを報告するには、「**非 null が必要なパラメーターで null リテラルの引数を使用している場合に報告する**」オプションを使用します。\n* `@Nullable` アノテーションがあるものの、常に null でない値を返すメソッドを報告するには、「**常に null でない値を返す null 許容メソッドを報告する** 」オプションを使用します。 この場合は、アノテーションを `@NotNull` に変更することが推奨されます。\n* インスペクションによる `assert` ステートメントの取り扱いを制御するには、「**assert ステートメントを無視する**」オプションを使用します。 このオプションは、デフォルトでは無効化されており、アサーションは実行されるものとして扱われます (-ea モード)。 このオプションが有効な場合、アサーションは完全に無視されます (-da モード)。\n* 一部のコードパスでのみ発生する可能性がある問題を報告するかどうかを制御するには、「**一部のコードパスでのみ発生する問題を報告する** 」オプションを使用します。 このオプションが無効な場合、「*exception is possible* 」などの警告は報告されません。 このインスペクションは、「*exception will definitely occur*」などの警告のみを報告します。 このモードを使用すると、誤検知の数が大幅に減る場合があります。null 許容性アノテーションおよび契約アノテーションがコードに一貫して付けられていない場合は特に減ると思われます。 そのため、このモードは既存コードベースの最も重大な問題を発見するのに役立つことがあります。\n\n\nIntelliJ IDEA 2022.3 より前は、このインスペクションは \"定数条件および例外\" インスペクションの一部でした。\n現在、そのインスペクションは \"定数値\" と \"null 許容性とデータフローの問題\" の 2 つのインスペクションに分割されています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DataFlowIssue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterCanBeLocal",
                "shortDescription": {
                  "text": "パラメーターとして渡されているが一度も読み取られない値"
                },
                "fullDescription": {
                  "text": "ローカル変数に置換できる冗長なメソッドパラメーターを報告します。 ローカルで使用しているパラメーターに毎回必ず先行して代入を行っている場合、そのパラメーターを除去して使用箇所をローカル変数に置換できます。 このようなパラメーターを使用することには意味がありません。なぜなら、パラメーターに渡される値は上書きされるためです。 通常、この問題はリファクタリングを実行した際に発生します。 例: 'void test(int p) {\n    p = 1;\n    System.out.print(p);\n  }' クイックフィックス適用後: 'void test() {\n    int p = 1;\n    System.out.print(p);\n  }'",
                  "markdown": "ローカル変数に置換できる冗長なメソッドパラメーターを報告します。\n\nローカルで使用しているパラメーターに毎回必ず先行して代入を行っている場合、そのパラメーターを除去して使用箇所をローカル変数に置換できます。\nこのようなパラメーターを使用することには意味がありません。なぜなら、パラメーターに渡される値は上書きされるためです。\n通常、この問題はリファクタリングを実行した際に発生します。\n\n例:\n\n\n      void test(int p) {\n        p = 1;\n        System.out.print(p);\n      }\n\nクイックフィックス適用後:\n\n\n      void test() {\n        int p = 1;\n        System.out.print(p);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterCanBeLocal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToSimpleGetterInClass",
                "shortDescription": {
                  "text": "クラス内からの単純な getter の呼び出し"
                },
                "fullDescription": {
                  "text": "プロパティのクラス内からの単純なプロパティ getter の呼び出しを報告します。 単純なプロパティ getter は単にフィールドの値を返却するものとして定義されており、その他の演算は行いません。 このような単純な getter の呼び出しは、クイックフィックスを使用して安全にインライン化できます。 一部のコーディング標準でも、コードの明確化を理由にした単純な getter の使用は推奨されていません。 例: 'public class Salient {\n    private String name;\n\n    public String getName() {\n      return name;\n    }\n\n    @Override\n    public String toString() {\n      return getName();\n    }\n  }' クイックフィックス適用後: 'public class Salient {\n    private String name;\n\n    public String getName() {\n      return name;\n    }\n\n    @Override\n    public String toString() {\n      return name;\n    }\n  }' このインスペクションは、次のオプションを使用して構成できます。 パラメーターとして渡された同じ型のオブジェクトではなく、'this' での getter 呼び出しのみを報告するかどうか。 非 'private' の getter を無視するかどうか。",
                  "markdown": "プロパティのクラス内からの単純なプロパティ getter の呼び出しを報告します。\n\n\n単純なプロパティ getter は単にフィールドの値を返却するものとして定義されており、その他の演算は行いません。 このような単純な getter の呼び出しは、クイックフィックスを使用して安全にインライン化できます。\n一部のコーディング標準でも、コードの明確化を理由にした単純な getter の使用は推奨されていません。\n\n**例:**\n\n\n      public class Salient {\n        private String name;\n\n        public String getName() {\n          return name;\n        }\n\n        @Override\n        public String toString() {\n          return getName();\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public class Salient {\n        private String name;\n\n        public String getName() {\n          return name;\n        }\n\n        @Override\n        public String toString() {\n          return name;\n        }\n      }\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* パラメーターとして渡された同じ型のオブジェクトではなく、`this` での getter 呼び出しのみを報告するかどうか。\n* 非 `private` の getter を無視するかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSimpleGetterFromWithinClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementDensity",
                "shortDescription": {
                  "text": "分岐密度が低すぎる 'switch' 文"
                },
                "fullDescription": {
                  "text": "実行ステートメントに対して switch ラベルの割合が少なすぎる 'switch' ステートメントまたは式を報告します。 このような 'switch' ステートメントは混乱を招く可能性があるため、リファクタリングする必要があると思われます。 例: 'switch (i) { // 1 つの case に 5 つの実行可能ステートメントがある -> 20% の密度\n        case 1:\n            System.out.println(\"1\");\n            System.out.println(\"2\");\n            System.out.println(\"3\");\n            System.out.println(\"4\");\n            System.out.println(\"5\");\n            break;\n    }' 実行可能ステートメントに使用できる switch ラベルの割合を指定するには、「最小分岐密度」フィールドを使用します。",
                  "markdown": "実行ステートメントに対して switch ラベルの割合が少なすぎる `switch` ステートメントまたは式を報告します。\n\nこのような `switch` ステートメントは混乱を招く可能性があるため、リファクタリングする必要があると思われます。\n\n例:\n\n\n        switch (i) { // 1 つの case に 5 つの実行可能ステートメントがある -> 20% の密度\n            case 1:\n                System.out.println(\"1\");\n                System.out.println(\"2\");\n                System.out.println(\"3\");\n                System.out.println(\"4\");\n                System.out.println(\"5\");\n                break;\n        }\n\n\n実行可能ステートメントに使用できる switch ラベルの割合を指定するには、「**最小分岐密度**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SwitchStatementDensity",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableFieldInSerializableClass",
                "shortDescription": {
                  "text": "'Serializable' クラス内の非 Serializable フィールド"
                },
                "fullDescription": {
                  "text": "'java.io.Serializable' を実装しているクラスの非 Serializable フィールドを報告します。 このようなフィールドは、オブジェクトがシリアル化されている場合にランタイム例外を引き起こします。 'transient' または 'static' で宣言されているフィールドは報告されません。また、'writeObject' メソッドが定義されているクラスのフィールドも報告されません。 このインスペクションは型 'java.util.Collection' および 'java.util.Map' のフィールドについて、その宣言を含む型が非 'Serializable' でない限りは 'Serializable' であると仮定します。 例: 'class NonSerializableClass {}\n\n  public class SerializableClass implements Serializable {\n      NonSerializableClass clazz; // 警告: Serializable クラス内に非 Serializable フィールド 'clazz' があります\n      static NonSerializableClass staticClazz; // 警告なし\n  }'\n このインスペクションは、次のオプションを使用して構成できます。 このインスペクションで継承先を報告対象外とするクラスをリストする。 これは、スーパークラスの 'Serializable' を継承しているものの、シリアル化を目的としていないクラスを対象としています。 このインスペクションにアノテーション付きフィールドを無視させるアノテーションをリストする。 匿名クラスで初期化されているフィールドを無視するかどうか。",
                  "markdown": "`java.io.Serializable` を実装しているクラスの非 Serializable フィールドを報告します。 このようなフィールドは、オブジェクトがシリアル化されている場合にランタイム例外を引き起こします。\n\n\n`transient` または `static` で宣言されているフィールドは報告されません。また、`writeObject` メソッドが定義されているクラスのフィールドも報告されません。\n\n\nこのインスペクションは型 `java.util.Collection` および `java.util.Map` のフィールドについて、その宣言を含む型が非 `Serializable` でない限りは `Serializable` であると仮定します。\n\n**例:**\n\n\n      class NonSerializableClass {}\n\n      public class SerializableClass implements Serializable {\n          NonSerializableClass clazz; // 警告: Serializable クラス内に非 Serializable フィールド 'clazz' があります\n          static NonSerializableClass staticClazz; // 警告なし\n      }\n      \n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* このインスペクションで継承先を報告対象外とするクラスをリストする。 これは、スーパークラスの `Serializable` を継承しているものの、シリアル化を目的としていないクラスを対象としています。\n* このインスペクションにアノテーション付きフィールドを無視させるアノテーションをリストする。\n* 匿名クラスで初期化されているフィールドを無視するかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableFieldInSerializableClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedJavadocCode",
                "shortDescription": {
                  "text": "Javadoc とコードの不一致"
                },
                "fullDescription": {
                  "text": "英語で書かれたメソッド仕様の部分で、メソッドの宣言と矛盾しているものを報告します。 対象には次が含まれます。 'true' または 'false' を返すよう指定されているが、その戻り値の型がブール値でないメソッド。 'null' を返すよう指定されているが、'@NotNull' アノテーションが付いている、またはその戻り値の型がプリミティブであるメソッド。 リストを返すように指定されているが、その戻り値の型がセットまたは配列であるメソッド。 その他。 例: '/**\n   * @return true if user is found, false otherwise\n   */\n  User findUser(String name);' このインスペクションは人間語の解釈を試みるため、誤検知が発生する可能性があることに注意してください。 ただし、インスペクションの報告が正しくない場合でも、紛らわしい記述を書き換える必要がある可能性はあります。 2022.3 の新機能です",
                  "markdown": "英語で書かれたメソッド仕様の部分で、メソッドの宣言と矛盾しているものを報告します。 対象には次が含まれます。\n\n* `true` または `false` を返すよう指定されているが、その戻り値の型がブール値でないメソッド。\n* `null` を返すよう指定されているが、`@NotNull` アノテーションが付いている、またはその戻り値の型がプリミティブであるメソッド。\n* リストを返すように指定されているが、その戻り値の型がセットまたは配列であるメソッド。\n* その他。\n\n**例:**\n\n\n      /**\n       * @return true if user is found, false otherwise\n       */\n      User findUser(String name);\n\n\nこのインスペクションは人間語の解釈を試みるため、誤検知が発生する可能性があることに注意してください。 ただし、インスペクションの報告が正しくない場合でも、紛らわしい記述を書き換える必要がある可能性はあります。\n\n\n2022.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedJavadocCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnhancedSwitchMigration",
                "shortDescription": {
                  "text": "拡張 'switch' に置換可能なステートメント"
                },
                "fullDescription": {
                  "text": "拡張 'switch' ステートメントまたは式に自動的に置換できる 'switch' ステートメントを報告します。 例: 'double getPrice(String fruit) {\n    // switch ステートメントは拡張 'switch' に置換できます\n    switch (fruit) {\n      case \"Apple\":\n        return 1.0;\n      case \"Orange\":\n        return 1.5;\n      case \"Mango\":\n        return 2.0;\n      default:\n        throw new IllegalArgumentException();\n    }\n  }' クイックフィックス適用後: 'double getPrice(String fruit) {\n    return switch (fruit) {\n      case \"Apple\" -> 1.0;\n      case \"Orange\" -> 1.5;\n      case \"Mango\" -> 2.0;\n      default -> throw new IllegalArgumentException();\n    };\n  }' 'switch' ステートメントへの変換について警告しないようにするには、「式に変換できる場合にのみ警告を表示する」オプションを使用します。 各分岐のステートメント数が指定した数よりも少ない場合にのみ式への変換について警告するには、「switch 式に変換する 1 つの分岐内の最大ステートメント数」オプションを使用します。 2019.1 の新機能です このインスペクションは Java 14 以降で使用できる Java の機能 '拡張 'switch' ブロック' に依存しています。",
                  "markdown": "拡張 `switch` ステートメントまたは式に自動的に置換できる `switch` ステートメントを報告します。\n\n**例:**\n\n\n      double getPrice(String fruit) {\n        // switch ステートメントは拡張 'switch' に置換できます\n        switch (fruit) {\n          case \"Apple\":\n            return 1.0;\n          case \"Orange\":\n            return 1.5;\n          case \"Mango\":\n            return 2.0;\n          default:\n            throw new IllegalArgumentException();\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      double getPrice(String fruit) {\n        return switch (fruit) {\n          case \"Apple\" -> 1.0;\n          case \"Orange\" -> 1.5;\n          case \"Mango\" -> 2.0;\n          default -> throw new IllegalArgumentException();\n        };\n      }\n      \n\n* `switch` ステートメントへの変換について警告しないようにするには、「**式に変換できる場合にのみ警告を表示する**」オプションを使用します。\n* 各分岐のステートメント数が指定した数よりも少ない場合にのみ式への変換について警告するには、「**switch 式に変換する 1 つの分岐内の最大ステートメント数**」オプションを使用します。\n\n2019.1 の新機能です\n\nこのインスペクションは Java 14 以降で使用できる Java の機能 '拡張 'switch' ブロック' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EnhancedSwitchMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 14",
                      "index": 101,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableAnnotation",
                "shortDescription": {
                  "text": "単純化できるアノテーション"
                },
                "fullDescription": {
                  "text": "単一要素またはマーカーショートハンド形式に単純化できるアノテーションを報告します。 報告される問題: アノテーションの名前と値のペアにある冗長な 'value=' 単一値のみを含む配列値を囲む冗長な波括弧 @ 記号とアノテーション名の間の冗長な空白 アノテーション名とパラメーターリストの間の冗長な空白 パラメーターのないアノテーションの冗長な丸括弧 例: '@interface Foo { String[] value(); }\n\n  @ Foo({\"foo\"})\n  public String name;' クイックフィックス適用後: '@interface Foo { String[] value(); }\n\n  @Foo(\"foo\")\n  public String name;'",
                  "markdown": "単一要素またはマーカーショートハンド形式に単純化できるアノテーションを報告します。\n\n\n報告される問題:\n\n* アノテーションの名前と値のペアにある冗長な `value=`\n* 単一値のみを含む配列値を囲む冗長な波括弧\n* @ 記号とアノテーション名の間の冗長な空白\n* アノテーション名とパラメーターリストの間の冗長な空白\n* パラメーターのないアノテーションの冗長な丸括弧\n\n**例:**\n\n\n      @interface Foo { String[] value(); }\n\n      @ Foo({\"foo\"})\n      public String name;\n\nクイックフィックス適用後:\n\n\n      @interface Foo { String[] value(); }\n\n      @Foo(\"foo\")\n      public String name;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DoubleLiteralMayBeFloatLiteral",
                "shortDescription": {
                  "text": "'float' へのキャストは 'float' リテラルにできます"
                },
                "fullDescription": {
                  "text": "'float' にすぐにキャストされる 'double' リテラル式を報告します。 このようなリテラル式は同等の 'float' リテラルに置換できます。 例: 'float f = (float)1.1;' クイックフィックス適用後: 'float f = 1.1f;'",
                  "markdown": "`float` にすぐにキャストされる `double` リテラル式を報告します。\n\nこのようなリテラル式は同等の `float` リテラルに置換できます。\n\n**例:**\n\n    float f = (float)1.1;\n\nクイックフィックス適用後:\n\n    float f = 1.1f;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DoubleLiteralMayBeFloatLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値の問題/キャスト",
                      "index": 104,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Guava",
                "shortDescription": {
                  "text": "Java に置換可能な Guava の関数型プリミティブ"
                },
                "fullDescription": {
                  "text": "Guava の関数型プリミティブで、標準の Java API 呼び出しに移行できる使用箇所を報告します。 このインスペクションは、'FluentIterable'、'Optional'、'Function'、'Predicate'、'Supplier' などのクラスとインターフェースが使用されていることを報告します。 例: 'ImmutableList<String> results = FluentIterable.from(List.of(1, 2, 3)).transform(Object::toString).toList();' クイックフィックス適用後: 'List<String> results = List.of(1, 2, 3).stream().map(Object::toString).collect(Collectors.toList());' このクイックフィックスはセマンティクスを変更する可能性があります。 遅延評価される Guava の Iterable の中には、先行評価される Iterable に変換できるものがあります。 このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "Guava の関数型プリミティブで、標準の Java API 呼び出しに移行できる使用箇所を報告します。\n\nこのインスペクションは、`FluentIterable`、`Optional`、`Function`、`Predicate`、`Supplier` などのクラスとインターフェースが使用されていることを報告します。\n\n例:\n\n\n      ImmutableList<String> results = FluentIterable.from(List.of(1, 2, 3)).transform(Object::toString).toList();\n\nクイックフィックス適用後:\n\n\n      List<String> results = List.of(1, 2, 3).stream().map(Object::toString).collect(Collectors.toList());\n\n\nこのクイックフィックスはセマンティクスを変更する可能性があります。 遅延評価される Guava の Iterable の中には、先行評価される Iterable に変換できるものがあります。\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Guava",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NoopMethodInAbstractClass",
                "shortDescription": {
                  "text": "'abstract' クラスの空メソッド"
                },
                "fullDescription": {
                  "text": "'abstract' クラスに含まれている空の (何もしない) メソッドを報告します。 一般的にはこのようなメソッド自体は 'abstract' にして、その実装を継承先のクラスに任せるのが優れた設計とされています。 例: 'abstract class Test {\n    protected void doTest() {\n    }\n  }'",
                  "markdown": "`abstract` クラスに含まれている空の (何もしない) メソッドを報告します。\n\n一般的にはこのようなメソッド自体は `abstract` にして、その実装を継承先のクラスに任せるのが優れた設計とされています。\n\n**例:**\n\n\n      abstract class Test {\n        protected void doTest() {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NoopMethodInAbstractClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverridableMethodCallDuringObjectConstruction",
                "shortDescription": {
                  "text": "オブジェクト構築中のオーバーライド可能なメソッド呼び出し"
                },
                "fullDescription": {
                  "text": "現在のクラスのオーバーライド可能なメソッドが、オブジェクト構築中に呼び出されていることを報告します。 メソッドは、次の項目内にある場合にオブジェクト構築中に呼び出されます。 コンストラクター 非 static インスタンスイニシャライザー 非 static フィールドイニシャライザー 'clone()' メソッド 'readObject()' メソッド 'readObjectNoData()' メソッド メソッドは 'final'、'static'、または 'private' で宣言されていない場合にオーバーライド可能です。 パッケージローカルメソッドはオーバーライド可能ですが、安全だと考えられます。 このような呼び出しはバグの検出を困難にします。オブジェクトの初期化がメソッド呼び出しの前に発生する可能性があるためです。 例: 'class Parent {\n    void someMethod() { }\n  }\n\n  class Child extends Parent {\n    Child() {\n      someMethod();\n    }\n  }' このインスペクションは以下のインスペクションと機能を共有しています。 オブジェクト構築中の抽象メソッド呼び出し オブジェクト構築中のオーバーライドされたメソッド呼び出し 警告の重複を避けるため、同時に 1 つのインスペクションのみを有効にしてください。",
                  "markdown": "現在のクラスのオーバーライド可能なメソッドが、オブジェクト構築中に呼び出されていることを報告します。\n\nメソッドは、次の項目内にある場合にオブジェクト構築中に呼び出されます。\n\n* コンストラクター\n* 非 static インスタンスイニシャライザー\n* 非 static フィールドイニシャライザー\n* `clone()` メソッド\n* `readObject()` メソッド\n* `readObjectNoData()` メソッド\n* メソッドは `final`、`static`、または `private` で宣言されていない場合にオーバーライド可能です。 パッケージローカルメソッドはオーバーライド可能ですが、安全だと考えられます。 このような呼び出しはバグの検出を困難にします。オブジェクトの初期化がメソッド呼び出しの前に発生する可能性があるためです。\n* **例:**\n\n\n      class Parent {\n        void someMethod() { }\n      }\n\n      class Child extends Parent {\n        Child() {\n          someMethod();\n        }\n      }\n\n* このインスペクションは以下のインスペクションと機能を共有しています。\n  * オブジェクト構築中の抽象メソッド呼び出し\n  * オブジェクト構築中のオーバーライドされたメソッド呼び出し\n* 警告の重複を避けるため、同時に 1 つのインスペクションのみを有効にしてください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverridableMethodCallDuringObjectConstruction",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初期化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverloadedMethodsWithSameNumberOfParameters",
                "shortDescription": {
                  "text": "同じ数のパラメーターを持つオーバーロードされたメソッド"
                },
                "fullDescription": {
                  "text": "同じクラス内で宣言され、名前とパラメーター数が同じメソッドを報告します。 このようなオーバーロードは、大きな混乱を招く可能性があります。どのオーバーロードが呼び出されるのかが不明確であるためです。 例: 'class Main {\n    public static void execute(Runnable r) {}\n    public static <T> void execute(RunnableFuture<T> c) {}\n  }' 明らかに互換性のないパラメーターの型を持つオーバーロードされたメソッドを無視するには、オプションを使用します。",
                  "markdown": "同じクラス内で宣言され、名前とパラメーター数が同じメソッドを報告します。 このようなオーバーロードは、大きな混乱を招く可能性があります。どのオーバーロードが呼び出されるのかが不明確であるためです。\n\n**例:**\n\n\n      class Main {\n        public static void execute(Runnable r) {}\n        public static <T> void execute(RunnableFuture<T> c) {}\n      }\n\n\n明らかに互換性のないパラメーターの型を持つオーバーロードされたメソッドを無視するには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverloadedMethodsWithSameNumberOfParameters",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規則/メソッド",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParametersPerMethod",
                "shortDescription": {
                  "text": "パラメーターが多すぎるメソッド"
                },
                "fullDescription": {
                  "text": "パラメーター数が指定された最大値を超えているメソッドを報告します。 パラメーターが多すぎるメソッドは、リファクタリングが必要かもしれません。 スーパーメソッドを持つメソッドは報告されません。 メソッドで許容されるパラメーター数の最大値を指定するには、「パラメーターの制限」フィールドを使用します。",
                  "markdown": "パラメーター数が指定された最大値を超えているメソッドを報告します。 パラメーターが多すぎるメソッドは、リファクタリングが必要かもしれません。\n\nスーパーメソッドを持つメソッドは報告されません。\n\nメソッドで許容されるパラメーター数の最大値を指定するには、「**パラメーターの制限**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithTooManyParameters",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メソッドメトリクス",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyLongLambda",
                "shortDescription": {
                  "text": "長すぎるラムダ式"
                },
                "fullDescription": {
                  "text": "ステートメント数が指定された最大値を超えているラムダ式を報告します。 長すぎるラムダ式は混乱を招く可能性があるため、ステートメントを単独のメソッドに抽出することをお勧めします。 次のステートメントはカウントの対象外です。 空のステートメント (セミコロン) ブロックステートメント 'for' ループの初期化ステートメント。すなわち、'for(int i = ...;...)' ステートメント内の 'int i = ...' 'for' ループの更新ステートメント。すなわち、'for(int i = ...;...; i += 2)' ステートメント内の 'i += 2' ラムダ式で許容されるステートメント数の最大値を指定するには、「非コメントソースステートメントの制限」フィールドを使用します。",
                  "markdown": "ステートメント数が指定された最大値を超えているラムダ式を報告します。\n\n長すぎるラムダ式は混乱を招く可能性があるため、ステートメントを単独のメソッドに抽出することをお勧めします。\n\n\n次のステートメントはカウントの対象外です。\n\n* 空のステートメント (セミコロン)\n* ブロックステートメント\n* `for` ループの初期化ステートメント。すなわち、`for(int i = ...;...)` ステートメント内の `int i = ...`\n* `for` ループの更新ステートメント。すなわち、`for(int i = ...;...; i += 2)` ステートメント内の `i += 2`\n\nラムダ式で許容されるステートメント数の最大値を指定するには、「**非コメントソースステートメントの制限**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyLongLambda",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メソッドメトリクス",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitCallToSuper",
                "shortDescription": {
                  "text": "暗黙的な 'super()' の呼び出し"
                },
                "fullDescription": {
                  "text": "\"super\" コンストラクターや同じクラス内の別のコンストラクターの呼び出しで始まっていないコンストラクターを報告します。 このようなコンストラクターは、暗黙的に 'super()' の呼び出しで始まっていると考えることができます。 一部のコーディング標準では、このような 'super()' の呼び出しを明示的にすることが推奨されています。 例: 'class Foo {\n    Foo() {}\n  }' クイックフィックス適用後: 'class Foo {\n    Foo() {\n      super();\n    }\n  }' 'Object' から直接拡張されているクラスを無視するには、インスペクションのオプションを使用します。 以下に例を示します。 'class Foo {\n    Foo() {} // 報告されません\n  }\n\n  class Bar extends Foo {\n    Bar() {} // 暗黙的な 'super()' の呼び出し\n  }'",
                  "markdown": "\"super\" コンストラクターや同じクラス内の別のコンストラクターの呼び出しで始まっていないコンストラクターを報告します。\n\nこのようなコンストラクターは、暗黙的に `super()` の呼び出しで始まっていると考えることができます。 一部のコーディング標準では、このような `super()` の呼び出しを明示的にすることが推奨されています。\n\n**例:**\n\n\n      class Foo {\n        Foo() {}\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        Foo() {\n          super();\n        }\n      }\n\n\n`Object` から直接拡張されているクラスを無視するには、インスペクションのオプションを使用します。\n以下に例を示します。\n\n\n      class Foo {\n        Foo() {} // 報告されません\n      }\n\n      class Bar extends Foo {\n        Bar() {} // 暗黙的な 'super()' の呼び出し\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ImplicitCallToSuper",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingDeprecatedAnnotation",
                "shortDescription": {
                  "text": "'@Deprecated' アノテーションがありません"
                },
                "fullDescription": {
                  "text": "'@deprecated' Javadoc タグが付いているものの、'@java.lang.Deprecated' アノテーションが付いていないモジュールの宣言、クラス、フィールド、またはメソッドを報告します。 例: '/**\n   * @deprecated {@code example()} を代わりに使用してください\n   */\n  void sample(){ }' クイックフィックス適用後: '/**\n   * @deprecated {@code example()} を代わりに使用してください\n   */\n  @Deprecated\n  void sample(){ }' Javadoc '@deprecated' タグ内で説明のない '@Deprecated' のアノテーションが付いたメンバーを報告するには、以下のチェックボックスを使用します。 このインスペクションは Java 5 以降で使用できる Java の機能 'アノテーション' に依存しています。",
                  "markdown": "`@deprecated` Javadoc タグが付いているものの、`@java.lang.Deprecated` アノテーションが付いていないモジュールの宣言、クラス、フィールド、またはメソッドを報告します。\n\n**例:**\n\n\n      /**\n       * @deprecated {@code example()} を代わりに使用してください\n       */\n      void sample(){ }\n\nクイックフィックス適用後:\n\n\n      /**\n       * @deprecated {@code example()} を代わりに使用してください\n       */\n      @Deprecated\n      void sample(){ }\n\n\nJavadoc `@deprecated` タグ内で説明のない `@Deprecated` のアノテーションが付いたメンバーを報告するには、以下のチェックボックスを使用します。\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 'アノテーション' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MissingDeprecatedAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringTemplateMigration",
                "shortDescription": {
                  "text": "文字列テンプレートを使用できます"
                },
                "fullDescription": {
                  "text": "文字列テンプレートに置換して単純化できる 'String' 連結を報告します。 例: 'String name = \"Bob\";\n  String greeting = \"Hello, \" + name + \". You are \" + 29 + \" years old.\";' クイックフィックス適用後: 'String name = \"Bob\";\n  String greeting = STR.\"Hello, \\{name}. You are 29 years old.\";' 2023.3 の新機能です このインスペクションは Java 21-preview 以降で使用できる Java の機能 '文字列テンプレート' に依存しています。",
                  "markdown": "文字列テンプレートに置換して単純化できる `String` 連結を報告します。\n\n**例:**\n\n\n      String name = \"Bob\";\n      String greeting = \"Hello, \" + name + \". You are \" + 29 + \" years old.\";\n\nクイックフィックス適用後:\n\n\n      String name = \"Bob\";\n      String greeting = STR.\"Hello, \\{name}. You are 29 years old.\";\n\n2023.3 の新機能です\n\nこのインスペクションは Java 21-preview 以降で使用できる Java の機能 '文字列テンプレート' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringTemplateMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 21",
                      "index": 75,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CachedNumberConstructorCall",
                "shortDescription": {
                  "text": "プリミティブ引数による Number コンストラクターの呼び出し"
                },
                "fullDescription": {
                  "text": "プリミティブの 'long'、'integer'、'short' または 'byte' 引数を持つ新しい 'Long'、'Integer'、'Short' または 'Byte' オブジェクトのインスタンス化を報告します。 Java 5 で導入された static メソッドの 'valueOf()' を使用することをお勧めします。 このメソッドはデフォルトで -128 以上 127 以下の値のオブジェクトをキャッシュします。 例: 'Integer i = new Integer(1);\n  Long l = new Long(1L);' クイックフィックスが適用されると、コードは次のように変更されます。 'Integer i = Integer.valueOf(1);\n  Long l = Long.valueOf(1L);' このインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以上の場合にのみ報告します。 'String' 引数を持つ数値のコンストラクターの呼び出しを無視するには、「文字列引数を持つ新しい数値式を無視する」オプションを使用します。 非推奨のコンストラクターの呼び出しのみを報告するには、「コンストラクターが @Deprecated の場合のみ報告する」オプションを使用します。 JDK 9 以降、'Long'、'Integer'、'Short'、'Byte' コンストラクターは非推奨です。",
                  "markdown": "プリミティブの `long`、`integer`、`short` または `byte` 引数を持つ新しい `Long`、`Integer`、`Short` または `Byte` オブジェクトのインスタンス化を報告します。\n\nJava 5 で導入された static メソッドの `valueOf()` を使用することをお勧めします。 このメソッドはデフォルトで -128 以上 127 以下の値のオブジェクトをキャッシュします。\n\n**例:**\n\n\n      Integer i = new Integer(1);\n      Long l = new Long(1L);\n\nクイックフィックスが適用されると、コードは次のように変更されます。\n\n\n      Integer i = Integer.valueOf(1);\n      Long l = Long.valueOf(1L);\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以上の場合にのみ報告します。\n\n\n`String` 引数を持つ数値のコンストラクターの呼び出しを無視するには、「**文字列引数を持つ新しい数値式を無視する**」オプションを使用します。\n\n\n非推奨のコンストラクターの呼び出しのみを報告するには、「**コンストラクターが @Deprecated の場合のみ報告する** 」オプションを使用します。\nJDK 9 以降、`Long`、`Integer`、`Short`、`Byte` コンストラクターは非推奨です。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CachedNumberConstructorCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MustAlreadyBeRemovedApi",
                "shortDescription": {
                  "text": "API はすでに削除されています"
                },
                "fullDescription": {
                  "text": "現在バージョンの宣言するライブラリでは除去されているべき '@ApiStatus.ScheduledForRemoval' でマークされている宣言を報告します。 除去をスケジュールした指定のバージョンを、以下のようにして設定したバージョンと比較できます。 ドット区切りの文字列でバージョンを指定して、オプションで接尾辞 'alpha'、'beta'、'snapshot'、または 'eap' を付けます。 有効なバージョン: '1.0'、'2.3.1'、'2018.1'、'7.5-snapshot'、'3.0-eap' など。 直感的なバージョン比較: '1.0 < 2.0'、'1.0-eap < 1.0'、'2.3-snapshot < 2.3' など。 比較ロジックに関する詳細は、VersionComparatorUtil の実装を参照してください。",
                  "markdown": "現在バージョンの宣言するライブラリでは除去されているべき `@ApiStatus.ScheduledForRemoval` でマークされている宣言を報告します。\n\n除去をスケジュールした指定のバージョンを、以下のようにして設定したバージョンと比較できます。\n\n\nドット区切りの文字列でバージョンを指定して、オプションで接尾辞 `alpha`、`beta`、`snapshot`、または `eap` を付けます。\n\n有効なバージョン: `1.0`、`2.3.1`、`2018.1`、`7.5-snapshot`、`3.0-eap` など。\n\n\n直感的なバージョン比較: `1.0 < 2.0`、`1.0-eap < 1.0`、`2.3-snapshot < 2.3` など。\n比較ロジックに関する詳細は、[VersionComparatorUtil](https://github.com/JetBrains/intellij-community/blob/master/platform/util-rt/src/com/intellij/util/text/VersionComparatorUtil.java) の実装を参照してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MustAlreadyBeRemovedApi",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneDeclaresCloneNotSupported",
                "shortDescription": {
                  "text": "'CloneNotSupportedException' を宣言していない 'clone()'"
                },
                "fullDescription": {
                  "text": "'throws CloneNotSupportedException' を宣言していない 'clone()' メソッドを報告します。 'throws CloneNotSupportedException' が宣言されていない場合、メソッドのサブクラスは標準的な方法でクローンを禁止できなくなります。 このインスペクションは、'final' 宣言されている 'clone()' メソッドと 'final' クラスの 'clone()' メソッドを報告しません。 インスペクションの構成: このインスペクションに 'protected clone()' メソッドについてのみ警告を表示させるには、「'protected' クローンメソッドについてのみ警告する」オプションを使用します。 Effective Java (第 2 版および第 3 版) では、'public' メソッドで 'CloneNotSupportedException' の宣言を省略することが推奨されています。チェック例外をスローしないメソッドは使いやすいためです。 例: 'public class Example implements Cloneable {\n    // メソッドは 'throws CloneNotSupportedException' を宣言していません\n    protected Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException e) {\n            return null;\n        }\n    }\n  }'",
                  "markdown": "`throws CloneNotSupportedException` を宣言していない `clone()` メソッドを報告します。\n\n`throws CloneNotSupportedException` が宣言されていない場合、メソッドのサブクラスは標準的な方法でクローンを禁止できなくなります。 このインスペクションは、`final` 宣言されている `clone()` メソッドと\n`final` クラスの `clone()` メソッドを報告しません。\n\nインスペクションの構成:\n\nこのインスペクションに `protected clone()` メソッドについてのみ警告を表示させるには、「**'protected' クローンメソッドについてのみ警告する** 」オプションを使用します。\n*Effective Java* (第 2 版および第 3 版) では、`public` メソッドで `CloneNotSupportedException` の宣言を省略することが推奨されています。チェック例外をスローしないメソッドは使いやすいためです。\n\n例:\n\n\n      public class Example implements Cloneable {\n        // メソッドは 'throws CloneNotSupportedException' を宣言していません\n        protected Object clone() {\n            try {\n                return super.clone();\n            } catch (CloneNotSupportedException e) {\n                return null;\n            }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneDoesntDeclareCloneNotSupportedException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クローン関連の問題",
                      "index": 79,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownDocumentationCommentsMigration",
                "shortDescription": {
                  "text": "Javadoc コメントは Markdown ドキュメントのコメントにできます"
                },
                "fullDescription": {
                  "text": "Markdown ドキュメントコメントに変換できる Javadoc コメントを報告します。 例: '/**\n   * For blubbering of the florz.\n   *\n   * Similar to {@link com.deeps.Querp querping} class.\n   */\n  class FlorzBlubber {\n  }' クイックフィックス適用後: '/// For blubbering of the florz.\n  /// Similar to [querping][com.deeps.Querp] class.\n  class FlorzBlubber {\n  }' 2024.2 の新機能です",
                  "markdown": "Markdown ドキュメントコメントに変換できる Javadoc コメントを報告します。\n\n**例:**\n\n\n      /**\n       * For blubbering of the florz.\n       *\n       * Similar to {@link com.deeps.Querp querping} class.\n       */\n      class FlorzBlubber {\n      }\n\nクイックフィックス適用後:\n\n\n      /// For blubbering of the florz.\n      /// Similar to [querping][com.deeps.Querp] class.\n      class FlorzBlubber {\n      }\n\n2024.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MarkdownDocumentationCommentsMigration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 23",
                      "index": 105,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanExpressionMayBeConditional",
                "shortDescription": {
                  "text": "条件式に置換可能なブール式"
                },
                "fullDescription": {
                  "text": "条件式を使用するよりもコンパクトで、ほぼ間違いなく明確な方法で表現できる 'boolean' 式を報告します。 'boolean' 式を条件式に置換するには、このクイックフィックスを使用します。 例: 'a && b || !a && c;' クイックフィックス適用後: 'a ? b : c;'",
                  "markdown": "条件式を使用するよりもコンパクトで、ほぼ間違いなく明確な方法で表現できる `boolean` 式を報告します。\n\n`boolean` 式を条件式に置換するには、このクイックフィックスを使用します。\n\n**例:**\n\n\n      a && b || !a && c;\n\nクイックフィックス適用後:\n\n\n      a ? b : c;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "BooleanExpressionMayBeConditional",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldHidesSuperclassField",
                "shortDescription": {
                  "text": "サブクラスフィールドはスーパークラスフィールドを非表示にします"
                },
                "fullDescription": {
                  "text": "派生クラスのフィールドのうち、スーパークラスのフィールドと名前がまったく同じものを報告します。 Java のフィールドは派生クラスではオーバーライドできないため、このような派生クラスのフィールドがあるとスーパークラスのフィールドが不可視になります。 このような命名を行うと、基底クラスの名前がまったく同じフィールドが意図されている場合に派生クラスのフィールドを誤って使用する可能性があります。 派生クラスのフィールドの名前を変更するクイックフィックスが提案されます。 例: 'class Parent {\n  Parent parent;\n}\nclass Child extends Parent {\n  Child parent;\n}' このインスペクションでは、以下のオプションを構成できます。 アクセスできないフィールドを無視する - このインスペクションがすべての名前の競合を報告すべきか、サブクラスから見えるフィールドとの競合のみを報告すべきかを指定します。 static フィールドを不可視にする static フィールドを無視する - 基底クラスの 'static' フィールドを不可視にする 'static' フィールドを無視します。",
                  "markdown": "派生クラスのフィールドのうち、スーパークラスのフィールドと名前がまったく同じものを報告します。 Java のフィールドは派生クラスではオーバーライドできないため、このような派生クラスのフィールドがあるとスーパークラスのフィールドが不可視になります。\n\n\nこのような命名を行うと、基底クラスの名前がまったく同じフィールドが意図されている場合に派生クラスのフィールドを誤って使用する可能性があります。\n\n派生クラスのフィールドの名前を変更するクイックフィックスが提案されます。\n\n**例:**\n\n    class Parent {\n      Parent parent;\n    }\n    class Child extends Parent {\n      Child parent;\n    }\n\n\nこのインスペクションでは、以下のオプションを構成できます。\n\n1. **アクセスできないフィールドを無視する** - このインスペクションがすべての名前の競合を報告すべきか、サブクラスから見えるフィールドとの競合のみを報告すべきかを指定します。\n2. **static フィールドを不可視にする static フィールドを無視する** - 基底クラスの `static` フィールドを不可視にする `static` フィールドを無視します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldNameHidesFieldInSuperclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimpleDateFormatWithoutLocale",
                "shortDescription": {
                  "text": "ロケールなしの 'SimpleDateFormat'"
                },
                "fullDescription": {
                  "text": "'java.util.Locale' を指定しない 'java.util.SimpleDateFormat' または 'java.time.format.DateTimeFormatter' のインスタンス化を報告します。 これらの呼び出しはプラットフォームデフォルトのロケールを使用するため、OS の設定に依存します。 そのため、コードが異なるプラットフォームで実行された場合や OS の設定が変更された場合には予想外の動作をする可能性があります。 '例:' 'new SimpleDateFormat(\"yyyy\");\n  DateTimeFormatter.ofPattern(\"d/M/y\");'",
                  "markdown": "`java.util.Locale` を指定しない `java.util.SimpleDateFormat` または `java.time.format.DateTimeFormatter` のインスタンス化を報告します。 これらの呼び出しはプラットフォームデフォルトのロケールを使用するため、OS の設定に依存します。 そのため、コードが異なるプラットフォームで実行された場合や OS の設定が変更された場合には予想外の動作をする可能性があります。\n\n`例:`\n\n\n      new SimpleDateFormat(\"yyyy\");\n      DateTimeFormatter.ofPattern(\"d/M/y\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimpleDateFormatWithoutLocale",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryExplicitNumericCast",
                "shortDescription": {
                  "text": "不要な明示的数値キャスト"
                },
                "fullDescription": {
                  "text": "コンパイラーによって暗黙的に挿入されるプリミティブな数値キャストを報告します。 コンパイラーによって除去されるプリミティブな数値キャストも報告します。 例: 'int x = (short)5; // このキャストは javac ツールによって除去されます' クイックフィックス適用後: 'int x = 5;'",
                  "markdown": "コンパイラーによって暗黙的に挿入されるプリミティブな数値キャストを報告します。 コンパイラーによって除去されるプリミティブな数値キャストも報告します。\n\n**例:**\n\n    int x = (short)5; // このキャストは javac ツールによって除去されます\n\nクイックフィックス適用後:\n`int x = 5;`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryExplicitNumericCast",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値の問題/キャスト",
                      "index": 104,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnnotationClass",
                "shortDescription": {
                  "text": "アノテーションインターフェース"
                },
                "fullDescription": {
                  "text": "アノテーションインターフェースを報告します。 このようなインターフェースは、Java 1.4 以前ではサポートされていません。",
                  "markdown": "アノテーションインターフェースを報告します。 このようなインターフェースは、Java 1.4 以前ではサポートされていません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnnotationClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java の言語レベル関連の問題",
                      "index": 61,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TransientFieldNotInitialized",
                "shortDescription": {
                  "text": "デシリアライズ時に Transient フィールドが初期化されない"
                },
                "fullDescription": {
                  "text": "通常のオブジェクト構築中に初期化されているものの、所属クラスに 'readObject' メソッドがない 'transient' フィールドを報告します。 'transient' フィールドはシリアル化されていないため、逆シリアル化中に 'readObject()' メソッドで個別に初期化する必要があります。 通常のオブジェクト構築中に初期化されていない 'transient' フィールドは、デフォルトの初期化を使用すると見なされ、このインスペクションでは報告されません。 例: 'class Person implements Serializable {\n    transient String name = \"Default\"; //警告: 実際には逆シリアル化後に null になる可能性があります\n    transient String surname; //null はデフォルト値と見なされ、報告されません\n  }'",
                  "markdown": "通常のオブジェクト構築中に初期化されているものの、所属クラスに `readObject` メソッドがない `transient` フィールドを報告します。\n\n\n`transient` フィールドはシリアル化されていないため、逆シリアル化中に `readObject()` メソッドで個別に初期化する必要があります。\n\n\n通常のオブジェクト構築中に初期化されていない `transient` フィールドは、デフォルトの初期化を使用すると見なされ、このインスペクションでは報告されません。\n\n**例:**\n\n\n      class Person implements Serializable {\n        transient String name = \"Default\"; //警告: 実際には逆シリアル化後に null になる可能性があります\n        transient String surname; //null はデフォルト値と見なされ、報告されません\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TransientFieldNotInitialized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PropertyValueSetToItself",
                "shortDescription": {
                  "text": "自身に設定されているプロパティ値"
                },
                "fullDescription": {
                  "text": "同じオブジェクトの getter を値として使用している setter メソッドの呼び出しを報告します。 通常、このコードは何もしないため、意図されたものではないと思われます。 例: 'bean.setPayerId(bean.getPayerId());'",
                  "markdown": "同じオブジェクトの getter を値として使用している setter メソッドの呼び出しを報告します。 通常、このコードは何もしないため、意図されたものではないと思われます。\n\n**例:**\n\n    bean.setPayerId(bean.getPayerId());\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PropertyValueSetToItself",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 関連の問題",
                      "index": 34,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Finalize",
                "shortDescription": {
                  "text": "'finalize()' はオーバーライドできません"
                },
                "fullDescription": {
                  "text": "'Object.finalize()' メソッドのオーバーライドを報告します。 'Object.finalize()' のドキュメントからの抜粋: ファイナライズの仕組みには本質的に問題があります。 ファイナライズにより、パフォーマンスの問題、デッドロック、およびハングが発生する可能性があります。 ファイナライザーに問題があると、リソースがリークする可能性があります。ファイナライズが不要になった場合にファイナライズをキャンセルする方法はありません。また、異なるオブジェクトの 'finalize' メソッドを呼び出される場合、それらの順序は不定です。 また、ファイナライズのタイミングに関しては何も保証されていません。 'finalize' メソッドは、不特定の遅延が発生した後にのみファイナライズ可能なオブジェクトに対してのみ呼び出されることがあります。 インスペクションの構成: 'finalize()' の実装で、メソッド本体が空であるもの、または 'false' と評価され、コンパイル時定数である条件を持つ 'if' ステートメントのみを含む本体を持つものを無視するには、「自明な 'finalize()' 実装では無視する」オプションを使用します。 パフォーマンス上の理由により、非自明な 'finalize()' をサブクラスの空の実装でオーバーライドするのが得策な場合があります。 サブクラスのオーバーライドを防ぐため、空の final 'finalize()' 実装を使用することもできます。",
                  "markdown": "`Object.finalize()` メソッドのオーバーライドを報告します。\n\n`Object.finalize()` のドキュメントからの抜粋:\n>\n> ファイナライズの仕組みには本質的に問題があります。 ファイナライズにより、パフォーマンスの問題、デッドロック、およびハングが発生する可能性があります。 ファイナライザーに問題があると、リソースがリークする可能性があります。ファイナライズが不要になった場合にファイナライズをキャンセルする方法はありません。また、異なるオブジェクトの `finalize` メソッドを呼び出される場合、それらの順序は不定です。 また、ファイナライズのタイミングに関しては何も保証されていません。 `finalize` メソッドは、不特定の遅延が発生した後にのみファイナライズ可能なオブジェクトに対してのみ呼び出されることがあります。\n\nインスペクションの構成:\n\n* `finalize()` の実装で、メソッド本体が空であるもの、または `false` と評価され、コンパイル時定数である条件を持つ `if` ステートメントのみを含む本体を持つものを無視するには、「**自明な 'finalize()' 実装では無視する** 」オプションを使用します。 パフォーマンス上の理由により、非自明な `finalize()` をサブクラスの空の実装でオーバーライドするのが得策な場合があります。 サブクラスのオーバーライドを防ぐため、空の final `finalize()` 実装を使用することもできます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalizeDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ファイナライズ",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessArithmeticExpression",
                "shortDescription": {
                  "text": "無意味な算術式"
                },
                "fullDescription": {
                  "text": "無意味な算術式を報告します。 このような式には、0 の加算または減算、0 または 1 の乗算、および 1 による除算が含まれます。 このような式は自動リファクタリングによって発生している可能性があり、開発者が意図していたものではないと思われます。 クイックフィックスを使用すると、このような式が単純化されます。 例: 'void f(int a) {\n    int x = a - a;\n    int y = a + 0;\n    int res = x / x;\n  }' クイックフィックス適用後: 'void f(int a) {\n    int x = 0;\n    int y = a;\n    int res = 1;\n  }' ただし、すべての可能な入力について提案される置換が元のコードと完全に同等になるとは限りません。ご注意ください。 たとえば、このインスペクションは 'x / x' を '1' に置換することを提案します。 しかし、'x' が０の場合、元のコードは 'ArithmeticException' をスローするか、結果が 'NaN' になります。 また、'x' が 'NaN' の場合は結果も 'NaN' になります。 そのような動作が意図されている可能性はほとんどありません。",
                  "markdown": "無意味な算術式を報告します。 このような式には、0 の加算または減算、0 または 1 の乗算、および 1 による除算が含まれます。\n\nこのような式は自動リファクタリングによって発生している可能性があり、開発者が意図していたものではないと思われます。\n\nクイックフィックスを使用すると、このような式が単純化されます。\n\n**例:**\n\n\n      void f(int a) {\n        int x = a - a;\n        int y = a + 0;\n        int res = x / x;\n      }\n\nクイックフィックス適用後:\n\n\n      void f(int a) {\n        int x = 0;\n        int y = a;\n        int res = 1;\n      }\n\n\nただし、すべての可能な入力について提案される置換が元のコードと完全に同等になるとは限りません。ご注意ください。 たとえば、このインスペクションは `x / x` を `1` に置換することを提案します。\nしかし、`x` が０の場合、元のコードは `ArithmeticException` をスローするか、結果が `NaN` になります。\nまた、`x` が `NaN` の場合は結果も `NaN` になります。 そのような動作が意図されている可能性はほとんどありません。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessArithmeticExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyLargePrimitiveArrayInitializer",
                "shortDescription": {
                  "text": "過度に大きなプリミティブ型配列イニシャライザー"
                },
                "fullDescription": {
                  "text": "含んでいる要素数が多すぎるプリミティブ配列の配列イニシャライザー式を報告します。 このようなイニシャライザーにより、クラスファイルが過度に大きくなる可能性があります。各配列要素を初期化するコードを生成する必要があるためです。 メモリの使用や帯域幅に制限のある環境では、リソースファイルからプリミティブの大規模配列をロードするほうが効率的な可能性があります。 このインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。 このインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。 プリミティブの配列イニシャライザーで許容される要素の最大数を指定するには、オプションを使用します。",
                  "markdown": "含んでいる要素数が多すぎるプリミティブ配列の配列イニシャライザー式を報告します。 このようなイニシャライザーにより、クラスファイルが過度に大きくなる可能性があります。各配列要素を初期化するコードを生成する必要があるためです。 メモリの使用や帯域幅に制限のある環境では、リソースファイルからプリミティブの大規模配列をロードするほうが効率的な可能性があります。\n\n\nこのインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。\nこのインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。\n\n\nプリミティブの配列イニシャライザーで許容される要素の最大数を指定するには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyLargePrimitiveArrayInitializer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス/組み込み",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassInitializer",
                "shortDescription": {
                  "text": "非 'static' イニシャライザー"
                },
                "fullDescription": {
                  "text": "クラス内にある非 'static' のイニシャライザーを報告します。 一部のコーディング標準はインスタンスのイニシャライザーを禁止しており、初期化にはコンストラクターかフィールドイニシャライザーを使用することを推奨しています。 また、 'static' キーワードを削除すると、非 'static' のイニシャライザーが予期せず作成されて不可解なバグが発生する可能性があります。 このインスペクションは匿名クラスに含まれるインスタンスイニシャライザーを報告しません。 コンストラクターがないクラスに含まれるインスタンスイニシャライザーを無視するには、「 クラスに 1 つ以上のコンストラクターがある場合にのみ警告する」オプションを使用します。",
                  "markdown": "クラス内にある非 `static` のイニシャライザーを報告します。\n\n一部のコーディング標準はインスタンスのイニシャライザーを禁止しており、初期化にはコンストラクターかフィールドイニシャライザーを使用することを推奨しています。\nまた、 `static` キーワードを削除すると、非 `static` のイニシャライザーが予期せず作成されて不可解なバグが発生する可能性があります。\n\nこのインスペクションは匿名クラスに含まれるインスタンスイニシャライザーを報告しません。\n\n\nコンストラクターがないクラスに含まれるインスタンスイニシャライザーを無視するには、「 **クラスに 1 つ以上のコンストラクターがある場合にのみ警告する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonStaticInitializer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectNotify",
                "shortDescription": {
                  "text": "'notifyAll()' の代わりに 'notify()' が呼ばれています"
                },
                "fullDescription": {
                  "text": "'Object.notify()' の呼び出しを報告します。 'Object.notify()' を呼び出すとデッドロックが発生する可能性があるため、ほとんどの場合は 'Object.notifyAll()' を使用するほうが適切です。 Doug Lea's の「Concurrent Programming in Java」の解説を参照してください。",
                  "markdown": "`Object.notify()` の呼び出しを報告します。 `Object.notify()` を呼び出すとデッドロックが発生する可能性があるため、ほとんどの場合は `Object.notifyAll()` を使用するほうが適切です。 Doug Lea's の「*Concurrent Programming in Java*」の解説を参照してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToNotifyInsteadOfNotifyAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ContinueOrBreakFromFinallyBlock",
                "shortDescription": {
                  "text": "'finally' ブロック内の 'continue' または 'break'"
                },
                "fullDescription": {
                  "text": "'finally' ブロック内の 'break' または 'continue' ステートメントを報告します。 このようなステートメントは意図的な場合もありますが、大きな混乱を招く可能性があり、例外のスローをマスクしてデバッグを困難にする可能性があります。 例: 'while (true) {\n        try {\n          throwingMethod();\n        } finally {\n            continue;\n        }\n    }'",
                  "markdown": "`finally` ブロック内の `break` または `continue` ステートメントを報告します。\n\nこのようなステートメントは意図的な場合もありますが、大きな混乱を招く可能性があり、例外のスローをマスクしてデバッグを困難にする可能性があります。\n\n**例:**\n\n\n        while (true) {\n            try {\n              throwingMethod();\n            } finally {\n                continue;\n            }\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ContinueOrBreakFromFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LengthOneStringsInConcatenation",
                "shortDescription": {
                  "text": "単一文字列の連結"
                },
                "fullDescription": {
                  "text": "1 文字からなる文字列リテラルの連結を報告します。 このようなリテラルを同等の文字リテラルに置換し、パフォーマンスを若干向上させることができます。 例: 'String hello = hell + \"o\";' クイックフィックス適用後: 'String hello = hell + 'o';'",
                  "markdown": "1 文字からなる文字列リテラルの連結を報告します。\n\nこのようなリテラルを同等の文字リテラルに置換し、パフォーマンスを若干向上させることができます。\n\n**例:**\n\n\n      String hello = hell + \"o\";\n\nクイックフィックス適用後:\n\n\n      String hello = hell + 'o';\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SingleCharacterStringConcatenation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithTooManyTransitiveDependencies",
                "shortDescription": {
                  "text": "推移的な依存関係が多すぎるクラス"
                },
                "fullDescription": {
                  "text": "他のクラスへの直接的または間接的な依存が多すぎるクラスを報告します。 このようなクラスの依存関係の依存関係に修正を加えるとクラスを変更する必要性が生じるため、不安定になる可能性があります。 トップレベルのクラスのみが報告されます。 クラスで許容される直接的または間接的な依存関係数の最大値を指定するには、「推移的な依存関係の最大数」フィールドを使用します。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "他のクラスへの直接的または間接的な依存が多すぎるクラスを報告します。\n\nこのようなクラスの依存関係の依存関係に修正を加えるとクラスを変更する必要性が生じるため、不安定になる可能性があります。\n\nトップレベルのクラスのみが報告されます。\n\nクラスで許容される直接的または間接的な依存関係数の最大値を指定するには、「**推移的な依存関係の最大数**」フィールドを使用します。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyTransitiveDependencies",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依存関係の問題",
                      "index": 86,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryThis",
                "shortDescription": {
                  "text": "不要な 'this' 修飾子"
                },
                "fullDescription": {
                  "text": "不要な 'this' 修飾子を報告します。 コードの参照を明確にするための 'this' の使用は多くのコードスタイルで非推奨とされており、自動リファクタリングを使用すれば簡単に不要にすることができます。 例: 'class Foo {\n    int x;\n    void foo() {\n      this.x = 2;\n    }\n  }' クイックフィックス適用後: 'class Foo {\n    int x;\n    void foo() {\n      x = 2;\n    }\n  }' フィールドへの代入を無視するには、インスペクションの設定を使用します。 たとえば、'this.x = 2;' は報告されませんが、'int y = this.x;' は報告されます。",
                  "markdown": "不要な `this` 修飾子を報告します。\n\n\nコードの参照を明確にするための `this` の使用は多くのコードスタイルで非推奨とされており、自動リファクタリングを使用すれば簡単に不要にすることができます。\n\n**例:**\n\n\n      class Foo {\n        int x;\n        void foo() {\n          this.x = 2;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        int x;\n        void foo() {\n          x = 2;\n        }\n      }\n\n\nフィールドへの代入を無視するには、インスペクションの設定を使用します。\nたとえば、`this.x = 2;` は報告されませんが、`int y = this.x;` は報告されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceVariableUninitializedUse",
                "shortDescription": {
                  "text": "初期化の前に使用されるインスタンスフィールド"
                },
                "fullDescription": {
                  "text": "初期化する前に読み込まれているインスタンス変数を報告します。 このインスペクションは 'null' による等価チェックを無視します。 例: 'class Foo {\n    int bar;\n\n    Foo() {\n      System.out.println(bar);\n    }\n  }' このインスペクションは非常に保守的なデータフローアルゴリズムを使用しており、インスタンス変数が初期化されていないものとして誤って報告される場合があります。 初期化されているものとして報告される変数は、常に初期化されます。 特別なアノテーションを指定するには、「次のアノテーションが付いている場合は無視」オプションを使用します。 このインスペクションは、そのようなアノテーションが付いているフィールドを無視します。 初期化されていないプリミティブフィールドを無視するには、「プリミティブフィールドを無視」オプションを使用します。",
                  "markdown": "初期化する前に読み込まれているインスタンス変数を報告します。\n\nこのインスペクションは `null` による等価チェックを無視します。\n\n**例:**\n\n\n      class Foo {\n        int bar;\n\n        Foo() {\n          System.out.println(bar);\n        }\n      }\n\nこのインスペクションは非常に保守的なデータフローアルゴリズムを使用しており、インスタンス変数が初期化されていないものとして誤って報告される場合があります。 初期化されているものとして報告される変数は、常に初期化されます。\n\n特別なアノテーションを指定するには、「**次のアノテーションが付いている場合は無視**」オプションを使用します。 このインスペクションは、そのようなアノテーションが付いているフィールドを無視します。\n\n初期化されていないプリミティブフィールドを無視するには、「**プリミティブフィールドを無視**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceVariableUsedBeforeInitialized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初期化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoopWithImplicitTerminationCondition",
                "shortDescription": {
                  "text": "暗黙の終了条件を持つループ"
                },
                "fullDescription": {
                  "text": "'true' 定数のみを条件に持つ 'while'、'do-while'、'for' ループを報告します。 また、このようなループはループの中断を引き起こす可能性のある 'if' ステートメントを含んでいることが原因で終了する可能性があります。 このような 'if' ステートメントは 'while' または 'for' ループ内では最初または唯一のステートメント、'do-while' ループ内では最後または唯一のステートメントにする必要があります。 このような 'if' ステートメントを除去し、その条件を明示的なループ条件に変えると、ループが単純になります。",
                  "markdown": "`true` 定数のみを条件に持つ `while`、`do-while`、`for` ループを報告します。 また、このようなループはループの中断を引き起こす可能性のある `if` ステートメントを含んでいることが原因で終了する可能性があります。\n\nこのような `if` ステートメントは `while` または `for` ループ内では最初または唯一のステートメント、`do-while` ループ内では最後または唯一のステートメントにする必要があります。\n\nこのような `if` ステートメントを除去し、その条件を明示的なループ条件に変えると、ループが単純になります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoopWithImplicitTerminationCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExplicitArrayFilling",
                "shortDescription": {
                  "text": "明示的な配列の埋め込み"
                },
                "fullDescription": {
                  "text": "'Arrays.setAll()' または 'Arrays.fill()' の呼び出しに置換できるループを報告します。 このインスペクションは、プロジェクトまたはモジュールの言語レベルが 8 以上の場合に、ループを 'Arrays.setAll()' に置換することを提案します。 ループは言語レベルを問わず、'Arrays.fill()' に置換できます。 例: 'for (int i=0; i<array.length; i++) {\n     array[i] = calc(i);\n  }' クイックフィックス適用後: 'Arrays.setAll(array, this::calc);' 2017.1 の新機能です",
                  "markdown": "`Arrays.setAll()` または `Arrays.fill()` の呼び出しに置換できるループを報告します。\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 8 以上の場合に、ループを `Arrays.setAll()` に置換することを提案します。\nループは言語レベルを問わず、`Arrays.fill()` に置換できます。\n\n例:\n\n\n      for (int i=0; i<array.length; i++) {\n         array[i] = calc(i);\n      }\n\nクイックフィックス適用後:\n\n\n      Arrays.setAll(array, this::calc);\n\n2017.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExplicitArrayFilling",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BadExceptionDeclared",
                "shortDescription": {
                  "text": "禁止対象例外の宣言"
                },
                "fullDescription": {
                  "text": "'throws' 節で不適切な例外を宣言しているメソッドを報告します。 たとえば、 'java.lang.Exception' や 'java.lang.Throwable' などの一般的すぎる例外は不適切な可能性があります。 例: 'void describeModule(String module) throws Exception {} // 警告: 禁止対象例外 'Exception' が宣言されています' インスペクションの構成: 報告対象の例外を指定するには、禁止対象例外 リストを使用します。 ライブラリメソッドをオーバーライドするメソッドで宣言された例外を無視するには、「ライブラリメソッドをオーバーライドするメソッドで宣言された例外を無視する」オプションを使用します。",
                  "markdown": "`throws` 節で不適切な例外を宣言しているメソッドを報告します。 たとえば、 `java.lang.Exception` や `java.lang.Throwable` などの一般的すぎる例外は不適切な可能性があります。\n\n**例:**\n\n\n      void describeModule(String module) throws Exception {} // 警告: 禁止対象例外 'Exception' が宣言されています\n\nインスペクションの構成:\n\n* 報告対象の例外を指定するには、**禁止対象例外** リストを使用します。\n* ライブラリメソッドをオーバーライドするメソッドで宣言された例外を無視するには、「**ライブラリメソッドをオーバーライドするメソッドで宣言された例外を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProhibitedExceptionDeclared",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IntegerMultiplicationImplicitCastToLong",
                "shortDescription": {
                  "text": "整数乗算またはシフトの暗黙的な 'long' へのキャスト"
                },
                "fullDescription": {
                  "text": "暗黙的に long 型にキャストされている整数の乗算と左シフトを報告します。 例: 'void f(int i) {\n    long val = 65536 * i;\n  }' クイックフィックスが適用されると、コードは次のように変更されます。 'void x(int i) {\n    long val = 65536L * i;\n  }' 例: 'void f(int i) {\n    long value = i << 24;\n  }' クイックフィックスが適用されると、コードは次のように変更されます。 'void f(int i) {\n    long value = (long) i << 24;\n  }' オーバーフローの切り捨てが予期せず発生する場合があるため、このような乗数は多くの場合は間違いです。 この問題は、 'int' リテラルを 'long' リテラル ('65536L') に変換すると解決できます。",
                  "markdown": "暗黙的に long 型にキャストされている整数の乗算と左シフトを報告します。\n\n**例:**\n\n\n      void f(int i) {\n        long val = 65536 * i;\n      }\n\nクイックフィックスが適用されると、コードは次のように変更されます。\n\n\n      void x(int i) {\n        long val = 65536L * i;\n      }\n\n**例:**\n\n\n      void f(int i) {\n        long value = i << 24;\n      }\n\nクイックフィックスが適用されると、コードは次のように変更されます。\n\n\n      void f(int i) {\n        long value = (long) i << 24;\n      }\n\n\nオーバーフローの切り捨てが予期せず発生する場合があるため、このような乗数は多くの場合は間違いです。\nこの問題は、 `int` リテラルを `long` リテラル (`65536`**L**) に変換すると解決できます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IntegerMultiplicationImplicitCastToLong",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値の問題/キャスト",
                      "index": 104,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExpressionMayBeFactorized",
                "shortDescription": {
                  "text": "因数分解できる式"
                },
                "fullDescription": {
                  "text": "因数分解可能な式、つまり再編成して共通因数をくくり出すことができる式を報告します。 これにより重複を減らし、コードの可読性を向上させることができます。 例: 'a && b || a && c' クイックフィックス適用後: 'a && (b || c)' 2021.3 の新機能です",
                  "markdown": "因数分解可能な式、つまり再編成して共通因数をくくり出すことができる式を報告します。 これにより重複を減らし、コードの可読性を向上させることができます。\n\n**例:**\n\n\n      a && b || a && c\n\nクイックフィックス適用後:\n\n\n      a && (b || c)\n\n2021.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ExpressionMayBeFactorized",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceAssignmentWithOperatorAssignment",
                "shortDescription": {
                  "text": "演算子代入に置換可能な代入"
                },
                "fullDescription": {
                  "text": "代入演算子に置換できる代入演算を報告します。 代入演算子を使用したコードは、より簡潔で明瞭になります。 例: 'x = x + 3;\n  x = x / 3;' クイックフィックス適用後: 'x += 3;\n  x /= 3;' '&&' と '||' を無視するには、「条件演算子を無視する」オプションを使用します。 条件演算子を代入演算子に置換すると、計算方法が遅延評価から先行評価に変わります。その結果、式のセマンティクスが変更される可能性があります。 知名度の低い '^' と '%' を無視するには、「あいまいな演算子を無視する」オプションを使用します。",
                  "markdown": "代入演算子に置換できる代入演算を報告します。\n\n代入演算子を使用したコードは、より簡潔で明瞭になります。\n\n**例:**\n\n      x = x + 3;\n      x = x / 3;\n\nクイックフィックス適用後:\n\n      x += 3;\n      x /= 3;\n\n\n`&&` と `||` を無視するには、「**条件演算子を無視する**」オプションを使用します。 条件演算子を代入演算子に置換すると、計算方法が遅延評価から先行評価に変わります。その結果、式のセマンティクスが変更される可能性があります。\n\n\n知名度の低い `^` と `%` を無視するには、「**あいまいな演算子を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AssignmentReplaceableWithOperatorAssignment",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代入関連の問題",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ListRemoveInLoop",
                "shortDescription": {
                  "text": "ループ内の 'List.remove()' 呼び出し"
                },
                "fullDescription": {
                  "text": "ループ内で呼び出されている 'List.remove(index)' で、'List.subList().clear()' に置換できるものを報告します。 多くの要素を削除する場合、ほとんどの 'List' の実装ではこの置換を行うほうが効率的です。 例: 'void removeRange(List<String> list, int from, int to) {\n    for (int i = from; i < to; i++) {\n        list.remove(from);\n    }\n  }' クイックフィックス適用後: 'void removeRange(List<String> list, int from, int to) {\n    if (to > from) {\n      list.subList(from, to).clear();\n    }\n  }' このクイックフィックスは範囲チェックを自動的に追加し、最小値が最大値よりも大きい場合に 'IndexOutOfBoundsException' が発生するのを阻止します。 そのような状況がコードで発生し得ない場合は、範囲チェックを除去できます。 2018.2 の新機能です",
                  "markdown": "ループ内で呼び出されている `List.remove(index)` で、`List.subList().clear()` に置換できるものを報告します。\n\n多くの要素を削除する場合、ほとんどの `List` の実装ではこの置換を行うほうが効率的です。\n\n例:\n\n\n      void removeRange(List<String> list, int from, int to) {\n        for (int i = from; i < to; i++) {\n            list.remove(from);\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      void removeRange(List<String> list, int from, int to) {\n        if (to > from) {\n          list.subList(from, to).clear();\n        }\n      }\n\n\nこのクイックフィックスは範囲チェックを自動的に追加し、最小値が最大値よりも大きい場合に `IndexOutOfBoundsException` が発生するのを阻止します。 そのような状況がコードで発生し得ない場合は、範囲チェックを除去できます。\n\n2018.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ListRemoveInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnFromFinallyBlock",
                "shortDescription": {
                  "text": "'finally' ブロック内の 'return'"
                },
                "fullDescription": {
                  "text": "'finally' ブロック内の 'return' ステートメントを報告します。 このような 'return' ステートメントは意図的な場合もありますが、例外のスローをマスクし、デバッグを困難にする可能性があります。 例: 'try {\n    foo();\n  } finally {\n    if (bar()) return;\n  }'",
                  "markdown": "`finally` ブロック内の `return` ステートメントを報告します。\n\nこのような `return` ステートメントは意図的な場合もありますが、例外のスローをマスクし、デバッグを困難にする可能性があります。\n\n**例:**\n\n\n      try {\n        foo();\n      } finally {\n        if (bar()) return;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReturnInsideFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingOverrideAnnotation",
                "shortDescription": {
                  "text": "'@Override' アノテーションの欠落"
                },
                "fullDescription": {
                  "text": "スーパークラスメソッドをオーバーライドしているものの、'@java.lang.Override' アノテーションのないメソッドを報告します。 メソッドに '@java.lang.Override' アノテーションを付けると、コードの可読性が向上します。アノテーションはメソッドの意図を現しているためです。 また、オーバーライド対象メソッドのシグネチャーがスーパークラスのメソッドと一致していない場合、コンパイラーがエラーを返します。 例: 'class X {\n      public String toString() {\n        return \"hello world\";\n      }\n    }' クイックフィックス適用後: 'class X {\n      @Override\n      public String toString() {\n        return \"hello world\";\n      }\n    }' インスペクションの構成: 'java.lang.Object' メソッド ('equals()'、'hashCode()'、'toString()') を無視するには、「'equals()'、'hashCode()'、'toString()' メソッドを無視」オプションを使用します。 '@Override' アノテーションが原因でこれらのメソッドが消滅し、コードがコンパイルできなくなるリスクは比較的小さいと思われます。 匿名クラスのメソッドを無視するには、「匿名クラスのメソッドを無視する」オプションを使用します。 '＠Override' アノテーションがないメソッドのみを警告し、1 つ以上の子孫に '@Override' アノテーションがないオーバーライドされたメソッドを警告しない場合は、「オーバーライドメソッドのすべてに '@Override' アノテーションがない場合にメソッドをハイライト」オプションを無効にします。 このインスペクションは Java 5 以降で使用できる Java の機能 'アノテーション' に依存しています。",
                  "markdown": "スーパークラスメソッドをオーバーライドしているものの、`@java.lang.Override` アノテーションのないメソッドを報告します。\n\n\nメソッドに `@java.lang.Override` アノテーションを付けると、コードの可読性が向上します。アノテーションはメソッドの意図を現しているためです。\nまた、オーバーライド対象メソッドのシグネチャーがスーパークラスのメソッドと一致していない場合、コンパイラーがエラーを返します。\n\n**例:**\n\n\n        class X {\n          public String toString() {\n            return \"hello world\";\n          }\n        }\n      \nクイックフィックス適用後:\n\n\n        class X {\n          @Override\n          public String toString() {\n            return \"hello world\";\n          }\n        }\n      \nインスペクションの構成:\n\n* `java.lang.Object` メソッド (`equals()`、`hashCode()`、`toString()`) を無視するには、「**'equals()'、'hashCode()'、'toString()' メソッドを無視** 」オプションを使用します。 `@Override` アノテーションが原因でこれらのメソッドが消滅し、コードがコンパイルできなくなるリスクは比較的小さいと思われます。\n* 匿名クラスのメソッドを無視するには、「**匿名クラスのメソッドを無視する**」オプションを使用します。\n* `＠Override` アノテーションがないメソッドのみを警告し、1 つ以上の子孫に `@Override` アノテーションがないオーバーライドされたメソッドを警告しない場合は、「**オーバーライドメソッドのすべてに '@Override' アノテーションがない場合にメソッドをハイライト**」オプションを無効にします。\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 'アノテーション' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "override",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantExplicitClose",
                "shortDescription": {
                  "text": "冗長な 'close()'"
                },
                "fullDescription": {
                  "text": "try-with-resources ブロックの末尾にある不要な 'close()' の呼び出しを報告し、その除去を提案します。 例: 'try(MyAutoCloseable ac = new MyAutoCloseable()) {\n    foo();\n    ac.close();\n  }' クイックフィックス適用後: 'try(MyAutoCloseable ac = new MyAutoCloseable()) {\n    foo();\n  }' 2018.1 の新機能です",
                  "markdown": "try-with-resources ブロックの末尾にある不要な `close()` の呼び出しを報告し、その除去を提案します。\n\n**例**:\n\n\n      try(MyAutoCloseable ac = new MyAutoCloseable()) {\n        foo();\n        ac.close();\n      }\n\nクイックフィックス適用後:\n\n\n      try(MyAutoCloseable ac = new MyAutoCloseable()) {\n        foo();\n      }\n\n2018.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantExplicitClose",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertStatement",
                "shortDescription": {
                  "text": "'assert' ステートメント"
                },
                "fullDescription": {
                  "text": "'assert' ステートメントを報告します。 デフォルトでは、'assert' ステートメントはプロダクション環境での実行中には無効になります。 代わりに、ロガーまたは例外の使用を検討してください。 'assert' ステートメントは、Java 1.3 以前の JVM ではサポートされていません。 このインスペクションは Java 1.4 以降で使用できる Java の機能 'アサーション' に依存しています。",
                  "markdown": "`assert` ステートメントを報告します。 デフォルトでは、`assert` ステートメントはプロダクション環境での実行中には無効になります。 代わりに、ロガーまたは例外の使用を検討してください。\n\n`assert` ステートメントは、Java 1.3 以前の JVM ではサポートされていません。\n\n\nこのインスペクションは Java 1.4 以降で使用できる Java の機能 'アサーション' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java の言語レベル関連の問題",
                      "index": 61,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CharUsedInArithmeticContext",
                "shortDescription": {
                  "text": "算術コンテキストでの 'char' 式の使用"
                },
                "fullDescription": {
                  "text": "加算式または減算式で使用されている 'char' 型の式を報告します。 このようなコードは必ずしも問題ではありませんが、(たとえば文字列が必要な場合に) バグの原因になる可能性があります。 例: 'int a = 'a' + 42;' クイックフィックス適用後: 'int a = (int) 'a' + 42;' 'String' コンテキストの場合: 'int i1 = 1;\nint i2 = 2;\nSystem.out.println(i2 + '-' + i1 + \" = \" + (i2 - i1));' クイックフィックス適用後: 'System.out.println(i2 + \"-\" + i1 + \" = \" + (i2 - i1));'",
                  "markdown": "加算式または減算式で使用されている `char` 型の式を報告します。\n\nこのようなコードは必ずしも問題ではありませんが、(たとえば文字列が必要な場合に) バグの原因になる可能性があります。\n\n**例:** `int a = 'a' + 42;`\n\nクイックフィックス適用後: `int a = (int) 'a' + 42;`\n\n`String` コンテキストの場合:\n\n    int i1 = 1;\n    int i2 = 2;\n    System.out.println(i2 + '-' + i1 + \" = \" + (i2 - i1));\n\nクイックフィックス適用後:\n`System.out.println(i2 + \"-\" + i1 + \" = \" + (i2 - i1));`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CharUsedInArithmeticContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringEqualsCharSequence",
                "shortDescription": {
                  "text": "'CharSequence' 引数で 'String.equals()' を呼び出し"
                },
                "fullDescription": {
                  "text": "'CharSequence' を引数に含む 'String.equals()' の呼び出しを報告します。 'String.equals()' は 'String' の引数に対してのみ 'true' を返すことができます。 'String' の内容を非 'String' の 'CharSequence' 引数と比較するには、'contentEquals()' メソッドを使用してください。 例: 'boolean equals(String s, CharSequence ch) {\n    return s.equals(ch);\n  }' クイックフィックス適用後: 'boolean equals(String s, CharSequence ch) {\n    return s.contentEquals(ch);\n  }' 2017.3 の新機能です",
                  "markdown": "`CharSequence` を引数に含む `String.equals()` の呼び出しを報告します。\n\n\n`String.equals()` は `String` の引数に対してのみ `true` を返すことができます。\n`String` の内容を非 `String` の `CharSequence` 引数と比較するには、`contentEquals()` メソッドを使用してください。\n\n**例:**\n\n\n      boolean equals(String s, CharSequence ch) {\n        return s.equals(ch);\n      }\n\nクイックフィックス適用後:\n\n\n      boolean equals(String s, CharSequence ch) {\n        return s.contentEquals(ch);\n      }\n\n\n2017.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringEqualsCharSequence",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarySemicolon",
                "shortDescription": {
                  "text": "不要なセミコロン"
                },
                "fullDescription": {
                  "text": "クラスメンバーの間やブロックステートメントの中、クラス定義の後などに使用されているセミコロンをはじめとする不要なセミコロンを報告します。 このようなセミコロンは Java では有効ですが、冗長なため、除去できます。 例: 'class C {\n    ;\n    void m() throws Exception {\n        try (AutoCloseable r1 = createAutoCloseable();) {\n          ;\n        }\n    }\n    ;\n  }' クイックフィックス適用後: 'class C {\n    void m() throws Exception {\n      try (AutoCloseable r1 = createAutoCloseable()) {\n      }\n    }\n  }'",
                  "markdown": "クラスメンバーの間やブロックステートメントの中、クラス定義の後などに使用されているセミコロンをはじめとする不要なセミコロンを報告します。\n\nこのようなセミコロンは Java では有効ですが、冗長なため、除去できます。\n\n例:\n\n\n      class C {\n        ;\n        void m() throws Exception {\n            try (AutoCloseable r1 = createAutoCloseable();) {\n              ;\n            }\n        }\n        ;\n      }\n\nクイックフィックス適用後:\n\n\n      class C {\n        void m() throws Exception {\n          try (AutoCloseable r1 = createAutoCloseable()) {\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessarySemicolon",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestFailedLine",
                "shortDescription": {
                  "text": "テストで失敗した行"
                },
                "fullDescription": {
                  "text": "テストで失敗したメソッド呼び出しまたはアサーションを報告します。 コードの失敗した行をすばやく検出し、すぐにデバッグを開始するのに役立ちます。 例: '@Test\n  fun foo() {\n    assertEquals(1, 0) // ハイライトされます\n  }'",
                  "markdown": "テストで失敗したメソッド呼び出しまたはアサーションを報告します。 コードの失敗した行をすばやく検出し、すぐにデバッグを開始するのに役立ちます。\n\n**例:**\n\n\n      @Test\n      fun foo() {\n        assertEquals(1, 0) // ハイライトされます\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TestFailedLine",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語/テストフレームワーク",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicStaticCollectionField",
                "shortDescription": {
                  "text": "'public static' コレクションフィールド"
                },
                "fullDescription": {
                  "text": "変更可能な 'public' 'static' コレクションフィールドを報告します。 このようなフィールドは定数値のコレクションを保管するためによく使用されますが、'final' 宣言されている場合でも中身が変更される可能性があるため、やはりセキュリティ上の危険があります。 例: 'public static final List<String> EVENTS = new ArrayList<>();'\n 変更不可能なコレクションを返すメソッドを指定するには、オプション セクション内のテーブルを使用します。 指定したメソッドで初期化される 'public' 'static' コレクションフィールドが報告されなくなります。",
                  "markdown": "変更可能な `public` `static` コレクションフィールドを報告します。\n\nこのようなフィールドは定数値のコレクションを保管するためによく使用されますが、`final` 宣言されている場合でも中身が変更される可能性があるため、やはりセキュリティ上の危険があります。\n\n**例:**\n\n\n      public static final List<String> EVENTS = new ArrayList<>();\n      \n\n変更不可能なコレクションを返すメソッドを指定するには、**オプション** セクション内のテーブルを使用します。\n指定したメソッドで初期化される `public` `static` コレクションフィールドが報告されなくなります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicStaticCollectionField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsConcreteCollection",
                "shortDescription": {
                  "text": "明示的に 'Collection' クラスを拡張するクラス"
                },
                "fullDescription": {
                  "text": "'java.util.Collection' または 'java.util.Map' クラスの具象サブクラスを拡張しているクラスを報告します。 具象コレクション型のサブクラス化は一般的ではあるものの、お粗末な手法です。 コレクションの呼び出しを委譲するよりもかなり脆弱です。",
                  "markdown": "`java.util.Collection` または `java.util.Map` クラスの具象サブクラスを拡張しているクラスを報告します。\n\n\n具象コレクション型のサブクラス化は一般的ではあるものの、お粗末な手法です。 コレクションの呼び出しを委譲するよりもかなり脆弱です。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassExtendsConcreteCollection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocBlankLines",
                "shortDescription": {
                  "text": "改行するには、空白行を <p> に置換する必要があります"
                },
                "fullDescription": {
                  "text": "Javadoc コメントにある空行を報告します。 Javadoc に空行がある場合、テキストを別々の段落に分割する意図がある可能性があります。 しかし、Javadoc ツールと IntelliJ IDEA はドキュメントのコメントを表示する際に空行を無視します。 クイックフィックスは、空行を段落タグ (<p>) に置換することを提案します。 例: 'class Main {\n    /**\n     * 何もしません。\n     *\n     * まったく何もしません\n     */\n    void foo() {}\n  }' クイックフィックス適用後: 'class Main {\n    /**\n     * 何もしません。\n     * <p>\n     * まったく何もしません\n     */\n    void foo() {}\n  }' 2022.1 の新機能です",
                  "markdown": "Javadoc コメントにある空行を報告します。\n\n\nJavadoc に空行がある場合、テキストを別々の段落に分割する意図がある可能性があります。 しかし、Javadoc ツールと IntelliJ IDEA はドキュメントのコメントを表示する際に空行を無視します。\n\n\nクイックフィックスは、空行を段落タグ (\\<p\\>) に置換することを提案します。\n\n**例:**\n\n\n      class Main {\n        /**\n         * 何もしません。\n         *\n         * まったく何もしません\n         */\n        void foo() {}\n      }\n\nクイックフィックス適用後:\n\n\n      class Main {\n        /**\n         * 何もしません。\n         * <p>\n         * まったく何もしません\n         */\n        void foo() {}\n      }\n\n2022.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavadocBlankLines",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectInstantiationInEqualsHashCode",
                "shortDescription": {
                  "text": "'equals()' または 'hashCode()' 内部でのオブジェクトのインスタンス化"
                },
                "fullDescription": {
                  "text": "'equals()'、'hashCode()'、'compareTo()'、'Comparator.compare()' メソッド内の (一時的な) 新しいオブジェクトの構築を報告します。 新しいオブジェクトはコンストラクター呼び出しのほか、'foreach' ステートメント内でオートボクシングまたはイテレーターの作成を行った場合も作成される可能性があります。 これにより、パフォーマンスの問題が生じる可能性があります。たとえば、'Set' メソッドや 'Map' にオブジェクトを追加した場合、これらのメソッドが頻繁に呼び出されることになります。 このインスペクションは、オブジェクトが 'throw' または 'assert' ステートメントで作成されている場合は報告しません。 例: 'class Person {\n    private String name;\n    private int age;\n\n    public boolean equals(Object o) {\n      return Arrays.equals(new Object[] {name, age}, new Object[] {((Foo)o).name, ((Foo)o).age});\n    }\n\n    public int hashCode() {\n      return (name + age).hashCode();\n    }\n  }' この例では 2 つの追加配列が 'equals()' 内で作成され、'age' フィールドの使用箇所がボクシングを要求しており、'name + age' が暗黙的に新しい文字列を作成しています。",
                  "markdown": "`equals()`、`hashCode()`、`compareTo()`、`Comparator.compare()` メソッド内の (一時的な) 新しいオブジェクトの構築を報告します。\n\n\n新しいオブジェクトはコンストラクター呼び出しのほか、`foreach` ステートメント内でオートボクシングまたはイテレーターの作成を行った場合も作成される可能性があります。\nこれにより、パフォーマンスの問題が生じる可能性があります。たとえば、`Set` メソッドや `Map` にオブジェクトを追加した場合、これらのメソッドが頻繁に呼び出されることになります。\n\n\nこのインスペクションは、オブジェクトが `throw` または `assert` ステートメントで作成されている場合は報告しません。\n\n**例:**\n\n\n      class Person {\n        private String name;\n        private int age;\n\n        public boolean equals(Object o) {\n          return Arrays.equals(new Object[] {name, age}, new Object[] {((Foo)o).name, ((Foo)o).age});\n        }\n\n        public int hashCode() {\n          return (name + age).hashCode();\n        }\n      }\n\n\nこの例では 2 つの追加配列が `equals()` 内で作成され、`age` フィールドの使用箇所がボクシングを要求しており、`name + age` が暗黙的に新しい文字列を作成しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ObjectInstantiationInEqualsHashCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UtilityClassWithPublicConstructor",
                "shortDescription": {
                  "text": "public クラスのコンストラクターを持つユーティリティクラス"
                },
                "fullDescription": {
                  "text": "'public' コンストラクターを持つユーティリティクラスを報告します。 ユーティリティクラスでは、すべてのフィールドとメソッドが 'static' で宣言されています。 このようなクラスで 'public' コンストラクターを作成すると誤解を招き、クラスが誤ってインスタンス化される可能性があります。 例: 'public final class UtilityClass {\n    public UtilityClass(){\n    }\n    public static void foo() {}\n  }' クイックフィックス適用後: 'public final class UtilityClass {\n    private UtilityClass(){\n    }\n    public static void foo() {}\n  }'",
                  "markdown": "`public` コンストラクターを持つユーティリティクラスを報告します。\n\nユーティリティクラスでは、すべてのフィールドとメソッドが `static` で宣言されています。 このようなクラスで `public` コンストラクターを作成すると誤解を招き、クラスが誤ってインスタンス化される可能性があります。\n\n**例:**\n\n\n      public final class UtilityClass {\n        public UtilityClass(){\n        }\n        public static void foo() {}\n      }\n\nクイックフィックス適用後:\n\n\n      public final class UtilityClass {\n        private UtilityClass(){\n        }\n        public static void foo() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UtilityClassWithPublicConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeParameterExtendsFinalClass",
                "shortDescription": {
                  "text": "'final' クラスを拡張している型パラメータ"
                },
                "fullDescription": {
                  "text": "'final' クラスを拡張するために宣言されている型パラメーターを報告します。 'final' クラスは拡張できないため、型パラメーターを指定された 'final' クラスの型に置換するよう提案します。 例: 'void foo() {\n    List<? extends Integer> list; // 警告: Integer クラスは final クラスです\n  }' クイックフィックス適用後: 'void foo() {\n    List<Integer> list;\n  }' このインスペクションは Java 5 以降で使用できる Java の機能 'ジェネリクス' に依存しています。",
                  "markdown": "`final` クラスを拡張するために宣言されている型パラメーターを報告します。\n\n`final` クラスは拡張できないため、型パラメーターを指定された `final` クラスの型に置換するよう提案します。\n\n**例:**\n\n\n      void foo() {\n        List<? extends Integer> list; // 警告: Integer クラスは final クラスです\n      }\n\nクイックフィックス適用後:\n\n\n      void foo() {\n        List<Integer> list;\n      }\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 'ジェネリクス' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeParameterExtendsFinalClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrivialIf",
                "shortDescription": {
                  "text": "冗長な 'if' ステートメント"
                },
                "fullDescription": {
                  "text": "単一の代入式、'return' 式、または 'assert' ステートメントに単純化できる 'if' ステートメントを報告します。 例: 'if (foo()) {\n    return true;\n  } else {\n    return false;\n  }' クイックフィックス適用後: 'return foo();' インスペクションの構成: 連鎖した 'if' ステートメントに対する警告を非表示にする場合は、「連鎖した 'if' ステートメントを無視する」オプションを使用します。 たとえば、次のコードでは警告は非表示となりますが、クイックフィックスは使用できます。 'if (condition1) return true;\n  if (condition2) return false;\n  return true;' '条件に副作用がある場合、if (isTrue()) assert false;' を 'assert isTrue();' に置換すると assert が無効化された際にプログラムのセマンティクスが変更される可能性があります。 本体に 'assert' ステートメントのみを含む 'if' ステートメントに対する警告を非表示にする場合は、「自明な 'assert' を含む 'if' ステートメントを無視する」オプションを使用します。",
                  "markdown": "単一の代入式、`return` 式、または `assert` ステートメントに単純化できる `if` ステートメントを報告します。\n\n例:\n\n\n      if (foo()) {\n        return true;\n      } else {\n        return false;\n      }\n\nクイックフィックス適用後:\n\n\n      return foo();\n\nインスペクションの構成:\n\n連鎖した `if` ステートメントに対する警告を非表示にする場合は、「**連鎖した 'if' ステートメントを無視する**」オプションを使用します。\n\nたとえば、次のコードでは警告は非表示となりますが、クイックフィックスは使用できます。\n\n\n      if (condition1) return true;\n      if (condition2) return false;\n      return true;\n\n`条件に副作用がある場合、if (isTrue()) assert false;` を `assert isTrue();` に置換すると assert が無効化された際にプログラムのセマンティクスが変更される可能性があります。\n本体に `assert` ステートメントのみを含む `if` ステートメントに対する警告を非表示にする場合は、「**自明な 'assert' を含む 'if' ステートメントを無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantIfStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnconditionalWait",
                "shortDescription": {
                  "text": "無条件の 'wait()' 呼び出し"
                },
                "fullDescription": {
                  "text": "同期コンテキスト内で、無条件に呼び出されている 'wait()' を報告します。 'wait()' は通常、ある条件が true になるまでスレッドをブロックするために使用されます。 'wait()' が無条件に呼び出されている場合、多くの場合はロックの取得前に条件がチェックされています。 このような場合、条件をチェックしてロックを取得するまでの間に条件が true になるとデータ競合が発生する可能性があります。 このインスペクションによって検出されるコンストラクトが必ずしも間違っているわけではありませんが、検査する価値はあります。 例: 'class Bar {\n      void foo() throws InterruptedException {\n          synchronized (this) {\n              wait(); // 警告\n          }\n      }\n  }'",
                  "markdown": "同期コンテキスト内で、無条件に呼び出されている `wait()` を報告します。\n\n\n`wait()` は通常、ある条件が true になるまでスレッドをブロックするために使用されます。 `wait()` が無条件に呼び出されている場合、多くの場合はロックの取得前に条件がチェックされています。 このような場合、条件をチェックしてロックを取得するまでの間に条件が true になるとデータ競合が発生する可能性があります。\n\n\nこのインスペクションによって検出されるコンストラクトが必ずしも間違っているわけではありませんが、検査する価値はあります。\n\n**例:**\n\n\n      class Bar {\n          void foo() throws InterruptedException {\n              synchronized (this) {\n                  wait(); // 警告\n              }\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnconditionalWait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceGuardedByStatic",
                "shortDescription": {
                  "text": "static フィールドによってガードされているインスタンスメンバー"
                },
                "fullDescription": {
                  "text": "ガードが 'static' フィールドであるインスタンスフィールドまたはメソッドに対して使用されている '@GuardedBy' アノテーションを報告します。 非 static のものを static でガードすると、過度なロックの競合を引き起こす可能性があります。任意のオブジェクトインスタンスのロックされているフィールドにアクセスがあると、すべてのオブジェクトインスタンスでそのフィールドへの同時アクセスが阻止されるためです。 例: 'private static ReadWriteLock lock = new ReentrantReadWriteLock(); //static のガードしているフィールド\n    private Object state;\n\n    @GuardedBy(\"lock\")\n    public void bar() {\n        state = new Object();\n    }' サポート対象の '@GuardedBy' アノテーションは以下の通りです。 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "ガードが `static` フィールドであるインスタンスフィールドまたはメソッドに対して使用されている `@GuardedBy` アノテーションを報告します。 非 static のものを static でガードすると、過度なロックの競合を引き起こす可能性があります。任意のオブジェクトインスタンスのロックされているフィールドにアクセスがあると、すべてのオブジェクトインスタンスでそのフィールドへの同時アクセスが阻止されるためです。\n\n例:\n\n\n        private static ReadWriteLock lock = new ReentrantReadWriteLock(); //static のガードしているフィールド\n        private Object state;\n\n        @GuardedBy(\"lock\")\n        public void bar() {\n            state = new Object();\n        }\n\nサポート対象の `@GuardedBy` アノテーションは以下の通りです。\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceGuardedByStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/並行処理に関するアノテーションの問題",
                      "index": 58,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanMethodIsAlwaysInverted",
                "shortDescription": {
                  "text": "常に反転しているブールメソッド"
                },
                "fullDescription": {
                  "text": "戻り値の型が 'boolean' のメソッドで、呼び出される際に常に否定されているものを報告します。 メソッドを反転してオプションで名前を変更するクイックフィックスが提供されます。 パフォーマンス上の理由から、問題があるすべてのメソッドがエディターでハイライトされるとは限りません。 例: 'class C {\n    boolean alwaysTrue() {\n      return true;\n    }\n\n    void f() {\n      if (!alwaysTrue()) {\n        return;\n      }\n    }\n    boolean member = !alwaysTrue();\n  }' クイックフィックス適用後: 'class C {\n    boolean alwaysFalse() {\n      return false;\n    }\n\n    void f() {\n      if (alwaysFalse()) {\n        return;\n      }\n    }\n    boolean member = alwaysFalse();\n  }'",
                  "markdown": "戻り値の型が `boolean` のメソッドで、呼び出される際に常に否定されているものを報告します。\n\nメソッドを反転してオプションで名前を変更するクイックフィックスが提供されます。\nパフォーマンス上の理由から、問題があるすべてのメソッドがエディターでハイライトされるとは限りません。\n\n例:\n\n\n      class C {\n        boolean alwaysTrue() {\n          return true;\n        }\n\n        void f() {\n          if (!alwaysTrue()) {\n            return;\n          }\n        }\n        boolean member = !alwaysTrue();\n      }\n\nクイックフィックス適用後:\n\n\n      class C {\n        boolean alwaysFalse() {\n          return false;\n        }\n\n        void f() {\n          if (alwaysFalse()) {\n            return;\n          }\n        }\n        boolean member = alwaysFalse();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanMethodIsAlwaysInverted",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/データフロー",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodOverridesInaccessibleMethodOfSuper",
                "shortDescription": {
                  "text": "アクセスできないスーパークラスのメソッドをオーバーライドするメソッド"
                },
                "fullDescription": {
                  "text": "アクセス不可能なスーパークラスのメソッドと同じシグネチャーを持つメソッドを報告します。たとえば、private メソッド、または別のパッケージにあるスーパークラスの package-private メソッドが挙げられます。 このようなメソッドは混乱を招く可能性があります。サブクラスのメソッドがアクセス不可能なスーパークラスのメソッドを不可視にしている場合、オーバーライドのように見える可能性があるためです。 また、スーパークラスのメソッドの可視性が後から変更されると、サブクラスのセマンティクスがひそかに変わったり、コンパイルエラーが発生したりする場合があります。 メソッドの名前を変更するクイックフィックスが提案されます。 例: 'public class Super {\n    private void test() {\n    }\n  }\n\n  public class Sub extends Super {\n    void test() { // 'Super.test()' を public にするとコンパイルエラーが発生します\n                  // 'Super.test()' を package private にすると 'Sub.test()' がオーバーライドになります\n    }\n  }'",
                  "markdown": "アクセス不可能なスーパークラスのメソッドと同じシグネチャーを持つメソッドを報告します。たとえば、private メソッド、または別のパッケージにあるスーパークラスの package-private メソッドが挙げられます。\n\n\nこのようなメソッドは混乱を招く可能性があります。サブクラスのメソッドがアクセス不可能なスーパークラスのメソッドを不可視にしている場合、オーバーライドのように見える可能性があるためです。\nまた、スーパークラスのメソッドの可視性が後から変更されると、サブクラスのセマンティクスがひそかに変わったり、コンパイルエラーが発生したりする場合があります。\n\nメソッドの名前を変更するクイックフィックスが提案されます。\n\n**例:**\n\n\n      public class Super {\n        private void test() {\n        }\n      }\n\n      public class Sub extends Super {\n        void test() { // 'Super.test()' を public にするとコンパイルエラーが発生します\n                      // 'Super.test()' を package private にすると 'Sub.test()' がオーバーライドになります\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodOverridesInaccessibleMethodOfSuper",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AutoCloseableResource",
                "shortDescription": {
                  "text": "AutoCloseable は 'try'-with-resources なしで使用されています"
                },
                "fullDescription": {
                  "text": "try-with-resources ステートメント (自動リソース管理 とも呼ばれる) で使用されていない 'AutoCloseable' インスタンスを報告します。 つまり、try-with-resources が使用可能になる前に使用されていた「'try' の前/中でリソースを開き、'finally' で閉じる」スタイルも報告されます。 このインスペクションは、Java 7 以降で開発する際にすべての「安全に閉じられていない」インスペクションを置き換えることを目的としています。 例: 'private static void foo() throws IOException {\n    InputStream profile = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"/someFile\");\n    System.out.println(profile.read());\n  }' このインスペクションは、次のオプションを使用して構成できます。 閉じる必要がなく、このインスペクションで無視すべき 'AutoCloseable' のサブクラスをリストします。 注意: このインスペクションは 'java.util.stream.Stream' が無視対象としてリストに登録されている場合でも、'java.nio.file.Files' のメソッドである 'lines()'、'walk()'、'list()'、'find()' が返すストリームを報告します。 これらのストリームには、閉じる必要のある関連 I/O リソースが含まれています。 'AutoCloseable' を返すメソッドで、呼び出されたときに無視すべきものをリストします。 'AutoCloseable' がメソッド呼び出しの結果である場合に無視するかどうか。 このオプションを有効にすると、ファクトリメソッドの結果も無視されます。 このインスペクションで 'AutoCloseable' インスタンスがメソッド呼び出しの引数として渡されたかどうかを報告するかどうか。 このオプションが有効になっている場合、このインスペクションは呼び出されたメソッドでリソースが閉じられていると見なします。 名前に 'close' と'AutoCloseable' 引数が含まれる 'finally' ブロック内のメソッド呼び出しは無視されません。 リソースクラスのコンストラクターへのメソッド参照を無視するかどうか。 リソースを返し、名前が 'get' で始まるメソッドを無視するかどうか。 無視した場合、誤検知を減らすことができます。ほとんどの getter はリソースの所有権を譲渡せず、それらの呼び出しサイトはリソースを閉じる役目を担っていないためです。 このインスペクションは Java 7 以降で使用できる Java の機能 'try-with-resources' に依存しています。",
                  "markdown": "try-with-resources ステートメント (*自動リソース管理* とも呼ばれる) で使用されていない `AutoCloseable` インスタンスを報告します。\n\n\nつまり、try-with-resources が使用可能になる前に使用されていた「`try` の前/中でリソースを開き、`finally` で閉じる」スタイルも報告されます。\nこのインスペクションは、Java 7 以降で開発する際にすべての「*安全に閉じられていない*」インスペクションを置き換えることを目的としています。\n\n**例:**\n\n\n      private static void foo() throws IOException {\n        InputStream profile = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"/someFile\");\n        System.out.println(profile.read());\n      }\n\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* 閉じる必要がなく、このインスペクションで無視すべき `AutoCloseable` のサブクラスをリストします。   \n  **注意** : このインスペクションは `java.util.stream.Stream` が無視対象としてリストに登録されている場合でも、`java.nio.file.Files` のメソッドである `lines()`、`walk()`、`list()`、`find()` が返すストリームを報告します。 これらのストリームには、閉じる必要のある関連 I/O リソースが含まれています。\n* `AutoCloseable` を返すメソッドで、呼び出されたときに無視すべきものをリストします。\n* `AutoCloseable` がメソッド呼び出しの結果である場合に無視するかどうか。 このオプションを有効にすると、ファクトリメソッドの結果も無視されます。\n* このインスペクションで `AutoCloseable` インスタンスがメソッド呼び出しの引数として渡されたかどうかを報告するかどうか。 このオプションが有効になっている場合、このインスペクションは呼び出されたメソッドでリソースが閉じられていると見なします。 名前に 'close' と`AutoCloseable` 引数が含まれる `finally` ブロック内のメソッド呼び出しは無視されません。\n* リソースクラスのコンストラクターへのメソッド参照を無視するかどうか。\n* リソースを返し、名前が 'get' で始まるメソッドを無視するかどうか。 無視した場合、誤検知を減らすことができます。ほとんどの getter はリソースの所有権を譲渡せず、それらの呼び出しサイトはリソースを閉じる役目を担っていないためです。\n\nこのインスペクションは Java 7 以降で使用できる Java の機能 'try-with-resources' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "resource",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/リソース管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IntLiteralMayBeLongLiteral",
                "shortDescription": {
                  "text": "'long' へのキャストは 'long' リテラルにできます"
                },
                "fullDescription": {
                  "text": "'long' にすぐにキャストされる 'int' リテラル式を報告します。 このようなリテラル式は同等の 'long' リテラルに置換できます。 例: 'Long l = (long)42;' クイックフィックス適用後: 'Long l = 42L;'",
                  "markdown": "`long` にすぐにキャストされる `int` リテラル式を報告します。\n\nこのようなリテラル式は同等の `long` リテラルに置換できます。\n\n**例:**\n\n    Long l = (long)42;\n\nクイックフィックス適用後:\n\n    Long l = 42L;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IntLiteralMayBeLongLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値の問題/キャスト",
                      "index": 104,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SingleStatementInBlock",
                "shortDescription": {
                  "text": "コードブロックには単一のステートメントが含まれています"
                },
                "fullDescription": {
                  "text": "コードブロック内にステートメントを 1 つ含む制御フローステートメントを報告し、制御フローステートメントの本体から波括弧を除去するよう提案します。 例: 'if (x > 0) {\n    System.out.println(\"x is positive\");\n  }' クイックフィックス適用後: 'if (x > 0) System.out.println(\"x is positive\");'",
                  "markdown": "コードブロック内にステートメントを 1 つ含む制御フローステートメントを報告し、制御フローステートメントの本体から波括弧を除去するよう提案します。\n\n例:\n\n\n      if (x > 0) {\n        System.out.println(\"x is positive\");\n      }\n\nクイックフィックス適用後:\n\n\n      if (x > 0) System.out.println(\"x is positive\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SingleStatementInBlock",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestCaseWithConstructor",
                "shortDescription": {
                  "text": "非自明なコンストラクターを含む TestCase"
                },
                "fullDescription": {
                  "text": "初期化ロジックをコンストラクターの中で使用しているテストケースを報告します。 コンストラクターが失敗した場合、'@After' アノテーションが付いたメソッドまたは 'tearDown()' メソッドは呼び出されません。 その結果、テスト環境が部分的に初期化されたままになり、他のテストに悪影響を与える可能性があります。 代わりに、テストケースの初期化を 'setUp()' メソッドか '@Before' アノテーションが付いたメソッドで実行する必要があります。 悪い例: 'public class ImportantTest {\n    private File file;\n\n    public ImportantTest() throws IOException {\n      file = File.createTempFile(\"xyz\", \".tmp\");\n    }\n\n    // ... tests go here\n  }'",
                  "markdown": "初期化ロジックをコンストラクターの中で使用しているテストケースを報告します。 コンストラクターが失敗した場合、`@After` アノテーションが付いたメソッドまたは `tearDown()` メソッドは呼び出されません。 その結果、テスト環境が部分的に初期化されたままになり、他のテストに悪影響を与える可能性があります。 代わりに、テストケースの初期化を `setUp()` メソッドか `@Before` アノテーションが付いたメソッドで実行する必要があります。\n\n悪い例:\n\n\n      public class ImportantTest {\n        private File file;\n\n        public ImportantTest() throws IOException {\n          file = File.createTempFile(\"xyz\", \".tmp\");\n        }\n\n        // ... tests go here\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnitTestCaseWithNonTrivialConstructors",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語/テストフレームワーク",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SingleCharacterStartsWith",
                "shortDescription": {
                  "text": "単一文字の 'startsWith()' または 'endsWith()'"
                },
                "fullDescription": {
                  "text": "単一文字の文字列リテラルが引数として渡されている 'String.startsWith()' および 'String.endsWith()' の呼び出しを報告します。 このような呼び出しをより効率性に優れた実装の 'String.charAt()' に置換するクイックフィックスが提案されます。 ただし、この変更によるパフォーマンス向上は最小限であり、非ゼロ長チェックが追加されるために可読性が低下してしまいます。そのため、このクイックフィックスは厳密なループ内でのみ適用することをお勧めします。 このインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。 このインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。 例: 'boolean startsWithX(String s) {\n    return s.startsWith(\"x\");\n  }' クイックフィックス適用後: 'boolean startsWithX(String s) {\n    return !s.isEmpty() && s.charAt(0) == 'x';\n  }'",
                  "markdown": "単一文字の文字列リテラルが引数として渡されている `String.startsWith()` および `String.endsWith()` の呼び出しを報告します。\n\n\nこのような呼び出しをより効率性に優れた実装の `String.charAt()` に置換するクイックフィックスが提案されます。\n\n\nただし、この変更によるパフォーマンス向上は最小限であり、非ゼロ長チェックが追加されるために可読性が低下してしまいます。そのため、このクイックフィックスは厳密なループ内でのみ適用することをお勧めします。\n\n\nこのインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。\nこのインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。\n\n**例:**\n\n\n      boolean startsWithX(String s) {\n        return s.startsWith(\"x\");\n      }\n\nクイックフィックス適用後:\n\n\n      boolean startsWithX(String s) {\n        return !s.isEmpty() && s.charAt(0) == 'x';\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SingleCharacterStartsWith",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス/組み込み",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UtilityClassCanBeEnum",
                "shortDescription": {
                  "text": "ユーティリティクラスは 'enum'"
                },
                "fullDescription": {
                  "text": "列挙型に変換できるユーティリティクラスを報告します。 一部のコーディングスタイルガイドラインは、ユーティリティクラスを列挙型として実装して、'private' コンストラクターでのコードカバレッジの問題を回避することを要求しています。 例: 'class StringUtils {\n    public static final String EMPTY = \"\";\n  }' クイックフィックス適用後: 'enum StringUtils {\n    ;\n    public static final String EMPTY = \"\";\n  }' このインスペクションは Java 5 以降で使用できる Java の機能 '列挙型' に依存しています。",
                  "markdown": "列挙型に変換できるユーティリティクラスを報告します。\n\n一部のコーディングスタイルガイドラインは、ユーティリティクラスを列挙型として実装して、`private` コンストラクターでのコードカバレッジの問題を回避することを要求しています。\n\n**例:**\n\n\n      class StringUtils {\n        public static final String EMPTY = \"\";\n      }\n\nクイックフィックス適用後:\n\n\n      enum StringUtils {\n        ;\n        public static final String EMPTY = \"\";\n      }\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 '列挙型' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UtilityClassCanBeEnum",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReadObjectAndWriteObjectPrivate",
                "shortDescription": {
                  "text": "'private' と宣言されていない 'readObject()' または 'writeObject()'"
                },
                "fullDescription": {
                  "text": "'readObject' または 'writeObject' メソッドが private で宣言されていない 'Serializable' クラスを報告します。 これらのメソッドの可視性を 'private' よりも高くする理由はありません。 対応するメソッドを 'private' にするクイックフィックスが提案されます。 例: 'public class Test implements Serializable {\n    public void readObject(ObjectInputStream stream) {\n      /* ... */\n    }\n  }' クイックフィックス適用後: 'public class Test implements Serializable {\n    private void readObject(ObjectInputStream stream) {\n      /* ... */\n    }\n  }'",
                  "markdown": "`readObject` または `writeObject` メソッドが private で宣言されていない `Serializable` クラスを報告します。 これらのメソッドの可視性を `private` よりも高くする理由はありません。\n\n\n対応するメソッドを `private` にするクイックフィックスが提案されます。\n\n**例:**\n\n\n      public class Test implements Serializable {\n        public void readObject(ObjectInputStream stream) {\n          /* ... */\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public class Test implements Serializable {\n        private void readObject(ObjectInputStream stream) {\n          /* ... */\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonPrivateSerializationMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsObject",
                "shortDescription": {
                  "text": "明示的に 'Object' を拡張するクラス"
                },
                "fullDescription": {
                  "text": "'java.lang.Object' の拡張を明示的に宣言しているクラスを報告します。 このような宣言は冗長であるため、安全に除去できます。 例: 'class MyClass extends Object {\n  }' クイックフィックスを使用すると、冗長な 'extends Object' 節が除去されます。 'class MyClass {\n  }'",
                  "markdown": "`java.lang.Object` の拡張を明示的に宣言しているクラスを報告します。\n\nこのような宣言は冗長であるため、安全に除去できます。\n\n例:\n\n\n      class MyClass extends Object {\n      }\n\nクイックフィックスを使用すると、冗長な `extends Object` 節が除去されます。\n\n\n      class MyClass {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassExplicitlyExtendsObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantFileCreation",
                "shortDescription": {
                  "text": "冗長な 'File' オブジェクトの作成"
                },
                "fullDescription": {
                  "text": "'String' パスのみを使用できる場合に、'FileInputStream'、'FileOutputStream'、'FileReader'、'FileWriter'、'PrintStream'、'PrintWriter'、'Formatter' コンストラクターのいずれかで作成されている冗長な 'File' を報告します。 例: 'InputStream is = new FileInputStream(new File(\"in.txt\"));' クイックフィックス適用後: 'InputStream is = new FileInputStream(\"in.txt\");' 2020.3 の新機能です",
                  "markdown": "`String` パスのみを使用できる場合に、`FileInputStream`、`FileOutputStream`、`FileReader`、`FileWriter`、`PrintStream`、`PrintWriter`、`Formatter` コンストラクターのいずれかで作成されている冗長な `File` を報告します。\n\n例:\n\n\n    InputStream is = new FileInputStream(new File(\"in.txt\"));\n\nクイックフィックス適用後:\n\n\n    InputStream is = new FileInputStream(\"in.txt\");\n\n2020.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantFileCreation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessBooleanExpression",
                "shortDescription": {
                  "text": "無意味なブール式"
                },
                "fullDescription": {
                  "text": "不要な、または複雑すぎるブール式を報告します。 このような式には、'&&' と 'true' の併用、'||' と 'false' の併用、等価比較とブールリテラルの併用、ブールリテラルの否定などがあります。 このような式は単純化できます。 例: 'boolean a = !(x && false);\n  boolean b = false || x;\n  boolean c = x != true;' クイックフィックス適用後: 'boolean a = true;\n  boolean b = x;\n  boolean c = !x;' インスペクションの構成: 式が無意味であるかどうかを判断する際に名前付きの定数を無視する場合は、「無意味な式を判断する際に名前付きの定数を無視する」オプションを使用します。",
                  "markdown": "不要な、または複雑すぎるブール式を報告します。\n\nこのような式には、`&&` と `true` の併用、`||` と `false` の併用、等価比較とブールリテラルの併用、ブールリテラルの否定などがあります。 このような式は単純化できます。\n\n例:\n\n\n      boolean a = !(x && false);\n      boolean b = false || x;\n      boolean c = x != true;\n\nクイックフィックス適用後:\n\n\n      boolean a = true;\n      boolean b = x;\n      boolean c = !x;\n\n\nインスペクションの構成:\n式が無意味であるかどうかを判断する際に名前付きの定数を無視する場合は、「**無意味な式を判断する際に名前付きの定数を無視する** 」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessBooleanExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ListenerMayUseAdapter",
                "shortDescription": {
                  "text": "リスナーを実装する代わりにアダプターを拡張可能なクラス"
                },
                "fullDescription": {
                  "text": "対応するアダプターを拡張せず、リスナーを実装しているクラスを報告します。 リスナーの実装をアダプターの拡張に置換した後に残留している重複した空のメソッドをすべて除去するクイックフィックスを使用できます。 空のメソッドが見つからなかった場合も警告するようにインスペクションを構成するには、「空の実装メソッドが見つかった場合にのみ警告する」オプションを使用します。",
                  "markdown": "対応するアダプターを拡張せず、リスナーを実装しているクラスを報告します。\n\nリスナーの実装をアダプターの拡張に置換した後に残留している重複した空のメソッドをすべて除去するクイックフィックスを使用できます。\n\n\n空のメソッドが見つからなかった場合も警告するようにインスペクションを構成するには、「**空の実装メソッドが見つかった場合にのみ警告する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ListenerMayUseAdapter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReassignedVariable",
                "shortDescription": {
                  "text": "再代入された変数"
                },
                "fullDescription": {
                  "text": "コードの可読性を損ねて理解しにくくしている再代入された変数を報告します。 例: 'int value = 2 * (height + width);\n  System.out.println(\"perimeter: \" + value);\n\n  value = height * width;\n  System.out.println(\"area: \" + value);'",
                  "markdown": "コードの可読性を損ねて理解しにくくしている再代入された変数を報告します。\n\n例:\n\n\n      int value = 2 * (height + width);\n      System.out.println(\"perimeter: \" + value);\n\n      value = height * width;\n      System.out.println(\"area: \" + value);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReassignedVariable",
                    "ideaSeverity": "TEXT ATTRIBUTES",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodNameSameAsClassName",
                "shortDescription": {
                  "text": "クラス名と同じメソッド名"
                },
                "fullDescription": {
                  "text": "所属クラスと名前がまったく同じメソッドを報告します。 このような命名は Java 言語では許されていますが、一般的にはコンストラクターを定義するために予約されています。 メソッドにこのような名前を使用するのは、間違っているか、悪い慣例だと思われます。 例: 'class MyClass {\n    int val;\n\n    // メソッド MyClass はその包含クラスとまったく同じ名前を使用しています。\n    // 'void' は間違いで追加された可能性があります。\n    void MyClass(int val) {\n      this.val = val;\n    }\n  }' クイックフィックスを使用すると、適切な場合にメソッドがコンストラクターに変換されます。 'class MyClass {\n    int val;\n\n    MyClass(int val) {\n      this.val = val;\n    }\n  }' メソッドの名前を変更する別のクイックフィックスもあります。",
                  "markdown": "所属クラスと名前がまったく同じメソッドを報告します。 このような命名は Java 言語では許されていますが、一般的にはコンストラクターを定義するために予約されています。 メソッドにこのような名前を使用するのは、間違っているか、悪い慣例だと思われます。\n\n**例:**\n\n\n      class MyClass {\n        int val;\n\n        // メソッド MyClass はその包含クラスとまったく同じ名前を使用しています。\n        // 'void' は間違いで追加された可能性があります。\n        void MyClass(int val) {\n          this.val = val;\n        }\n      }\n\nクイックフィックスを使用すると、適切な場合にメソッドがコンストラクターに変換されます。\n\n\n      class MyClass {\n        int val;\n\n        MyClass(int val) {\n          this.val = val;\n        }\n      }\n\nメソッドの名前を変更する別のクイックフィックスもあります。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodNameSameAsClassName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規則/メソッド",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExpressionComparedToItself",
                "shortDescription": {
                  "text": "式がそれ自身と比較されています"
                },
                "fullDescription": {
                  "text": "左右のオペランドがまったく同じ式になっている比較を報告します。 自身と比較する式は意図的に使用されている場合もありますが、ほとんどの場合は見落としです。 例: '// left.getLength() == right.getLength() が意図されていたと思われます\n  boolean result = left.getLength() == left.getLength();' 副作用を引き起こす可能性がある比較を無視するには、「副作用のある条件を無視する」オプションを使用します。 このオプションを無効化すると、同じメソッドが後続の呼び出しで異なる値を返す場合などに誤検知が発生する可能性があります。 例: 'native int unknownMethod();\n  \n  ...\n  \n  if (unknownMethod() > unknownMethod()) {\n    System.out.println(\"Got it\");\n  }' 'unknownMethod()' (上の例) は副作用を引き起こす可能性があるため、警告は「副作用のある条件を無視する」オプションが無効な場合にのみトリガーされます。 2024.2 の新機能です",
                  "markdown": "左右のオペランドがまったく同じ式になっている比較を報告します。 自身と比較する式は意図的に使用されている場合もありますが、ほとんどの場合は見落としです。\n\n例:\n\n\n      // left.getLength() == right.getLength() が意図されていたと思われます\n      boolean result = left.getLength() == left.getLength();\n\n\n副作用を引き起こす可能性がある比較を無視するには、「**副作用のある条件を無視する**」オプションを使用します。\nこのオプションを無効化すると、同じメソッドが後続の呼び出しで異なる値を返す場合などに誤検知が発生する可能性があります。\n\n例:\n\n\n      native int unknownMethod();\n      \n      ...\n      \n      if (unknownMethod() > unknownMethod()) {\n        System.out.println(\"Got it\");\n      }\n\n`unknownMethod()` (上の例) は副作用を引き起こす可能性があるため、警告は「**副作用のある条件を無視する**」オプションが無効な場合にのみトリガーされます。\n\n2024.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExpressionComparedToItself",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LocalVariableNamingConvention",
                "shortDescription": {
                  "text": "ローカル変数の命名規則"
                },
                "fullDescription": {
                  "text": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないローカル変数を報告します。 例: 'int X = 42;' は、このインスペクションが変数名の開始文字が小文字であることを要求するデフォルト設定で有効になっている場合に報告されます。 インスペクションの構成: ローカル変数の名前に期待される最小文字数、最大文字数、および正規表現を指定するには、「オプション」セクションのフィールドを使用します。 名前の長さをチェックしない場合は、0 を指定します。 正規表現は、java.util.regex の標準的な形式で指定する必要があります。 'for' ループおよび 'catch' セクションのパラメーターを無視するには、チェックボックスを使用します。",
                  "markdown": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないローカル変数を報告します。\n\n**例:** `int X = 42;` は、このインスペクションが変数名の開始文字が小文字であることを要求するデフォルト設定で有効になっている場合に報告されます。\n\nインスペクションの構成:\n\n\nローカル変数の名前に期待される最小文字数、最大文字数、および正規表現を指定するには、「**オプション** 」セクションのフィールドを使用します。\n名前の長さをチェックしない場合は、**0** を指定します。 正規表現は、**java.util.regex** の標準的な形式で指定する必要があります。\n\n`for` ループおよび `catch` セクションのパラメーターを無視するには、チェックボックスを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LocalVariableNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規約",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryJavaDocLink",
                "shortDescription": {
                  "text": "不要な Javadoc リンク"
                },
                "fullDescription": {
                  "text": "Javadoc の '@see' / '{@link}' / '{@linkplain}' タグで、コメントがあるメソッド、コメントがあるメソッドのスーパーメソッド、またはコメントを含んでいるクラスを参照しているものを報告します。 このようなリンクは不要であり、このインスペクションのクイックフィックスを使用して安全に除去できます。 タグが唯一の内容である場合にクイックフィックスを使用すると、Javadoc コメント全体が除去されます。 例: 'class Example {\n    /**\n     * @see Example#method\n     */\n    public void method() { }\n  }' クイックフィックス適用後: 'class Example {\n  public void method() { }\n}' スーパーメソッドへのインラインリンク ('{@link}' と '{@linkplain}') を無視するには、以下のチェックボックスを使用します。 すべてのスーパーメソッドへのリンクは Javadoc ツールによって自動的に追加されますが、スーパーメソッドへのインラインリンクは Javadoc コメントのテキスト内で必要になる場合があります。",
                  "markdown": "Javadoc の `@see` / `{@link}` / `{@linkplain}` タグで、コメントがあるメソッド、コメントがあるメソッドのスーパーメソッド、またはコメントを含んでいるクラスを参照しているものを報告します。\n\nこのようなリンクは不要であり、このインスペクションのクイックフィックスを使用して安全に除去できます。 タグが唯一の内容である場合にクイックフィックスを使用すると、Javadoc コメント全体が除去されます。\n\n**例:**\n\n\n      class Example {\n        /**\n         * @see Example#method\n         */\n        public void method() { }\n      }\n\nクイックフィックス適用後:\n\n\n    class Example {\n      public void method() { }\n    }\n\n\nスーパーメソッドへのインラインリンク (`{@link}` と `{@linkplain}`) を無視するには、以下のチェックボックスを使用します。 すべてのスーパーメソッドへのリンクは Javadoc ツールによって自動的に追加されますが、スーパーメソッドへのインラインリンクは Javadoc コメントのテキスト内で必要になる場合があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryJavaDocLink",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedSwitchStatement",
                "shortDescription": {
                  "text": "ネストした 'switch' ステートメント"
                },
                "fullDescription": {
                  "text": "ネストした 'switch' ステートメントまたは式を報告します。 ネストした 'switch' ステートメントを使用したコードは大きな混乱を招く可能性があります。 このようなステートメントは個別のメソッドに抽出できます。 例: 'int res = switch (i) {\n            case 0 -> 0;\n            default -> switch (i) {\n                case 100 -> 0;\n                default -> i;\n            };\n        };'",
                  "markdown": "ネストした `switch` ステートメントまたは式を報告します。\n\nネストした `switch` ステートメントを使用したコードは大きな混乱を招く可能性があります。 このようなステートメントは個別のメソッドに抽出できます。\n\n例:\n\n\n      int res = switch (i) {\n                case 0 -> 0;\n                default -> switch (i) {\n                    case 100 -> 0;\n                    default -> i;\n                };\n            };\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedSwitchStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyTryBlock",
                "shortDescription": {
                  "text": "空の 'try' ブロック"
                },
                "fullDescription": {
                  "text": "try-with-resources ステートメントを含む空の 'try' ブロックを報告します。 コメント付きの 'try' ブロックは空と見なされます。 このインスペクションは JSP ファイルに含まれる空の 'try' ブロックを報告しません。",
                  "markdown": "try-with-resources ステートメントを含む空の `try` ブロックを報告します。\n\nコメント付きの `try` ブロックは空と見なされます。\n\n\nこのインスペクションは JSP ファイルに含まれる空の `try` ブロックを報告しません。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyTryBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CollectionsFieldAccessReplaceableByMethodCall",
                "shortDescription": {
                  "text": "空のコレクションフィールドへの参照はメソッドの呼び出しに置換できます"
                },
                "fullDescription": {
                  "text": "'java.util.Collections' フィールド ('EMPTY_LIST'、'EMPTY_MAP'、 'EMPTY_SET') の使用箇所を報告します。 これらのフィールドの使用箇所は、'emptyList()'、'emptyMap()'、'emptySet()' のいずれかのメソッドの呼び出しに置換できます。 型パラメーターは推論できるため、このようなメソッドの呼び出しはコンパイラーによる未チェックの警告を抑止します。 例: 'List<Integer> emptyList = Collections.EMPTY_LIST;' クイックフィックス適用後: 'List<Integer> emptyList = Collections.emptyList();' このインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以上の場合にのみ報告します。",
                  "markdown": "`java.util.Collections` フィールド (`EMPTY_LIST`、`EMPTY_MAP`、 `EMPTY_SET`) の使用箇所を報告します。 これらのフィールドの使用箇所は、`emptyList()`、`emptyMap()`、`emptySet()` のいずれかのメソッドの呼び出しに置換できます。 型パラメーターは推論できるため、このようなメソッドの呼び出しはコンパイラーによる未チェックの警告を抑止します。\n\n**例:**\n\n\n      List<Integer> emptyList = Collections.EMPTY_LIST;\n\nクイックフィックス適用後:\n\n\n      List<Integer> emptyList = Collections.emptyList();\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以上の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionsFieldAccessReplaceableByMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertWithSideEffects",
                "shortDescription": {
                  "text": "副作用のある 'assert' ステートメント"
                },
                "fullDescription": {
                  "text": "副作用を引き起こす 'assert' ステートメントを報告します。 アサーションはオフに切り替えることができるため、このような副作用が必ず発生するとは限りません。そのため、検出困難なバグを引き起こす可能性があります。 このインスペクションで検出される一般的な望ましくない副作用は、変数とフィールドの変更です。 メソッドの呼び出しが関係する場合は、さらに詳しく解析されます。 例: 'assert i++ < 10;' このインスペクションは Java 1.4 以降で使用できる Java の機能 'アサーション' に依存しています。",
                  "markdown": "副作用を引き起こす `assert` ステートメントを報告します。\n\n\nアサーションはオフに切り替えることができるため、このような副作用が必ず発生するとは限りません。そのため、検出困難なバグを引き起こす可能性があります。 このインスペクションで検出される一般的な望ましくない副作用は、変数とフィールドの変更です。 メソッドの呼び出しが関係する場合は、さらに詳しく解析されます。\n\n**例:**\n\n\n      assert i++ < 10;\n\nこのインスペクションは Java 1.4 以降で使用できる Java の機能 'アサーション' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertWithSideEffects",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitOrAwaitWithoutTimeout",
                "shortDescription": {
                  "text": "タイムアウトのない 'wait()' または 'await()'"
                },
                "fullDescription": {
                  "text": "タイムアウト指定のない 'Object.wait()' または 'Condition.await()' の呼び出しを報告します。 高可用性が要求されるプログラムでは、このような呼び出しは危険な場合があります。'notify()'/'notifyAll()' または 'signal()'/'signalAll()' が呼び出されない場合、1 つのコンポーネントで障害が発生すると、待機中のコンポーネントがブロックされる可能性があるためです。 例: 'void foo(Object bar) throws InterruptedException {\n    bar.wait();\n  }'",
                  "markdown": "タイムアウト指定のない `Object.wait()` または `Condition.await()` の呼び出しを報告します。\n\n\n高可用性が要求されるプログラムでは、このような呼び出しは危険な場合があります。`notify()`/`notifyAll()` または `signal()`/`signalAll()` が呼び出されない場合、1 つのコンポーネントで障害が発生すると、待機中のコンポーネントがブロックされる可能性があるためです。\n\n**例:**\n\n\n      void foo(Object bar) throws InterruptedException {\n        bar.wait();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitOrAwaitWithoutTimeout",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RefusedBequest",
                "shortDescription": {
                  "text": "スーパーメソッドを呼び出さないメソッド"
                },
                "fullDescription": {
                  "text": "super メソッドを呼び出さずに super メソッドをオーバーライドしているメソッドを報告します。 このような状況は Refused Bequest (相続拒否) という呼び名でも知られています。 このようなメソッドは抽象化に問題があることを示唆しており、追跡困難なバグを生み出す原因になる場合があります。 このインスペクションは 'clone()' を除く 'java.lang.Object' からオーバーライドされたメソッドを報告しません。 'clone()' メソッドは規則に従ってその super メソッドを呼び出し、正しい型のオブジェクトを返す必要があります。 例 1: 'class A {\n    @Override\n    public Object clone() {\n      // 'super.clone()' を呼び出していません\n      return new A();\n    }\n  }' 例 2: 'interface I {\n    default void foo() {}\n  }\n\n  class A implements I {\n    // 「'default' スーパーメソッドを無視する」が無効な場合は\n    // メソッドに対して警告が表示されます\n    @Override\n    public void foo(){}\n  }' インスペクションの構成: 指定のリストに含まれるアノテーションが付いた super メソッド を無視するには、「スーパーメソッドに次のアノテーションが付けられた場合にのみ報告する」オプションを使用します。 アノテーションは手動でリストに追加できます。 空のメソッド、または例外をスローするだけの super メソッドを無視するには、「空のスーパーメソッドを無視」オプションを使用します。 インターフェースの 'default' super メソッドを無視するには、「'default' スーパーメソッドを無視する」オプションを使用します。",
                  "markdown": "super メソッドを呼び出さずに super メソッドをオーバーライドしているメソッドを報告します。 このような状況は *Refused Bequest* (相続拒否) という呼び名でも知られています。 このようなメソッドは抽象化に問題があることを示唆しており、追跡困難なバグを生み出す原因になる場合があります。\n\n\nこのインスペクションは `clone()` を除く `java.lang.Object` からオーバーライドされたメソッドを報告しません。\n`clone()` メソッドは規則に従ってその super メソッドを呼び出し、正しい型のオブジェクトを返す必要があります。\n\n**例 1:**\n\n\n      class A {\n        @Override\n        public Object clone() {\n          // 'super.clone()' を呼び出していません\n          return new A();\n        }\n      }\n\n**例 2:**\n\n\n      interface I {\n        default void foo() {}\n      }\n\n      class A implements I {\n        // 「'default' スーパーメソッドを無視する」が無効な場合は\n        // メソッドに対して警告が表示されます\n        @Override\n        public void foo(){}\n      }\n\nインスペクションの構成:\n\n* 指定のリストに含まれるアノテーションが付いた super メソッド を無視するには、「**スーパーメソッドに次のアノテーションが付けられた場合にのみ報告する**」オプションを使用します。 アノテーションは手動でリストに追加できます。\n* 空のメソッド、または例外をスローするだけの super メソッドを無視するには、「**空のスーパーメソッドを無視**」オプションを使用します。\n* インターフェースの `default` super メソッドを無視するには、「**'default' スーパーメソッドを無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodDoesntCallSuperMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalClass",
                "shortDescription": {
                  "text": "クラスは継承できません"
                },
                "fullDescription": {
                  "text": "'final' で宣言されているクラスを報告します。 'sealed' クラスまたはインターフェースを拡張する final クラスは報告されません。 このようなクラスは継承不可能であり、オブジェクト指向設計が不十分な可能性があります。 一部のコーディング標準は、'final' クラスを推奨していません。 例: 'public final class Main {\n  }' クイックフィックス適用後: 'public class Main {\n  }'",
                  "markdown": "`final` で宣言されているクラスを報告します。 `sealed` クラスまたはインターフェースを拡張する final クラスは報告されません。 このようなクラスは継承不可能であり、オブジェクト指向設計が不十分な可能性があります。 一部のコーディング標準は、`final` クラスを推奨していません。\n\n**例:**\n\n\n      public final class Main {\n      }\n\nクイックフィックス適用後:\n\n\n      public class Main {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryEmptyArrayUsage",
                "shortDescription": {
                  "text": "不必要な長さゼロの配列を使用"
                },
                "fullDescription": {
                  "text": "長さがゼロであることが分かっている配列が代入されており、その配列の要素の型を含むクラス内に対応する定数がある場合に報告します。 長さがゼロの配列はイミュータブルであるため、同じ配列のインスタンスを再利用してメモリを節約できます。 例: 'class Item {\n    // 再利用可能な長さがゼロの public 配列定数\n    public static final Item[] EMPTY_ARRAY = new Item[0];\n  }\n  class EmptyNode {\n    Item[] getChildren() {\n      // 長さがゼロの配列の作成は不要\n      return new Item[0];\n    }\n  }' クイックフィックス適用後: 'class EmptyNode {\n    Item[] getChildren() {\n      return Item.EMPTY_ARRAY;\n    }\n  }'",
                  "markdown": "長さがゼロであることが分かっている配列が代入されており、その配列の要素の型を含むクラス内に対応する定数がある場合に報告します。 長さがゼロの配列はイミュータブルであるため、同じ配列のインスタンスを再利用してメモリを節約できます。\n\n**例:**\n\n\n      class Item {\n        // 再利用可能な長さがゼロの public 配列定数\n        public static final Item[] EMPTY_ARRAY = new Item[0];\n      }\n      class EmptyNode {\n        Item[] getChildren() {\n          // 長さがゼロの配列の作成は不要\n          return new Item[0];\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class EmptyNode {\n        Item[] getChildren() {\n          return Item.EMPTY_ARRAY;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantForZeroLengthArrayAllocation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メモリ",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LiteralAsArgToStringEquals",
                "shortDescription": {
                  "text": "文字列リテラルは 'equals()' 修飾子にできます"
                },
                "fullDescription": {
                  "text": "文字列リテラルの引数を使用している 'String.equals()' または 'String.equalsIgnoreCase()' 呼び出しを報告します。 一部のコーディング標準は、文字列リテラルを引数ではなく 'equals()' の修飾子にして 'NullPointerException' を最小限に抑えるべきだと規定しています。 リテラルと式を交換するクイックフィックスを使用できます。 例: 'boolean isFoo(String value) {\n    return value.equals(\"foo\");\n  }' クイックフィックス適用後: 'boolean isFoo(String value) {\n    return \"foo\".equals(value);\n  }'",
                  "markdown": "文字列リテラルの引数を使用している `String.equals()` または `String.equalsIgnoreCase()` 呼び出しを報告します。\n\n一部のコーディング標準は、文字列リテラルを引数ではなく `equals()` の修飾子にして `NullPointerException` を最小限に抑えるべきだと規定しています。\n\nリテラルと式を交換するクイックフィックスを使用できます。\n\n**例:**\n\n\n      boolean isFoo(String value) {\n        return value.equals(\"foo\");\n      }\n\nクイックフィックス適用後:\n\n\n      boolean isFoo(String value) {\n        return \"foo\".equals(value);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LiteralAsArgToStringEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateExpressions",
                "shortDescription": {
                  "text": "同じ式が複数回出現"
                },
                "fullDescription": {
                  "text": "あるメソッド (またはコンストラクター、イニシャライザー) で同等の式が複数回使用されており、その式の結果を再利用できる場合に報告します。 式は副作用がなく、かつ ('Object.equals()' について) 結果が常に同じである場合に報告されます。 このような式の例としては、'a + b'、'Math.max(a, b)'、'a.equals(b)'、's.substring(a,b)' などが挙げられます。 常に同じ結果を得られるようにするため、式の中で使用される変数によって各式の値が変更されないことが確認されます。 このような式には、'String' や 'BigDecimal' などのイミュータブルなクラスのメソッドのほか、'Objects' や 'Math' ('random()' を除く) などのユーティリティクラスのメソッドが含まれる場合があります。 'Object.equals()'、'Object.hashCode()'、'Object.toString()'、 'Comparable.compareTo()'、'Comparator.compare()' などの一般的なメソッドも目に見える副作用が無いため、問題なく使用できます。 式の複雑度の最小しきい値を指定するには、「式の複雑度のしきい値」オプションを使用します。 それよりも大きな数値を指定すると、短い式に関する報告が省かれます。 同じ引数がある場合、'Path.of' と 'Paths.get' の呼び出しは同等のものとして扱われます。 このような呼び出しは、どんなに引数が複雑であっても常に報告されます。 この動作は、さまざまな複雑度のしきい値を使用して調整可能です。 2018.3 の新機能です",
                  "markdown": "あるメソッド (またはコンストラクター、イニシャライザー) で同等の式が複数回使用されており、その式の結果を再利用できる場合に報告します。\n\n\n式は副作用がなく、かつ (`Object.equals()` について) 結果が常に同じである場合に報告されます。\nこのような式の例としては、`a + b`、`Math.max(a, b)`、`a.equals(b)`、`s.substring(a,b)` などが挙げられます。 常に同じ結果を得られるようにするため、式の中で使用される変数によって各式の値が変更されないことが確認されます。\n\n\nこのような式には、`String` や `BigDecimal` などのイミュータブルなクラスのメソッドのほか、`Objects` や `Math` (`random()` を除く) などのユーティリティクラスのメソッドが含まれる場合があります。\n`Object.equals()`、`Object.hashCode()`、`Object.toString()`、\n`Comparable.compareTo()`、`Comparator.compare()` などの一般的なメソッドも目に見える副作用が無いため、問題なく使用できます。\n\n\n式の複雑度の最小しきい値を指定するには、「**式の複雑度のしきい値**」オプションを使用します。 それよりも大きな数値を指定すると、短い式に関する報告が省かれます。\n\n\n同じ引数がある場合、`Path.of` と `Paths.get` の呼び出しは同等のものとして扱われます。 このような呼び出しは、どんなに引数が複雑であっても常に報告されます。 この動作は、さまざまな複雑度のしきい値を使用して調整可能です。\n\n2018.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DuplicateExpressions",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryReturn",
                "shortDescription": {
                  "text": "不要な 'return' ステートメント"
                },
                "fullDescription": {
                  "text": "'void' を返しているコンストラクターとメソッドの最後にある 'return' ステートメントを報告します。 このようなステートメントは冗長であり、安全に除去できます。 このインスペクションは JSP ファイルでは報告しません。 例: 'void message() {\n    System.out.println(\"Hello World\");\n    return;\n  }' クイックフィックス適用後: 'void message() {\n    System.out.println(\"Hello World\");\n  }' 'if' ステートメントの then 分岐にも 'else' 分岐がある 'return' ステートメントを無視するには、「'else' 分岐のある 'if' ステートメントの then 分岐で無視する」オプションを使用します。",
                  "markdown": "`void` を返しているコンストラクターとメソッドの最後にある `return` ステートメントを報告します。 このようなステートメントは冗長であり、安全に除去できます。\n\nこのインスペクションは JSP ファイルでは報告しません。\n\n例:\n\n\n      void message() {\n        System.out.println(\"Hello World\");\n        return;\n      }\n\nクイックフィックス適用後:\n\n\n      void message() {\n        System.out.println(\"Hello World\");\n      }\n\n\n`if` ステートメントの then 分岐にも `else` 分岐がある `return` ステートメントを無視するには、「**'else' 分岐のある 'if' ステートメントの then 分岐で無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryReturnStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicInnerClass",
                "shortDescription": {
                  "text": "'public' ネストクラス"
                },
                "fullDescription": {
                  "text": "'public' のネストしたクラスを報告します。 例: 'public class Outer {\n    public static class Nested {} // 警告\n    public class Inner {}         // 警告\n    public enum Mode {}           // 設定に応じて警告\n    public interface I {}         // 設定に応じて警告\n  }' インスペクションの構成: 'public' 内の列挙型を無視するには、「'public' 内の列挙型を無視する」オプションを使用します。 'public' 内のインターフェースを無視するには、「'public' 内のインターフェースを無視する」オプションを使用します。",
                  "markdown": "`public` のネストしたクラスを報告します。\n\n**例:**\n\n\n      public class Outer {\n        public static class Nested {} // 警告\n        public class Inner {}         // 警告\n        public enum Mode {}           // 設定に応じて警告\n        public interface I {}         // 設定に応じて警告\n      }\n\nインスペクションの構成:\n\n* `public` 内の列挙型を無視するには、「**'public' 内の列挙型を無視する**」オプションを使用します。\n* `public` 内のインターフェースを無視するには、「**'public' 内のインターフェースを無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/カプセル化",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanConstructor",
                "shortDescription": {
                  "text": "Boolean コンストラクターの呼び出し"
                },
                "fullDescription": {
                  "text": "'Boolean' オブジェクトの作成を報告します。 新しい 'Boolean' オブジェクトの構築が必要になることはまれであり、頻繁に構築しすぎるとパフォーマンスの問題が発生する場合があります。 また、'Boolean' コンストラクターは Java 9 以降は非推奨となっており、今後の Java バージョンでは廃止されるか、アクセスできなくなる可能性があります。 例: 'Boolean b1 = new Boolean(true);\n  Boolean b2 = new Boolean(str);' クイックフィックス適用後: 'Boolean b1 = Boolean.TRUE;\n  Boolean b2 = Boolean.valueOf(str);'",
                  "markdown": "`Boolean` オブジェクトの作成を報告します。\n\n\n新しい `Boolean` オブジェクトの構築が必要になることはまれであり、頻繁に構築しすぎるとパフォーマンスの問題が発生する場合があります。 また、`Boolean` コンストラクターは Java 9 以降は非推奨となっており、今後の Java バージョンでは廃止されるか、アクセスできなくなる可能性があります。\n\n**例:**\n\n\n      Boolean b1 = new Boolean(true);\n      Boolean b2 = new Boolean(str);\n\nクイックフィックス適用後:\n\n\n      Boolean b1 = Boolean.TRUE;\n      Boolean b2 = Boolean.valueOf(str);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanConstructorCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalGuard",
                "shortDescription": {
                  "text": "非 final '@GuardedBy' フィールド"
                },
                "fullDescription": {
                  "text": "ガード対象のフィールドが 'final' でない '@GuardedBy' アノテーションを報告します。 非 final フィールドをガードすると、そのフィールド自体ではなく、フィールドの値 (可変) がロックされます。そのため、予期しない競合状態が発生する可能性があります。 例: 'private ReadWriteLock lock = new ReentrantReadWriteLock(); // 非 final のフィールドをガード\n    private Object state;\n\n    @GuardedBy(\"lock\")\n    public void bar() {\n        state = new Object();\n    }' サポート対象の '@GuardedBy' アノテーションは以下の通りです。 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "ガード対象のフィールドが `final` でない `@GuardedBy` アノテーションを報告します。\n\n非 final フィールドをガードすると、そのフィールド自体ではなく、フィールドの値 (可変) がロックされます。そのため、予期しない競合状態が発生する可能性があります。\n\n例:\n\n\n        private ReadWriteLock lock = new ReentrantReadWriteLock(); // 非 final のフィールドをガード\n        private Object state;\n\n        @GuardedBy(\"lock\")\n        public void bar() {\n            state = new Object();\n        }\n\nサポート対象の `@GuardedBy` アノテーションは以下の通りです。\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalGuard",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/並行処理に関するアノテーションの問題",
                      "index": 58,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TooBroadScope",
                "shortDescription": {
                  "text": "スコープが広すぎる変数"
                },
                "fullDescription": {
                  "text": "より小さなスコープに移動できる変数宣言を報告します。 この宣言は、主にメソッド開始部の Pascal 形式宣言に役立ちます。 また、スコープが広すぎる変数もリファクタリング後に残っていることがよくあります。 例: 'StringBuilder sb = new StringBuilder();\n  System.out.println();\n  sb.append(1);' クイックフィックス適用後: 'System.out.println();\n  StringBuilder sb = new StringBuilder();\n  sb.append(1);' インスペクションの構成: より深いコードブロック内に移動できる変数のみを報告するには、「内部ブロックに移動できる変数のみを報告する」オプションを使用します。 たとえば、このオプションが有効な場合には上記の 'sb' 変数の移動は提案されません。 しかし、次のコードに対しては移動が提案されます。 'StringBuilder sb = new StringBuilder(a);\n  if (flag) {\n    sb.append(1);\n  }' new 式で初期化されている変数のみを報告するには、「new 式をイニシャライザーとして持つ変数を報告する (安全でない可能性があります)」オプションを使用します。 この場合、コンストラクターに非ローカルの副作用があるとインスペクションが安全ではなくなる可能性があります。 たとえば、このオプションが有効な場合には 'foo' 変数の移動が提案されます。 'class Foo {\n    static List<Foo> fooList = new ArrayList<>();\n    String bar;\n\n    Foo(String bar) {\n        this.bar = bar;\n        fooList.add(this);\n    }\n\n    public static void main(String[] args) {\n      // 安全ではないですが移動可能です\n      Foo foo = new Foo(\"bar\");\n      System.out.println(fooList.size());\n      System.out.println(foo.bar);\n    }\n  }'",
                  "markdown": "より小さなスコープに移動できる変数宣言を報告します。\n\nこの宣言は、主にメソッド開始部の *Pascal 形式*宣言に役立ちます。 また、スコープが広すぎる変数もリファクタリング後に残っていることがよくあります。\n\n**例:**\n\n\n      StringBuilder sb = new StringBuilder();\n      System.out.println();\n      sb.append(1);\n\nクイックフィックス適用後:\n\n\n      System.out.println();\n      StringBuilder sb = new StringBuilder();\n      sb.append(1);\n\nインスペクションの構成:\n\n* より深いコードブロック内に移動できる変数のみを報告するには、「**内部ブロックに移動できる変数のみを報告する** 」オプションを使用します。 たとえば、このオプションが有効な場合には上記の `sb` 変数の移動は提案されません。 しかし、次のコードに対しては移動が提案されます。\n\n\n        StringBuilder sb = new StringBuilder(a);\n        if (flag) {\n          sb.append(1);\n        }\n\n* new 式で初期化されている変数のみを報告するには、「**new 式をイニシャライザーとして持つ変数を報告する (安全でない可能性があります)** 」オプションを使用します。 この場合、コンストラクターに非ローカルの副作用があるとインスペクションが安全ではなくなる可能性があります。 たとえば、このオプションが有効な場合には `foo` 変数の移動が提案されます。\n\n\n        class Foo {\n          static List<Foo> fooList = new ArrayList<>();\n          String bar;\n\n          Foo(String bar) {\n              this.bar = bar;\n              fooList.add(this);\n          }\n\n          public static void main(String[] args) {\n            // 安全ではないですが移動可能です\n            Foo foo = new Foo(\"bar\");\n            System.out.println(fooList.size());\n            System.out.println(foo.bar);\n          }\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TooBroadScope",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/データフロー",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CollectionAddedToSelf",
                "shortDescription": {
                  "text": "自身に追加されているコレクション"
                },
                "fullDescription": {
                  "text": "'java.util.Collection' または 'java.util.Map' に対するメソッド呼び出しの引数が、コレクションまたはそれ自身にマップしている場合に報告します。 このような状況は、raw 型を含むコードでコピーペーストを行うと発生する可能性があります。 例: 'ArrayList list = new ArrayList<>();\n  list.add(list); // ここで警告が発生します\n  return list.hashCode(); // StackOverflowError がスローされます'",
                  "markdown": "`java.util.Collection` または `java.util.Map` に対するメソッド呼び出しの引数が、コレクションまたはそれ自身にマップしている場合に報告します。 このような状況は、raw 型を含むコードでコピーペーストを行うと発生する可能性があります。\n\n**例:**\n\n\n      ArrayList list = new ArrayList<>();\n      list.add(list); // ここで警告が発生します\n      return list.hashCode(); // StackOverflowError がスローされます\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionAddedToSelf",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfStatementMissingBreakInLoop",
                "shortDescription": {
                  "text": "'if' 条件での早期ループ終了"
                },
                "fullDescription": {
                  "text": "セマンティクスを変更せずに 'break' で終了できる 'if' ステートメントがあるループを報告します。 そのように終了することで、冗長なループの反復処理を防ぎます。 例: 'boolean found = false;\n  for (int i = 0; i < arr.length; i++) {\n    if (Objects.equals(value, arr[i])) {\n      found = true;\n    }\n  }' クイックフィックス適用後: 'boolean found = false;\n  for (int i = 0; i < arr.length; i++) {\n    if (Objects.equals(value, arr[i])) {\n      found = true;\n      break;\n    }\n  }' 2019.2 の新機能です",
                  "markdown": "セマンティクスを変更せずに `break` で終了できる `if` ステートメントがあるループを報告します。 そのように終了することで、冗長なループの反復処理を防ぎます。\n\n**例:**\n\n\n      boolean found = false;\n      for (int i = 0; i < arr.length; i++) {\n        if (Objects.equals(value, arr[i])) {\n          found = true;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      boolean found = false;\n      for (int i = 0; i < arr.length; i++) {\n        if (Objects.equals(value, arr[i])) {\n          found = true;\n          break;\n        }\n      }\n\n2019.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IfStatementMissingBreakInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowableSupplierOnlyThrowException",
                "shortDescription": {
                  "text": "Throwable サプライヤーが値を返すことはありません"
                },
                "fullDescription": {
                  "text": "例外を返す代わりにスローしている 'Optional.orElseThrow()' 呼び出し内の 'Supplier' ラムダを報告します。 例: 'optional.orElseThrow(() -> {\n    throw new RuntimeException();\n});' クイックフィックス適用後: 'optional.orElseThrow(() -> new RuntimeException());' 2023.1 の新機能です",
                  "markdown": "例外を返す代わりにスローしている `Optional.orElseThrow()` 呼び出し内の `Supplier` ラムダを報告します。\n\n**例:**\n\n\n    optional.orElseThrow(() -> {\n        throw new RuntimeException();\n    });\n\nクイックフィックス適用後:\n\n\n    optional.orElseThrow(() -> new RuntimeException());\n\n2023.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowableSupplierOnlyThrowException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantStreamOptionalCall",
                "shortDescription": {
                  "text": "'Stream' または 'Optional' 呼び出しチェーンの冗長なステップ"
                },
                "fullDescription": {
                  "text": "'map(x -> x)' または 'filter(x -> true)' などの冗長な 'Stream' または 'Optional' の呼び出し、冗長な 'sorted' または 'distinct' の呼び出しを報告します。 'streamOfIntegers.map(Integer::valueOf)' のようなコードでのマッピング操作は、'requireNonNull()' として機能します。ストリームに 'null' が含まれている場合は 'NullPointerException' がスローされるため、まったく冗長ではありません。 このような場合に報告しないようにするには、「Stream.map() の冗長なボクシングを報告する」オプションを無効にします。 このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "`map(x -> x)` または `filter(x -> true)` などの冗長な `Stream` または `Optional` の呼び出し、冗長な `sorted` または `distinct` の呼び出しを報告します。\n\n`streamOfIntegers.map(Integer::valueOf)` のようなコードでのマッピング操作は、`requireNonNull()` として機能します。ストリームに `null` が含まれている場合は `NullPointerException` がスローされるため、まったく冗長ではありません。\nこのような場合に報告しないようにするには、「**Stream.map() の冗長なボクシングを報告する**」オプションを無効にします。\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantStreamOptionalCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarySuperQualifier",
                "shortDescription": {
                  "text": "不要な 'super' 修飾子"
                },
                "fullDescription": {
                  "text": "メソッド呼び出しとフィールド参照内の不要な 'super' 修飾子を報告します。 スーパークラスのフィールドまたはメソッドが呼び出し元のクラスで不可視になっていない/オーバーライドされていない場合、'super' 修飾子は不要です。 例: 'class Foo {\n    void foo() {}\n  }\n\n  class Bar extends Foo {\n    void bar() {\n      super.foo();\n    }\n  }' クイックフィックス適用後: 'class Foo {\n    void foo() {}\n  }\n\n  class Bar extends Foo {\n    void bar() {\n      foo();\n    }\n  }' スーパークラスメンバーのアクセスを外部クラスと名前がまったく同じメンバーと区別するための修飾子を無視するには、インスペクションの設定を使用します。 次のインスペクションも参照してください。 Java | 可視性 | 外側のコード内要素へのアクセスに見える継承フィールドのアクセス Java | 可視性 | ローカルメソッド呼び出しに見える継承されたメソッド呼び出し",
                  "markdown": "メソッド呼び出しとフィールド参照内の不要な `super` 修飾子を報告します。\n\n\nスーパークラスのフィールドまたはメソッドが呼び出し元のクラスで不可視になっていない/オーバーライドされていない場合、`super` 修飾子は不要です。\n\n**例:**\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          super.foo();\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          foo();\n        }\n      }\n\n\nスーパークラスメンバーのアクセスを外部クラスと名前がまったく同じメンバーと区別するための修飾子を無視するには、インスペクションの設定を使用します。\n\n\n次のインスペクションも参照してください。\n\n* *Java \\| 可視性 \\| 外側のコード内要素へのアクセスに見える継承フィールドのアクセス*\n* *Java \\| 可視性 \\| ローカルメソッド呼び出しに見える継承されたメソッド呼び出し*"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessarySuperQualifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadPriority",
                "shortDescription": {
                  "text": "'Thread.setPriority()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'Thread.setPriority()' の呼び出しを報告します。 スレッドの優先順位変更は本質的に移植性のない操作です。Java の仕様では、優先順位がスレッドのスケジューリングでどのように使用されるかも、そもそも使用されるかどうかも保証されていないためです。",
                  "markdown": "`Thread.setPriority()` の呼び出しを報告します。 スレッドの優先順位変更は本質的に移植性のない操作です。Java の仕様では、優先順位がスレッドのスケジューリングでどのように使用されるかも、そもそも使用されるかどうかも保証されていないためです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadSetPriority",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsOnSuspiciousObject",
                "shortDescription": {
                  "text": "'equals()' がそれをオーバーライドしないクラスに対して呼び出されています"
                },
                "fullDescription": {
                  "text": "'StringBuilder'、'StringBuffer'、および 'java.util.concurrent.atomic' パッケージのインスタンスに対する 'equals()' 呼び出しを報告します。 'equals()' メソッドはこれらのクラスではオーバーライドされていないため、2 つのオブジェクトの中身が同じであっても、'false' を返す可能性があります。 参照の等価比較を意図している場合は、混乱を避けるために '==' を使用することをお勧めします。 中身の比較に変換するための 'StringBuilder'、'StringBuffer'、'AtomicBoolean'、'AtomicInteger'、'AtomicBoolean' および 'AtomicLong' 用のクイックフィックスを使用できます。 このクイックフィックスはインスタンスのいずれかが null の場合にセマンティクスを変更する場合があります。 例: 'public void test(StringBuilder sb1, StringBuilder sb2) {\n    boolean result = sb1.equals(sb2); // 疑わしいコード\n  }' クイックフィックス適用後: 'public void test(StringBuilder sb1, StringBuilder sb2) {\n      boolean result = sb1.toString().equals(sb2.toString());\n  }' 2017.2 の新機能です",
                  "markdown": "`StringBuilder`、`StringBuffer`、および `java.util.concurrent.atomic` パッケージのインスタンスに対する `equals()` 呼び出しを報告します。\n\n`equals()` メソッドはこれらのクラスではオーバーライドされていないため、2 つのオブジェクトの中身が同じであっても、`false` を返す可能性があります。\n参照の等価比較を意図している場合は、混乱を避けるために `==` を使用することをお勧めします。\n中身の比較に変換するための `StringBuilder`、`StringBuffer`、`AtomicBoolean`、`AtomicInteger`、`AtomicBoolean` および `AtomicLong` 用のクイックフィックスを使用できます。 このクイックフィックスはインスタンスのいずれかが null の場合にセマンティクスを変更する場合があります。\n\n例:\n\n\n      public void test(StringBuilder sb1, StringBuilder sb2) {\n        boolean result = sb1.equals(sb2); // 疑わしいコード\n      }\n\nクイックフィックス適用後:\n\n\n      public void test(StringBuilder sb1, StringBuilder sb2) {\n          boolean result = sb1.toString().equals(sb2.toString());\n      }\n\n2017.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsOnSuspiciousObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfPropertiesAsHashtable",
                "shortDescription": {
                  "text": "'Hashtable' としての 'Properties' オブジェクトの使用"
                },
                "fullDescription": {
                  "text": "'java.util.Properties' オブジェクトに対する次のメソッドの呼び出しを報告します。 'put()' 'putIfAbsent()' 'putAll()' 'get()' 歴史的な理由から、'java.util.Properties' は 'java.util.Hashtable' から継承しますが、'String' 型以外のプロパティ値の汚染を防ぐ目的でこれらのメソッドを使用することはお勧めしません。 マップ内のキーパラメーターと値パラメーターの両方が 'String' 型の場合、'java.util.Properties.putAll()' への呼び出しは報告されません。 このような呼び出しは安全であるため、より良い代替コードは存在しません。 例: 'Object f(Properties props) {\n    props.put(\"hello\", \"world\");\n    props.putIfAbsent(\"hello\", \"world\");\n    props.putAll(new HashMap<>());\n    return props.get(\"Hello\");\n  }' クイックフィックス適用後: 'Object f(Properties props) {\n    props.setProperty(\"hello\", \"world\");\n    props.putIfAbsent(\"hello\", \"world\");\n    props.putAll(new HashMap<>());\n    return props.getProperty(\"hello\");\n  }'",
                  "markdown": "`java.util.Properties` オブジェクトに対する次のメソッドの呼び出しを報告します。\n\n* `put()`\n* `putIfAbsent()`\n* `putAll()`\n* `get()`\n\n\n歴史的な理由から、`java.util.Properties` は `java.util.Hashtable` から継承しますが、`String` 型以外のプロパティ値の汚染を防ぐ目的でこれらのメソッドを使用することはお勧めしません。\n\n\nマップ内のキーパラメーターと値パラメーターの両方が `String` 型の場合、`java.util.Properties.putAll()` への呼び出しは報告されません。\nこのような呼び出しは安全であるため、より良い代替コードは存在しません。\n\n**例:**\n\n\n      Object f(Properties props) {\n        props.put(\"hello\", \"world\");\n        props.putIfAbsent(\"hello\", \"world\");\n        props.putAll(new HashMap<>());\n        return props.get(\"Hello\");\n      }\n\nクイックフィックス適用後:\n\n\n      Object f(Properties props) {\n        props.setProperty(\"hello\", \"world\");\n        props.putIfAbsent(\"hello\", \"world\");\n        props.putAll(new HashMap<>());\n        return props.getProperty(\"hello\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfPropertiesAsHashtable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodCoupling",
                "shortDescription": {
                  "text": "過度に結合されたメソッド"
                },
                "fullDescription": {
                  "text": "他のクラスへの参照が多すぎるメソッドを報告します。 結合が多すぎるメソッドは非常に脆弱な場合があるため、より小さな複数のメソッドに分割する必要があるかもしれません。 参照先の各クラスは、その参照回数にかかわらず 1 回だけカウントされます。 インスペクションの構成: メソッドで許容される結合数の最大値を指定するには、「メソッド結合の制限」フィールドを使用します。 'java' または 'javax' パッケージ内のクラスへの参照をカウントするには、「Java システムクラスへの結合を含める」オプションを使用します。 サードパーティのライブラリクラスへの参照をカウントするには、「ライブラリクラスへの結合を含める」オプションを使用します。",
                  "markdown": "他のクラスへの参照が多すぎるメソッドを報告します。 結合が多すぎるメソッドは非常に脆弱な場合があるため、より小さな複数のメソッドに分割する必要があるかもしれません。\n\n参照先の各クラスは、その参照回数にかかわらず 1 回だけカウントされます。\n\nインスペクションの構成:\n\n* メソッドで許容される結合数の最大値を指定するには、「**メソッド結合の制限**」フィールドを使用します。\n* `java` または `javax` パッケージ内のクラスへの参照をカウントするには、「**Java システムクラスへの結合を含める**」オプションを使用します。\n* サードパーティのライブラリクラスへの参照をカウントするには、「**ライブラリクラスへの結合を含める**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyCoupledMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メソッドメトリクス",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalFieldOfException",
                "shortDescription": {
                  "text": "'Exception' クラスの非 final フィールド"
                },
                "fullDescription": {
                  "text": "'final' で宣言されていない 'java.lang.Exception' のサブクラスにあるフィールドを報告します。 例外オブジェクトのデータは変更すべきではありません。変更した場合、後でデバッグしたりログを記録するためのエラーコンテキストが失われる可能性があります。 例: 'public class EditorException extends Exception {\n    private String message; // 警告: 例外クラスに非 final フィールド 'message' があります\n  }'",
                  "markdown": "`final` で宣言されていない `java.lang.Exception` のサブクラスにあるフィールドを報告します。\n\n例外オブジェクトのデータは変更すべきではありません。変更した場合、後でデバッグしたりログを記録するためのエラーコンテキストが失われる可能性があります。\n\n**例:**\n\n\n      public class EditorException extends Exception {\n        private String message; // 警告: 例外クラスに非 final フィールド 'message' があります\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldOfException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantStringFormatCall",
                "shortDescription": {
                  "text": "冗長な 'String.format()' 呼び出し"
                },
                "fullDescription": {
                  "text": "安全に除去または単純化できる 'format()' や 'printf()' のようなメソッドの呼び出しを報告します。 例: 'System.out.println(String.format(\"Total count: %d\", 42));' クイックフィックス適用後: 'System.out.printf(\"Total count: %d%n\", 42);'",
                  "markdown": "安全に除去または単純化できる `format()` や `printf()` のようなメソッドの呼び出しを報告します。\n\n**例:**\n\n\n      System.out.println(String.format(\"Total count: %d\", 42));\n\nクイックフィックス適用後:\n\n\n      System.out.printf(\"Total count: %d%n\", 42);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantStringFormatCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessNullCheck",
                "shortDescription": {
                  "text": "メソッド呼び出し前の不要な 'null' チェック"
                },
                "fullDescription": {
                  "text": "'null' が渡されると必ず 'false' を返すメソッド (例: 'Class.isInstance') の呼び出しに先行する 'null' チェックを報告します。 このような場合はメソッドの呼び出しが常に 'false' を返すため、このようなチェックは過剰であると思われます。 例: 'if (x != null && myClass.isInstance(x)) { ... }' クイックフィックス適用後: 'if (myClass.isInstance(x)) { ... }'",
                  "markdown": "`null` が渡されると必ず `false` を返すメソッド (例: `Class.isInstance`) の呼び出しに先行する `null` チェックを報告します。\n\nこのような場合はメソッドの呼び出しが常に `false` を返すため、このようなチェックは過剰であると思われます。\n\n**例:**\n\n\n      if (x != null && myClass.isInstance(x)) { ... }\n\nクイックフィックス適用後:\n\n\n      if (myClass.isInstance(x)) { ... }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessNullCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AccessToStaticFieldLockedOnInstance",
                "shortDescription": {
                  "text": "インスタンスデータにロックされた 'static' フィールドへのアクセス"
                },
                "fullDescription": {
                  "text": "'this' または 'this' のインスタンスフィールドのいずれかでロックされている非定数の static フィールドへのアクセスを報告します。 インスタンスデータの static フィールドをロックしても、そのフィールドが他のインスタンスによって変更されるのを防ぐことはできないため、予期しない競合状態が発生する可能性があります。 例: 'static String test;\n  public void foo() {\n      synchronized (this) {\n          System.out.println(test); // 警告\n      }\n  }' 特定の型の static フィールドを無視できるようにするクイックフィックスがあります。 このような無視対象の型は、インスペクションのオプションで管理できます。 static フィールドに使用されるクラスを無視するように指定するには、インスペクションのオプションを使用します。",
                  "markdown": "`this` または `this` のインスタンスフィールドのいずれかでロックされている非定数の static フィールドへのアクセスを報告します。\n\n\nインスタンスデータの static フィールドをロックしても、そのフィールドが他のインスタンスによって変更されるのを防ぐことはできないため、予期しない競合状態が発生する可能性があります。\n\n**例:**\n\n\n      static String test;\n      public void foo() {\n          synchronized (this) {\n              System.out.println(test); // 警告\n          }\n      }\n\n\n特定の型の static フィールドを無視できるようにするクイックフィックスがあります。\nこのような無視対象の型は、インスペクションのオプションで管理できます。\n\n\nstatic フィールドに使用されるクラスを無視するように指定するには、インスペクションのオプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessToStaticFieldLockedOnInstance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodOverridesStaticMethod",
                "shortDescription": {
                  "text": "メソッドはスーパークラスの 'static' メソッドをオーバーライドしようとしています"
                },
                "fullDescription": {
                  "text": "スーパークラスの 'static' メソッドと同じシグネチャーを持つ 'static' メソッドを報告します。 このようなメソッドは、実際にはスーパークラスのメソッドを不可視にしていても、オーバーライドのように見える可能性があります。Java では 'static' メソッドをオーバーライドできないためです。 例: 'class Parent {\n    static void method(){}\n  }\n\n  class Example extends Parent {\n    static void method(){} //警告\n  }'",
                  "markdown": "スーパークラスの `static` メソッドと同じシグネチャーを持つ `static` メソッドを報告します。 このようなメソッドは、実際にはスーパークラスのメソッドを不可視にしていても、オーバーライドのように見える可能性があります。Java では `static` メソッドをオーバーライドできないためです。\n\n**例:**\n\n\n      class Parent {\n        static void method(){}\n      }\n\n      class Example extends Parent {\n        static void method(){} //警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodOverridesStaticMethodOfSuperclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnclearBinaryExpression",
                "shortDescription": {
                  "text": "優先順位の異なる複数の演算子"
                },
                "fullDescription": {
                  "text": "異なる演算子で構成されているにも関わらず、波括弧が使用されていないバイナリ、条件式、または 'instanceof' 式を報告します。 このような式は演算子の優先順位ルールが異なるため、読みにくい可能性があります。 例: 'int n = 3 + 9 * 8 + 1;' クイックフィックス適用後: 'int n = 3 + (9 * 8) + 1;'",
                  "markdown": "異なる演算子で構成されているにも関わらず、波括弧が使用されていないバイナリ、条件式、または `instanceof` 式を報告します。 このような式は演算子の優先順位ルールが異なるため、読みにくい可能性があります。\n\n例:\n\n\n      int n = 3 + 9 * 8 + 1;\n\nクイックフィックス適用後:\n\n\n      int n = 3 + (9 * 8) + 1;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnclearExpression",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VariableTypeCanBeExplicit",
                "shortDescription": {
                  "text": "明示的にできる変数型"
                },
                "fullDescription": {
                  "text": "明示的な型に置換できる 'var' 型のローカル変数を報告します。 例: 'var str = \"Hello\";' クイックフィックス適用後: 'String str = \"Hello\";' このインスペクションは Java 10 以降で使用できる Java の機能 'ローカル変数の型推論' に依存しています。",
                  "markdown": "明示的な型に置換できる `var` 型のローカル変数を報告します。\n\n**例:**\n\n\n      var str = \"Hello\";\n\nクイックフィックス適用後:\n\n\n      String str = \"Hello\";\n\nこのインスペクションは Java 10 以降で使用できる Java の機能 'ローカル変数の型推論' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "VariableTypeCanBeExplicit",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 10",
                      "index": 112,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChainedMethodCall",
                "shortDescription": {
                  "text": "チェーンメソッド呼び出し"
                },
                "fullDescription": {
                  "text": "ターゲットが別のメソッド呼び出しになっているメソッド呼び出しを報告します。 クイックフィックスは、ローカル変数の導入を提案します。 例: 'class X {\n    int foo(File f) {\n      return f.getName().length();\n    }\n  }' クイックフィックス適用後: 'class X {\n    int foo(File f) {\n      final String name = f.getName();\n      return name.length();\n    }\n  }' 次のケースで警告を表示するかどうかを切り替えるには、インスペクションのオプションを使用します。 'private final int i = new Random().nextInt();' のようなフィールド初期化子での連鎖メソッド呼び出し。 'new StringBuilder().append(\"x: \").append(new X()).append(\"y: \").append(new Y()).toString();' のような同じ型に対する連鎖メソッドの呼び出し。",
                  "markdown": "ターゲットが別のメソッド呼び出しになっているメソッド呼び出しを報告します。 クイックフィックスは、ローカル変数の導入を提案します。\n\n**例:**\n\n\n      class X {\n        int foo(File f) {\n          return f.getName().length();\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class X {\n        int foo(File f) {\n          final String name = f.getName();\n          return name.length();\n        }\n      }\n\n次のケースで警告を表示するかどうかを切り替えるには、インスペクションのオプションを使用します。\n\n*\n  `private final int i = new Random().nextInt();` のようなフィールド初期化子での連鎖メソッド呼び出し。\n\n*\n  `new StringBuilder().append(\"x: \").append(new X()).append(\"y: \").append(new Y()).toString();` のような同じ型に対する連鎖メソッドの呼び出し。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ChainedMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UtilityClassWithoutPrivateConstructor",
                "shortDescription": {
                  "text": "'private' コンストラクターのないユーティリティークラス"
                },
                "fullDescription": {
                  "text": "'private' コンストラクターのないユーティリティクラスを報告します。 ユーティリティクラスでは、すべてのフィールドとメソッドが 'static' で宣言されています。 ユーティリティクラスに 'private' コンストラクターを作成すると、誤ってインスタンス化されることを防ぐことができます。 特別なアノテーションを指定するには、「次のアノテーションが付いている場合は無視」オプションを使用します。 このインスペクションは、ここで指定されたアノテーションのいずれかが付いているクラスを無視します。 main メソッド以外にメソッドがないクラスを無視するには、「main メソッドのみを持つクラスを無視する」オプションを使用します。",
                  "markdown": "`private` コンストラクターのないユーティリティクラスを報告します。\n\nユーティリティクラスでは、すべてのフィールドとメソッドが `static` で宣言されています。 ユーティリティクラスに `private` コンストラクターを作成すると、誤ってインスタンス化されることを防ぐことができます。\n\n\n特別なアノテーションを指定するには、「**次のアノテーションが付いている場合は無視**」オプションを使用します。 このインスペクションは、ここで指定されたアノテーションのいずれかが付いているクラスを無視します。\n\n\nmain メソッド以外にメソッドがないクラスを無視するには、「**main メソッドのみを持つクラスを無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UtilityClassWithoutPrivateConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsUtilityClass",
                "shortDescription": {
                  "text": "ユーティリティクラスを拡張したクラス"
                },
                "fullDescription": {
                  "text": "ユーティリティクラスを拡張しているクラスを報告します。 ユーティリティクラスは、すべてのフィールドとメソッドが static である空でないクラスです。 ユーティリティクラスを拡張すると、不注意でユーティリティクラスをオブジェクトインスタンス化してしまう可能性があります。拡張可能にする目的でコンストラクターを private にすることはできないためです。 インスペクションの構成: ユーティリティクラスをオーバーライドしているものの、ユーティリティクラス自体でもあるクラスを無視するには、「オーバーライドしているクラスがユーティリティクラスの場合は無視する」オプションを使用します。",
                  "markdown": "ユーティリティクラスを拡張しているクラスを報告します。\n\n\nユーティリティクラスは、すべてのフィールドとメソッドが static である空でないクラスです。\nユーティリティクラスを拡張すると、不注意でユーティリティクラスをオブジェクトインスタンス化してしまう可能性があります。拡張可能にする目的でコンストラクターを private にすることはできないためです。\n\n\nインスペクションの構成:\n\n* ユーティリティクラスをオーバーライドしているものの、ユーティリティクラス自体でもあるクラスを無視するには、「**オーバーライドしているクラスがユーティリティクラスの場合は無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExtendsUtilityClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8ListSort",
                "shortDescription": {
                  "text": "'Collections.sort()' は 'List.sort()' に置換できます"
                },
                "fullDescription": {
                  "text": "'list.sort(comparator)' に置換できる 'Collections.sort(list, comparator)' の呼び出しを報告します。 'Collections.sort' は単なるラッパーであるため、インスタンスメソッドを直接使用することをお勧めします。 このインスペクションは Java 8 以降で使用できる Java の機能 'コレクション内のラムダメソッド' に依存しています。",
                  "markdown": "`list.sort(comparator)` に置換できる `Collections.sort(list, comparator)` の呼び出しを報告します。\n\n`Collections.sort` は単なるラッパーであるため、インスタンスメソッドを直接使用することをお勧めします。\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'コレクション内のラムダメソッド' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8ListSort",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertMessageNotString",
                "shortDescription": {
                  "text": "文字列ではない 'assert' メッセージ"
                },
                "fullDescription": {
                  "text": "'java.lang.String' 型のものではない 'assert' メッセージを報告します。 文字列を使用すると、失敗またはアサーションの理由を診断するのに役立つ詳細な情報を取得できます。 例: 'void foo(List<Integer> myList) {\n    assert myList.isEmpty() : false;\n  }' 'assert' メッセージ型が 'boolean' または 'java.lang.Boolean' の場合のみ警告するには、「'assert' メッセージ型が 'boolean' または 'java.lang.Boolean' の場合にのみ警告する」オプションを使用します。 'boolean' の詳細メッセージがアサーションの失敗に関する追加情報を提供する可能性はほぼありません。また、このようなコードは '&' ではなく ':' を誤って入力したことが原因で発生している可能性があります。 このインスペクションは Java 1.4 以降で使用できる Java の機能 'アサーション' に依存しています。",
                  "markdown": "`java.lang.String` 型のものではない `assert` メッセージを報告します。\n\n文字列を使用すると、失敗またはアサーションの理由を診断するのに役立つ詳細な情報を取得できます。\n\n**例:**\n\n\n      void foo(List<Integer> myList) {\n        assert myList.isEmpty() : false;\n      }\n\n\n`assert` メッセージ型が `boolean` または `java.lang.Boolean` の場合のみ警告するには、「**`assert` メッセージ型が 'boolean' または 'java.lang.Boolean' の場合にのみ警告する** 」オプションを使用します。\n`boolean` の詳細メッセージがアサーションの失敗に関する追加情報を提供する可能性はほぼありません。また、このようなコードは `&` ではなく `:` を誤って入力したことが原因で発生している可能性があります。\n\nこのインスペクションは Java 1.4 以降で使用できる Java の機能 'アサーション' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertMessageNotString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparatorCombinators",
                "shortDescription": {
                  "text": "'Comparator' 連結子を使用できます"
                },
                "fullDescription": {
                  "text": "ラムダ式として定義されている 'Comparator' インスタンスで、'Comparator.comparing()' 呼び出しを使用して表現できるものを報告します。 'Comparator.thenComparing()' 式に置換できる連鎖比較も報告されます。 例: 'myList.sort((person1, person2) -> person1.getName().compareTo(person2.getName()));\n\n  myList2.sort((person1, person2) -> {\n      int res = person1.first().compareTo(person2.first());\n      if(res == 0) res = person1.second().compareTo(person2.second());\n      if(res == 0) res = person1.third() - person2.third();\n      return res;\n  });' クイックフィックス適用後: 'myList.sort(Comparator.comparing(Person::getName));\n\n  myList2.sort(Comparator.comparing(Person::first)\n                         .thenComparing(Person::second)\n                         .thenComparingInt(Person::third));' このインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。",
                  "markdown": "ラムダ式として定義されている `Comparator` インスタンスで、`Comparator.comparing()` 呼び出しを使用して表現できるものを報告します。 `Comparator.thenComparing()` 式に置換できる連鎖比較も報告されます。\n\n例:\n\n\n      myList.sort((person1, person2) -> person1.getName().compareTo(person2.getName()));\n\n      myList2.sort((person1, person2) -> {\n          int res = person1.first().compareTo(person2.first());\n          if(res == 0) res = person1.second().compareTo(person2.second());\n          if(res == 0) res = person1.third() - person2.third();\n          return res;\n      });\n\nクイックフィックス適用後:\n\n\n      myList.sort(Comparator.comparing(Person::getName));\n\n      myList2.sort(Comparator.comparing(Person::first)\n                             .thenComparing(Person::second)\n                             .thenComparingInt(Person::third));\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparatorCombinators",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternVariableCanBeUsed",
                "shortDescription": {
                  "text": "パターン変数を使用できます"
                },
                "fullDescription": {
                  "text": "通常よりもコンパクトなパターン変数に置換できるローカル変数宣言を報告します。 例: 'if (obj instanceof String) {\n    String str = (String) obj;\n    System.out.println(str);\n  }' 上のコードは下のコードに置換できます。 'if (obj instanceof String str) {\n    System.out.println(str);\n  }' 2020.1 の新機能です このインスペクションは Java 16 以降で使用できる Java の機能 ''instanceof' のパターン' に依存しています。",
                  "markdown": "通常よりもコンパクトなパターン変数に置換できるローカル変数宣言を報告します。\n\n**例:**\n\n\n      if (obj instanceof String) {\n        String str = (String) obj;\n        System.out.println(str);\n      }\n\n上のコードは下のコードに置換できます。\n\n\n      if (obj instanceof String str) {\n        System.out.println(str);\n      }\n\n2020.1 の新機能です\n\nこのインスペクションは Java 16 以降で使用できる Java の機能 ''instanceof' のパターン' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PatternVariableCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 16",
                      "index": 113,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractMethodCallInConstructor",
                "shortDescription": {
                  "text": "オブジェクト構築中の抽象メソッド呼び出し"
                },
                "fullDescription": {
                  "text": "現在のクラスの 'abstract' メソッドが、オブジェクト構築中に呼び出されていることを報告します。 メソッドは、次の項目内にある場合にオブジェクト構築中に呼び出されます。 コンストラクター 非 static インスタンスイニシャライザー 非 static フィールドイニシャライザー 'clone()' メソッド 'readObject()' メソッド 'readObjectNoData()' メソッド このような呼び出しはバグの検出を困難にします。オブジェクトの初期化がメソッド呼び出しの前に発生する可能性があるためです。 例: 'abstract class Parent {\n    abstract void abstractMethod();\n  }\n\n  class Child extends Parent {\n    Child() {\n      abstractMethod();\n    }\n  }' このインスペクションは以下のインスペクションと機能を共有しています。 オブジェクト構築中のオーバーライド可能なメソッド呼び出し オブジェクト構築中のオーバーライドされたメソッド呼び出し 警告の重複を避けるため、同時に 1 つのインスペクションのみを有効にしてください。",
                  "markdown": "現在のクラスの `abstract` メソッドが、オブジェクト構築中に呼び出されていることを報告します。\n\nメソッドは、次の項目内にある場合にオブジェクト構築中に呼び出されます。\n\n* コンストラクター\n* 非 static インスタンスイニシャライザー\n* 非 static フィールドイニシャライザー\n* `clone()` メソッド\n* `readObject()` メソッド\n* `readObjectNoData()` メソッド\n\nこのような呼び出しはバグの検出を困難にします。オブジェクトの初期化がメソッド呼び出しの前に発生する可能性があるためです。\n\n**例:**\n\n\n      abstract class Parent {\n        abstract void abstractMethod();\n      }\n\n      class Child extends Parent {\n        Child() {\n          abstractMethod();\n        }\n      }\n\nこのインスペクションは以下のインスペクションと機能を共有しています。\n\n* オブジェクト構築中のオーバーライド可能なメソッド呼び出し\n* オブジェクト構築中のオーバーライドされたメソッド呼び出し\n\n警告の重複を避けるため、同時に 1 つのインスペクションのみを有効にしてください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractMethodCallInConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初期化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsReplaceableByObjectsCall",
                "shortDescription": {
                  "text": "'Objects.equals()' 式で置換可能な 'equals()' 式"
                },
                "fullDescription": {
                  "text": "'java.util.Objects#equals' の呼び出しに置換できる式を報告します。 例: 'void f(Object a, Object b) {\n    boolean result = a != null && a.equals(b);\n  }' クイックフィックス適用後: 'void f(Object a, Object b) {\n    boolean result = Objects.equals(a, b);\n  }' 'a != null && a.equals(b)' のような式を 'Objects.equals(a, b)' に置換すると、セマンティクスがわずかに変更されます。 この動作を有効または無効にするには、「'a != null \\&\\& a.equals(b)' のような式をハイライトする」オプションを使用します。 このインスペクションは Java 7 以降で使用できる Java の機能 'java.util.Objects API' に依存しています。",
                  "markdown": "`java.util.Objects#equals` の呼び出しに置換できる式を報告します。\n\n**例:**\n\n\n      void f(Object a, Object b) {\n        boolean result = a != null && a.equals(b);\n      }\n\nクイックフィックス適用後:\n\n\n      void f(Object a, Object b) {\n        boolean result = Objects.equals(a, b);\n      }\n\n\n`a != null && a.equals(b)` のような式を `Objects.equals(a, b)` に置換すると、セマンティクスがわずかに変更されます。 この動作を有効または無効にするには、「**'a != null \\\\\\&\\\\\\& a.equals(b)' のような式をハイライトする**」オプションを使用します。\n\nこのインスペクションは Java 7 以降で使用できる Java の機能 'java.util.Objects API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EqualsReplaceableByObjectsCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 7",
                      "index": 114,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitToExplicitClassBackwardMigration",
                "shortDescription": {
                  "text": "暗黙的に宣言されたクラスは通常のクラスに置換できます"
                },
                "fullDescription": {
                  "text": "暗黙的に宣言されているクラスを報告し、その通常クラスへの置換を提案します。 例 (Sample.java ファイル内): 'public static void main() {\n      System.out.println(\"Hello, world!\");\n  }' クイックフィックス適用後: 'public class Sample {\n    public static void main() {\n        System.out.println(\"Hello, world!\");\n    }\n}' このインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。 2024.1 の新機能です このインスペクションは Java 21-preview 以降で使用できる Java の機能 '暗黙的に宣言されたクラス' に依存しています。",
                  "markdown": "暗黙的に宣言されているクラスを報告し、その通常クラスへの置換を提案します。\n\n**例 (Sample.java ファイル内):**\n\n\n      public static void main() {\n          System.out.println(\"Hello, world!\");\n      }\n\nクイックフィックス適用後:\n\n\n    public class Sample {\n        public static void main() {\n            System.out.println(\"Hello, world!\");\n        }\n    }\n\n\nこのインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。\n\n2024.1 の新機能です\n\nこのインスペクションは Java 21-preview 以降で使用できる Java の機能 '暗黙的に宣言されたクラス' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ImplicitToExplicitClassBackwardMigration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 21",
                      "index": 75,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousClassVariableHidesContainingMethodVariable",
                "shortDescription": {
                  "text": "メソッドを含む変数を非表示にする匿名クラス変数"
                },
                "fullDescription": {
                  "text": "匿名クラスのフィールドのうち、外側のメソッドまたはラムダ式のローカル変数またはパラメーターと名前がまったく同じものを報告します。 このような命名を行うと、外側のメソッドの名前がまったく同じ変数やパラメーターが意図されている場合に匿名クラスのフィールドを誤って使用する可能性があります。 フィールドの名前を変更するクイックフィックスが提案されます。 例: 'class Test {\n    public Test(String value) {\n      Object foo = new Object() {\n        private String value = \"TEST\";\n        public void foo() {\n          System.out.println(value); //パラメーターではなくフィールドにアクセスしています\n        }\n      };\n    }\n  }'",
                  "markdown": "匿名クラスのフィールドのうち、外側のメソッドまたはラムダ式のローカル変数またはパラメーターと名前がまったく同じものを報告します。\n\n\nこのような命名を行うと、外側のメソッドの名前がまったく同じ変数やパラメーターが意図されている場合に匿名クラスのフィールドを誤って使用する可能性があります。\n\nフィールドの名前を変更するクイックフィックスが提案されます。\n\n**例:**\n\n\n      class Test {\n        public Test(String value) {\n          Object foo = new Object() {\n            private String value = \"TEST\";\n            public void foo() {\n              System.out.println(value); //パラメーターではなくフィールドにアクセスしています\n            }\n          };\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnonymousClassVariableHidesContainingMethodVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TailRecursion",
                "shortDescription": {
                  "text": "末尾再帰"
                },
                "fullDescription": {
                  "text": "末尾再帰、つまりメソッドが return を実行する前に自身を最後に呼び出しているメソッド呼び出しを報告します。 末尾再帰は常にループに置換できます。その結果、処理が大幅に高速化します。 一部の JVM は末尾呼び出しの最適化を行いますが、行わないものもあります。 そのため、末尾再帰の解決に関わるパフォーマンス特性は仮想マシンによって大きく異なります。 例: 'int factorial(int val, int runningVal) {\n    if (val == 1) {\n      return runningVal;\n    } else {\n      return factorial(val - 1, runningVal * val);\n    }\n  }' クイックフィックス適用後: 'int factorial(int val, int runningVal) {\n    while (true) {\n      if (val == 1) {\n        return runningVal;\n      } else {\n        runningVal = runningVal * val;\n        val = val - 1;\n      }\n    }\n  }'",
                  "markdown": "末尾再帰、つまりメソッドが return を実行する前に自身を最後に呼び出しているメソッド呼び出しを報告します。\n\n\n末尾再帰は常にループに置換できます。その結果、処理が大幅に高速化します。\n一部の JVM は末尾呼び出しの最適化を行いますが、行わないものもあります。 そのため、末尾再帰の解決に関わるパフォーマンス特性は仮想マシンによって大きく異なります。\n\n例:\n\n\n      int factorial(int val, int runningVal) {\n        if (val == 1) {\n          return runningVal;\n        } else {\n          return factorial(val - 1, runningVal * val);\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      int factorial(int val, int runningVal) {\n        while (true) {\n          if (val == 1) {\n            return runningVal;\n          } else {\n            runningVal = runningVal * val;\n            val = val - 1;\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TailRecursion",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodRefCanBeReplacedWithLambda",
                "shortDescription": {
                  "text": "ラムダで置換可能なメソッド参照"
                },
                "fullDescription": {
                  "text": "'MyClass::myMethod' や 'myObject::myMethod' などのメソッド参照を報告し、同等のラムダ式に置換することを提案します。 ラムダ式は、メソッド参照よりも簡単に編集できる場合があります。 例: 'System.out::println' クイックフィックス適用後: 's -> System.out.println(s)' デフォルトでは、このインスペクションはエディター内のコードをハイライトせず、クイックフィックスのみを提供します。 このインスペクションは以下の Java 機能に依存しています: メソッド参照 ラムダ式 これらの機能は Java 8 以降で使用できます。",
                  "markdown": "`MyClass::myMethod` や `myObject::myMethod` などのメソッド参照を報告し、同等のラムダ式に置換することを提案します。\n\nラムダ式は、メソッド参照よりも簡単に編集できる場合があります。\n\n例:\n\n\n      System.out::println\n\nクイックフィックス適用後:\n\n\n      s -> System.out.println(s)\n\nデフォルトでは、このインスペクションはエディター内のコードをハイライトせず、クイックフィックスのみを提供します。\n\nこのインスペクションは以下の Java 機能に依存しています:\n\n* メソッド参照\n* ラムダ式\n\nこれらの機能は Java 8 以降で使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MethodRefCanBeReplacedWithLambda",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedSynchronizedStatement",
                "shortDescription": {
                  "text": "ネストした 'synchronized' ステートメント"
                },
                "fullDescription": {
                  "text": "ネストした 'synchronized' ステートメントを報告します。 このようなステートメントは場合によってはデッドロックを引き起こす可能性があるため、同期のネストは可能な限り避けることをお勧めします。 例: 'synchronized (lockA){\n    //スレッド 1 が lockB を待機中\n    synchronized (lockB){ //警告\n    }\n  }\n  ...\n  synchronized (lockB) {\n    //スレッド 2 が lockA を待機中\n    synchronized (lockA) { //警告\n    }\n  }'",
                  "markdown": "ネストした `synchronized` ステートメントを報告します。 このようなステートメントは場合によってはデッドロックを引き起こす可能性があるため、同期のネストは可能な限り避けることをお勧めします。\n\n**例:**\n\n\n      synchronized (lockA){\n        //スレッド 1 が lockB を待機中\n        synchronized (lockB){ //警告\n        }\n      }\n      ...\n      synchronized (lockB) {\n        //スレッド 2 が lockA を待機中\n        synchronized (lockA) { //警告\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedSynchronizedStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringEqualsEmptyString",
                "shortDescription": {
                  "text": "'String.equals()' は 'String.isEmpty()' に置換できます"
                },
                "fullDescription": {
                  "text": "'String' を空の文字列と比較するために呼び出されている 'equals()' を報告します。 この場合は '.isEmpty()' を使用するほうが適切です。それにより、チェック対象が明確になるためです。 例: 'void checkString(String s){\n    if (\"\".equals(s)) throw new IllegalArgumentException();\n  }' クイックフィックス適用後: 'void checkString(String s){\n    if (s != null && s.isEmpty()) throw new IllegalArgumentException();\n  }' '\"\".equals(str)' は 'str' が null の場合に false を返却します。 安全を考慮し、このインスペクションのクイックフィックスは 'equals()' 引数が nullable な場合に明示的な null チェックを挿入します。 インスペクションにこのような場合を無視させるには、オプションを使用します。",
                  "markdown": "`String` を空の文字列と比較するために呼び出されている `equals()` を報告します。 この場合は `.isEmpty()` を使用するほうが適切です。それにより、チェック対象が明確になるためです。\n\n**例:**\n\n\n      void checkString(String s){\n        if (\"\".equals(s)) throw new IllegalArgumentException();\n      }\n\nクイックフィックス適用後:\n\n\n      void checkString(String s){\n        if (s != null && s.isEmpty()) throw new IllegalArgumentException();\n      }\n\n\n`\"\".equals(str)` は `str` が null の場合に false を返却します。 安全を考慮し、このインスペクションのクイックフィックスは `equals()` 引数が nullable な場合に明示的な null チェックを挿入します。 インスペクションにこのような場合を無視させるには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringEqualsEmptyString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncorrectDateTimeFormat",
                "shortDescription": {
                  "text": "正しくない 'DateTimeFormat' パターン"
                },
                "fullDescription": {
                  "text": "不正な日時形式のパターンを報告します。 次のエラーが報告されます。 \"TT\" などのサポートされていないパターン文字 \"#\" などの予約文字の使用 使い方が正しくないパディング 対になっていない角括弧 不正な数の連続するパターン文字 例: 'DateTimeFormatter.ofPattern(\"[][]]\"); // 始めの '[' がない終わりの ']'\n  DateTimeFormatter.ofPattern(\"TT\"); // 不正なパターン文字 'T'\n  DateTimeFormatter.ofPattern(\"{\"); // 予約文字 '{' の使用\n  DateTimeFormatter.ofPattern(\"MMMMMM\"); // 連続するパターン文字 'M' が多すぎます' 2022.3 の新機能です",
                  "markdown": "不正な日時形式のパターンを報告します。\n\n次のエラーが報告されます。\n\n* \"TT\" などのサポートされていないパターン文字\n* \"#\" などの予約文字の使用\n* 使い方が正しくないパディング\n* 対になっていない角括弧\n* 不正な数の連続するパターン文字\n\n例:\n\n\n      DateTimeFormatter.ofPattern(\"[][]]\"); // 始めの '[' がない終わりの ']'\n      DateTimeFormatter.ofPattern(\"TT\"); // 不正なパターン文字 'T'\n      DateTimeFormatter.ofPattern(\"{\"); // 予約文字 '{' の使用\n      DateTimeFormatter.ofPattern(\"MMMMMM\"); // 連続するパターン文字 'M' が多すぎます\n\n2022.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IncorrectDateTimeFormat",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PreviewFeature",
                "shortDescription": {
                  "text": "プレビュー機能の警告"
                },
                "fullDescription": {
                  "text": "プレビュー機能 API ('@PreviewFeature' アノテーションが付いた 'java.*' または 'javax.*' 名前空間内のモジュール、パッケージ、クラス、インターフェース、メソッド、コンストラクター、フィールド、列挙型定数) の使用箇所を報告します。 プレビュー機能は仕様化と実装が完了している Java 言語、Java 仮想マシン、または Java SE API の新機能ですが、まだ正式には導入されていません。 プレビュー機能の概念は、JEP 12 で定義されています。 この機能が変更または除去された場合、コードでプレビュー API を使用している場合は今後リリースされる JDK バージョンでコンパイルが停止する可能性があります。 このインスペクションは、プロジェクトまたはモジュールの言語レベルがプレビューの場合にのみ報告します。 2021.1 の新機能です",
                  "markdown": "プレビュー機能 API (` @PreviewFeature` アノテーションが付いた `java.*` または `javax.*` 名前空間内のモジュール、パッケージ、クラス、インターフェース、メソッド、コンストラクター、フィールド、列挙型定数) の使用箇所を報告します。\n\n\nプレビュー機能は仕様化と実装が完了している Java 言語、Java 仮想マシン、または Java SE API の新機能ですが、まだ正式には導入されていません。 プレビュー機能の概念は、[JEP 12](https://openjdk.org/jeps/12) で定義されています。\n\n\nこの機能が変更または除去された場合、コードでプレビュー API を使用している場合は今後リリースされる JDK バージョンでコンパイルが停止する可能性があります。\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが**プレビュー**の場合にのみ報告します。\n\n2021.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "preview",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コンパイラー関連の問題",
                      "index": 87,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TooBroadThrows",
                "shortDescription": {
                  "text": "広すぎる 'throws' 節"
                },
                "fullDescription": {
                  "text": "メソッドが実際にスローする例外よりも一般的な例外を含む 'throws' 節を報告します。 例: 'public void createFile() throws Exception { // 警告: 'throws Exception' が広すぎるため、例外 'IOException' がマスクされています\n    File file = new File(\"pathToFile\");\n    file.createNewFile();\n  }' クイックフィックス適用後: 'public void createFile() throws IOException {\n    File file = new File(\"pathToFile\");\n    file.createNewFile();\n  }' インスペクションの構成: 指定したよりも大きな数の他の例外を非表示にしている例外を無視するには、「警告する非表示の例外の最大数」フィールドを使用します。 このインスペクションで最も一般的な例外についてのみ警告するには、「RuntimeException、Exception、Error または Throwable についてのみ警告する」オプションを使用します。 ライブラリメソッドをオーバーライドするメソッド内の広すぎる 'throws' 節を無視するには、「ライブラリメソッドをオーバーライドするメソッドで宣言された例外を無視する」オプションを使用します。 他の例外を隠しているものの、なおメソッド本体からスローされる可能性があるため、厳密には広すぎない例外を無視するには、「他の例外を隠しているが、それ自体がスローされる例外を無視する」オプションを使用します。",
                  "markdown": "メソッドが実際にスローする例外よりも一般的な例外を含む `throws` 節を報告します。\n\n**例:**\n\n\n      public void createFile() throws Exception { // 警告: 'throws Exception' が広すぎるため、例外 'IOException' がマスクされています\n        File file = new File(\"pathToFile\");\n        file.createNewFile();\n      }\n\nクイックフィックス適用後:\n\n\n      public void createFile() throws IOException {\n        File file = new File(\"pathToFile\");\n        file.createNewFile();\n      }\n\nインスペクションの構成:\n\n* 指定したよりも大きな数の他の例外を非表示にしている例外を無視するには、「**警告する非表示の例外の最大数**」フィールドを使用します。\n* このインスペクションで最も一般的な例外についてのみ警告するには、「**RuntimeException、Exception、Error または Throwable についてのみ警告する**」オプションを使用します。\n* ライブラリメソッドをオーバーライドするメソッド内の広すぎる `throws` 節を無視するには、「**ライブラリメソッドをオーバーライドするメソッドで宣言された例外を無視する**」オプションを使用します。\n* 他の例外を隠しているものの、なおメソッド本体からスローされる可能性があるため、厳密には広すぎない例外を無視するには、「**他の例外を隠しているが、それ自体がスローされる例外を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyBroadThrowsClause",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitSubclassInspection",
                "shortDescription": {
                  "text": "実行時にオーバーライドできない final 宣言"
                },
                "fullDescription": {
                  "text": "実行時に一部のフレームワーク (Spring や Hibernate など) によるクラスのサブクラス化が阻害されている状況を報告します。 必要ながらもサブクラス化が不可能である一般的な例を以下に示します。 フレームワーク固有のアノテーション (Spring の '@Configuration' など) が付いた 'final' クラス フレームワーク固有のアノテーション (Spring の '@Transactional' など) が付いた 'final'、'static'、または 'private' メソッド 'final' クラス内でフレームワーク固有のアノテーションが付いたメソッド 報告対象の状況は、使用されているフレームワークによって決まります。",
                  "markdown": "実行時に一部のフレームワーク (Spring や Hibernate など) によるクラスのサブクラス化が阻害されている状況を報告します。\n\n必要ながらもサブクラス化が不可能である一般的な例を以下に示します。\n\n* フレームワーク固有のアノテーション (Spring の `@Configuration` など) が付いた `final` クラス\n* フレームワーク固有のアノテーション (Spring の `@Transactional` など) が付いた `final`、`static`、または `private` メソッド\n* `final` クラス内でフレームワーク固有のアノテーションが付いたメソッド\n\n報告対象の状況は、使用されているフレームワークによって決まります。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ImplicitSubclassInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryFullyQualifiedName",
                "shortDescription": {
                  "text": "不要な完全修飾名"
                },
                "fullDescription": {
                  "text": "完全修飾クラス名で、短縮できるものを報告します。 クイックフィックスを使用すると、完全修飾名が短縮され、必要に応じて import ステートメントが追加されます。 例: 'class ListWrapper {\n    java.util.List<Integer> l;\n  }' クイックフィックス適用後: 'import java.util.List;\n  class ListWrapper {\n    List<Integer> l;\n  }' インスペクションの構成: Java 9 の 'provides' と 'uses' モジュールステートメントの中で完全修飾名を無視する場合は、「Java 9 モジュールのステートメントで無視する」オプションを使用します。 このインスペクションは、「設定 | エディター | コードスタイル | Java | インポート」で以下のオプションを使用して構成できます。 内部クラスへの参照を外部クラスで修飾する必要がある場合は、「内部クラスのインポートを挿入する」オプションを使用します。 Javadoc で完全修飾名を使用できるようにするには、「Javadoc で完全修飾クラス名を使用する」オプションを使用します。",
                  "markdown": "完全修飾クラス名で、短縮できるものを報告します。\n\nクイックフィックスを使用すると、完全修飾名が短縮され、必要に応じて import ステートメントが追加されます。\n\n例:\n\n\n      class ListWrapper {\n        java.util.List<Integer> l;\n      }\n\nクイックフィックス適用後:\n\n\n      import java.util.List;\n      class ListWrapper {\n        List<Integer> l;\n      }\n\nインスペクションの構成:\n\n\nJava 9 の `provides` と `uses` モジュールステートメントの中で完全修飾名を無視する場合は、「**Java 9 モジュールのステートメントで無視する**」オプションを使用します。\n\n\nこのインスペクションは、「[設定 \\| エディター \\| コードスタイル \\| Java \\| インポート](settings://preferences.sourceCode.Java?JavaDoc%20Inner)」で以下のオプションを使用して構成できます。\n\n* 内部クラスへの参照を外部クラスで修飾する必要がある場合は、「**内部クラスのインポートを挿入する**」オプションを使用します。\n* Javadoc で完全修飾名を使用できるようにするには、「**Javadoc で完全修飾クラス名を使用する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessaryFullyQualifiedName",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegatedConditional",
                "shortDescription": {
                  "text": "否定条件を含む条件式"
                },
                "fullDescription": {
                  "text": "条件が否定されている条件式を報告します。 通常、このようなステートメントは条件式の分岐の順序を入れ替えると明確さが増します。 'obj != null' または 'num != 0' 形式の比較を無視するには、「'!= null' 比較を無視する」および「'!= 0' 比較を無視する」オプションを使用します。 'obj != null' は事実上 \"obj exists\" を意味するため、式全体に否定の意図はありません。このため、理解しやすいです。 同じ論法は 'num != 0' 式にも当てはまります。ビットマスクを使用する場合がその代表例です。 これらの形式には、関心の高いケースを最初に書けるというメリットもあります。 次の例のように、ほとんどの場合は '== null' 分岐の値は 'null' そのものです。 'static String getName(Person p) {\n        return p != null ? p.getName() : null;\n    }\n\n    static String getExecutableString(int fileMode) {\n        return (fileMode & 0b001001001) != 0 ? \"executable\" : \"non-executable\";\n    }'",
                  "markdown": "条件が否定されている条件式を報告します。\n\n通常、このようなステートメントは条件式の分岐の順序を入れ替えると明確さが増します。\n\n\n`obj != null` または `num != 0` 形式の比較を無視するには、「**'!= null' 比較を無視する** 」および「**'!= 0' 比較を無視する** 」オプションを使用します。\n`obj != null` は事実上 \"obj exists\" を意味するため、式全体に否定の意図はありません。このため、理解しやすいです。\n\n\n同じ論法は `num != 0` 式にも当てはまります。ビットマスクを使用する場合がその代表例です。\n\n\nこれらの形式には、関心の高いケースを最初に書けるというメリットもあります。\n次の例のように、ほとんどの場合は `== null` 分岐の値は `null` そのものです。\n\n\n        static String getName(Person p) {\n            return p != null ? p.getName() : null;\n        }\n\n        static String getExecutableString(int fileMode) {\n            return (fileMode & 0b001001001) != 0 ? \"executable\" : \"non-executable\";\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConditionalExpressionWithNegatedCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectEqualsCanBeEquality",
                "shortDescription": {
                  "text": "'==' に置換可能な 'equals()' 呼び出し"
                },
                "fullDescription": {
                  "text": "セマンティクスを変更せずに '==' または '!=' 式に置換できる 'equals()' への呼び出しを報告します。 このような呼び出しは、自身に 'equals()' 実装を持たず、デフォルトの'Object.equals()' を使用している 'final' クラスを比較する目的で使用されている場合に置換できます。 この置換により、パフォーマンスが向上する可能性があります。 'enum' 値に対する 'equals()' の呼び出しに対応する、「列挙値での 'equals()' 呼び出し」という独立したインスペクションがあります。",
                  "markdown": "セマンティクスを変更せずに `==` または `!=` 式に置換できる `equals()` への呼び出しを報告します。\n\nこのような呼び出しは、自身に `equals()` 実装を持たず、デフォルトの`Object.equals()` を使用している `final` クラスを比較する目的で使用されている場合に置換できます。\nこの置換により、パフォーマンスが向上する可能性があります。\n\n`enum` 値に対する `equals()` の呼び出しに対応する、「列挙値での 'equals()' 呼び出し」という独立したインスペクションがあります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectEqualsCanBeEquality",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JDBCPrepareStatementWithNonConstantString",
                "shortDescription": {
                  "text": "非定数文字列による 'Connection.prepare*()' の呼び出し"
                },
                "fullDescription": {
                  "text": "動的に作成される文字列をプリペアドステートメントとして受け取っている 'java.sql.Connection.prepareStatement()'、'java.sql.Connection.prepareCall()'、またはそのバリアントの呼び出しを報告します。 動的に作成される SQL ステートメントは、一般的にセキュリティ違反の元になります。 このインスペクションはデフォルトではコンパイル時の定数を無視します。 例: 'String bar() { return \"bar\"; }\n\n  Connection connection = DriverManager.getConnection(\"\", \"\", \"\");\n  connection.(\"SELECT * FROM user WHERE name='\" + bar() + \"'\");' すべての 'static' 'final' フィールドを定数と見なすには、インスペクション設定を使用します。 このオプションが有効な場合、次のような文字列は無視されますので注意してください。 'static final String SQL = \"SELECT * FROM user WHERE name='\" + getUserInput() + \"'\";'",
                  "markdown": "動的に作成される文字列をプリペアドステートメントとして受け取っている `java.sql.Connection.prepareStatement()`、`java.sql.Connection.prepareCall()`、またはそのバリアントの呼び出しを報告します。\n\n\n動的に作成される SQL ステートメントは、一般的にセキュリティ違反の元になります。 このインスペクションはデフォルトではコンパイル時の定数を無視します。\n\n**例:**\n\n\n      String bar() { return \"bar\"; }\n\n      Connection connection = DriverManager.getConnection(\"\", \"\", \"\");\n      connection.(\"SELECT * FROM user WHERE name='\" + bar() + \"'\");\n\nすべての `static` `final` フィールドを定数と見なすには、インスペクション設定を使用します。 このオプションが有効な場合、次のような文字列は無視されますので注意してください。\n\n\n      static final String SQL = \"SELECT * FROM user WHERE name='\" + getUserInput() + \"'\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JDBCPrepareStatementWithNonConstantString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanParameter",
                "shortDescription": {
                  "text": "'boolean' パラメーターを持つ 'public' メソッド"
                },
                "fullDescription": {
                  "text": "'boolean' パラメーターを受け取っている public メソッドを報告します。 ほとんどの場合、setter ではない public メソッド (API の一部) に 'boolean' パラメーターを追加することはバッドプラクティスです。 このようなメソッドを使用しているコードを読む場合、ソースまたはドキュメントを見ずに 'boolean' が表している内容を読み解くのは難しい可能性があります。 この問題は、boolean の罠 とも呼ばれます。 多くの場合、'boolean' パラメーターは 'enum' に置換できます。 例: '// 警告: このメソッドの呼び出しを見ても\n  // boolean パラメーターの意味を\n  // 理解するのは困難です\n  public boolean setPermission(File f,\n                               int access,\n                               boolean enable,\n                               boolean ownerOnly) {\n    // ...\n  }' メソッドに複数の boolean パラメーターが含まれている場合にのみ警告するには、「複数のブール値パラメーターを持つメソッドのみを報告する」オプションを使用します。",
                  "markdown": "`boolean` パラメーターを受け取っている public メソッドを報告します。\n\nほとんどの場合、setter ではない public メソッド (API の一部) に `boolean` パラメーターを追加することはバッドプラクティスです。\nこのようなメソッドを使用しているコードを読む場合、ソースまたはドキュメントを見ずに `boolean` が表している内容を読み解くのは難しい可能性があります。\n\nこの問題は、[boolean の罠](https://ariya.io/2011/08/hall-of-api-shame-boolean-trap) とも呼ばれます。\n多くの場合、`boolean` パラメーターは `enum` に置換できます。\n\n例:\n\n\n      // 警告: このメソッドの呼び出しを見ても\n      // boolean パラメーターの意味を\n      // 理解するのは困難です\n      public boolean setPermission(File f,\n                                   int access,\n                                   boolean enable,\n                                   boolean ownerOnly) {\n        // ...\n      }\n\n\nメソッドに複数の boolean パラメーターが含まれている場合にのみ警告するには、「**複数のブール値パラメーターを持つメソッドのみを報告する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemProperties",
                "shortDescription": {
                  "text": "システムプロパティへのアクセス"
                },
                "fullDescription": {
                  "text": "以下のいずれかのメソッドを使用してシステムプロパティにアクセスしているコードを報告します。 'System.getProperties()'、'System.setProperty()'、'System.setProperties()'、'System.clearProperties()' 'Integer.getInteger()' 'Boolean.getBoolean()' システムプロパティへのアクセス自体にセキュリティ上のリスクはありませんが、悪意のあるコードでよく見られるものです。 システムプロパティにアクセスするコードはセキュリティ監査で詳細に調査すべきです。",
                  "markdown": "以下のいずれかのメソッドを使用してシステムプロパティにアクセスしているコードを報告します。\n\n* `System.getProperties()`、`System.setProperty()`、`System.setProperties()`、`System.clearProperties()`\n* `Integer.getInteger()`\n* `Boolean.getBoolean()`\n\n\nシステムプロパティへのアクセス自体にセキュリティ上のリスクはありませんが、悪意のあるコードでよく見られるものです。\nシステムプロパティにアクセスするコードはセキュリティ監査で詳細に調査すべきです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessOfSystemProperties",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestInProductSource",
                "shortDescription": {
                  "text": "プロダクトソース内のテスト"
                },
                "fullDescription": {
                  "text": "プロダクションソースツリーにあるテストクラスとテストメソッドを報告します。 これはミスである可能性が高く、テストコードのプロダクションへの混入を招く可能性があります。",
                  "markdown": "プロダクションソースツリーにあるテストクラスとテストメソッドを報告します。 これはミスである可能性が高く、テストコードのプロダクションへの混入を招く可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TestInProductSource",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語/テストフレームワーク",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CopyConstructorMissesField",
                "shortDescription": {
                  "text": "フィールドが無いコピーコンストラクター"
                },
                "fullDescription": {
                  "text": "クラスのすべてのフィールドをコピーしていないコピーコンストラクターを報告します。 イニシャライザーを含む 'final' フィールドと 'transient' フィールドはコピーする必要がないと見なされます。 例: 'class Point {\n\n    private int x;\n    private int y;\n\n    Point(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    Point(Point other) {\n      // フィールド x と y が初期化されていません\n    }\n  }' 2018.1 の新機能です",
                  "markdown": "クラスのすべてのフィールドをコピーしていないコピーコンストラクターを報告します。\n\n\nイニシャライザーを含む `final` フィールドと `transient` フィールドはコピーする必要がないと見なされます。\n\n**例:**\n\n\n      class Point {\n\n        private int x;\n        private int y;\n\n        Point(int x, int y) {\n          this.x = x;\n          this.y = y;\n        }\n\n        Point(Point other) {\n          // フィールド x と y が初期化されていません\n        }\n      }\n\n2018.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CopyConstructorMissesField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InvalidComparatorMethodReference",
                "shortDescription": {
                  "text": "無効なメソッド参照が使用されている 'Comparator'"
                },
                "fullDescription": {
                  "text": "契約を満たさない 'Comparator' インターフェースにマッピングされているメソッド参照を報告します。 'Integer::max' のような一部のメソッド参照は 'Comparator' インターフェースにマッピングできます。 しかし、このようなメソッド参照を 'Comparator' として使用することは無意味であり、予測できない結果を引き起こす可能性があります。 例: 'ArrayList<Integer> ints = foo();\n  ints.sort(Math::min);' クイックフィックス適用後: 'ArrayList<Integer> ints = foo();\n  ints.sort(Comparator.reverseOrder());'",
                  "markdown": "契約を満たさない `Comparator` インターフェースにマッピングされているメソッド参照を報告します。\n\n\n`Integer::max` のような一部のメソッド参照は `Comparator` インターフェースにマッピングできます。\nしかし、このようなメソッド参照を `Comparator` として使用することは無意味であり、予測できない結果を引き起こす可能性があります。\n\n例:\n\n\n      ArrayList<Integer> ints = foo();\n      ints.sort(Math::min);\n\nクイックフィックス適用後:\n\n\n      ArrayList<Integer> ints = foo();\n      ints.sort(Comparator.reverseOrder());\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InvalidComparatorMethodReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastCanBeRemovedNarrowingVariableType",
                "shortDescription": {
                  "text": "不要なキャストを招く過度に弱い変数の型"
                },
                "fullDescription": {
                  "text": "変数の型がキャスト先の型に絞り込めば除去できる型キャストを報告します。 例: 'Object x = \"  string  \";\n  System.out.println(((String)x).trim());' ここで、'x' の型を 'String' に変換するというキャストは不要です。 提案されたクイックフィックスを使用すると、変数の型が更新され、その変数に対する不要なすべてのキャストが除去されます。 'String x = \"  string  \";\n  System.out.println(x.trim());' 2018.2 の新機能です",
                  "markdown": "変数の型がキャスト先の型に絞り込めば除去できる型キャストを報告します。\n\n例:\n\n\n      Object x = \"  string  \";\n      System.out.println(((String)x).trim());\n\n\nここで、`x` の型を `String` に変換するというキャストは不要です。 提案されたクイックフィックスを使用すると、変数の型が更新され、その変数に対する不要なすべてのキャストが除去されます。\n\n\n      String x = \"  string  \";\n      System.out.println(x.trim());\n\n2018.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CastCanBeRemovedNarrowingVariableType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9ModuleExportsPackageToItself",
                "shortDescription": {
                  "text": "パッケージを自分自身にエクスポート/オープンしているモジュール"
                },
                "fullDescription": {
                  "text": "同じ Java 9 モジュール内でエクスポートされている、または開かれているパッケージで、そのモジュール内に定義があるものを報告します。 クイックフィックスは、そのようなディレクティブを 'module-info.java' から除去します。 例: 'module com.mycomp {\n    exports com.mycomp.main to com.mycomp;\n  }' クイックフィックス適用後: 'module main {\n  }' このインスペクションは Java 9 以降で使用できる Java の機能 'モジュール' に依存しています。",
                  "markdown": "同じ Java 9 モジュール内でエクスポートされている、または開かれているパッケージで、そのモジュール内に定義があるものを報告します。 クイックフィックスは、そのようなディレクティブを `module-info.java` から除去します。\n\n例:\n\n\n      module com.mycomp {\n        exports com.mycomp.main to com.mycomp;\n      }\n\nクイックフィックス適用後:\n\n\n      module main {\n      }\n\nこのインスペクションは Java 9 以降で使用できる Java の機能 'モジュール' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java9ModuleExportsPackageToItself",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ToArrayCallWithZeroLengthArrayArgument",
                "shortDescription": {
                  "text": "'Collection.toArray()' の呼び出しスタイル"
                },
                "fullDescription": {
                  "text": "好ましい形式ではない 'Collection.toArray()' の呼び出しを報告し、好ましい形式を適用することを提案します。 コレクションから配列への変換形式には次の 2 つがあります。 'c.toArray(new String[c.size()])' など、あらかじめサイズが設定されている配列 'c.toArray(new String[0])' などの空の配列 古い Java バージョンでは適切なサイズの配列を作成するために必要なリフレクションの呼び出し動作が非常に遅かったため、あらかじめサイズが設定された配列の使用が推奨されていました。 ただし、OpenJDK 6 の最新アップデート以降はこの呼び出しが組み込まれているため、空配列のパフォーマンスはあらかじめサイズが設定されている配列と同等であるか、場合によっては上回っています。 また、並列または同期コレクションについては 'size' および 'toArray' 呼び出しの間でデータ競合が発生する可能性があるため、あらかじめサイズが設定された配列を渡すのは危険です。 これは、操作中にコレクションが同時に縮小された場合に配列の最後に余分な 'null' が発生する原因になります。 好ましい形式を選択するには、インスペクションのオプションを使用します。",
                  "markdown": "好ましい形式ではない `Collection.toArray()` の呼び出しを報告し、好ましい形式を適用することを提案します。\n\nコレクションから配列への変換形式には次の 2 つがあります。\n\n* `c.toArray(new String[c.size()])` など、あらかじめサイズが設定されている配列\n* `c.toArray(new String[0])` などの空の配列\n\n古い Java バージョンでは適切なサイズの配列を作成するために必要なリフレクションの呼び出し動作が非常に遅かったため、あらかじめサイズが設定された配列の使用が推奨されていました。\n\nただし、OpenJDK 6 の最新アップデート以降はこの呼び出しが組み込まれているため、空配列のパフォーマンスはあらかじめサイズが設定されている配列と同等であるか、場合によっては上回っています。 また、並列または同期コレクションについては `size` および `toArray` 呼び出しの間でデータ競合が発生する可能性があるため、あらかじめサイズが設定された配列を渡すのは危険です。 これは、操作中にコレクションが同時に縮小された場合に配列の最後に余分な `null` が発生する原因になります。\n\n好ましい形式を選択するには、インスペクションのオプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ToArrayCallWithZeroLengthArrayArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggerInitializedWithForeignClass",
                "shortDescription": {
                  "text": "外部クラスで初期化されているロガー"
                },
                "fullDescription": {
                  "text": "'Logger' が含まれているクラスとは異なるクラスの 'class' リテラルで初期化されている 'Logger' インスタンスを報告します。 これは、別のクラスからコードをコピーして貼り付けた場合によく発生します。また、結果的にイベントが予想外のカテゴリでログに記録され、フィルターが不適切に適用される可能性があります。 外部クラスのリテラルを外側のクラスのリテラルに置換するクイックフィックスが提供されています。 例: 'public class Paramount {\n    protected static final Logger LOG = Logger.getLogger(Critical.class);\n\n    // ... その他のフィールドとメソッド\n  }' クイックフィックス適用後: 'public class Paramount {\n    protected static final Logger LOG = Logger.getLogger(Paramount.class);\n\n    // ... その他のフィールドとメソッド\n  }' インスペクションの構成: このインスペクションが認識するロガーファクトリクラスとロガーファクトリメソッドを指定するには、このテーブルを使用します。 ロガーを含むクラスのスーパークラスで初期化されているロガーを無視するには、「スーパークラスで初期化されているロガーを無視する」オプションを使用します。 'public' クラスのロガーについてのみ警告するには、「非 public クラスのロガーを無視する」を使用します。 「final フィールドで初期化されていないロガーを無視する」を使用して、final フィールドで初期化されるロガーのみを報告します。その他のケースは無視されます。",
                  "markdown": "`Logger` が含まれているクラスとは異なるクラスの `class` リテラルで初期化されている `Logger` インスタンスを報告します。 これは、別のクラスからコードをコピーして貼り付けた場合によく発生します。また、結果的にイベントが予想外のカテゴリでログに記録され、フィルターが不適切に適用される可能性があります。\n\n外部クラスのリテラルを外側のクラスのリテラルに置換するクイックフィックスが提供されています。\n\n**例:**\n\n\n      public class Paramount {\n        protected static final Logger LOG = Logger.getLogger(Critical.class);\n\n        // ... その他のフィールドとメソッド\n      }\n\nクイックフィックス適用後:\n\n\n      public class Paramount {\n        protected static final Logger LOG = Logger.getLogger(Paramount.class);\n\n        // ... その他のフィールドとメソッド\n      }\n\n\nインスペクションの構成:\n\n* このインスペクションが認識するロガーファクトリクラスとロガーファクトリメソッドを指定するには、このテーブルを使用します。\n* ロガーを含むクラスのスーパークラスで初期化されているロガーを無視するには、「**スーパークラスで初期化されているロガーを無視する**」オプションを使用します。\n* `public` クラスのロガーについてのみ警告するには、「**非 public クラスのロガーを無視する**」を使用します。\n* 「**final フィールドで初期化されていないロガーを無視する**」を使用して、final フィールドで初期化されるロガーのみを報告します。その他のケースは無視されます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LoggerInitializedWithForeignClass",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ログ関連",
                      "index": 91,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkerInterface",
                "shortDescription": {
                  "text": "マーカーインターフェース"
                },
                "fullDescription": {
                  "text": "メソッドまたはフィールドがないマーカーインターフェースを報告します。 このようなインターフェースは混乱を招く可能性があり、多くの場合は設計に問題があります。 このインスペクションは、2 つ以上のインターフェースを拡張しているインターフェースと、スーパーインターフェースのジェネリック型を指定しているインターフェースを無視します。",
                  "markdown": "メソッドまたはフィールドがないマーカーインターフェースを報告します。\n\nこのようなインターフェースは混乱を招く可能性があり、多くの場合は設計に問題があります。\n\nこのインスペクションは、2 つ以上のインターフェースを拡張しているインターフェースと、スーパーインターフェースのジェネリック型を指定しているインターフェースを無視します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkerInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CommentedOutCode",
                "shortDescription": {
                  "text": "コメントアウトされたコード"
                },
                "fullDescription": {
                  "text": "Java のコードが含まれているコメントを報告します。 通常、コメントアウトされているコードはすぐに古くなり、誤解の元になります。 多くのプロジェクトでは何らかのバージョンコントロールシステムが使用されるため、コメントアウトされているコードは完全に削除し、VCS の履歴を代わりに使用することをお勧めします。 2020.3 の新機能です",
                  "markdown": "Java のコードが含まれているコメントを報告します。\n\n通常、コメントアウトされているコードはすぐに古くなり、誤解の元になります。\n多くのプロジェクトでは何らかのバージョンコントロールシステムが使用されるため、コメントアウトされているコードは完全に削除し、VCS の履歴を代わりに使用することをお勧めします。\n\n2020.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CommentedOutCode",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コード成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToStaticFieldFromInstanceMethod",
                "shortDescription": {
                  "text": "インスタンスコンテキストからの static フィールドへの代入"
                },
                "fullDescription": {
                  "text": "インスタンスメソッド内からの 'static' フィールドへの代入、または変更を報告します。 このような代入は有効であっても安全に実行するのは難しく、フィールドを不注意で 'static' にした結果であることがしばしばです。 例: 'class Counter {\n    private static int count = 0;\n\n    void increment() {\n      // 警告: インスタンスメソッドから\n      // static フィールドを更新しています\n      count++;\n    }\n  }'",
                  "markdown": "インスタンスメソッド内からの `static` フィールドへの代入、または変更を報告します。\n\nこのような代入は有効であっても安全に実行するのは難しく、フィールドを不注意で `static` にした結果であることがしばしばです。\n\n**例:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // 警告: インスタンスメソッドから\n          // static フィールドを更新しています\n          count++;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToStaticFieldFromInstanceMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代入関連の問題",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SortedCollectionWithNonComparableKeys",
                "shortDescription": {
                  "text": "比較不可能な要素を含むソートコレクション"
                },
                "fullDescription": {
                  "text": "自然なソート順に依存している 'TreeSet' などのソートされたコレクションの構文で、その要素の型が 'Comparable' インターフェースを実装していないものを報告します。 このようなコレクションが適切に機能することはまずありません。 このようなコレクション要素の型が比較不可能なスーパータイプであるものの、コレクションが比較可能なサブタイプの保持のみを目的としている場合、誤検知が発生する可能性があります。 この場合でも前述のアプローチでは問題が発生しやすいため、コレクション要素の型を絞り込むか、スーパータイプを 'Comparable' で宣言することをお勧めします。 このインスペクションは、コレクション要素が 'extends Comparable' で宣言されていない型パラメーターである場合も報告します。 提供されたオプションを使用すると、(API の互換性を維持する目的などで) 型パラメーターの警告を抑止することができます。 2018.3 の新機能です",
                  "markdown": "自然なソート順に依存している `TreeSet` などのソートされたコレクションの構文で、その要素の型が `Comparable` インターフェースを実装していないものを報告します。\n\nこのようなコレクションが適切に機能することはまずありません。\n\n\nこのようなコレクション要素の型が比較不可能なスーパータイプであるものの、コレクションが比較可能なサブタイプの保持のみを目的としている場合、誤検知が発生する可能性があります。 この場合でも前述のアプローチでは問題が発生しやすいため、コレクション要素の型を絞り込むか、スーパータイプを `Comparable` で宣言することをお勧めします。\n\n\nこのインスペクションは、コレクション要素が `extends Comparable` で宣言されていない型パラメーターである場合も報告します。\n提供されたオプションを使用すると、(API の互換性を維持する目的などで) 型パラメーターの警告を抑止することができます。\n\n\n2018.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SortedCollectionWithNonComparableKeys",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithoutLogger",
                "shortDescription": {
                  "text": "ロガーのないクラス"
                },
                "fullDescription": {
                  "text": "ロガーが宣言されていないクラスを報告します。 アプリケーションのロギング実装を統一するには、すべてのクラスに専用のロガーを持たせることが重要です。 インターフェース、列挙、アノテーション、内部クラス、抽象クラスは、このインスペクションでは報告されません。 例: 'public class NoLoggerDeclared {\n\n    int calculateNthDigitOfPi(int n) {\n      // todo\n      return 1;\n    }\n  }' ロガークラスの名前を指定するには、オプション セクション内のテーブルを使用します。 指定したクラスのいずれかの型のフィールドを宣言しないクラスが、このインスペクションによって報告されます。",
                  "markdown": "ロガーが宣言されていないクラスを報告します。\n\nアプリケーションのロギング実装を統一するには、すべてのクラスに専用のロガーを持たせることが重要です。 インターフェース、列挙、アノテーション、内部クラス、抽象クラスは、このインスペクションでは報告されません。\n\n例:\n\n\n      public class NoLoggerDeclared {\n\n        int calculateNthDigitOfPi(int n) {\n          // todo\n          return 1;\n        }\n      }\n\n\nロガークラスの名前を指定するには、**オプション** セクション内のテーブルを使用します。\n指定したクラスのいずれかの型のフィールドを宣言しないクラスが、このインスペクションによって報告されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithoutLogger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ログ関連",
                      "index": 91,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnOfInnerClass",
                "shortDescription": {
                  "text": "匿名、ローカルまたは内部クラスのインスタンスのリターン"
                },
                "fullDescription": {
                  "text": "匿名、ローカル、または内部クラスのインスタンスを返却している 'return' ステートメントを報告します。 このようなインスタンスは外部インスタンスへの暗黙的な参照を維持することで、外部インスタンスのガベージコレクションを阻止します。 このようなインスタンスを返すメソッドの呼び出し元は返却されたインスタンスを保持し続けるため、メモリリークが発生する可能性があります。 インスペクションの構成: 'protected' メソッドまたは package-private メソッドからの返却を無視するには、「non-public メソッドからの返却を無視」オプションを使用します。 'private' メソッドからの返却は常に無視されます。",
                  "markdown": "匿名、ローカル、または内部クラスのインスタンスを返却している `return` ステートメントを報告します。 このようなインスタンスは外部インスタンスへの暗黙的な参照を維持することで、外部インスタンスのガベージコレクションを阻止します。 このようなインスタンスを返すメソッドの呼び出し元は返却されたインスタンスを保持し続けるため、メモリリークが発生する可能性があります。\n\n\nインスペクションの構成:\n\n* `protected` メソッドまたは package-private メソッドからの返却を無視するには、「**non-public メソッドからの返却を無視** 」オプションを使用します。 `private` メソッドからの返却は常に無視されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReturnOfInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メモリ",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractClassWithOnlyOneDirectInheritor",
                "shortDescription": {
                  "text": "単一の直接継承を持つ抽象クラス"
                },
                "fullDescription": {
                  "text": "直接継承が 1 つのみの抽象クラスを報告します。 このようなクラスは設計をかなり明確にするかもしれませんが、メモリの使用量や帯域幅が制限された環境ではアプリケーションの占有領域が無駄に増える原因になります。 抽象クラスを継承先とマージすることを検討してください。 このインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。 このインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。 例: 'abstract class Base {} // 報告されます\n\n  class Inheritor extends Base {}'",
                  "markdown": "直接継承が 1 つのみの抽象クラスを報告します。 このようなクラスは設計をかなり明確にするかもしれませんが、メモリの使用量や帯域幅が制限された環境ではアプリケーションの占有領域が無駄に増える原因になります。 抽象クラスを継承先とマージすることを検討してください。\n\n\nこのインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。\nこのインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。\n\n**例:**\n\n\n      abstract class Base {} // 報告されます\n\n      class Inheritor extends Base {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractClassWithOnlyOneDirectInheritor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス/組み込み",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousClassComplexity",
                "shortDescription": {
                  "text": "過度に複雑な匿名クラス"
                },
                "fullDescription": {
                  "text": "合計複雑度が指定された最大値を超えている匿名の内部クラスを報告します。 クラスの合計複雑度は、そのクラスで宣言されているすべてのメソッドとイニシャライザーのサイクロマティック複雑度を合計したものです。 継承先のメソッドやイニシャライザーは合計複雑度の考慮対象外です。 匿名クラスの複雑度は非常に低くしなければなりません。そうでなければ理解しにくいため、名前付きの内部クラスになるように昇格する必要があります。 クラスで許容される複雑度の最大値を指定するには、「サイクロマティック複雑度の制限」フィールドを使用します。",
                  "markdown": "合計複雑度が指定された最大値を超えている匿名の内部クラスを報告します。\n\nクラスの合計複雑度は、そのクラスで宣言されているすべてのメソッドとイニシャライザーのサイクロマティック複雑度を合計したものです。 継承先のメソッドやイニシャライザーは合計複雑度の考慮対象外です。\n\n匿名クラスの複雑度は非常に低くしなければなりません。そうでなければ理解しにくいため、名前付きの内部クラスになるように昇格する必要があります。\n\nクラスで許容される複雑度の最大値を指定するには、「**サイクロマティック複雑度の制限**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexAnonymousInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラスメトリクス",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitWithoutCorrespondingNotify",
                "shortDescription": {
                  "text": "対応する 'notify()' のない 'wait()'"
                },
                "fullDescription": {
                  "text": "'Object.wait()' の呼び出しのうち、対応する 'Object.notify()' または 'Object.notifyAll()' の呼び出しが見つからないものを報告します。 このインスペクションは、現在のクラスのフィールドを参照している修飾子を持つ呼び出しのみを報告します。 例: 'public class Foo {\n    public Object foo = new Object();\n\n    void bar() throws InterruptedException {\n      this.foo.wait();\n    }\n  }'",
                  "markdown": "`Object.wait()` の呼び出しのうち、対応する `Object.notify()` または `Object.notifyAll()` の呼び出しが見つからないものを報告します。\n\nこのインスペクションは、現在のクラスのフィールドを参照している修飾子を持つ呼び出しのみを報告します。\n\n**例:**\n\n\n      public class Foo {\n        public Object foo = new Object();\n\n        void bar() throws InterruptedException {\n          this.foo.wait();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitWithoutCorrespondingNotify",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnsecureRandomNumberGeneration",
                "shortDescription": {
                  "text": "安全でない乱数生成"
                },
                "fullDescription": {
                  "text": "'java.lang.Random' または 'java.lang.Math.random()' が使用されていることを報告します。 安全な環境では、'java.secure.SecureRandom' を選択するのは理にかなっています。なぜなら、暗号的な安全な乱数生成を実行できるからです。 例: 'long token = new Random().nextLong();'",
                  "markdown": "`java.lang.Random` または `java.lang.Math.random()` が使用されていることを報告します。\n\n\n安全な環境では、`java.secure.SecureRandom` を選択するのは理にかなっています。なぜなら、暗号的な安全な乱数生成を実行できるからです。\n\n**例:**\n\n\n      long token = new Random().nextLong();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnsecureRandomNumberGeneration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NullableProblems",
                "shortDescription": {
                  "text": "@NotNull/@Nullable 問題"
                },
                "fullDescription": {
                  "text": "null 許容性アノテーションに関連する問題を報告します。 例: オーバーライドするメソッドにアノテーションが付いていない。 'abstract class A {\n  @NotNull abstract String m();\n}\nclass B extends A {\n    String m() { return \"empty string\"; }\n}' プリミティブ型にアノテーションが付いている: '@NotNull int myFoo;' '@Nullable' と '@NotNull' が同じメンバーに使用されている: '@Nullable @NotNull String myFooString;' null 許容の要素のコレクションが 非 null の要素のコレクションに代入されている: 'void testList(List<@Nullable String> nullableList) {\n   List<@NotNull String> list2 = nullableList;\n}' null 許容性アノテーションを指定するには「アノテーションの構成」ボタンを、インスペクションが警告を出すべき個所を詳細に設定するにはチェックボックスを指定します。 このインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以降で、クラスパスで null 許容性アノテーションを使用できる場合にのみ報告します。",
                  "markdown": "null 許容性アノテーションに関連する問題を報告します。\n\n**例:**\n\n* オーバーライドするメソッドにアノテーションが付いていない。\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* プリミティブ型にアノテーションが付いている: `@NotNull int myFoo;`\n* `@Nullable` と `@NotNull` が同じメンバーに使用されている: `@Nullable @NotNull String myFooString;`\n* null 許容の要素のコレクションが 非 null の要素のコレクションに代入されている:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nnull 許容性アノテーションを指定するには「**アノテーションの構成**」ボタンを、インスペクションが警告を出すべき個所を詳細に設定するにはチェックボックスを指定します。\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以降で、クラスパスで null 許容性アノテーションを使用できる場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NullableProblems",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ/null 許容性の問題",
                      "index": 119,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsBetweenInconvertibleTypes",
                "shortDescription": {
                  "text": "互換性のない型のオブジェクト間の 'equals()'"
                },
                "fullDescription": {
                  "text": "ターゲットと引数が互換性のない型である 'equals()' の呼び出しを報告します。 このような呼び出しは理論的には役立つ場合もありますが、バグの可能性が高いです。 例: '新しい HashSet<String>().equals(new TreeSet<Integer>());'",
                  "markdown": "ターゲットと引数が互換性のない型である `equals()` の呼び出しを報告します。\n\nこのような呼び出しは理論的には役立つ場合もありますが、バグの可能性が高いです。\n\n**例:**\n\n\n      新しい HashSet<String>().equals(new TreeSet<Integer>());\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsBetweenInconvertibleTypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfAWTPeerClass",
                "shortDescription": {
                  "text": "AWT ピアクラスの使用"
                },
                "fullDescription": {
                  "text": "AWT ピアクラスが使用されていることを報告します。 このようなクラスはネイティブなウィンドウシステムウィジェットを表現しているため、異なるウィンドウシステム間では移植できません。 例: 'import java.awt.peer.ButtonPeer;\n\n  abstract class Sample implements ButtonPeer {\n    public void foo() {\n        Sample sample;\n    }\n  }'",
                  "markdown": "AWT ピアクラスが使用されていることを報告します。 このようなクラスはネイティブなウィンドウシステムウィジェットを表現しているため、異なるウィンドウシステム間では移植できません。\n\n**例:**\n\n\n      import java.awt.peer.ButtonPeer;\n\n      abstract class Sample implements ButtonPeer {\n        public void foo() {\n            Sample sample;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfAWTPeerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ポータビリティ",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateCondition",
                "shortDescription": {
                  "text": "重複した条件"
                },
                "fullDescription": {
                  "text": "'&&' 式、'||' 式、および 'if' ステートメントの分岐にある重複した条件を報告します。 重複した条件式は意図的に使用されている場合もありますが、不注意に起因するものがほとんどです。 例: 'boolean result = digit1 != digit2 || digit1 != digit2;' 副作用を引き起こす可能性がある条件を無視するには、「副作用のある条件を無視する」オプションを使用します。 このオプションを無効化すると、同じメソッドが後続の呼び出しで異なる値を返す場合などに誤検知が発生する可能性があります。 例: 'native boolean unknownMethod();\n  \n  ...\n  \n  if (unknownMethod() || unknownMethod()) {\n    System.out.println(\"Got it\");\n  }' 'unknownMethod()' (上の例) は副作用を引き起こす可能性があるため、警告は「副作用のある条件を無視する」オプションが無効な場合にのみトリガーされます。",
                  "markdown": "`&&` 式、`||` 式、および `if` ステートメントの分岐にある重複した条件を報告します。 重複した条件式は意図的に使用されている場合もありますが、不注意に起因するものがほとんどです。\n\n例:\n\n\n      boolean result = digit1 != digit2 || digit1 != digit2;\n\n\n副作用を引き起こす可能性がある条件を無視するには、「**副作用のある条件を無視する**」オプションを使用します。\nこのオプションを無効化すると、同じメソッドが後続の呼び出しで異なる値を返す場合などに誤検知が発生する可能性があります。\n\n例:\n\n\n      native boolean unknownMethod();\n      \n      ...\n      \n      if (unknownMethod() || unknownMethod()) {\n        System.out.println(\"Got it\");\n      }\n\n`unknownMethod()` (上の例) は副作用を引き起こす可能性があるため、警告は「**副作用のある条件を無視する**」オプションが無効な場合にのみトリガーされます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DuplicateCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringTemplateReverseMigration",
                "shortDescription": {
                  "text": "文字列テンプレートは連結文字列にできます"
                },
                "fullDescription": {
                  "text": "'STR' プロセッサを使用している文字列テンプレート式を報告し、プレーンな文字列連結に戻すクイックフィックスを提供します。 例: 'String name = \"Bob\";\n  String greeting = STR.\"Hello, \\{name}. You are 29 years old.\";' クイックフィックス適用後: 'String name = \"Bob\";\n  String greeting = \"Hello, \" + name + \". You are 29 years old.\";' 2024.2 の新機能です",
                  "markdown": "`STR` プロセッサを使用している文字列テンプレート式を報告し、プレーンな文字列連結に戻すクイックフィックスを提供します。\n\n**例:**\n\n\n      String name = \"Bob\";\n      String greeting = STR.\"Hello, \\{name}. You are 29 years old.\";\n\nクイックフィックス適用後:\n\n\n      String name = \"Bob\";\n      String greeting = \"Hello, \" + name + \". You are 29 years old.\";\n\n2024.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "StringTemplateReverseMigration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 21",
                      "index": 75,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizationOnGetClass",
                "shortDescription": {
                  "text": "'getClass()' の同期"
                },
                "fullDescription": {
                  "text": "'getClass()' の呼び出しの同期を報告します。 同期を含むクラスがサブクラス化されている場合、そのサブクラスは異なるクラスオブジェクトに同期します。 通常、'getClass()' の呼び出しは 'String.class' などのクラスリテラル式に置換できます。 さらに良い解決策は、アクセスを完全に制御できる 'private static final' ロックオブジェクトに同期することです。 例: 'synchronized(getClass()) {}'",
                  "markdown": "`getClass()` の呼び出しの同期を報告します。\n\n\n同期を含むクラスがサブクラス化されている場合、そのサブクラスは異なるクラスオブジェクトに同期します。 通常、`getClass()` の呼び出しは `String.class` などのクラスリテラル式に置換できます。 さらに良い解決策は、アクセスを完全に制御できる `private static final` ロックオブジェクトに同期することです。\n\n**例:**\n\n     synchronized(getClass()) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizationOnGetClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantExplicitVariableType",
                "shortDescription": {
                  "text": "省略可能なローカル変数型"
                },
                "fullDescription": {
                  "text": "冗長なローカル変数の型を報告します。 このような型はコンテキストから推論できるため、'var' に置換できます。 例: 'void test(InputStream s) {\n    try (InputStream in = s) {}\n  }' クイックフィックス適用後: 'void test(InputStream s) {\n    try (var in = s) {}\n  }' このインスペクションは Java 10 以降で使用できる Java の機能 'ローカル変数の型推論' に依存しています。",
                  "markdown": "冗長なローカル変数の型を報告します。\n\nこのような型はコンテキストから推論できるため、`var` に置換できます。\n\n**例:**\n\n\n      void test(InputStream s) {\n        try (InputStream in = s) {}\n      }\n\nクイックフィックス適用後:\n\n\n      void test(InputStream s) {\n        try (var in = s) {}\n      }\n\n\nこのインスペクションは Java 10 以降で使用できる Java の機能 'ローカル変数の型推論' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantExplicitVariableType",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 10",
                      "index": 112,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrownExceptionsPerMethod",
                "shortDescription": {
                  "text": "例外宣言が多すぎるメソッド"
                },
                "fullDescription": {
                  "text": "'throws' リスト内に含まれている例外のタイプが多すぎるメソッドを報告します。 メソッドで宣言されている例外の数が多すぎる場合、エラー処理を行っているコードが過度に複雑化している可能性があります。 メソッドの 'throws' リストに含めることが可能な例外タイプの最大数を指定するには、「スローされる例外の制限」フィールドを使用します。",
                  "markdown": "`throws` リスト内に含まれている例外のタイプが多すぎるメソッドを報告します。\n\nメソッドで宣言されている例外の数が多すぎる場合、エラー処理を行っているコードが過度に複雑化している可能性があります。\n\nメソッドの `throws` リストに含めることが可能な例外タイプの最大数を指定するには、「**スローされる例外の制限**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithTooExceptionsDeclared",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メソッドメトリクス",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantThrows",
                "shortDescription": {
                  "text": "冗長な 'throw' 節"
                },
                "fullDescription": {
                  "text": "メソッドのシグネチャーで宣言されているものの、メソッド自体、またはその実装とオーバーライドするメソッドによってスローされることのない例外を報告します。 このインスペクションは、'readObject()' や 'writeObject()' メソッドなどのシリアル化に関連するメソッドを無視します。 例: 'void method() throws InterruptedException {\n    System.out.println();\n  }' クイックフィックスを使用すると、宣言から不要な例外が除去され、冗長な 'try'-'catch' ステートメントが正規化されます。 'void method() {\n    System.out.println();\n  }' 注意: パフォーマンス上の理由から、一部の例外はエディターでハイライトしている間は報告されない場合があります。 すべての結果を表示するには、メインメニューから「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」を選択してインスペクションを実行します。 たとえば 'main()' メソッドによりスローされる例外を報告しないようにするには、「エントリポイントメソッドによってスローされる例外を無視」オプションを使用します。 エントリポイントメソッドは「Java | 宣言の冗長性 | 未使用の宣言」インスペクションの設定で構成できます。",
                  "markdown": "メソッドのシグネチャーで宣言されているものの、メソッド自体、またはその実装とオーバーライドするメソッドによってスローされることのない例外を報告します。\n\nこのインスペクションは、`readObject()` や `writeObject()` メソッドなどのシリアル化に関連するメソッドを無視します。\n\n**例:**\n\n\n      void method() throws InterruptedException {\n        System.out.println();\n      }\n\nクイックフィックスを使用すると、宣言から不要な例外が除去され、冗長な `try`-`catch` ステートメントが正規化されます。\n\n\n      void method() {\n        System.out.println();\n      }\n\n\n**注意:** パフォーマンス上の理由から、一部の例外はエディターでハイライトしている間は報告されない場合があります。\nすべての結果を表示するには、メインメニューから「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」を選択してインスペクションを実行します。\n\nたとえば `main()` メソッドによりスローされる例外を報告しないようにするには、「**エントリポイントメソッドによってスローされる例外を無視** 」オプションを使用します。\nエントリポイントメソッドは「[Java \\| 宣言の冗長性 \\| 未使用の宣言](settings://Errors?Unused%20Declaration%20entry%20point)」インスペクションの設定で構成できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantThrows",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableWithUnconstructableAncestor",
                "shortDescription": {
                  "text": "構築できない祖先を持つ Serializable クラス"
                },
                "fullDescription": {
                  "text": "'Serializable' クラスで、最も近い非 Serializable の上位クラスに引数なしのコンストラクターがないものを報告します。 このようなクラスは逆シリアル化できず、'InvalidClassException' で失敗します。 例: 'class Ancestor {\n    private String name;\n    Ancestor(String name) {\n      this.name = name;\n    }\n  }\n\n  // スーパークラスが Serializable ではなく、そのコンストラクターが\n  // 引数を取っているため、このクラスでは警告が発生します\n  class Descendant extends Ancestor implements Serializable {\n    Descendant() {\n      super(\"Bob\");\n    }\n  }'",
                  "markdown": "`Serializable` クラスで、最も近い非 Serializable の上位クラスに引数なしのコンストラクターがないものを報告します。 このようなクラスは逆シリアル化できず、`InvalidClassException` で失敗します。\n\n**例:**\n\n\n      class Ancestor {\n        private String name;\n        Ancestor(String name) {\n          this.name = name;\n        }\n      }\n\n      // スーパークラスが Serializable ではなく、そのコンストラクターが\n      // 引数を取っているため、このクラスでは警告が発生します\n      class Descendant extends Ancestor implements Serializable {\n        Descendant() {\n          super(\"Bob\");\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableClassWithUnconstructableAncestor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExcessiveLambdaUsage",
                "shortDescription": {
                  "text": "過度なラムダの使用"
                },
                "fullDescription": {
                  "text": "自明なラムダ式が使用されており、それと同じ動作をするものの、ラムダではなく具体的な値を受け取る代替メソッドが存在する場合に報告します。 このインスペクションはコードを単純化します。 例: 'Optional.orElseGet(() -> null)' クイックフィックス適用後: 'Optional.orElse(null)' 2017.1 の新機能です このインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。",
                  "markdown": "自明なラムダ式が使用されており、それと同じ動作をするものの、ラムダではなく具体的な値を受け取る代替メソッドが存在する場合に報告します。\n\nこのインスペクションはコードを単純化します。\n\n例:\n\n\n      Optional.orElseGet(() -> null)\n\nクイックフィックス適用後:\n\n\n      Optional.orElse(null)\n\n2017.1 の新機能です\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExcessiveLambdaUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaBodyCanBeCodeBlock",
                "shortDescription": {
                  "text": "コードブロックにできるラムダ本体"
                },
                "fullDescription": {
                  "text": "本体が式であるラムダを報告し、その式の本体をコードブロックに変換することを提案します。 例: 'n -> n + 1' クイックフィックス適用後: 'n -> {\n  return n + 1;\n}' このインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。",
                  "markdown": "本体が式であるラムダを報告し、その式の本体をコードブロックに変換することを提案します。\n\n例:\n\n\n      n -> n + 1\n\nクイックフィックス適用後:\n\n    n -> {\n      return n + 1;\n    }\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LambdaBodyCanBeCodeBlock",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterHidingMemberVariable",
                "shortDescription": {
                  "text": "フィールドを非表示にするパラメーター"
                },
                "fullDescription": {
                  "text": "外部クラスのフィールドと名前がまったく同じメソッドパラメーターを報告します。 このような命名を行うと、まったく同じ名前のフィールドを使用することが意図されている場合にパラメーターを誤って使用する可能性があります。 パラメーターの名前を変更するクイックフィックスが提案されます。 例: 'class Main {\n    private String value;\n\n    public Main(String value) {\n      value = value.toUpperCase();\n    }\n  }' このインスペクションでは、以下のオプションを構成できます。 プロパティの設定を無視 - 単純な setter のパラメーターを無視します。 サブクラスから不可視のスーパークラスフィールドを無視 - メソッドから不可視のスーパークラスにある 'private' フィールドを無視します。 コンストラクターの場合は無視 - コンストラクターのパラメーターを無視します。 抽象メソッドの場合は無視 - 抽象メソッドのパラメーターを無視します。 インスタンスフィールドを不可視にする static メソッドのパラメーターを無視 - インスタンスフィールドを不可視にする 'static' メソッドのパラメーターを無視し、外部クラスのインスタンスフィールドを不可視にする static 内部クラスにあるインスタンスメソッドのパラメーターを無視します。 このようなパラメーターは厳密に言えば不可視にはしていませんが、それでも混乱を招く可能性があります。",
                  "markdown": "外部クラスのフィールドと名前がまったく同じメソッドパラメーターを報告します。 このような命名を行うと、まったく同じ名前のフィールドを使用することが意図されている場合にパラメーターを誤って使用する可能性があります。\n\nパラメーターの名前を変更するクイックフィックスが提案されます。\n\n**例:**\n\n\n      class Main {\n        private String value;\n\n        public Main(String value) {\n          value = value.toUpperCase();\n        }\n      }\n      \n\nこのインスペクションでは、以下のオプションを構成できます。\n\n1. **プロパティの設定を無視** - 単純な setter のパラメーターを無視します。\n2. **サブクラスから不可視のスーパークラスフィールドを無視** - メソッドから不可視のスーパークラスにある `private` フィールドを無視します。\n3. **コンストラクターの場合は無視** - コンストラクターのパラメーターを無視します。\n4. **抽象メソッドの場合は無視** - 抽象メソッドのパラメーターを無視します。\n5. **インスタンスフィールドを不可視にする static メソッドのパラメーターを無視** - インスタンスフィールドを不可視にする `static` メソッドのパラメーターを無視し、外部クラスのインスタンスフィールドを不可視にする static 内部クラスにあるインスタンスメソッドのパラメーターを無視します。 このようなパラメーターは厳密に言えば不可視にはしていませんが、それでも混乱を招く可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterHidesMemberVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfAnotherObjectsPrivateField",
                "shortDescription": {
                  "text": "別のオブジェクトの non-public フィールドへのアクセス"
                },
                "fullDescription": {
                  "text": "別オブジェクトの 'private' または 'protected' フィールドへのアクセスを報告します。 Java では現在のオブジェクトと同じクラスのオブジェクトに対するこのようなフィールドへのアクセスは可能ですが、一部のコードスタイルはこのような使用法を推奨していません。 また、このような 'private' フィールドへの直接アクセスは、フレームワークがプロキシを使用してアクセスを仲介できるように他のオブジェクトに対するすべてのアクセスがメソッド呼び出しを通じて行われることを期待している Spring や Hibernate のようなコンポーネント指向のアーキテクチャでは失敗する可能性があります。 例: 'public class Base {\n    protected int bar;\n\n    void increment(Base base) {\n      bar++;\n      base.bar++; // 警告: 別のオブジェクトの非 public フィールドへの直接アクセス\n    }\n  }' フィールドをカプセル化するクイックフィックスを使用できます。 インスペクションの構成: 同じクラスからのアクセスを無視し、内部または外部クラスからのアクセスのみを報告するには、「同じクラスからのアクセスを無視」オプションを使用します。 内部クラスからのアクセスも無視する場合は、ネストした 内部クラスからのアクセスを無視 を使用します。 'equals()' メソッドからのアクセスを無視するには、'equals()' メソッドからのアクセスを無視 を使用します。",
                  "markdown": "別オブジェクトの `private` または `protected` フィールドへのアクセスを報告します。 Java では現在のオブジェクトと同じクラスのオブジェクトに対するこのようなフィールドへのアクセスは可能ですが、一部のコードスタイルはこのような使用法を推奨していません。 また、このような `private` フィールドへの直接アクセスは、フレームワークがプロキシを使用してアクセスを仲介できるように他のオブジェクトに対するすべてのアクセスがメソッド呼び出しを通じて行われることを期待している Spring や Hibernate のようなコンポーネント指向のアーキテクチャでは失敗する可能性があります。\n\n**例:**\n\n\n      public class Base {\n        protected int bar;\n\n        void increment(Base base) {\n          bar++;\n          base.bar++; // 警告: 別のオブジェクトの非 public フィールドへの直接アクセス\n        }\n      }\n\nフィールドをカプセル化するクイックフィックスを使用できます。\n\nインスペクションの構成:\n\n* 同じクラスからのアクセスを無視し、内部または外部クラスからのアクセスのみを報告するには、「**同じクラスからのアクセスを無視** 」オプションを使用します。\n\n  内部クラスからのアクセスも無視する場合は、ネストした **内部クラスからのアクセスを無視** を使用します。\n* `equals()` メソッドからのアクセスを無視するには、**'equals()' メソッドからのアクセスを無視** を使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessingNonPublicFieldOfAnotherObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/カプセル化",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessBitwiseExpression",
                "shortDescription": {
                  "text": "無意味なビット演算式"
                },
                "fullDescription": {
                  "text": "無意味なビット演算式を報告します。 このような式には、指定した型の最大値に対する '&' 演算子の適用、ゼロに対する 'or' 演算子の適用、そしてゼロによるシフトが含まれます。 このような式は自動リファクタリングを完遂しなかったために発生している可能性があり、本来意図していたものではないと思われます。 例: '// 警告: 演算は無意味であり、単純な `flags` に置換できます\n  // 0xFFFF_FFFF は整数の最大値であり、両方のリテラルが\n  // 32 ビット整数リテラルとして扱われます。\n  int bits = flags & 0xFFFF_FFFF;\n\n  // 警告: 演算は無意味であり、単純な `bits` に置換できます\n  // 0 と一緒に論理和演算を行うと常に他方のオペランドが出力されます\n  int or = bits | 0x0;\n\n  // 警告: この演算は常に結果がゼロになるため、無意味です\n  int xor = or ^ or;'",
                  "markdown": "無意味なビット演算式を報告します。\n\n\nこのような式には、指定した型の最大値に対する `&` 演算子の適用、ゼロに対する `or` 演算子の適用、そしてゼロによるシフトが含まれます。 このような式は自動リファクタリングを完遂しなかったために発生している可能性があり、本来意図していたものではないと思われます。\n\n**例:**\n\n\n      // 警告: 演算は無意味であり、単純な `flags` に置換できます\n      // 0xFFFF_FFFF は整数の最大値であり、両方のリテラルが\n      // 32 ビット整数リテラルとして扱われます。\n      int bits = flags & 0xFFFF_FFFF;\n\n      // 警告: 演算は無意味であり、単純な `bits` に置換できます\n      // 0 と一緒に論理和演算を行うと常に他方のオペランドが出力されます\n      int or = bits | 0x0;\n\n      // 警告: この演算は常に結果がゼロになるため、無意味です\n      int xor = or ^ or;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessBitwiseExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ビット演算関連の問題",
                      "index": 97,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CustomSecurityManager",
                "shortDescription": {
                  "text": "カスタム 'SecurityManager'"
                },
                "fullDescription": {
                  "text": "ユーザーが定義している 'java.lang.SecurityManager' のサブクラスを報告します。 このようなクラスは必ずしもセキュリティホールになるわけではありませんが、セキュリティの問題が発生する可能性があるため、念入りかつ本格的に検査する必要があります。 例: 'class CustomSecurityManager extends SecurityManager {\n  }'",
                  "markdown": "ユーザーが定義している `java.lang.SecurityManager` のサブクラスを報告します。\n\n\nこのようなクラスは必ずしもセキュリティホールになるわけではありませんが、セキュリティの問題が発生する可能性があるため、念入りかつ本格的に検査する必要があります。\n\n**例:**\n\n\n      class CustomSecurityManager extends SecurityManager {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CustomSecurityManager",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectEquality",
                "shortDescription": {
                  "text": "'equals()' の代わりに '==' を使用したオブジェクト比較"
                },
                "fullDescription": {
                  "text": "'equals()' ではなく'==' または '!=' を使用してオブジェクトの等価性をテストしているコードを報告します。 '==' または '!=' を使用するオブジェクトの比較は、等価性ではなく識別子でオブジェクトを比較するため、多くの場合はバグだと考えられます。 'null' との比較は報告されません。 配列、'String'、'Number' の比較は、個別のインスペクションによって報告されます。 例: 'if (list1 == list2) {\n    return;\n  }' クイックフィックス適用後: 'if (Objects.equals(list1, list2)) {\n    return;\n  }' このインスペクションの例外を構成するには、インスペクションの設定を使用します。",
                  "markdown": "`equals()` ではなく`==` または `!=` を使用してオブジェクトの等価性をテストしているコードを報告します。\n\n\n`==` または `!=` を使用するオブジェクトの比較は、等価性ではなく識別子でオブジェクトを比較するため、多くの場合はバグだと考えられます。\n`null` との比較は報告されません。\n\n\n配列、`String`、`Number` の比較は、個別のインスペクションによって報告されます。\n\n**例:**\n\n      if (list1 == list2) {\n        return;\n      }\n\nクイックフィックス適用後:\n\n      if (Objects.equals(list1, list2)) {\n        return;\n      }\n\nこのインスペクションの例外を構成するには、インスペクションの設定を使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectEquality",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TimeToString",
                "shortDescription": {
                  "text": "'Time.toString()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'java.sql.Time' オブジェクトに対する 'toString()' の呼び出しを報告します。 このような呼び出しは通常、国際化環境では正しくありません。",
                  "markdown": "`java.sql.Time` オブジェクトに対する `toString()` の呼び出しを報告します。 このような呼び出しは通常、国際化環境では正しくありません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToTimeToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateThrows",
                "shortDescription": {
                  "text": "重複する throws"
                },
                "fullDescription": {
                  "text": "メソッドの 'throws' に列挙されている重複した例外を報告します。 例: 'void f() throws Exception, Exception {}' クイックフィックス適用後: 'void f() throws Exception {}' 他の例外をサブクラス化している例外を無視するには、「他をサブクラス化する例外を無視する」オプションを使用します。",
                  "markdown": "メソッドの `throws` に列挙されている重複した例外を報告します。\n\n例:\n\n\n      void f() throws Exception, Exception {}\n\nクイックフィックス適用後:\n\n\n      void f() throws Exception {}\n\n\n他の例外をサブクラス化している例外を無視するには、「**他をサブクラス化する例外を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DuplicateThrows",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnstableTypeUsedInSignature",
                "shortDescription": {
                  "text": "不安定な型がシグネチャーで使用されています"
                },
                "fullDescription": {
                  "text": "シグネチャー内で不安定な API の型を参照しているものの、同じ不安定なアノテーションでマークされていないクラス、メソッド、フィールドの宣言を報告します。 このインスペクションは、公開 API のシグネチャーが不安定な (内部的、実験的な) 型が公開されないようにします。 たとえば、互換性のない型変更 (削除または他のパッケージへの移動) は互換性のないメソッドのシグネチャー変更を引き起こすため、メソッドが「実験的」なクラスを返す場合は、そのメソッド自体が「実験的」であると見なされます。 不安定な API をマークするアノテーションを指定するには、以下のリストを使用します。",
                  "markdown": "シグネチャー内で不安定な API の型を参照しているものの、同じ不安定なアノテーションでマークされていないクラス、メソッド、フィールドの宣言を報告します。\n\n\nこのインスペクションは、公開 API のシグネチャーが*不安定な* (内部的、実験的な) 型が公開されないようにします。\nたとえば、互換性のない型変更 (削除または他のパッケージへの移動) は互換性のないメソッドのシグネチャー変更を引き起こすため、メソッドが「*実験的* 」なクラスを返す場合は、そのメソッド自体が「*実験的*」であると見なされます。\n\n不安定な API をマークするアノテーションを指定するには、以下のリストを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnstableTypeUsedInSignature",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PrivateMemberAccessBetweenOuterAndInnerClass",
                "shortDescription": {
                  "text": "合成アクセサーの呼び出し"
                },
                "fullDescription": {
                  "text": "ネストしたクラスから外部クラスの非定数 'private' メンバーへの参照を報告します。 このような参照に対し、javac は package-private な合成アクセサーメソッドを生成します。その結果、安全性が損なわれる可能性があります。private に見えるメンバーが、実際にはパッケージ全体からアクセス可能であるためです。 ネストしたクラスとその外部クラスは個別のクラスファイルにコンパイルされます。 Java 仮想マシンは通常、あるクラスから別クラスの private フィールドとメソッドへのアクセスを禁止しています。 ネストしたクラスから外部クラスの private メンバーにアクセスできるようにするため、javac はpackage-private な合成アクセサーメソッドを作成します。 代わりに 'private' メンバーを package-private にすることで、実際のアクセシビリティが明確になります。 また、メモリ消費量が若干抑えられるため、リソースの使用が制限されている環境でパフォーマンスが向上する可能性があります。 このインスペクションは、プロジェクトまたはモジュールの言語レベルが 10 以下の場合にのみ報告します。 ネストベースのアクセス制御 (JEP 181) により、Java 11 以降ではアクセサーメソッドは生成されなくなりました。 例: 'class Outer {\n    private void x() {}\n\n    class Inner {\n      void y() {\n        x();\n      }\n    }\n  }' クイックフィックス適用後: 'class Outer {\n    void x() {}\n\n    class Inner {\n      void y() {\n        x();\n      }\n    }\n  }'",
                  "markdown": "ネストしたクラスから外部クラスの非定数 `private` メンバーへの参照を報告します。 このような参照に対し、javac は package-private な合成アクセサーメソッドを生成します。その結果、安全性が損なわれる可能性があります。private に見えるメンバーが、実際にはパッケージ全体からアクセス可能であるためです。\n\n\nネストしたクラスとその外部クラスは個別のクラスファイルにコンパイルされます。 Java 仮想マシンは通常、あるクラスから別クラスの private フィールドとメソッドへのアクセスを禁止しています。 ネストしたクラスから外部クラスの private メンバーにアクセスできるようにするため、javac はpackage-private な合成アクセサーメソッドを作成します。\n\n\n代わりに `private` メンバーを package-private にすることで、実際のアクセシビリティが明確になります。\nまた、メモリ消費量が若干抑えられるため、リソースの使用が制限されている環境でパフォーマンスが向上する可能性があります。\n\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 10 以下の場合にのみ報告します。\nネストベースのアクセス制御 ([JEP 181](https://openjdk.org/jeps/181)) により、Java 11 以降ではアクセサーメソッドは生成されなくなりました。\n\n**例:**\n\n\n      class Outer {\n        private void x() {}\n\n        class Inner {\n          void y() {\n            x();\n          }\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Outer {\n        void x() {}\n\n        class Inner {\n          void y() {\n            x();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SyntheticAccessorCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス/組み込み",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemRunFinalizersOnExit",
                "shortDescription": {
                  "text": "'System.runFinalizersOnExit()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'System.runFinalizersOnExit()' の呼び出しを報告します。 これは、Java 言語で最も危険な呼び出しの 1 つです。 この呼び出しは本質的にスレッドセーフではなく、データの破損やデッドロックを誘発するだけでなく、呼び出し箇所から遠く離れたプログラムの部分に影響を与える可能性があります。 この呼び出しは非推奨であり、JDK 11 で除去されたため、使用しないことを強くお勧めします。 このインスペクションは、プロジェクトまたはモジュールの言語レベルが 10 以下の場合にのみ報告します。",
                  "markdown": "`System.runFinalizersOnExit()` の呼び出しを報告します。\n\n\nこれは、Java 言語で最も危険な呼び出しの 1 つです。 この呼び出しは本質的にスレッドセーフではなく、データの破損やデッドロックを誘発するだけでなく、呼び出し箇所から遠く離れたプログラムの部分に影響を与える可能性があります。\nこの呼び出しは非推奨であり、JDK 11 で除去されたため、使用しないことを強くお勧めします。\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 10 以下の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemRunFinalizersOnExit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassIndependentOfModule",
                "shortDescription": {
                  "text": "モジュールに依存しないクラス"
                },
                "fullDescription": {
                  "text": "以下の条件に当てはまるクラスを報告します。 所属モジュール内の他のクラスに依存していない 所属モジュール内の他のクラスの依存関係になっていない このようなクラスは、モジュール化戦略が場当たり的または矛盾していることを暗に示しており、多くの場合は移動するのが得策です。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "以下の条件に当てはまるクラスを報告します。\n\n* 所属モジュール内の他のクラスに依存していない\n* 所属モジュール内の他のクラスの依存関係になっていない\n\nこのようなクラスは、モジュール化戦略が場当たり的または矛盾していることを暗に示しており、多くの場合は移動するのが得策です。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassIndependentOfModule",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/モジュール化関連の問題",
                      "index": 65,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternVariablesCanBeReplacedWithCast",
                "shortDescription": {
                  "text": "パターンで 'instanceof' を使用しています"
                },
                "fullDescription": {
                  "text": "パターンを持つ 'instanceof' を報告し、キャストを持つ普通の 'instanceof' に変換することを提案します。 このインスペクションは、クイックフィックスを適用することで以前の Java バージョンを使用してパターンを持つ 'instanceof' をコードベースに移動できるようにします。 'instanceof' の前に複雑な式が使用されている場合、結果はパターンを持つ元の 'instanceof' と完全に同等ではない場合があることに注意してください。 この場合、この式は再評価されます。 例: 'if (object instanceof String txt && txt.length() == 1) {\n      System.out.println(txt);\n  } else {\n      return;\n  }\n  System.out.println(txt);' クイックフィックス適用後: 'if (object instanceof String && ((String) object).length() ==1) {\n      String txt = (String) object;\n      System.out.println(txt);\n  } else {\n      return;\n  }\n  String txt = (String) object;\n  System.out.println(txt);' 2023.1 の新機能です",
                  "markdown": "パターンを持つ `instanceof` を報告し、キャストを持つ普通の `instanceof` に変換することを提案します。\n\nこのインスペクションは、クイックフィックスを適用することで以前の Java バージョンを使用してパターンを持つ `instanceof` をコードベースに移動できるようにします。\n\n\n`instanceof` の前に複雑な式が使用されている場合、結果はパターンを持つ元の `instanceof` と完全に同等ではない場合があることに注意してください。 この場合、この式は再評価されます。\n\n例:\n\n\n      if (object instanceof String txt && txt.length() == 1) {\n          System.out.println(txt);\n      } else {\n          return;\n      }\n      System.out.println(txt);\n\nクイックフィックス適用後:\n\n\n      if (object instanceof String && ((String) object).length() ==1) {\n          String txt = (String) object;\n          System.out.println(txt);\n      } else {\n          return;\n      }\n      String txt = (String) object;\n      System.out.println(txt);\n\n2023.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PatternVariablesCanBeReplacedWithCast",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceInefficientStreamCount",
                "shortDescription": {
                  "text": "count() で終わる非効率な Stream API 呼び出しチェーン"
                },
                "fullDescription": {
                  "text": "'count()' 操作で終わっている Stream API 呼び出しチェーンで、最適化可能なものを報告します。 このインスペクションにより、次のように呼び出しチェーンを置換できます。 'Collection.stream().count()' → 'Collection.size()' Java 8 の 'Collection.stream().count()' はコレクションの要素を実際に反復処理してカウントしますが、'Collection.size()' は大部分のコレクションをより高速に処理します。 'Stream.flatMap(Collection::stream).count()' → 'Stream.mapToLong(Collection::size).sum()' 同様に、すべてのネストしたコレクションを反復処理する必要はありません。 代わりに、それらのコレクションのサイズを合計できます。 'Stream.filter(o -> ...).count() > 0' → 'Stream.anyMatch(o -> ...)' 元の呼び出しとは異なり、'anyMatch()' は一致する要素が見つかった時点で処理を停止する場合があります。 'Stream.filter(o -> ...).count() == 0' → 'Stream.noneMatch(o -> ...)' 上記と同様です。 置換後のコードに 'anyMatch()' のような短絡操作が含まれる場合、中間ストリーム操作によって副作用が発生した場合に動作が目に見える形で変わる可能性があります。 一般的に、Stream API 呼び出しでは副作用を回避する必要があります。 このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "`count()` 操作で終わっている Stream API 呼び出しチェーンで、最適化可能なものを報告します。\n\n\nこのインスペクションにより、次のように呼び出しチェーンを置換できます。\n\n* `Collection.stream().count()` → `Collection.size()` Java 8 の `Collection.stream().count()` はコレクションの要素を実際に反復処理してカウントしますが、`Collection.size()` は大部分のコレクションをより高速に処理します。\n* `Stream.flatMap(Collection::stream).count()` → `Stream.mapToLong(Collection::size).sum()` 同様に、すべてのネストしたコレクションを反復処理する必要はありません。 代わりに、それらのコレクションのサイズを合計できます。\n* `Stream.filter(o -> ...).count() > 0` → `Stream.anyMatch(o -> ...)` 元の呼び出しとは異なり、`anyMatch()` は一致する要素が見つかった時点で処理を停止する場合があります。\n* `Stream.filter(o -> ...).count() == 0` → `Stream.noneMatch(o -> ...)` 上記と同様です。\n\n\n置換後のコードに `anyMatch()` のような短絡操作が含まれる場合、中間ストリーム操作によって副作用が発生した場合に動作が目に見える形で変わる可能性があります。 一般的に、Stream API 呼び出しでは副作用を回避する必要があります。\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceInefficientStreamCount",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterTypePreventsOverriding",
                "shortDescription": {
                  "text": "オーバーライドを阻止するパラメーター型"
                },
                "fullDescription": {
                  "text": "サブクラスメソッドのパラメーターの型と対応するスーパーメソッドのパラメーターの型が同じ名前であるものの、異なるパッケージに属している場合に報告します。 このような場合、サブクラスメソッドはスーパーメソッドをオーバーライドできません。 例: 'public class A {\n public void method(Object o) {}\n}\n\npublic class B extends A {\n public void method(Object o) {} // パラメーターの型に関する警告\n class Object {}\n}' クイックフィックス適用後: 'public class A {\n public void method(Object o) {}\n}\n\npublic class B extends A {\n public void method(java.lang.Object o) {} // 新しいパラメーターの型\n class Object {}\n}'",
                  "markdown": "サブクラスメソッドのパラメーターの型と対応するスーパーメソッドのパラメーターの型が同じ名前であるものの、異なるパッケージに属している場合に報告します。 このような場合、サブクラスメソッドはスーパーメソッドをオーバーライドできません。\n\n**例:**\n\n\n    public class A {\n     public void method(Object o) {}\n    }\n\n    public class B extends A {\n     public void method(Object o) {} // パラメーターの型に関する警告\n     class Object {}\n    }\n\nクイックフィックス適用後:\n\n\n    public class A {\n     public void method(Object o) {}\n    }\n\n    public class B extends A {\n     public void method(java.lang.Object o) {} // 新しいパラメーターの型\n     class Object {}\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterTypePreventsOverriding",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ManualArrayToCollectionCopy",
                "shortDescription": {
                  "text": "手動による配列からコレクションへのコピー"
                },
                "fullDescription": {
                  "text": "配列の内容をコレクションにコピーするためにループを使用しているコードを報告します。 このような処理を簡潔に書き、高速に実行するには、'Collection.addAll(Arrays.asList())' または 'Collections.addAll()' を使用します。 追加のステートメントが中に書かれていないループのみを報告します。 例: 'void addAll(List<String> list, String[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n      String s = arr[i];\n      list.add(s);\n    }\n  }' クイックフィックス適用後: 'void addAll(List<String> list, String[] arr) {\n    Collections.addAll(list, arr);\n  }'",
                  "markdown": "配列の内容をコレクションにコピーするためにループを使用しているコードを報告します。\n\n\nこのような処理を簡潔に書き、高速に実行するには、`Collection.addAll(Arrays.asList())` または `Collections.addAll()` を使用します。\n\n\n追加のステートメントが中に書かれていないループのみを報告します。\n\n**例:**\n\n\n      void addAll(List<String> list, String[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n          String s = arr[i];\n          list.add(s);\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      void addAll(List<String> list, String[] arr) {\n        Collections.addAll(list, arr);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ManualArrayToCollectionCopy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchLabeledRuleCanBeCodeBlock",
                "shortDescription": {
                  "text": "コードブロックを持つことができるラベル付き switch ルール"
                },
                "fullDescription": {
                  "text": "式の本体を含む 'switch' 式または拡張 'switch' ステートメントのルールを報告します。 このようなルールはコードブロックに変換できます。 例: 'String message = switch (errorCode) {\n    case 404 -> \"Not found!\";\n    ...\n  };' クイックフィックス適用後: 'String message = switch (errorCode) {\n    case 404 -> {\n                yield \"Not found!\";\n            }\n    ...\n  };' 2019.1 の新機能です このインスペクションは Java 14 以降で使用できる Java の機能 '拡張 'switch' ブロック' に依存しています。",
                  "markdown": "式の本体を含む `switch` 式または拡張 `switch` ステートメントのルールを報告します。 このようなルールはコードブロックに変換できます。\n\n例:\n\n\n      String message = switch (errorCode) {\n        case 404 -> \"Not found!\";\n        ...\n      };\n\nクイックフィックス適用後:\n\n\n      String message = switch (errorCode) {\n        case 404 -> {\n                    yield \"Not found!\";\n                }\n        ...\n      };\n\n2019.1 の新機能です\n\nこのインスペクションは Java 14 以降で使用できる Java の機能 '拡張 'switch' ブロック' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SwitchLabeledRuleCanBeCodeBlock",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtractMethodRecommender",
                "shortDescription": {
                  "text": "メソッドを抽出できます"
                },
                "fullDescription": {
                  "text": "コードのフラグメントを別のメソッドに抽出し、コードをより明確にすることを提案します。 このインスペクションは以下を含め、抽出に適した候補を選択するための多数のヒューリスティックを備えています。 抽出されたフラグメントに非ローカルの制御フローがない 抽出されたフラグメントに出力変数が 1 つだけある 抽出されたフラグメント内とその外に似たような出力変数の使用箇所がない 抽出されたフラグメントに入力パラメーターが少ししかない (デフォルトでは 3 つ以下。インスペクションオプションで構成可能) 抽出されたフラグメントが構成されている長さ (デフォルトでは 500 文字) 以上であるものの、含んでいるメソッド本体の 60% 以下である",
                  "markdown": "コードのフラグメントを別のメソッドに抽出し、コードをより明確にすることを提案します。 このインスペクションは以下を含め、抽出に適した候補を選択するための多数のヒューリスティックを備えています。\n\n* 抽出されたフラグメントに非ローカルの制御フローがない\n* 抽出されたフラグメントに出力変数が 1 つだけある\n* 抽出されたフラグメント内とその外に似たような出力変数の使用箇所がない\n* 抽出されたフラグメントに入力パラメーターが少ししかない (デフォルトでは 3 つ以下。インスペクションオプションで構成可能)\n* 抽出されたフラグメントが構成されている長さ (デフォルトでは 500 文字) 以上であるものの、含んでいるメソッド本体の 60% 以下である"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExtractMethodRecommender",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コード成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringOperationCanBeSimplified",
                "shortDescription": {
                  "text": "冗長な 'String' 操作"
                },
                "fullDescription": {
                  "text": "より単純な式に置換できる 'String' コンストラクター、および 'toString()' または 'substring()' などのメソッドへの冗長な呼び出しを報告します。 たとえば、このようなメソッドの呼び出しは、'\"string\".substring(0)'、'\"string\".toString()'、'new StringBuilder().toString().substring(1,3)' のようなコードで安全に除去できます。 例: 'System.out.println(new String(\"message\"));' クイックフィックス適用後: 'System.out.println(\"message\");' このクイックフィックスは冗長なコンストラクターの呼び出しを除去するため、'String' 参照の同等性に影響を与える可能性があります。ご注意ください。 たとえバッドプラクティスだとされていても、これを維持する必要がある場合は警告を抑止するか、冗長な 'String' コンストラクターの呼び出しを無視するインスペクション設定を使用してください。 上記の例のようなコードを報告しないようにするには、以下の「String コンストラクターの呼び出しを報告しない」オプションを使用します。 これにより、異なるオブジェクト識別子を保証するために 'new String()' の呼び出しを使用するコードでクイックフィックスを適用した後に '==' または '!=' を使用する String の比較結果が変更されるのを防ぐことができます。 以下のようなコードを報告しないようにするには、下にある「単一引数の substring() の呼び出しを報告しない」オプションを使用します。 'stringBuilder.append(string.substring(5));' これは以下に置換できます。 'stringBuilder.append(string, 5, string.length());' 2018.1 の新機能です",
                  "markdown": "より単純な式に置換できる `String` コンストラクター、および `toString()` または `substring()` などのメソッドへの冗長な呼び出しを報告します。\n\nたとえば、このようなメソッドの呼び出しは、`\"string\".substring(0)`、`\"string\".toString()`、`new StringBuilder().toString().substring(1,3)` のようなコードで安全に除去できます。\n\n例:\n\n\n      System.out.println(new String(\"message\"));\n\nクイックフィックス適用後:\n\n\n      System.out.println(\"message\");\n\n\nこのクイックフィックスは冗長なコンストラクターの呼び出しを除去するため、`String` 参照の同等性に影響を与える可能性があります。ご注意ください。\nたとえバッドプラクティスだとされていても、これを維持する必要がある場合は警告を抑止するか、冗長な `String` コンストラクターの呼び出しを無視するインスペクション設定を使用してください。\n\n\n上記の例のようなコードを報告しないようにするには、以下の「**String コンストラクターの呼び出しを報告しない** 」オプションを使用します。\nこれにより、異なるオブジェクト識別子を保証するために `new String()` の呼び出しを使用するコードでクイックフィックスを適用した後に `==` または `!=` を使用する String の比較結果が変更されるのを防ぐことができます。\n\n\n以下のようなコードを報告しないようにするには、下にある「**単一引数の substring() の呼び出しを報告しない**」オプションを使用します。\n\n\n      stringBuilder.append(string.substring(5));\n\nこれは以下に置換できます。\n\n\n      stringBuilder.append(string, 5, string.length());\n\n2018.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringOperationCanBeSimplified",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassReferencesSubclass",
                "shortDescription": {
                  "text": "クラスが自分のサブクラスを参照"
                },
                "fullDescription": {
                  "text": "自身のサブクラスを参照しているクラスを報告します。 このような参照は混乱を招く可能性があり、オブジェクト指向設計のいくつかのルールに違反しています。 例: 'class Entity {\n    // 警告: クラスが自分のサブクラスを参照しています\n    void compare(SimpleEntity entity) {\n      ...\n    }\n  }\n  class SimpleEntity extends Entity {\n    ...\n  }'",
                  "markdown": "自身のサブクラスを参照しているクラスを報告します。 このような参照は混乱を招く可能性があり、オブジェクト指向設計のいくつかのルールに違反しています。\n\n例:\n\n\n      class Entity {\n        // 警告: クラスが自分のサブクラスを参照しています\n        void compare(SimpleEntity entity) {\n          ...\n        }\n      }\n      class SimpleEntity extends Entity {\n        ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassReferencesSubclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaReflectionMemberAccess",
                "shortDescription": {
                  "text": "存在しない/非表示のクラスメンバーへのリフレクションアクセス"
                },
                "fullDescription": {
                  "text": "存在しない、または不可視のフィールドとメソッドへのリフレクションアクセスを報告します。 例: 'Field stringHashField() throws NoSuchFieldException {\n    return String.class.getField(\"hash\");\n  }' クイックフィックス適用後: 'Field stringHashField() throws NoSuchFieldException {\n    return String.class.getDeclaredField(\"hash\");\n  }' 'final' クラスの場合は、そのクラスに指定した名前のフィールドまたはメソッドがあるかどうかは明らかです。 非 'final' クラスの場合は、その名前のフィールドまたはメソッドを持つサブクラスがある可能性があるため、誤検知が発生する場合があります。 すべての場所、または特定のクラスで発生しうるこのような誤検知を排除するには、インスペクションの設定を使用します。 2017.2 の新機能です",
                  "markdown": "存在しない、または不可視のフィールドとメソッドへのリフレクションアクセスを報告します。\n\n例:\n\n\n      Field stringHashField() throws NoSuchFieldException {\n        return String.class.getField(\"hash\");\n      }\n\nクイックフィックス適用後:\n\n\n      Field stringHashField() throws NoSuchFieldException {\n        return String.class.getDeclaredField(\"hash\");\n      }\n\n\n`final` クラスの場合は、そのクラスに指定した名前のフィールドまたはメソッドがあるかどうかは明らかです。\n\n\n非 `final` クラスの場合は、その名前のフィールドまたはメソッドを持つサブクラスがある可能性があるため、誤検知が発生する場合があります。\nすべての場所、または特定のクラスで発生しうるこのような誤検知を排除するには、インスペクションの設定を使用します。\n\n2017.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaReflectionMemberAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/リフレクションアクセス",
                      "index": 98,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObviousNullCheck",
                "shortDescription": {
                  "text": "明らかに null でない引数で呼び出された null チェックメソッド"
                },
                "fullDescription": {
                  "text": "null チェックを行うメソッド ('Objects.requireNonNull' や 'Assert.assertNotNull') で、明らかに null でない値 (新しく作成されたオブジェクトなど) に対して呼び出されるものを報告します。 このようなチェックは冗長であるため、プログラミングにミスがある可能性があります。 例: 'final String greeting = Objects.requireNonNull(\"Hi!\");' クイックフィックス適用後: 'final String greeting = \"Hi!\";' 2017.2 の新機能です",
                  "markdown": "null チェックを行うメソッド (`Objects.requireNonNull` や `Assert.assertNotNull`) で、明らかに null でない値 (新しく作成されたオブジェクトなど) に対して呼び出されるものを報告します。 このようなチェックは冗長であるため、プログラミングにミスがある可能性があります。\n\n**例:**\n\n\n      final String greeting = Objects.requireNonNull(\"Hi!\");\n\nクイックフィックス適用後:\n\n\n      final String greeting = \"Hi!\";\n\n2017.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ObviousNullCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerialVersionUIDNotStaticFinal",
                "shortDescription": {
                  "text": "'private static final long' と宣言されていない 'serialVersionUID' フィールド"
                },
                "fullDescription": {
                  "text": "'Serializable' クラスで、その 'serialVersionUID' フィールドが 'private static final long' で宣言されていないものを報告します。 例: 'class SampleClass implements Serializable {\n    private long serialVersionUID = 1; // Serializable クラスのフィールドが 'private static final long' で宣言されていません\n\n    public SampleClass() {\n        System.out.println(serialVersionUID);\n    }\n  }'",
                  "markdown": "`Serializable` クラスで、その `serialVersionUID` フィールドが `private static final long` で宣言されていないものを報告します。\n\n**例:**\n\n\n      class SampleClass implements Serializable {\n        private long serialVersionUID = 1; // Serializable クラスのフィールドが 'private static final long' で宣言されていません\n\n        public SampleClass() {\n            System.out.println(serialVersionUID);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerialVersionUIDWithWrongSignature",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InnerClassOnInterface",
                "shortDescription": {
                  "text": "インターフェースの内部クラス"
                },
                "fullDescription": {
                  "text": "'interface' クラスにある内部クラスを報告します。 一部のコーディング標準は、このようなクラスの使用を推奨していません。 このインスペクションは、列挙型クラスとアノテーションインターフェースを報告しません。 内部インターフェースを無視するには、「インターフェースの内部インターフェースを無視する」オプションを使用します。 例: 'interface I {\n    interface Inner {\n    }\n  }'",
                  "markdown": "`interface` クラスにある内部クラスを報告します。\n\n一部のコーディング標準は、このようなクラスの使用を推奨していません。 このインスペクションは、列挙型クラスとアノテーションインターフェースを報告しません。\n\n\n内部インターフェースを無視するには、「**インターフェースの内部インターフェースを無視する**」オプションを使用します。 例:\n\n\n      interface I {\n        interface Inner {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassOfInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DateToString",
                "shortDescription": {
                  "text": "'Date.toString()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'java.util.Date' オブジェクトに対する 'toString()' の呼び出しを報告します。 このような呼び出しは通常、国際化環境では正しくありません。",
                  "markdown": "`java.util.Date` オブジェクトに対する `toString()` の呼び出しを報告します。 このような呼び出しは通常、国際化環境では正しくありません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToDateToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IterableUsedAsVararg",
                "shortDescription": {
                  "text": "可変引数として使用されている Iterable"
                },
                "fullDescription": {
                  "text": "可変長引数メソッドの呼び出しに含まれる疑わしい 'Collection' または 'Iterable' の使用箇所を報告します。 たとえば、次のようなメソッドがあるとします。 '<T> boolean contains(T needle, T... haystack) {...}' これを次のように呼び出すのは、疑わしく思えます。 'if(contains(\"item\", listOfStrings)) {...}' なぜなら、リストが要素を 1 つしか持たない配列にラップされるからです。 このようなコードは正常にコンパイルされ、実行しても例外がスローされないかもしれませんが、誤って使用されている可能性が高いです。 2019.2 の新機能です このインスペクションは Java 5 以降で使用できる Java の機能 '可変引数メソッド' に依存しています。",
                  "markdown": "可変長引数メソッドの呼び出しに含まれる疑わしい `Collection` または `Iterable` の使用箇所を報告します。\n\nたとえば、次のようなメソッドがあるとします。\n\n\n      <T> boolean contains(T needle, T... haystack) {...}\n\nこれを次のように呼び出すのは、疑わしく思えます。\n\n\n      if(contains(\"item\", listOfStrings)) {...}\n\nなぜなら、リストが要素を 1 つしか持たない配列にラップされるからです。\nこのようなコードは正常にコンパイルされ、実行しても例外がスローされないかもしれませんが、誤って使用されている可能性が高いです。\n\n2019.2 の新機能です\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 '可変引数メソッド' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IterableUsedAsVararg",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodNameSameAsParentName",
                "shortDescription": {
                  "text": "親クラス名と同じメソッド名"
                },
                "fullDescription": {
                  "text": "メソッド名を混同する可能性があるため、メソッドのクラスのスーパークラスと同じ名前のメソッドを報告します。 このインスペクションは、階層の奥深くにあるインターフェースまたはスーパークラスをチェックしません。 例: 'class Parent {}\n  class Child extends Parent {\n     public Parent Parent() {\n       return null;\n     }\n  }' このようなメソッドの名前を変更するクイックフィックスは、エディターでのみ使用できます。",
                  "markdown": "メソッド名を混同する可能性があるため、メソッドのクラスのスーパークラスと同じ名前のメソッドを報告します。\n\nこのインスペクションは、階層の奥深くにあるインターフェースまたはスーパークラスをチェックしません。\n\n**例:**\n\n\n      class Parent {}\n      class Child extends Parent {\n         public Parent Parent() {\n           return null;\n         }\n      }\n\nこのようなメソッドの名前を変更するクイックフィックスは、エディターでのみ使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodNameSameAsParentName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規則/メソッド",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicFieldAccessedInSynchronizedContext",
                "shortDescription": {
                  "text": "'synchronized' コンテキストでアクセスされている非 private フィールド"
                },
                "fullDescription": {
                  "text": "同期コンテンツでアクセスされている、非 'final'、非 'private' フィールドを報告します。 非 'private' フィールドは必ず同期的にアクセスされるとは保証されていないため、このような「部分的な同期」アクセスは一貫性のないデータ構造を予期せず生み出す可能性があります。 例: 'class Bar {\n    public String field1;\n  }\n  public Bar myBar;\n\n  synchronized public void sample() {\n   myBar.field1 = \"bar\";\n  }'",
                  "markdown": "同期コンテンツでアクセスされている、非 `final`、非 `private` フィールドを報告します。\n\n\n非 `private` フィールドは必ず同期的にアクセスされるとは保証されていないため、このような「部分的な同期」アクセスは一貫性のないデータ構造を予期せず生み出す可能性があります。\n\n**例:**\n\n\n      class Bar {\n        public String field1;\n      }\n      public Bar myBar;\n\n      synchronized public void sample() {\n       myBar.field1 = \"bar\";\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonPrivateFieldAccessedInSynchronizedContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedLabel",
                "shortDescription": {
                  "text": "未使用のラベル"
                },
                "fullDescription": {
                  "text": "'break' または 'continue' ステートメントのいずれのターゲットでもないラベルを報告します。 例: 'label: for (int i = 0; i < 10; i++) {\n    if (i == 3) {\n      break;\n    }\n  }' クイックフィックスを適用すると、ラベルが除去されます。 'for (int i = 0; i < 10; i++) {\n    if (i == 3) {\n      break;\n    }\n  }'",
                  "markdown": "`break` または `continue` ステートメントのいずれのターゲットでもないラベルを報告します。\n\n**例:**\n\n\n      label: for (int i = 0; i < 10; i++) {\n        if (i == 3) {\n          break;\n        }\n      }\n\nクイックフィックスを適用すると、ラベルが除去されます。\n\n\n      for (int i = 0; i < 10; i++) {\n        if (i == 3) {\n          break;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForeachStatement",
                "shortDescription": {
                  "text": "拡張 'for' ステートメント"
                },
                "fullDescription": {
                  "text": "拡張 'for' ステートメントを報告します。 例: 'for (int x: Arrays.asList(1, 2, 3)) {\n    System.out.println(x);\n  }' クイックフィックス適用後: 'for (Iterator<Integer> iterator = Arrays.asList(1, 2, 3).iterator(); iterator.hasNext(); ) {\n    final int x = iterator.next();\n    System.out.println(x);\n  }' 拡張 'for' ステートメントは Java 5 で登場しました。 このインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。",
                  "markdown": "拡張 `for` ステートメントを報告します。\n\n例:\n\n\n      for (int x: Arrays.asList(1, 2, 3)) {\n        System.out.println(x);\n      }\n\nクイックフィックス適用後:\n\n\n      for (Iterator<Integer> iterator = Arrays.asList(1, 2, 3).iterator(); iterator.hasNext(); ) {\n        final int x = iterator.next();\n        System.out.println(x);\n      }\n\n\n*拡張* `for` *ステートメント*は Java 5 で登場しました。\nこのインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForeachStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java の言語レベル関連の問題",
                      "index": 61,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaParameterNamingConvention",
                "shortDescription": {
                  "text": "ラムダパラメーターの命名規則"
                },
                "fullDescription": {
                  "text": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないラムダパラメーターを報告します。 例: 'Function<String, String> id = X -> X;' は、このインスペクションがパラメーター名の開始文字が小文字であることを要求するデフォルト設定で有効になっている場合に報告されます。 インスペクションの構成: ラムダパラメーターの名前に期待される最小文字数、最大文字数、および正規表現を指定するには、「オプション」セクションのフィールドを使用します。 名前の長さをチェックしない場合は、0 を指定します。 正規表現は標準的な 'java.util.regex' 形式で指定する必要があります。",
                  "markdown": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないラムダパラメーターを報告します。\n\n**例:** `Function<String, String> id = X -> X;` は、このインスペクションがパラメーター名の開始文字が小文字であることを要求するデフォルト設定で有効になっている場合に報告されます。\n\nインスペクションの構成:\n\n\nラムダパラメーターの名前に期待される最小文字数、最大文字数、および正規表現を指定するには、「**オプション** 」セクションのフィールドを使用します。\n名前の長さをチェックしない場合は、**0** を指定します。\n\n正規表現は標準的な `java.util.regex` 形式で指定する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LambdaParameterNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規約",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LawOfDemeter",
                "shortDescription": {
                  "text": "デメテルの法則"
                },
                "fullDescription": {
                  "text": "デメテルの法則の違反を報告します。 デメテルの法則は実際には法則ではなく、他の呼び出しから受け取ったオブジェクトに対してメソッドを呼び出してはならないというスタイルガイドラインを規定しています。 このガイドラインに準拠したコードは保守、改変、およびリファクタリングが容易であり、メソッド間の結合がより疎であり、重複が少なく、情報がより秘匿化されています。 一方、このガイドラインを満たすために多くのラッパーメソッドを作成する必要がある場合があります。 例: 'boolean pay(Customer c, Invoice invoice) {\n    int dollars = c.getWallet().contents; // 違反\n    if (dollars >= invoice.getAmount()) {\n      Wallet w = c.getWallet();\n      w.subtract(invoice.getAmount()); // 違反\n      return true;\n    }\n    return false;\n  }' 上記の例は、'Customer' で 'payInvoice(Invoice invoice)' メソッドとして実装した方がよい可能性があります。 ライブラリを変更することなしに修正できないデメテルの法則の違反を無視するには、「ライブラリメソッドへの呼び出しを無視してライブラリフィールドにアクセスする」オプションを使用します。",
                  "markdown": "[デメテルの法則](https://en.wikipedia.org/wiki/Law_of_Demeter)の違反を報告します。\n\n\nデメテルの法則は実際には法則ではなく、他の呼び出しから受け取ったオブジェクトに対してメソッドを呼び出してはならないというスタイルガイドラインを規定しています。\nこのガイドラインに準拠したコードは保守、改変、およびリファクタリングが容易であり、メソッド間の結合がより疎であり、重複が少なく、情報がより秘匿化されています。 一方、このガイドラインを満たすために多くのラッパーメソッドを作成する必要がある場合があります。\n\n**例:**\n\n\n      boolean pay(Customer c, Invoice invoice) {\n        int dollars = c.getWallet().contents; // 違反\n        if (dollars >= invoice.getAmount()) {\n          Wallet w = c.getWallet();\n          w.subtract(invoice.getAmount()); // 違反\n          return true;\n        }\n        return false;\n      }\n\n上記の例は、`Customer` で `payInvoice(Invoice invoice)` メソッドとして実装した方がよい可能性があります。\n\n\nライブラリを変更することなしに修正できないデメテルの法則の違反を無視するには、「**ライブラリメソッドへの呼び出しを無視してライブラリフィールドにアクセスする**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LawOfDemeter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/データフロー",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalUsedAsFieldOrParameterType",
                "shortDescription": {
                  "text": "フィールドまたはパラメーターの型として使用される 'Optional'"
                },
                "fullDescription": {
                  "text": "'java.util.Optional<T>'、'java.util.OptionalDouble'、'java.util.OptionalInt'、'java.util.OptionalLong'、または 'com.google.common.base.Optional' がフィールドまたはパラメーターの型として使用されているケースを報告します。 'Optional' は、「結果がない」ことを明確に表現する方法が必要なライブラリメソッドの戻り値の型に限定的なメカニズムを提供する目的で設計されたものです。 また、クラスを 'Serializable' にする必要がある場合に 'java.util.Optional' 型を持つフィールドを使用することには問題があります。'java.util.Optional' はシリアル化できないためです。 例: 'class MyClass {\n    Optional<String> name; // Optional フィールド\n\n    // Optional のパラメーター\n    void setName(Optional<String> name) {\n      this.name = name;\n    }\n  }'",
                  "markdown": "`java.util.Optional<T>`、`java.util.OptionalDouble`、`java.util.OptionalInt`、`java.util.OptionalLong`、または `com.google.common.base.Optional` がフィールドまたはパラメーターの型として使用されているケースを報告します。\n\n`Optional` は、「結果がない」ことを明確に表現する方法が必要なライブラリメソッドの戻り値の型に限定的なメカニズムを提供する目的で設計されたものです。\n\nまた、クラスを `Serializable` にする必要がある場合に `java.util.Optional` 型を持つフィールドを使用することには問題があります。`java.util.Optional` はシリアル化できないためです。\n\n例:\n\n\n      class MyClass {\n        Optional<String> name; // Optional フィールド\n\n        // Optional のパラメーター\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalUsedAsFieldOrParameterType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceAllDot",
                "shortDescription": {
                  "text": "疑わしい正規表現の引数"
                },
                "fullDescription": {
                  "text": "'String.replaceAll()' または 'String.split()' の呼び出しで、最初の引数が単一の正規表現メタ文字であるものを報告します。 正規表現メタ文字は '.$|()[{^?*+\\' のいずれかです。 これらのメタ文字は、正規表現では特別な意味を持っています。 たとえば、'\"ab.cd\".replaceAll(\".\", \"-\")' を呼び出すと '\"-----\"' が生成されます。ドットは任意の文字と一致するためです。 この場合は、代わりにエスケープされたもの '\"\\\\.\"' が意図されていたと思われます。 'File.separator' を正規表現として使用していることも報告されます。 'File.separator' にはプラットフォーム固有の値があります。 Linux と Mac では '/' と等しくなりますが、Windows では '\\' と等しくなります。これは有効な正規表現ではないため、このようなコードには移植性がありません。 例: 's.replaceAll(\".\", \"-\");' クイックフィックス適用後: 's.replaceAll(\"\\\\.\", \"-\");'",
                  "markdown": "`String.replaceAll()` または `String.split()` の呼び出しで、最初の引数が単一の正規表現メタ文字であるものを報告します。\n\n\n正規表現メタ文字は `.$|()[{^?*+\\` のいずれかです。 これらのメタ文字は、正規表現では特別な意味を持っています。\nたとえば、`\"ab.cd\".replaceAll(\".\", \"-\")` を呼び出すと `\"-----\"` が生成されます。ドットは任意の文字と一致するためです。\nこの場合は、代わりにエスケープされたもの `\"\\\\.\"` が意図されていたと思われます。\n\n\n`File.separator` を正規表現として使用していることも報告されます。 `File.separator` にはプラットフォーム固有の値があります。 Linux と Mac では `/` と等しくなりますが、Windows では `\\` と等しくなります。これは有効な正規表現ではないため、このようなコードには移植性がありません。\n\n**例:**\n\n\n      s.replaceAll(\".\", \"-\");\n\nクイックフィックス適用後:\n\n\n      s.replaceAll(\"\\\\.\", \"-\");\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousRegexArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForCanBeForeach",
                "shortDescription": {
                  "text": "'for' ループは拡張 for ループに置換できます"
                },
                "fullDescription": {
                  "text": "コレクションまたは配列を反復処理し、拡張 'for' ループ (foreach 反復構文) に自動的に置換できる 'for' ループを報告します。 例: 'for (Iterator<String> iterator = list.iterator(); iterator.hasNext(); ) {\n    String item = iterator.next();\n    System.out.println(item);\n  }' クイックフィックス適用後: 'for (String item : list) {\n    System.out.println(item);\n  }' 'list.get(index)' の呼び出しを含むループを検出するには、「インデックス付きの 'java.util.List' ループを報告する」オプションを使用します。 このようなループは多くの場合、'list.remove(index)' の呼び出しなどでプロセスの基になるリストを変更しない限り、拡張 'for' ループに置換できます。 後者の場合、拡張 'for' ループが 'ConcurrentModificationException' をスローする可能性があります。 また、場合によっては 'list.get(index)' ループの処理が若干高速になります。 型パラメーターのないコレクションを無視するには、「型指定されていないコレクションに対して反復を報告しない」オプションを使用します。 これにより、'java.lang.Object' 型の拡張 'for' ループ変数の作成と、ループ変数が使用されるキャストの挿入を防ぐことがます。 このインスペクションは Java 5 以降で使用できる Java の機能 'For-each ループ' に依存しています。",
                  "markdown": "コレクションまたは配列を反復処理し、拡張 `for` ループ (foreach 反復構文) に自動的に置換できる `for` ループを報告します。\n\n**例:**\n\n\n      for (Iterator<String> iterator = list.iterator(); iterator.hasNext(); ) {\n        String item = iterator.next();\n        System.out.println(item);\n      }\n\nクイックフィックス適用後:\n\n\n      for (String item : list) {\n        System.out.println(item);\n      }\n\n\n`list.get(index)` の呼び出しを含むループを検出するには、「**インデックス付きの 'java.util.List' ループを報告する** 」オプションを使用します。\nこのようなループは多くの場合、`list.remove(index)` の呼び出しなどでプロセスの基になるリストを変更しない限り、拡張 `for` ループに置換できます。\n後者の場合、拡張 `for` ループが `ConcurrentModificationException` をスローする可能性があります。\nまた、場合によっては `list.get(index)` ループの処理が若干高速になります。\n\n\n型パラメーターのないコレクションを無視するには、「**型指定されていないコレクションに対して反復を報告しない** 」オプションを使用します。\nこれにより、`java.lang.Object` 型の拡張 `for` ループ変数の作成と、ループ変数が使用されるキャストの挿入を防ぐことがます。\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 'For-each ループ' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForLoopReplaceableByForEach",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AmbiguousFieldAccess",
                "shortDescription": {
                  "text": "外側のコード内要素へのアクセスに見える継承フィールドのアクセス"
                },
                "fullDescription": {
                  "text": "匿名、内部、またはローカルクラスを囲む外側のコードに同じ名前のローカル変数、パラメーター、フィールドがあり、それらのクラスからスーパークラスのフィールドにアクセスしている場合に報告します。 このような場合、実際にはスーパークラスのフィールドへのアクセスであっても、外側のコードの要素がアクセスされているように見えるかもしれません。 コードの意図を明確にするために、フィールドのアクセスに明示的な 'super' 修飾子を追加することをお勧めします。 例: 'class First {\n      protected String ambiguous;\n    }\n    class Second {\n      void foo(String ambiguous) {\n        new First() {\n          {\n            System.out.println(ambiguous); // パラメーターではなくフィールドにアクセスしています\n          }\n        };\n      }\n    }' クイックフィックス適用後: 'class First {\n      protected String ambiguous;\n    }\n    class Second {\n      void foo(String ambiguous) {\n        new First() {\n          {\n            System.out.println(super.ambiguous);\n          }\n        };\n      }\n    }'",
                  "markdown": "匿名、内部、またはローカルクラスを囲む外側のコードに同じ名前のローカル変数、パラメーター、フィールドがあり、それらのクラスからスーパークラスのフィールドにアクセスしている場合に報告します。 このような場合、実際にはスーパークラスのフィールドへのアクセスであっても、外側のコードの要素がアクセスされているように見えるかもしれません。\n\n\nコードの意図を明確にするために、フィールドのアクセスに明示的な `super` 修飾子を追加することをお勧めします。\n\n**例:**\n\n\n        class First {\n          protected String ambiguous;\n        }\n        class Second {\n          void foo(String ambiguous) {\n            new First() {\n              {\n                System.out.println(ambiguous); // パラメーターではなくフィールドにアクセスしています\n              }\n            };\n          }\n        }\n\nクイックフィックス適用後:\n\n\n        class First {\n          protected String ambiguous;\n        }\n        class Second {\n          void foo(String ambiguous) {\n            new First() {\n              {\n                System.out.println(super.ambiguous);\n              }\n            };\n          }\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AmbiguousFieldAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonProtectedConstructorInAbstractClass",
                "shortDescription": {
                  "text": "抽象クラスの public コンストラクター"
                },
                "fullDescription": {
                  "text": "'abstract' クラスの 'public' コンストラクターを報告します。 'abstract' クラスのコンストラクターはサブクラスのコンストラクターからのみ呼び出し可能であるため、'public' で宣言すると混乱を招く可能性があります。 クイックフィックスにより、このようなコンストラクターを protected にできます。 例: 'public abstract class Foo {\n    public Foo () { // 警告: 'public' 修飾子があります\n        /* ... */\n    }\n  }' クイックフィックス適用後: 'public abstract class Foo {\n    protected Foo () {\n        /* ... */\n    }\n  }' インスペクションの構成: 非 public クラスで 'public' コンストラクターを無視するには、以下の「non-public のクラスでは無視する」オプションを使用します。",
                  "markdown": "`abstract` クラスの `public` コンストラクターを報告します。\n\n\n`abstract` クラスのコンストラクターはサブクラスのコンストラクターからのみ呼び出し可能であるため、`public` で宣言すると混乱を招く可能性があります。\n\nクイックフィックスにより、このようなコンストラクターを protected にできます。\n\n**例:**\n\n\n      public abstract class Foo {\n        public Foo () { // 警告: 'public' 修飾子があります\n            /* ... */\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public abstract class Foo {\n        protected Foo () {\n            /* ... */\n        }\n      }\n\nインスペクションの構成:\n\n非 public クラスで `public` コンストラクターを無視するには、以下の「**non-public のクラスでは無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstructorNotProtectedInAbstractClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparableImplementedButEqualsNotOverridden",
                "shortDescription": {
                  "text": "'Comparable' を実装しているが 'equals()' をオーバーライドしていない"
                },
                "fullDescription": {
                  "text": "'java.lang.Comparable' を実装しているものの、'equals()' をオーバーライドしていないクラスを報告します。 'equals()' がオーバーライドされていない場合、'equals()' の実装は 'compareTo()' の実装と矛盾します。 このようなクラスのオブジェクトが 'java.util.SortedSet' などのコレクションに追加された場合、このコレクションは 'equals()' の項で定義されている 'java.util.Set' の契約に違反します。 例: 'class Length implements Comparable<Length> {\n    private int cm = 0;\n\n    @Override\n    public int compareTo(@NotNull Length o) {\n      if (cm == o.cm) return 0;\n      return cm < o.cm ? -1 : 1;\n    }\n  }' クイックフィックス適用後: 'class Length implements Comparable<Length> {\n    private int cm = 0;\n\n    @Override\n    public int compareTo(@NotNull Length o) {\n      if (cm == o.cm) return 0;\n      return cm < o.cm ? -1 : 1;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      return o instanceof Length && compareTo((Length) o) == 0;\n    }\n  }'",
                  "markdown": "`java.lang.Comparable` を実装しているものの、`equals()` をオーバーライドしていないクラスを報告します。\n\n\n`equals()` がオーバーライドされていない場合、`equals()` の実装は `compareTo()` の実装と矛盾します。 このようなクラスのオブジェクトが `java.util.SortedSet` などのコレクションに追加された場合、このコレクションは `equals()` の項で定義されている `java.util.Set` の契約に違反します。\n\n**例:**\n\n\n      class Length implements Comparable<Length> {\n        private int cm = 0;\n\n        @Override\n        public int compareTo(@NotNull Length o) {\n          if (cm == o.cm) return 0;\n          return cm < o.cm ? -1 : 1;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Length implements Comparable<Length> {\n        private int cm = 0;\n\n        @Override\n        public int compareTo(@NotNull Length o) {\n          if (cm == o.cm) return 0;\n          return cm < o.cm ? -1 : 1;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n          return o instanceof Length && compareTo((Length) o) == 0;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparableImplementedButEqualsNotOverridden",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageVisibleField",
                "shortDescription": {
                  "text": "パッケージ可視フィールド"
                },
                "fullDescription": {
                  "text": "アクセス修飾子なしで宣言されているフィールド (package-private とも呼ばれる) を報告します。 定数 (すなわち、'static' と 'final' が付いたフィールド) は報告されません。 例: 'public class A {\n    Object object;             // 警告\n    final static int MODE = 0; // 定数は警告されません\n  }'",
                  "markdown": "アクセス修飾子なしで宣言されているフィールド (package-private とも呼ばれる) を報告します。\n\n定数 (すなわち、`static` と `final` が付いたフィールド) は報告されません。\n\n**例:**\n\n\n      public class A {\n        Object object;             // 警告\n        final static int MODE = 0; // 定数は警告されません\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageVisibleField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/カプセル化",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MapReplaceableByEnumMap",
                "shortDescription": {
                  "text": "'EnumMap' に置換可能な 'Map'"
                },
                "fullDescription": {
                  "text": "キーの型が列挙型クラスになっている 'java.util.Map' オブジェクトのインスタンス化を報告します。 このような 'java.util.Map' オブジェクトは 'java.util.EnumMap' オブジェクトに置換できます。 'java.util.EnumMap' で実装すると、大幅に効率が良くなります。その基本データ構造が単純な配列であるためです。 例: 'Map<MyEnum, String> myEnums = new HashMap<>();' クイックフィックス適用後: 'Map<MyEnum, String> myEnums = new EnumMap<>(MyEnum.class);'",
                  "markdown": "キーの型が列挙型クラスになっている `java.util.Map` オブジェクトのインスタンス化を報告します。 このような `java.util.Map` オブジェクトは `java.util.EnumMap` オブジェクトに置換できます。\n\n\n`java.util.EnumMap` で実装すると、大幅に効率が良くなります。その基本データ構造が単純な配列であるためです。\n\n**例:**\n\n\n      Map<MyEnum, String> myEnums = new HashMap<>();\n\nクイックフィックス適用後:\n\n\n      Map<MyEnum, String> myEnums = new EnumMap<>(MyEnum.class);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MapReplaceableByEnumMap",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstantiationOfUtilityClass",
                "shortDescription": {
                  "text": "ユーティリティクラスのインスタンス化"
                },
                "fullDescription": {
                  "text": "'new' キーワードを使用したユーティリティクラスのインスタンス化を報告します。 ユーティリティクラスでは、すべてのフィールドとメソッドは 'static' です。 このようなクラスのインスタンス化は不要であり、間違いの可能性が高いです。 例: 'class MyUtils {\n    public static double cube(double x) {\n      return x * x * x;\n    }\n  }\n  class Main {\n    public static void main(String[] args) {\n      // ユーティリティクラスのインスタンス化\n      MyUtils utils = new MyUtils();\n    }\n  }' ユーティリティクラスのインスタンス化を阻止するため、'private' コンストラクターを使用することをお勧めします。",
                  "markdown": "`new` キーワードを使用したユーティリティクラスのインスタンス化を報告します。\n\n\nユーティリティクラスでは、すべてのフィールドとメソッドは `static` です。\nこのようなクラスのインスタンス化は不要であり、間違いの可能性が高いです。\n\n**例:**\n\n\n      class MyUtils {\n        public static double cube(double x) {\n          return x * x * x;\n        }\n      }\n      class Main {\n        public static void main(String[] args) {\n          // ユーティリティクラスのインスタンス化\n          MyUtils utils = new MyUtils();\n        }\n      }\n\n\nユーティリティクラスのインスタンス化を阻止するため、`private` コンストラクターを使用することをお勧めします。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstantiationOfUtilityClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrailingWhitespacesInTextBlock",
                "shortDescription": {
                  "text": "テキストブロック内にある末尾の空白"
                },
                "fullDescription": {
                  "text": "末尾に空白文字があるテキストブロックを報告します。 末尾の空白は偶発的なものと考えられ、Java コンパイラーにより取り除かれます。 2021.1 の新機能です このインスペクションは Java 15 以降で使用できる Java の機能 'テキストブロックリテラル' に依存しています。",
                  "markdown": "末尾に空白文字があるテキストブロックを報告します。 末尾の空白は偶発的なものと考えられ、Java コンパイラーにより取り除かれます。\n\n2021.1 の新機能です\n\nこのインスペクションは Java 15 以降で使用できる Java の機能 'テキストブロックリテラル' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TrailingWhitespacesInTextBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnNull",
                "shortDescription": {
                  "text": "'null' の戻り値"
                },
                "fullDescription": {
                  "text": "戻り値が 'null' の 'return' ステートメントを報告します。 このコンストラクトは便利な場合もありますが、'NullPointerException' でコードが失敗しやすくなる可能性があります。 メソッドが 'null' を返すように設計されている場合は、'@Nullable' アノテーションを付けることをお勧めします。その場合、該当のメソッドはこのインスペクションでは無視されます。 例: 'class Person {\n    public String getName () {\n      return null;\n    }\n  }' クイックフィックス適用後: 'class Person {\n    public @Nullable String getName () {\n      return null;\n    }\n  }' 戻り値の型が 'java.util.Optional' の場合、'null' を 'Optional.empty()' に変換する追加のクイックフィックスが提案されます。 このインスペクションは、次のオプションを使用して構成できます。 'private' メソッドを無視するかどうか。 この場合、匿名クラスとラムダからの 'null' の返却も無視します。 配列の 'null' 値の返却、コレクションオブジェクトの返却、プレーンオブジェクトの返却、またはこれらの 3 つの組み合わせを報告するかどうか。 戻り値の型が 'java.util.Optional' のメソッドでの 'null' の返却は常に報告されます。 'nullable' と見なすアノテーションを指定するには、「アノテーションの構成」をクリックします。",
                  "markdown": "戻り値が `null` の `return` ステートメントを報告します。 このコンストラクトは便利な場合もありますが、`NullPointerException` でコードが失敗しやすくなる可能性があります。\n\n\nメソッドが `null` を返すように設計されている場合は、`@Nullable` アノテーションを付けることをお勧めします。その場合、該当のメソッドはこのインスペクションでは無視されます。\n\n**例:**\n\n\n      class Person {\n        public String getName () {\n          return null;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Person {\n        public @Nullable String getName () {\n          return null;\n        }\n      }\n\n\n戻り値の型が `java.util.Optional` の場合、`null` を `Optional.empty()` に変換する追加のクイックフィックスが提案されます。\n\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* `private` メソッドを無視するかどうか。 この場合、匿名クラスとラムダからの `null` の返却も無視します。\n* 配列の `null` 値の返却、コレクションオブジェクトの返却、プレーンオブジェクトの返却、またはこれらの 3 つの組み合わせを報告するかどうか。 戻り値の型が `java.util.Optional` のメソッドでの `null` の返却は常に報告されます。\n* 'nullable' と見なすアノテーションを指定するには、「**アノテーションの構成**」をクリックします。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReturnOfNull",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ/null 許容性の問題",
                      "index": 119,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewClassNamingConvention",
                "shortDescription": {
                  "text": "クラスの命名規則"
                },
                "fullDescription": {
                  "text": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないクラスを報告します。 例: このインスペクションがテストに対して有効になっており、クラス名の最小文字数に 8 (デフォルト) が指定されている場合、次のテストクラスはクラス名の文字数が 8 未満の 6 であるため、警告が発生します: 'public class MyTest{}'。 このようなクラスの名前を変更するクイックフィックスは、エディターでのみ使用できます。 インスペクションの構成: チェック対象のクラスを指定するには、「オプション」セクション内のリストを使用します。 チェック対象外にするクラスのチェックボックスからはチェックを外してください。 提供された入力フィールドを使用して、クラスの型ごとにクラス名に期待される最小長、最大長、および正規表現を指定します。 対応するチェックをスキップするには、長さフィールドに 0 を指定します。 正規表現は標準的な 'java.util.regex' 形式で指定する必要があります。",
                  "markdown": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないクラスを報告します。\n\n**例:** このインスペクションがテストに対して有効になっており、クラス名の最小文字数に 8 (デフォルト) が指定されている場合、次のテストクラスはクラス名の文字数が 8 未満の 6 であるため、警告が発生します: `public class MyTest{}`。\n\nこのようなクラスの名前を変更するクイックフィックスは、エディターでのみ使用できます。\n\nインスペクションの構成:\n\n\nチェック対象のクラスを指定するには、「**オプション**」セクション内のリストを使用します。 チェック対象外にするクラスのチェックボックスからはチェックを外してください。\n\n提供された入力フィールドを使用して、クラスの型ごとにクラス名に期待される最小長、最大長、および正規表現を指定します。 対応するチェックをスキップするには、長さフィールドに **0** を指定します。\n\n正規表現は標準的な `java.util.regex` 形式で指定する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewClassNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規則/クラス",
                      "index": 68,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggingStringTemplateAsArgument",
                "shortDescription": {
                  "text": "文字列テンプレートをロギング呼び出しの引数に使用"
                },
                "fullDescription": {
                  "text": "SLF4J および Log4j 2 ロギングメソッドの引数として使用されている文字列テンプレートを報告します。 メソッド 'org.apache.logging.log4j.Logger.log()' とそのオーバーロードは「すべてのログレベル」オプションでのみサポートされています。 文字列テンプレートは、ロギングメッセージがログに記録されない場合でも実行時に評価されます。そのため、パフォーマンスに否定的な影響を及ぼす可能性があります。 代わりに、ロギングが無効な場合には評価されないパラメーター化されたログメッセージを使用することをお勧めします。 例 (Kotlin の場合): 'val variable1 = getVariable()\n      logger.info(\"variable1: $variable1\")' クイックフィックス適用後 (Kotlin の場合): 'val variable1 = getVariable()\n      logger.info(\"variable1: {}\", variable1)' 提案される置換は、元のコードと同等ではない場合があることに注意してください。たとえば、文字列テンプレートにメソッド呼び出しまたは引数式が含まれている場合が挙げられます。 特定のより高いロギングレベルを無視するには、「警告対象」リストを使用します。 より高いロギングレベルは常に有効にできます。また、引数は常に評価されます。 プリミティブ型、それらのラッパー、または文字列を持つ式のみが含まれる文字列テンプレートを無視するには、「プリミティブ型、それらのラッパー、または文字列を持つ式のみが含まれている場合は警告しない」オプションを使用します。 このオプションは、コレクションの遅延読み込みを防ぐ場合などに役立つ場合があります。 プリミティブ型、それらのラッパー、または文字列を持つ式のみが含まれている文字列を実行時に作成すると、パフォーマンスに否定的な影響を及ぼす可能性があることに注意してください。 メッセージの後に引数として例外のみを含む呼び出しを無視するには、「メッセージの引数の後に例外のみを引数に取っている呼び出しの場合に警告しない」オプションを使用します。 たとえば、カスタムのコードスタイルを使用してインスペクションの動作を調整するのに役立つ可能性があります。 2023.1 の新機能です",
                  "markdown": "**SLF4J** および **Log4j 2** ロギングメソッドの引数として使用されている文字列テンプレートを報告します。 メソッド `org.apache.logging.log4j.Logger.log()` とそのオーバーロードは「**すべてのログレベル** 」オプションでのみサポートされています。 文字列テンプレートは、ロギングメッセージがログに記録されない場合でも実行時に評価されます。そのため、パフォーマンスに否定的な影響を及ぼす可能性があります。 代わりに、ロギングが無効な場合には評価されないパラメーター化されたログメッセージを使用することをお勧めします。\n\n**例 (Kotlin の場合):**\n\n\n          val variable1 = getVariable()\n          logger.info(\"variable1: $variable1\")\n\n**クイックフィックス適用後 (Kotlin の場合):**\n\n\n          val variable1 = getVariable()\n          logger.info(\"variable1: {}\", variable1)\n\n\n提案される置換は、元のコードと同等ではない場合があることに注意してください。たとえば、文字列テンプレートにメソッド呼び出しまたは引数式が含まれている場合が挙げられます。\n\n* 特定のより高いロギングレベルを無視するには、「**警告対象**」リストを使用します。 より高いロギングレベルは常に有効にできます。また、引数は常に評価されます。\n* プリミティブ型、それらのラッパー、または文字列を持つ式のみが含まれる文字列テンプレートを無視するには、「**プリミティブ型、それらのラッパー、または文字列を持つ式のみが含まれている場合は警告しない**」オプションを使用します。 このオプションは、コレクションの遅延読み込みを防ぐ場合などに役立つ場合があります。 プリミティブ型、それらのラッパー、または文字列を持つ式のみが含まれている文字列を実行時に作成すると、パフォーマンスに否定的な影響を及ぼす可能性があることに注意してください。\n* メッセージの後に引数として例外のみを含む呼び出しを無視するには、「**メッセージの引数の後に例外のみを引数に取っている呼び出しの場合に警告しない**」オプションを使用します。 たとえば、カスタムのコードスタイルを使用してインスペクションの動作を調整するのに役立つ可能性があります。\n\n2023.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoggingStringTemplateAsArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語/ログ関連",
                      "index": 45,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnpredictableBigDecimalConstructorCall",
                "shortDescription": {
                  "text": "予測不可能な 'BigDecimal' コンストラクターの呼び出し"
                },
                "fullDescription": {
                  "text": "'double' 値を受け付ける 'BigDecimal' コンストラクターへの呼び出しを報告します。 このようなコンストラクターは、与えられた 'double' 値と正確に等しい 'BigDecimal' を生成します。 ただし、double は IEEE 754 64 ビット倍精度バイナリ浮動小数点形式でエンコードされているため、正確な値を期待できない場合があります。 たとえば、'new BigDecimal(0.1)' は 'BigDecimal' オブジェクトを生成します。 その値は '0.1000000000000000055511151231257827021181583404541015625' であり、これは double で表現可能な 0.1 に最も近い数値です。 ソースコードの記述と同じ値を格納する 'BigDecimal' を得るには、'new BigDecimal(\"0.1\")' または 'BigDecimal.valueOf(0.1)' のいずれかを使用してください。 例: 'class Constructor {\n    void foo() {\n      new BigDecimal(0.1);\n    }\n  }' クイックフィックス適用後: 'class Constructor {\n    void foo() {\n      new BigDecimal(\"0.1\");\n    }\n  }'",
                  "markdown": "`double` 値を受け付ける `BigDecimal` コンストラクターへの呼び出しを報告します。 このようなコンストラクターは、与えられた `double` 値と正確に等しい `BigDecimal` を生成します。 ただし、double は IEEE 754 64 ビット倍精度バイナリ浮動小数点形式でエンコードされているため、正確な値を期待できない場合があります。\n\nたとえば、`new BigDecimal(0.1)` は `BigDecimal` オブジェクトを生成します。 その値は `0.1000000000000000055511151231257827021181583404541015625` であり、これは double で表現可能な 0.1 に最も近い数値です。\nソースコードの記述と同じ値を格納する `BigDecimal` を得るには、`new BigDecimal(\"0.1\")` または `BigDecimal.valueOf(0.1)` のいずれかを使用してください。\n\n**例:**\n\n\n      class Constructor {\n        void foo() {\n          new BigDecimal(0.1);\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Constructor {\n        void foo() {\n          new BigDecimal(\"0.1\");\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnpredictableBigDecimalConstructorCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseCompareMethod",
                "shortDescription": {
                  "text": "'compare()' メソッドを使用して数値を比較可能"
                },
                "fullDescription": {
                  "text": "冗長性の高いコンストラクトか効率が低いコンストラクトの代わりに、'Long'、'Short'、'Byte'、'Double' または 'Float' クラスの 'Integer.compare()' メソッドまたは同様のメソッドへの呼び出しに置換できる式を報告します。 'x' と 'y' がボクシングされた整数の場合は 'x.compareTo(y)' が提案され、プリミティブの場合は 'Integer.compare(x, y)' が提案されます。 例: 'public int compare(int x, int y) {\n    return x > y ? 1 : x < y ? -1 : 0;\n  }' クイックフィックス適用後: 'public int compare(int x, int y) {\n    return Integer.compare(x, y);\n  }' 'Double.compare' と 'Float.compare' により、コードのセマンティクスがわずかに変更されます。 具体的には、'-0.0' と '0.0' が区別されるようになります ('Double.compare(-0.0, 0.0)' が -1 になります)。 また、'NaN' 値が一貫して処理されます。 ほとんどの場合、実際にはこのセマンティクスの変更によってコードが改善されます。 セマンティクスの変更が受け入れられない場合は、チェックボックスを使用して浮動小数点数に対するこのインスペクションを無効にしてください。 2017.2 の新機能です",
                  "markdown": "冗長性の高いコンストラクトか効率が低いコンストラクトの代わりに、`Long`、`Short`、`Byte`、`Double` または `Float` クラスの `Integer.compare()` メソッドまたは同様のメソッドへの呼び出しに置換できる式を報告します。\n\n`x` と `y` がボクシングされた整数の場合は `x.compareTo(y)` が提案され、プリミティブの場合は `Integer.compare(x, y)` が提案されます。\n\n**例:**\n\n\n      public int compare(int x, int y) {\n        return x > y ? 1 : x < y ? -1 : 0;\n      }\n\nクイックフィックス適用後:\n\n\n      public int compare(int x, int y) {\n        return Integer.compare(x, y);\n      }\n\n\n`Double.compare` と `Float.compare` により、コードのセマンティクスがわずかに変更されます。 具体的には、`-0.0` と `0.0` が区別されるようになります (`Double.compare(-0.0, 0.0)` が -1 になります)。\nまた、`NaN` 値が一貫して処理されます。 ほとんどの場合、実際にはこのセマンティクスの変更によってコードが改善されます。 セマンティクスの変更が受け入れられない場合は、チェックボックスを使用して浮動小数点数に対するこのインスペクションを無効にしてください。\n\n2017.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseCompareMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援",
                      "index": 52,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IntegerDivisionInFloatingPointContext",
                "shortDescription": {
                  "text": "浮動小数点コンテキストにおける整数除算"
                },
                "fullDescription": {
                  "text": "結果が浮動小数点数として使用されている整数の除算を報告します。 このような除算は多くの場合は誤りであり、整数の除算によって発生する切り捨てが原因で予期しない結果になる場合があります。 例: 'float x = 3.0F + 3 * 2 / 5;' クイックフィックス適用後: 'float x = 3.0F + ((float) (3 * 2)) /5;'",
                  "markdown": "結果が浮動小数点数として使用されている整数の除算を報告します。 このような除算は多くの場合は誤りであり、整数の除算によって発生する切り捨てが原因で予期しない結果になる場合があります。\n\n**例:**\n\n\n      float x = 3.0F + 3 * 2 / 5;\n\nクイックフィックス適用後:\n\n\n      float x = 3.0F + ((float) (3 * 2)) /5;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IntegerDivisionInFloatingPointContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertWithoutMessage",
                "shortDescription": {
                  "text": "メッセージの無いアサーション"
                },
                "fullDescription": {
                  "text": "エラーメッセージ文字列の引数がない 'assertXXX()' または 'fail()' の呼び出しを報告します。 アサーションの失敗に関するエラーメッセージがテストケースの意図を明確にするのに役立つ場合があります。 例: 'assertTrue(checkValid());' クイックフィックス適用後: 'assertTrue(checkValid(), \"|\");' 使用しているアサーションフレームワークに従って、メッセージの引数が既存の引数の前または後に追加されます。",
                  "markdown": "エラーメッセージ文字列の引数がない `assertXXX()` または `fail()` の呼び出しを報告します。 アサーションの失敗に関するエラーメッセージがテストケースの意図を明確にするのに役立つ場合があります。\n\n**例:**\n\n\n      assertTrue(checkValid());\n\nクイックフィックス適用後:\n\n    assertTrue(checkValid(), \"|\");\n\n\n使用しているアサーションフレームワークに従って、メッセージの引数が既存の引数の前または後に追加されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertWithoutMessage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/テストフレームワーク",
                      "index": 96,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MoveFieldAssignmentToInitializer",
                "shortDescription": {
                  "text": "イニシャライザーに移動できるフィールド代入"
                },
                "fullDescription": {
                  "text": "代入によるフィールドの初期化をフィールドの宣言内での初期化に置換することを提案します。 フィールドの代入がインスタンスまたは static イニシャライザー内にあり、フィールドの宣言と結合するほうが安全であると思われる場合にのみ報告します。 コンストラクター内での代入など、それ以外の場合はハイライトなしでクイックフィックスが提供されます。これは、修正によってセマンティクスが変更される可能性があるためです。 例: 'class MyClass {\n    static final int intConstant;\n    \n    static {\n      intConstant = 10;\n    }\n  }' クイックフィックスは、代入される値をフィールドイニシャライザーに移動し、可能な場合にクラスイニシャライザーを除去します。 'class MyClass {\n    static final int intConstant = 10;\n  }' 2017.2 から導入された機能です",
                  "markdown": "代入によるフィールドの初期化をフィールドの宣言内での初期化に置換することを提案します。\n\nフィールドの代入がインスタンスまたは static イニシャライザー内にあり、フィールドの宣言と結合するほうが安全であると思われる場合にのみ報告します。\nコンストラクター内での代入など、それ以外の場合はハイライトなしでクイックフィックスが提供されます。これは、修正によってセマンティクスが変更される可能性があるためです。\n\n例:\n\n\n      class MyClass {\n        static final int intConstant;\n        \n        static {\n          intConstant = 10;\n        }\n      }\n\nクイックフィックスは、代入される値をフィールドイニシャライザーに移動し、可能な場合にクラスイニシャライザーを除去します。\n\n\n      class MyClass {\n        static final int intConstant = 10;\n      }\n\n2017.2 から導入された機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MoveFieldAssignmentToInitializer",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationInFormatCall",
                "shortDescription": {
                  "text": "文字列連結を 'format()' の呼び出し引数に使用"
                },
                "fullDescription": {
                  "text": "フォーマット文字列引数として使用されている非定数の文字列連結を報告します。 このような文字列連結は意図的な場合もありますが、フォーマットメソッドを誤用している場合がほとんどです。また、連結された文字列で使用されている変数に '%' などの特殊文字が含まれている場合にはセキュリティの問題が発生することもあります。 また、',' のつもりで '+' を入力することで、文字列書式設定の引数を誤って連結した結果である可能性もあります。 例: 'static String formatGreeting(String userName) {\n    return String.format(\"Hello, \" + userName);\n  }' この例では、'userName' がフォーマット文字列の一部として解釈されます。その結果、('userName' が '\"%\"' の場合などに) 'IllegalFormatException' が発生したり、('userName' が '\"%2000000000%\"' の場合などに) 膨大な量のメモリが使用されたりする可能性があります。 この呼び出しは 'String.format(\"Hello, %s\", userName);' に置換する必要があると思われます。 このインスペクションは、'java.util.Formatter'、'java.lang.String'、'java.io.PrintWriter'、 または 'java.io.PrintStream' のフォーマットメソッドの呼び出しをチェックします。",
                  "markdown": "フォーマット文字列引数として使用されている非定数の文字列連結を報告します。\n\n\nこのような文字列連結は意図的な場合もありますが、フォーマットメソッドを誤用している場合がほとんどです。また、連結された文字列で使用されている変数に `%` などの特殊文字が含まれている場合にはセキュリティの問題が発生することもあります。\n\n\nまた、`,` のつもりで `+` を入力することで、文字列書式設定の引数を誤って連結した結果である可能性もあります。\n\n**例:**\n\n\n      static String formatGreeting(String userName) {\n        return String.format(\"Hello, \" + userName);\n      }\n\n\nこの例では、`userName` がフォーマット文字列の一部として解釈されます。その結果、(`userName` が `\"%\"` の場合などに) `IllegalFormatException` が発生したり、(`userName` が `\"%2000000000%\"` の場合などに) 膨大な量のメモリが使用されたりする可能性があります。\nこの呼び出しは `String.format(\"Hello, %s\", userName);` に置換する必要があると思われます。\n\n\nこのインスペクションは、`java.util.Formatter`、`java.lang.String`、`java.io.PrintWriter`、\nまたは `java.io.PrintStream` のフォーマットメソッドの呼び出しをチェックします。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationInFormatCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalBreakInInfiniteLoop",
                "shortDescription": {
                  "text": "ループ内の条件付き break"
                },
                "fullDescription": {
                  "text": "ループの最初または最後にある条件付き break を報告し、代わりにループ条件を追加してコードを短縮することを提案します。 例: 'while (true) {\n    if (i  == 23) break;\n    i++;\n  }' クイックフィックス適用後: 'while (i != 23) {\n    i++;\n  }'",
                  "markdown": "ループの最初または最後にある条件付き break を報告し、代わりにループ条件を追加してコードを短縮することを提案します。\n\n例:\n\n\n      while (true) {\n        if (i  == 23) break;\n        i++;\n      }\n\nクイックフィックス適用後:\n\n\n      while (i != 23) {\n        i++;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConditionalBreakInInfiniteLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnqualifiedInnerClassAccess",
                "shortDescription": {
                  "text": "修飾されていない内部クラスアクセス"
                },
                "fullDescription": {
                  "text": "外側のクラスの名前で修飾されていない内側のクラスへの参照を報告します。 例: 'import foo.Foo.Bar;\n\n  class Foo {\n    class Bar {}\n  }\n\n  class Baz {\n    void f(Bar bar) {}\n  }' クイックフィックス適用後: 'class Foo {\n    class Bar {}\n  }\n\n  class Baz {\n    void f(Foo.Bar bar) {}\n  }' 同じクラス内にある内側のクラスを無視するには、インスペクションの設定を使用します。この場合、インポートは必要ありません。",
                  "markdown": "外側のクラスの名前で修飾されていない内側のクラスへの参照を報告します。\n\n**例:**\n\n\n      import foo.Foo.Bar;\n\n      class Foo {\n        class Bar {}\n      }\n\n      class Baz {\n        void f(Bar bar) {}\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        class Bar {}\n      }\n\n      class Baz {\n        void f(Foo.Bar bar) {}\n      }\n\n\n同じクラス内にある内側のクラスを無視するには、インスペクションの設定を使用します。この場合、インポートは必要ありません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnqualifiedInnerClassAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantClassCall",
                "shortDescription": {
                  "text": "冗長な 'isInstance()' または 'cast()' の呼び出し"
                },
                "fullDescription": {
                  "text": "冗長な 'java.lang.Class' メソッドの呼び出しを報告します。 たとえば、'Xyz.class.isInstance(object)' は 'object instanceof Xyz' に置換できます。 instanceof によるチェックを推奨します。これらは組み込みのメソッドであるため、パフォーマンスは同等と考えられますが、後者のほうが静的なチェックを明確に表しています。 2018.2 の新機能です",
                  "markdown": "冗長な `java.lang.Class` メソッドの呼び出しを報告します。\n\nたとえば、`Xyz.class.isInstance(object)` は `object instanceof Xyz` に置換できます。\ninstanceof によるチェックを推奨します。これらは組み込みのメソッドであるため、パフォーマンスは同等と考えられますが、後者のほうが静的なチェックを明確に表しています。\n\n2018.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantClassCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitWhileHoldingTwoLocks",
                "shortDescription": {
                  "text": "2 つのロックを保持する 'wait()'"
                },
                "fullDescription": {
                  "text": "現在のスレッドが 2 つのロックを保持している間に発生する可能性のある 'wait()' メソッドの呼び出しを報告します。 'wait()' の呼び出しではターゲットのロックが 1 つしか解放されないため、2 つのロックを保持した状態で待機した場合は容易にデッドロックが発生する可能性があります。 例: 'synchronized (lockA) {\n    synchronized (lockB) {\n      lockB.wait(); //警告\n      //スレッド A はここで lockA を保持したまま停止します\n    }\n  }\n\n  synchronized (lockA) { //スレッド B はブロックに入ってスレッド A を解放できません\n    lockB.notify();\n  }'",
                  "markdown": "現在のスレッドが 2 つのロックを保持している間に発生する可能性のある `wait()` メソッドの呼び出しを報告します。\n\n\n`wait()` の呼び出しではターゲットのロックが 1 つしか解放されないため、2 つのロックを保持した状態で待機した場合は容易にデッドロックが発生する可能性があります。\n\n**例:**\n\n\n      synchronized (lockA) {\n        synchronized (lockB) {\n          lockB.wait(); //警告\n          //スレッド A はここで lockA を保持したまま停止します\n        }\n      }\n\n      synchronized (lockA) { //スレッド B はブロックに入ってスレッド A を解放できません\n        lockB.notify();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitWhileHoldingTwoLocks",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryStringEscape",
                "shortDescription": {
                  "text": "不必要にエスケープされた文字"
                },
                "fullDescription": {
                  "text": "'String' リテラル内、および必要に応じて 'char' リテラル内で不必要にエスケープされている文字を報告します。 エスケープされたタブ文字 '\\t' は報告されません。タブ文字は表示されないためです。 例: 'String s = \"\\'Scare\\' quotes\";\n  String t = \"\"\"\n    All you need is\\n\\tLove\\n\"\"\";' クイックフィックス適用後: 'String s = \"'Scare' quotes\";\n  String t = \"\"\"\n    All you need is\n    \\tLove\n  \"\"\";' 2019.3 の新機能です",
                  "markdown": "`String` リテラル内、および必要に応じて `char` リテラル内で不必要にエスケープされている文字を報告します。\n\nエスケープされたタブ文字 `\\t` は報告されません。タブ文字は表示されないためです。\n\n例:\n\n\n      String s = \"\\'Scare\\' quotes\";\n      String t = \"\"\"\n        All you need is\\n\\tLove\\n\"\"\";\n\nクイックフィックス適用後:\n\n\n      String s = \"'Scare' quotes\";\n      String t = \"\"\"\n        All you need is\n        \\tLove\n      \"\"\";\n\n2019.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryStringEscape",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableInnerClassWithNonSerializableOuterClass",
                "shortDescription": {
                  "text": "非 Serializable な外部クラスを持つ Serializable な 非 'static' 内部クラス"
                },
                "fullDescription": {
                  "text": "'Serializable' を実装している非 static の内部クラスで、'Serializable' を実装していないクラス内で宣言されているものを報告します。 このようなクラスは外部クラスを暗黙的に参照しているため、正しくシリアル化される可能性はないと思われます。 例: 'class A {\n    class Main implements Serializable {\n    }\n  }' このインスペクションは、次のオプションを使用して構成できます。 このインスペクションで継承先を報告対象外とするクラスをリストする。 これは、スーパークラスの 'Serializable' を継承しているものの、シリアル化を目的としていないクラスを対象としています。 'Serializable' 匿名クラスを無視するかどうか。",
                  "markdown": "`Serializable` を実装している非 static の内部クラスで、`Serializable` を実装していないクラス内で宣言されているものを報告します。\n\n\nこのようなクラスは外部クラスを暗黙的に参照しているため、正しくシリアル化される可能性はないと思われます。\n\n**例:**\n\n\n      class A {\n        class Main implements Serializable {\n        }\n      }\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* このインスペクションで継承先を報告対象外とするクラスをリストする。 これは、スーパークラスの `Serializable` を継承しているものの、シリアル化を目的としていないクラスを対象としています。\n* `Serializable` 匿名クラスを無視するかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableInnerClassWithNonSerializableOuterClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousListRemoveInLoop",
                "shortDescription": {
                  "text": "ループ内の疑わしい 'List.remove()'"
                },
                "fullDescription": {
                  "text": "昇順ループ内にある 'list.remove(index)' の呼び出しを報告します。 このような呼び出しは疑わしいです。除去処理の後はリストが短くなり、次の要素がスキップされるためです。 このような場合、除去処理の後にインデックス変数を減算して修正するのが簡単ですが、イテレーターを介して除去するか、'removeIf()' メソッド (Java 8 以降) を使用して除去するのうがより確実だと思われます。 'remove()' がループ内で複数回呼び出されることを想定していない場合は、その後に 'break' を追加することを検討してください。 例: 'public static void main(String[] args) {\n    process(new ArrayList<>(\n      Arrays.asList(\"1\", \"2\", \"|\", \"3\", \"4\")));\n  }\n\n  static void process(List<String> list) {\n    for (int i = 0; i < list.size(); i++) {\n      if (list.get(i).equals(\"|\")) {\n        list.remove(i);\n        continue;\n      }\n      System.out.println(list.get(i));\n    }\n  }' '1 2 3 4' のようなコードが出力されるように見えますが、実際には '3' は出力されません。 2018.2 の新機能です",
                  "markdown": "昇順ループ内にある `list.remove(index)` の呼び出しを報告します。\n\n\nこのような呼び出しは疑わしいです。除去処理の後はリストが短くなり、次の要素がスキップされるためです。 このような場合、除去処理の後にインデックス変数を減算して修正するのが簡単ですが、イテレーターを介して除去するか、`removeIf()` メソッド (Java 8 以降) を使用して除去するのうがより確実だと思われます。\n`remove()` がループ内で複数回呼び出されることを想定していない場合は、その後に `break` を追加することを検討してください。\n\n**例:**\n\n      public static void main(String[] args) {\n        process(new ArrayList<>(\n          Arrays.asList(\"1\", \"2\", \"|\", \"3\", \"4\")));\n      }\n\n      static void process(List<String> list) {\n        for (int i = 0; i < list.size(); i++) {\n          if (list.get(i).equals(\"|\")) {\n            list.remove(i);\n            continue;\n          }\n          System.out.println(list.get(i));\n        }\n      }\n\n`1 2 3 4` のようなコードが出力されるように見えますが、実際には `3` は出力されません。\n\n2018.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousListRemoveInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegativeIntConstantInLongContext",
                "shortDescription": {
                  "text": "long コンテキストにある負の int 16 進数定数"
                },
                "fullDescription": {
                  "text": "long コンテキストにある負の int 16 進数の定数を報告します。 このような定数は暗黙的に long に拡張され、上位ビットが 0 ではなく 1 になります (たとえば、0xFFFF_FFFF は 0xFFFF_FFFF_FFFF_FFFFL になります)。 このような挙動が意図されている可能性は低く、たとえ意図されている場合でも、明示的に long 定数を使用するほうが混乱を招く可能性が低くなります。 例: '// 警告: これは int 定数 -1 で、long に拡張されて\n  // 0xFFFF_FFFF_FFFF_FFFFL になります。\n  long mask = 0xFFFF_FFFF;' 2022.3 の新機能です",
                  "markdown": "long コンテキストにある負の int 16 進数の定数を報告します。 このような定数は暗黙的に long に拡張され、上位ビットが 0 ではなく 1 になります (たとえば、0xFFFF_FFFF は 0xFFFF_FFFF_FFFF_FFFFL になります)。 このような挙動が意図されている可能性は低く、たとえ意図されている場合でも、明示的に long 定数を使用するほうが混乱を招く可能性が低くなります。\n\n**例:**\n\n\n      // 警告: これは int 定数 -1 で、long に拡張されて\n      // 0xFFFF_FFFF_FFFF_FFFFL になります。\n      long mask = 0xFFFF_FFFF;\n\n2022.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NegativeIntConstantInLongContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldCanBeLocal",
                "shortDescription": {
                  "text": "ローカル変数にすることができるフィールド"
                },
                "fullDescription": {
                  "text": "ローカル変数に置換できる冗長なクラスフィールドを報告します。 ローカルで使用しているフィールドに毎回必ず先行して代入を行っている場合、そのフィールドを除去して使用箇所をローカル変数に置換できます。",
                  "markdown": "ローカル変数に置換できる冗長なクラスフィールドを報告します。\n\nローカルで使用しているフィールドに毎回必ず先行して代入を行っている場合、そのフィールドを除去して使用箇所をローカル変数に置換できます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldCanBeLocal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UrlHashCode",
                "shortDescription": {
                  "text": "'URL' オブジェクトに対する 'equals()' または 'hashCode()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'java.net.URL' オブジェクトに対する 'hashCode()' と 'equals()' の呼び出しと、マップとセットに 'URL' オブジェクトを追加している呼び出しを報告します。 'URL' の 'equals()' メソッドと 'hashCode()' メソッドは、ホスト名を解決するために DNS ルックアップを実行する可能性があります。 このため、ネットワークと DNS サーバーの可用性と速度によっては大幅な遅延が発生する場合があります。 'java.net.URL' の代わりに 'java.net.URI' を使用することで、DNS ルックアップを回避できます。 例: 'boolean urlEquals(URL url1, URL url2) {\n      return url1.equals(url2);\n  }'",
                  "markdown": "`java.net.URL` オブジェクトに対する `hashCode()` と `equals()` の呼び出しと、マップとセットに `URL` オブジェクトを追加している呼び出しを報告します。\n\n\n`URL` の `equals()` メソッドと `hashCode()` メソッドは、ホスト名を解決するために DNS ルックアップを実行する可能性があります。\nこのため、ネットワークと DNS サーバーの可用性と速度によっては大幅な遅延が発生する場合があります。\n`java.net.URL` の代わりに `java.net.URI` を使用することで、DNS ルックアップを回避できます。\n\n**例:**\n\n\n      boolean urlEquals(URL url1, URL url2) {\n          return url1.equals(url2);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UrlHashCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WhileLoopSpinsOnField",
                "shortDescription": {
                  "text": "フィールドでの 'while' ループ処理"
                },
                "fullDescription": {
                  "text": "非 'volatile' フィールドの値で周回しており、別スレッドによる変更を待機している 'while' ループを報告します。 このようなループはループ内でほとんど作業が行われない場合に CPU 消費が非常に激しくなる可能性があるうえ、意図したものとは異なるセマンティクスを持っている可能性があります。 Java メモリモデルでは、別スレッドによってフィールドの値が変更された場合でも、このようなループが完了することはありません。 また、Java 9 以降は 'volatile' フィールドの周回ループ内で 'Thread.onSpinWait()' を呼び出すことをお勧めします。これにより、一部のハードウェアのパフォーマンスが大幅に向上する可能性があります。 例: 'class SpinsOnField {\n    boolean ready = false;\n\n    void run() {\n      while (!ready) {\n      }\n      // 何らかの処理を実行します\n    }\n\n    void markAsReady() {\n      ready = true;\n    }\n  }' クイックフィックス適用後: 'class SpinsOnField {\n    volatile boolean ready = false;\n\n    void run() {\n      while (!ready) {\n        Thread.onSpinWait();\n      }\n      // 何らかの処理を実行します\n    }\n\n    void markAsReady() {\n      ready = true;\n    }\n  }' 空の 'while' ループのみを報告するには、インスペクションのオプションを使用します。",
                  "markdown": "非 `volatile` フィールドの値で周回しており、別スレッドによる変更を待機している `while` ループを報告します。\n\n\nこのようなループはループ内でほとんど作業が行われない場合に CPU 消費が非常に激しくなる可能性があるうえ、意図したものとは異なるセマンティクスを持っている可能性があります。\nJava メモリモデルでは、別スレッドによってフィールドの値が変更された場合でも、このようなループが完了することはありません。\n\n\nまた、Java 9 以降は `volatile` フィールドの周回ループ内で `Thread.onSpinWait()` を呼び出すことをお勧めします。これにより、一部のハードウェアのパフォーマンスが大幅に向上する可能性があります。\n\n**例:**\n\n\n      class SpinsOnField {\n        boolean ready = false;\n\n        void run() {\n          while (!ready) {\n          }\n          // 何らかの処理を実行します\n        }\n\n        void markAsReady() {\n          ready = true;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class SpinsOnField {\n        volatile boolean ready = false;\n\n        void run() {\n          while (!ready) {\n            Thread.onSpinWait();\n          }\n          // 何らかの処理を実行します\n        }\n\n        void markAsReady() {\n          ready = true;\n        }\n      }\n\n\n空の `while` ループのみを報告するには、インスペクションのオプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WhileLoopSpinsOnField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DefaultAnnotationParam",
                "shortDescription": {
                  "text": "デフォルトのアノテーションパラメーター値"
                },
                "fullDescription": {
                  "text": "アノテーションパラメーターで、その 'default' 値に代入されているものを報告します。 例: '@interface Test {\n      Class<?> expected() default Throwable.class;\n  }\n\n  @Test(expected = Throwable.class)\n  void testSmth() {}' クイックフィックス適用後: '@Test()\n  void testSmth() {}'",
                  "markdown": "アノテーションパラメーターで、その `default` 値に代入されているものを報告します。\n\n例:\n\n\n      @interface Test {\n          Class<?> expected() default Throwable.class;\n      }\n\n      @Test(expected = Throwable.class)\n      void testSmth() {}\n\nクイックフィックス適用後:\n\n\n      @Test()\n      void testSmth() {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DefaultAnnotationParam",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfStatementWithIdenticalBranches",
                "shortDescription": {
                  "text": "同一の分岐または共通部分を持つ 'if' ステートメント"
                },
                "fullDescription": {
                  "text": "'if' ステートメントで、共通部分を分岐から抽出できるものを報告します。 このような共通部分は条件には依存しないため、'if' ステートメントの内容が分かりにくくなります。 例: 'if (x > 12) {\n    doSomethingBefore();\n    doSomethingDifferent1();\n    doSomethingAfter();\n  } else {\n    doSomethingBefore();\n    doSomethingDifferent2();\n    doSomethingAfter();\n  }' クイックフィックス適用後: 'doSomethingBefore();\n  if (x > 12) {\n    doSomethingDifferent1();\n  } else {\n    doSomethingDifferent2();\n  }\n  doSomethingAfter();' 2018.1 で更新された機能です",
                  "markdown": "`if` ステートメントで、共通部分を分岐から抽出できるものを報告します。\n\nこのような共通部分は条件には依存しないため、`if` ステートメントの内容が分かりにくくなります。\n\n例:\n\n\n      if (x > 12) {\n        doSomethingBefore();\n        doSomethingDifferent1();\n        doSomethingAfter();\n      } else {\n        doSomethingBefore();\n        doSomethingDifferent2();\n        doSomethingAfter();\n      }\n\nクイックフィックス適用後:\n\n\n      doSomethingBefore();\n      if (x > 12) {\n        doSomethingDifferent1();\n      } else {\n        doSomethingDifferent2();\n      }\n      doSomethingAfter();\n\n2018.1 で更新された機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IfStatementWithIdenticalBranches",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InterfaceWithOnlyOneDirectInheritor",
                "shortDescription": {
                  "text": "単一の直接継承を持つインターフェース"
                },
                "fullDescription": {
                  "text": "直接継承が 1 つのみのインターフェースを報告します。 このようなインターフェースは設計をかなり明確にするかもしれませんが、メモリの使用量や帯域幅が制限された環境ではアプリケーションの占有領域が無駄に増える原因になります。 インターフェースを継承先とマージすることを検討してください。 このインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。 このインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。",
                  "markdown": "直接継承が 1 つのみのインターフェースを報告します。 このようなインターフェースは設計をかなり明確にするかもしれませんが、メモリの使用量や帯域幅が制限された環境ではアプリケーションの占有領域が無駄に増える原因になります。 インターフェースを継承先とマージすることを検討してください。\n\n\nこのインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。\nこのインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InterfaceWithOnlyOneDirectInheritor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス/組み込み",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceofChain",
                "shortDescription": {
                  "text": "連鎖した 'instanceof' チェック"
                },
                "fullDescription": {
                  "text": "連鎖している 'if'-'else' ステートメントで、どの条件も 'instanceof' 式またはクラスの等価式 ('String.class' との比較など) になっているものを報告します。 このような構文がある場合、一般的にはこのような型ベースの振り分けを明示的な連鎖する型テストではなくポリモーフィックなメソッド呼び出しで行うことを要求するオブジェクト指向設計に失敗しています。 例: 'double getArea(Shape shape) {\n    // 警告: 抽象化に失敗しています。\n    // shape インターフェースの抽象メソッドである\n    // getArea() を宣言して、すべての継承先で\n    // 実装することをお勧めします。\n    if (shape instanceof Point) {\n      return 0;\n    }\n    if (shape instanceof Circle) {\n      return Math.PI *\n        Math.pow(((Circle) shape).radius(), 2);\n    }\n    if (shape instanceof Rectangle) {\n      return ((Rectangle) shape).width() *\n        ((Rectangle) shape).height();\n    }\n    throw new IllegalArgumentException();\n  }' ライブラリクラスの 'instanceof' 式を無視するには、以下のチェックボックスを使用します。",
                  "markdown": "連鎖している `if`-`else` ステートメントで、どの条件も `instanceof` 式またはクラスの等価式 (`String.class` との比較など) になっているものを報告します。 このような構文がある場合、一般的にはこのような型ベースの振り分けを明示的な連鎖する型テストではなくポリモーフィックなメソッド呼び出しで行うことを要求するオブジェクト指向設計に失敗しています。\n\n例:\n\n\n      double getArea(Shape shape) {\n        // 警告: 抽象化に失敗しています。\n        // shape インターフェースの抽象メソッドである\n        // getArea() を宣言して、すべての継承先で\n        // 実装することをお勧めします。\n        if (shape instanceof Point) {\n          return 0;\n        }\n        if (shape instanceof Circle) {\n          return Math.PI *\n            Math.pow(((Circle) shape).radius(), 2);\n        }\n        if (shape instanceof Rectangle) {\n          return ((Rectangle) shape).width() *\n            ((Rectangle) shape).height();\n        }\n        throw new IllegalArgumentException();\n      }\n\n\nライブラリクラスの `instanceof` 式を無視するには、以下のチェックボックスを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ChainOfInstanceofChecks",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BlockMarkerComments",
                "shortDescription": {
                  "text": "ブロックマーカーのコメント"
                },
                "fullDescription": {
                  "text": "コードブロックのマーカーとして使用されているコメントを報告します。 クイックフィックスを使用すると、このようなコメントが除去されます。 例: 'while (i < 10) {\n    i++;\n  } // end while' クイックフィックス適用後: 'while (i < 10) {\n    i++;\n  }'",
                  "markdown": "コードブロックのマーカーとして使用されているコメントを報告します。 クイックフィックスを使用すると、このようなコメントが除去されます。\n\n例:\n\n\n      while (i < 10) {\n        i++;\n      } // end while\n\nクイックフィックス適用後:\n\n\n      while (i < 10) {\n        i++;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BlockMarkerComments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableHasSerializationMethods",
                "shortDescription": {
                  "text": "'readObject()' と 'writeObject()' のない Serializable クラス"
                },
                "fullDescription": {
                  "text": "'readObject()' および 'writeObject()' メソッドを実装していない 'Serializable' クラスを報告します。 'readObject()' および 'writeObject()' メソッドが実装されていない場合はデフォルトのシリアル化アルゴリズムが使用されますが、多くの環境ではパフォーマンスと互換性の面で最適ではない可能性があります。 このインスペクションは、次のオプションを使用して構成できます。 このインスペクションで継承先を報告対象外とするクラスをリストする。 これは、スーパークラスの 'Serializable' を継承しているものの、シリアル化を目的としていないクラスを対象としています。 非 static フィールドのない 'Serializable' クラスを無視するかどうか。 'Serializable' 匿名クラスを無視するかどうか。",
                  "markdown": "`readObject()` および `writeObject()` メソッドを実装していない `Serializable` クラスを報告します。\n\n\n`readObject()` および `writeObject()` メソッドが実装されていない場合はデフォルトのシリアル化アルゴリズムが使用されますが、多くの環境ではパフォーマンスと互換性の面で最適ではない可能性があります。\n\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* このインスペクションで継承先を報告対象外とするクラスをリストする。 これは、スーパークラスの `Serializable` を継承しているものの、シリアル化を目的としていないクラスを対象としています。\n* 非 static フィールドのない `Serializable` クラスを無視するかどうか。\n* `Serializable` 匿名クラスを無視するかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableHasSerializationMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizeOnLock",
                "shortDescription": {
                  "text": "'Lock' オブジェクトの同期"
                },
                "fullDescription": {
                  "text": "'java.util.concurrent.locks.Lock' のインスタンスをロックしている 'synchronized' ブロックを報告します。 このような同期はほぼ確実に意図されたものではありません。代わりに適切なバージョンの '.lock()' と '.unlock()' を使用する必要があります。 例: 'final ReentrantLock lock = new ReentrantLock();\n\n  public void foo() {\n    synchronized (lock) {}\n  }'",
                  "markdown": "`java.util.concurrent.locks.Lock` のインスタンスをロックしている `synchronized` ブロックを報告します。 このような同期はほぼ確実に意図されたものではありません。代わりに適切なバージョンの `.lock()` と `.unlock()` を使用する必要があります。\n\n**例:**\n\n\n      final ReentrantLock lock = new ReentrantLock();\n\n      public void foo() {\n        synchronized (lock) {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchroniziationOnLockObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BadExceptionCaught",
                "shortDescription": {
                  "text": "禁止対象の 'Exception' がキャッチされました"
                },
                "fullDescription": {
                  "text": "不適切な例外をキャッチしている 'catch' 節を報告します。 たとえば、'java.lang.NullPointerException' や 'java.lang.IllegalMonitorStateException' のような一部の例外はプログラミングのミスであり、プロダクションコードではほぼ確実にキャッチすべきではありません。 例: 'try {\n    return component.getMousePosition(true) != null;\n  } catch (NullPointerException e) { // 警告: 禁止対象例外 'NullPointerException' がキャッチされています\n    return false;\n  }' 報告対象の例外を指定するには、禁止対象例外 リストを使用します。",
                  "markdown": "不適切な例外をキャッチしている `catch` 節を報告します。\n\nたとえば、`java.lang.NullPointerException` や `java.lang.IllegalMonitorStateException` のような一部の例外はプログラミングのミスであり、プロダクションコードではほぼ確実にキャッチすべきではありません。\n\n**例:**\n\n\n      try {\n        return component.getMousePosition(true) != null;\n      } catch (NullPointerException e) { // 警告: 禁止対象例外 'NullPointerException' がキャッチされています\n        return false;\n      }\n\n報告対象の例外を指定するには、**禁止対象例外** リストを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProhibitedExceptionCaught",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IdempotentLoopBody",
                "shortDescription": {
                  "text": "べき等ループの本体"
                },
                "fullDescription": {
                  "text": "最初の繰り返しで生じる副作用を除き、後続のすべての繰り返しで副作用が生じないループを報告します (これはプログラミングにミスがある可能性を示唆している場合があります)。 そのようなループの繰り返しは、0 回、1 回、もしくは無限に続く可能性があります。 ループを無限に繰り返しても到達できないケースがある場合、そのループを 'if' ステートメントに置換できます。 そうしないと、プログラムがループから抜け出せなくなる可能性があります。 例: 'public void foo(String baseName, String names) {\n        int suffix = 1;\n        String name = baseName;\n        while (names.contains(name)) {\n            // エラー: suffix が更新されていないため、ループ本体は常に同じ結果になります\n            name = baseName + suffix;\n        }\n    }' 2018.1 の新機能です",
                  "markdown": "最初の繰り返しで生じる副作用を除き、後続のすべての繰り返しで副作用が生じないループを報告します (これはプログラミングにミスがある可能性を示唆している場合があります)。\n\nそのようなループの繰り返しは、0 回、1 回、もしくは無限に続く可能性があります。\nループを無限に繰り返しても到達できないケースがある場合、そのループを `if` ステートメントに置換できます。\nそうしないと、プログラムがループから抜け出せなくなる可能性があります。\n\n例:\n\n\n        public void foo(String baseName, String names) {\n            int suffix = 1;\n            String name = baseName;\n            while (names.contains(name)) {\n                // エラー: suffix が更新されていないため、ループ本体は常に同じ結果になります\n                name = baseName + suffix;\n            }\n        }\n\n2018.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IdempotentLoopBody",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantImplements",
                "shortDescription": {
                  "text": "冗長なインターフェース宣言"
                },
                "fullDescription": {
                  "text": "クラスの 'implements' リスト内のインターフェース、またはスーパークラスによってすでに実装されている、またはスーパーインターフェースによって拡張されているインターフェースの 'extends' リストを報告します。 このような宣言は不要であり、安全に除去できます。 例: 'class X implements One, Two {\n  }\n  interface One {}\n  interface Two extends One {}' クイックフィックス適用後: 'class X implements Two {\n  }\n  interface One {}\n  interface Two extends One {}' 'extends' または 'implements' リスト内の 'Serializable' または 'Externalizable' に対して報告しないようにするには、オプションを使用します。",
                  "markdown": "クラスの `implements` リスト内のインターフェース、またはスーパークラスによってすでに実装されている、またはスーパーインターフェースによって拡張されているインターフェースの `extends` リストを報告します。 このような宣言は不要であり、安全に除去できます。\n\n**例:**\n\n\n      class X implements One, Two {\n      }\n      interface One {}\n      interface Two extends One {}\n\nクイックフィックス適用後:\n\n\n      class X implements Two {\n      }\n      interface One {}\n      interface Two extends One {}\n\n\n`extends` または `implements` リスト内の `Serializable` または `Externalizable` に対して報告しないようにするには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantInterfaceDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceofCatchParameter",
                "shortDescription": {
                  "text": "'catch' パラメーターの 'instanceof'"
                },
                "fullDescription": {
                  "text": "'instanceof' 式が 'catch' ブロック内のパラメーターの型をテストする目的で使用されているケースを報告します。 'catch' パラメーターの型のテストは、'instanceof' を使用する代わりに 'catch' ブロックを分割して行うのが一般的には良いとされています。 例: 'void foo(Runnable runnable) {\n    try {\n        runnable.run();\n    } catch (Throwable throwable) {\n        if (throwable instanceof NoClassDefFoundError) { // 警告: 'catch' パラメーターの 'throwable' に 'instanceof' を使用しています\n            System.out.println(\"Class not found!\");\n        }\n    }\n  }'",
                  "markdown": "`instanceof` 式が `catch` ブロック内のパラメーターの型をテストする目的で使用されているケースを報告します。\n\n`catch` パラメーターの型のテストは、`instanceof` を使用する代わりに `catch` ブロックを分割して行うのが一般的には良いとされています。\n\n**例:**\n\n\n      void foo(Runnable runnable) {\n        try {\n            runnable.run();\n        } catch (Throwable throwable) {\n            if (throwable instanceof NoClassDefFoundError) { // 警告: 'catch' パラメーターの 'throwable' に 'instanceof' を使用しています\n                System.out.println(\"Class not found!\");\n            }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceofCatchParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantScheduledForRemovalAnnotation",
                "shortDescription": {
                  "text": "冗長な @ScheduledForRemoval アノテーション"
                },
                "fullDescription": {
                  "text": "Java 9 以降のバージョンを対象とするコードで '@ApiStatus.ScheduledForRemoval' アノテーションが 'inVersion' 属性なしで使用されている箇所を報告します。 コードを単純化するため、このような使用箇所は '@Deprecated' アノテーションの 'forRemoval' 属性で置換できます。 2022.1 の新機能です",
                  "markdown": "Java 9 以降のバージョンを対象とするコードで `@ApiStatus.ScheduledForRemoval` アノテーションが `inVersion` 属性なしで使用されている箇所を報告します。\n\n\nコードを単純化するため、このような使用箇所は `@Deprecated` アノテーションの `forRemoval` 属性で置換できます。\n\n2022.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantScheduledForRemovalAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コード成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalGetWithoutIsPresent",
                "shortDescription": {
                  "text": "isPresent() チェックなしで呼び出されている Optional.get()"
                },
                "fullDescription": {
                  "text": "'Optional' に対する 'get()' の呼び出しで、値の存在を確認していないものを報告します。 空の 'Optional' インスタンスに対して 'Optional.get()' を呼び出すと、例外がスローされます。 例: 'void x(List<Integer> list) {\n    final Optional<Integer> optional =\n      list.stream().filter(x -> x > 10).findFirst();\n    final Integer result = optional.get(); // ここで問題が発生します\n  }' このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "`Optional` に対する `get()` の呼び出しで、値の存在を確認していないものを報告します。\n\n空の `Optional` インスタンスに対して `Optional.get()` を呼び出すと、例外がスローされます。\n\n**例:**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // ここで問題が発生します\n      }\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalGetWithoutIsPresent",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FrequentlyUsedInheritorInspection",
                "shortDescription": {
                  "text": "一般的に使用される基底クラスを拡張できるクラス"
                },
                "fullDescription": {
                  "text": "より具体的で一般的に使用されるクラスかインターフェースの実装または拡張に置換できるクラスまたはインターフェースを報告します。 このインスペクションを機能させるには、スーパークラスがプロジェクトのソースファイルに含まれており、プロジェクトが IntelliJ IDEA のビルドシステムを使用している必要があります。 例: 'class MyInheritor implements A {} // A の参照では B が提案されます\n\n  interface A {}\n\n  abstract class B implements A {}\n\n  abstract class C1 extends B {}\n  abstract class C2 extends B {}\n  abstract class C3 extends B {}\n  abstract class C4 extends B {}\n  abstract class C5 extends B {}' デフォルトでは、このインスペクションはエディター内の問題をハイライトせず、クイックフィックスのみを提供します。 2017.2 の新機能です",
                  "markdown": "より具体的で一般的に使用されるクラスかインターフェースの実装または拡張に置換できるクラスまたはインターフェースを報告します。\n\nこのインスペクションを機能させるには、スーパークラスがプロジェクトのソースファイルに含まれており、プロジェクトが IntelliJ IDEA のビルドシステムを使用している必要があります。\n\n**例:**\n\n\n      class MyInheritor implements A {} // A の参照では B が提案されます\n\n      interface A {}\n\n      abstract class B implements A {}\n\n      abstract class C1 extends B {}\n      abstract class C2 extends B {}\n      abstract class C3 extends B {}\n      abstract class C4 extends B {}\n      abstract class C5 extends B {}\n\nデフォルトでは、このインスペクションはエディター内の問題をハイライトせず、クイックフィックスのみを提供します。\n\n2017.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FrequentlyUsedInheritorInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OnDemandImport",
                "shortDescription": {
                  "text": "'*' インポート"
                },
                "fullDescription": {
                  "text": "パッケージ全体を対象としている 'import' ステートメント ('* imports') を報告します。 一部のコーディング標準では、このような 'import' ステートメントは禁止されています。 「インポートの最適化」コマンドを使用すると、このようなステートメントを検出および修正するように IntelliJ IDEA を構成できます。 「設定 | エディター | コードスタイル | Java | インポート」に移動し、「シングルクラスインポートを使用する」オプションが有効になっていることを確認してから「'*' でインポートするクラス数」および「'*' で static インポートする名前数」フィールドに値を指定します。 そのため、このインスペクションは変更を意図していないコードベースについて主にオフラインで報告させる目的で主に役立ちます。",
                  "markdown": "パッケージ全体を対象としている `import` ステートメント ('\\* imports') を報告します。\n\n一部のコーディング標準では、このような `import` ステートメントは禁止されています。\n\n\n「**インポートの最適化** 」コマンドを使用すると、このようなステートメントを検出および修正するように IntelliJ IDEA を構成できます。 「[設定 \\| エディター \\| コードスタイル \\| Java \\| インポート](settings://preferences.sourceCode.Java?Use%20single%20class%20import)」に移動し、「**シングルクラスインポートを使用する** 」オプションが有効になっていることを確認してから「**'\\*' でインポートするクラス数** 」および「**'\\*' で static インポートする名前数**」フィールドに値を指定します。\nそのため、このインスペクションは変更を意図していないコードベースについて主にオフラインで報告させる目的で主に役立ちます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OnDemandImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/インポート",
                      "index": 23,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FallthruInSwitchStatement",
                "shortDescription": {
                  "text": "フォールスルーする 'switch' ステートメント"
                },
                "fullDescription": {
                  "text": "'switch' ステートメントの 'フォールスルー' を報告します。 フォールスルーは、'case' ラベルの後に続く一連の実行ステートメントが制御を移してから次の 'case' ラベルに遷移することが確実でない場合に起こります。 たとえば、分岐に 'break' ステートメントがない場合に発生する可能性があります。 このような場合、'switch' 式がフォールスルーされるラベルの値に等しくなくても、その 'switch' ラベルの後のステートメントに制御がフォールスルーします。 このような構文は意図的な場合もありますが、混乱を招き、多くの場合はタイプミスによるものです。 このインスペクションは、正規表現パターン '(?i)falls?\\s*thro?u' に一致するテキストでコメントされたフォールスルーを無視します。 次の分岐にフォールスルーする可能性がある分岐に 'break' を追加するクイックフィックスがあります。 例: 'switch(x) {\n      case (4):\n          if (condition) {\n              System.out.println(\"3\");\n              // ここには break がありません\n          } else {\n              break;\n          }\n      case (6):\n          System.out.println(\"4\");\n    }' クイックフィックス適用後: 'switch(x) {\n        case (4):\n            if (condition) {\n                System.out.println(\"3\");\n            } else {\n                break;\n            }\n            break;\n        case (6):\n            System.out.println(\"4\");\n    }'",
                  "markdown": "`switch` ステートメントの 'フォールスルー' を報告します。\n\nフォールスルーは、`case` ラベルの後に続く一連の実行ステートメントが制御を移してから次の `case` ラベルに遷移することが確実でない場合に起こります。 たとえば、分岐に `break` ステートメントがない場合に発生する可能性があります。\nこのような場合、`switch` 式がフォールスルーされるラベルの値に等しくなくても、その `switch` ラベルの後のステートメントに制御がフォールスルーします。 このような構文は意図的な場合もありますが、混乱を招き、多くの場合はタイプミスによるものです。\n\n\nこのインスペクションは、正規表現パターン `(?i)falls?\\s*thro?u` に一致するテキストでコメントされたフォールスルーを無視します。\n\n次の分岐にフォールスルーする可能性がある分岐に `break` を追加するクイックフィックスがあります。\n\n例:\n\n\n        switch(x) {\n          case (4):\n              if (condition) {\n                  System.out.println(\"3\");\n                  // ここには break がありません\n              } else {\n                  break;\n              }\n          case (6):\n              System.out.println(\"4\");\n        }\n\nクイックフィックス適用後:\n\n\n        switch(x) {\n            case (4):\n                if (condition) {\n                    System.out.println(\"3\");\n                } else {\n                    break;\n                }\n                break;\n            case (6):\n                System.out.println(\"4\");\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "fallthrough",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantOperationOnEmptyContainer",
                "shortDescription": {
                  "text": "空コンテナーでの冗長な操作"
                },
                "fullDescription": {
                  "text": "空のコレクション、マップ、または配列に対する冗長な操作を報告します。 空のコレクションに対する反復、要素の除去、並べ替え、およびその他の操作は無効であり、除去できます。 また、バグの兆候である可能性もあります。 例: 'if (numbers.isEmpty()){\n    //否定の欠落によるエラー\n    int max = numbers.stream().max(Comparator.naturalOrder()).get();\n    ...\n  }' 2019.1 の新機能です",
                  "markdown": "空のコレクション、マップ、または配列に対する冗長な操作を報告します。\n\n\n空のコレクションに対する反復、要素の除去、並べ替え、およびその他の操作は無効であり、除去できます。 また、バグの兆候である可能性もあります。\n\n**例:**\n\n\n      if (numbers.isEmpty()){\n        //否定の欠落によるエラー\n        int max = numbers.stream().max(Comparator.naturalOrder()).get();\n        ...\n      }\n\n2019.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantOperationOnEmptyContainer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalIsPresent",
                "shortDescription": {
                  "text": "非機能スタイル 'Optional.isPresent()' の使用箇所"
                },
                "fullDescription": {
                  "text": "'if' または条件式の条件として使用されている 'Optional' 式で、関数スタイルに書き換えられるものを報告します。 多くの場合、結果はより短く、読みやすくなります。 例: 'if (str.isPresent()) str.get().trim();' クイックフィックス適用後: 'str.ifPresent(String::trim);' このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "`if` または条件式の条件として使用されている `Optional` 式で、関数スタイルに書き換えられるものを報告します。 多くの場合、結果はより短く、読みやすくなります。\n\n例:\n\n\n      if (str.isPresent()) str.get().trim();\n\nクイックフィックス適用後:\n\n\n      str.ifPresent(String::trim);\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalIsPresent",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldNamingConvention",
                "shortDescription": {
                  "text": "フィールドの命名規則"
                },
                "fullDescription": {
                  "text": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないフィールドを報告します。 例: このインスペクションが定数に対して有効になっており、フィールド名の最小文字数に 5 (デフォルト) が指定されている場合、次の定数はフィールド名の文字数が 5 未満の 3 であるため、警告が発生します: 'public static final int MAX = 42;'。 このようなフィールドの名前を変更するクイックフィックスは、エディターでのみ使用できます。 インスペクションの構成: チェック対象のフィールドを指定するには、「オプション」セクション内のリストを使用します。 チェック対象外にするフィールドのチェックボックスからはチェックを外してください。 フィールドタイプごとに、提供された入力フィールドを使用して、フィールド名に期待される最小長、最大長、および正規表現を指定します。 対応するチェックをスキップするには、長さフィールドに 0 を指定します。 正規表現は、'java.util.regex' の標準的な形式で指定する必要があります。",
                  "markdown": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないフィールドを報告します。\n\n**例:** このインスペクションが定数に対して有効になっており、フィールド名の最小文字数に 5 (デフォルト) が指定されている場合、次の定数はフィールド名の文字数が 5 未満の 3 であるため、警告が発生します: `public static final int MAX = 42;`。\n\nこのようなフィールドの名前を変更するクイックフィックスは、エディターでのみ使用できます。\n\nインスペクションの構成:\n\nチェック対象のフィールドを指定するには、「**オプション**」セクション内のリストを使用します。 チェック対象外にするフィールドのチェックボックスからはチェックを外してください。\n\nフィールドタイプごとに、提供された入力フィールドを使用して、フィールド名に期待される最小長、最大長、および正規表現を指定します。\n対応するチェックをスキップするには、長さフィールドに **0** を指定します。\n\n正規表現は、`java.util.regex` の標準的な形式で指定する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規約",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AtomicFieldUpdaterNotStaticFinal",
                "shortDescription": {
                  "text": "'static final' で宣言されていない 'AtomicFieldUpdater' フィールド"
                },
                "fullDescription": {
                  "text": "次の型のうち: 'java.util.concurrent.atomic.AtomicLongFieldUpdater' 'java.util.concurrent.atomic.AtomicIntegerFieldUpdater' 'java.util.concurrent.atomic.AtomicReferenceFieldUpdater' 'static final' でないものを報告します。 1 つのクラスのすべてのインスタンスで 'volatile' フィールドを更新するのに必要なアトミックフィールドアップデーターは 1 つだけなので、これらの型はほとんどの場合に 'static' にすることができます。 アップデーターを 'final' にすると、JVM がアクセスを最適化してパフォーマンスを向上させることができます。 例: 'class Main {\n    private volatile int id;\n    private AtomicIntegerFieldUpdater<Main> idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, \"id\");\n  }' クイックフィックス適用後: 'class Main {\n    private volatile int id;\n    private static final AtomicIntegerFieldUpdater<Main> idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, \"id\");\n  }'",
                  "markdown": "次の型のうち:\n\n* `java.util.concurrent.atomic.AtomicLongFieldUpdater`\n* `java.util.concurrent.atomic.AtomicIntegerFieldUpdater`\n* `java.util.concurrent.atomic.AtomicReferenceFieldUpdater`\n\n`static final` でないものを報告します。 1 つのクラスのすべてのインスタンスで `volatile` フィールドを更新するのに必要なアトミックフィールドアップデーターは 1 つだけなので、これらの型はほとんどの場合に `static` にすることができます。\n\nアップデーターを `final` にすると、JVM がアクセスを最適化してパフォーマンスを向上させることができます。\n\n**例:**\n\n\n      class Main {\n        private volatile int id;\n        private AtomicIntegerFieldUpdater<Main> idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, \"id\");\n      }\n\nクイックフィックス適用後:\n\n\n      class Main {\n        private volatile int id;\n        private static final AtomicIntegerFieldUpdater<Main> idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, \"id\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AtomicFieldUpdaterNotStaticFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8MapForEach",
                "shortDescription": {
                  "text": "Map.forEach() を使用できます"
                },
                "fullDescription": {
                  "text": "'for(Entry<?,?> entry : map.entrySet()) {...}' または 'map.entrySet().forEach(entry -> ...)' から 'map.forEach((key, value) -> ...)' への置換を提案します。 例 'void print(Map<String, Integer> map) {\n    map.entrySet().forEach(entry -> {\n      String str = entry.getKey();\n      System.out.println(str + \":\" + entry.getValue());\n    });\n  }' クイックフィックス適用後: 'void print(Map<String, Integer> map) {\n    map.forEach((str, value) -> System.out.println(str + \":\" + value));\n  }' 「ループを報告しない」オプションが有効な場合は、'entrySet().forEach()' のケースのみが報告されます。 ただし、クイックフィックスアクションは 'for' ループにも使用できます。 2017.1 の新機能です このインスペクションは Java 8 以降で使用できる Java の機能 'コレクション内のラムダメソッド' に依存しています。",
                  "markdown": "`for(Entry<?,?> entry : map.entrySet()) {...}` または `map.entrySet().forEach(entry -> ...)` から `map.forEach((key, value) -> ...)` への置換を提案します。\n\n例\n\n\n      void print(Map<String, Integer> map) {\n        map.entrySet().forEach(entry -> {\n          String str = entry.getKey();\n          System.out.println(str + \":\" + entry.getValue());\n        });\n      }\n\nクイックフィックス適用後:\n\n\n      void print(Map<String, Integer> map) {\n        map.forEach((str, value) -> System.out.println(str + \":\" + value));\n      }\n\n\n「**ループを報告しない** 」オプションが有効な場合は、`entrySet().forEach()` のケースのみが報告されます。\nただし、クイックフィックスアクションは `for` ループにも使用できます。\n\n2017.1 の新機能です\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'コレクション内のラムダメソッド' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8MapForEach",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNamePrefixedWithPackageName",
                "shortDescription": {
                  "text": "パッケージ名の接頭辞を持つクラス名"
                },
                "fullDescription": {
                  "text": "名前の接頭辞にパッケージ名が付いているクラスで、大文字と小文字の違いを無視しているものを報告します。 このような名前を持たせることが合理的な場合もありますが、多くの場合は名前付けスキームに不備があるために使用されています。そのため、このような名前は冗長で扱いに困る可能性があります。 例: 'package byteCode;\n  class ByteCodeAnalyzer {}' このようなクラスの名前を変更するクイックフィックスは、エディターでのみ使用できます。",
                  "markdown": "名前の接頭辞にパッケージ名が付いているクラスで、大文字と小文字の違いを無視しているものを報告します。\n\nこのような名前を持たせることが合理的な場合もありますが、多くの場合は名前付けスキームに不備があるために使用されています。そのため、このような名前は冗長で扱いに困る可能性があります。\n\n**例:**\n\n\n      package byteCode;\n      class ByteCodeAnalyzer {}\n\nこのようなクラスの名前を変更するクイックフィックスは、エディターでのみ使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassNamePrefixedWithPackageName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規則/クラス",
                      "index": 68,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantConditionalExpression",
                "shortDescription": {
                  "text": "定数条件式"
                },
                "fullDescription": {
                  "text": "条件が 'true' または 'false' 定数である条件式を報告します。 このような式は、自動リファクタリングを実行することで発生する場合があり、単純化できます。 例: 'return true ? \"Yes\" : \"No\";' クイックフィックス適用後: 'return \"Yes\";'",
                  "markdown": "条件が `true` または `false` 定数である条件式を報告します。 このような式は、自動リファクタリングを実行することで発生する場合があり、単純化できます。\n\n例:\n\n\n      return true ? \"Yes\" : \"No\";\n\nクイックフィックス適用後:\n\n\n      return \"Yes\";\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantConditionalExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SameParameterValue",
                "shortDescription": {
                  "text": "メソッドパラメーターは常に同じ値です"
                },
                "fullDescription": {
                  "text": "常に同じ定数値を持つメソッドパラメーターを報告します。 例: 'static void printPoint(int x, int y) { // x は常に 0 です\n    System.out.println(x + \", \" + y);\n  }\n\n  public static void main(String[] args) {\n    printPoint(0, 1);\n    printPoint(0, 2);\n  }' クイックフィックスを使用すると、このような一定の値がインライン化されます。 これにより、メソッドの実装を単純化できます。 次の場合にインスペクションを抑止するには、「クイックフィックスが提供されない場合は無視する」オプションを使用します。 パラメーターがメソッド内で変更されている 渡されているパラメーターの値がアクセス不可能なフィールドへの参照になっている (Java の場合のみ)。 パラメーターが可変長である (Java の場合のみ)。 報告対象とする最大のメソッド可視性を制御するには、「最大のメソッド可視性」オプションを使用します。 同じパラメーター値があるメソッド使用箇所の最小数を指定するには、「パラメーターを報告するメソッド使用箇所の最小数」フィールドを使用します。",
                  "markdown": "常に同じ定数値を持つメソッドパラメーターを報告します。\n\n例:\n\n\n      static void printPoint(int x, int y) { // x は常に 0 です\n        System.out.println(x + \", \" + y);\n      }\n\n      public static void main(String[] args) {\n        printPoint(0, 1);\n        printPoint(0, 2);\n      }\n\nクイックフィックスを使用すると、このような一定の値がインライン化されます。 これにより、メソッドの実装を単純化できます。\n\n\n次の場合にインスペクションを抑止するには、「**クイックフィックスが提供されない場合は無視する**」オプションを使用します。\n\n* パラメーターがメソッド内で変更されている\n* 渡されているパラメーターの値がアクセス不可能なフィールドへの参照になっている (Java の場合のみ)。\n* パラメーターが可変長である (Java の場合のみ)。\n\n\n報告対象とする最大のメソッド可視性を制御するには、「**最大のメソッド可視性**」オプションを使用します。\n\n\n同じパラメーター値があるメソッド使用箇所の最小数を指定するには、「**パラメーターを報告するメソッド使用箇所の最小数**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SameParameterValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CatchMayIgnoreException",
                "shortDescription": {
                  "text": "例外を無視する可能性がある catch ブロック"
                },
                "fullDescription": {
                  "text": "空であるか、例外を無視する可能性がある 'catch' ブロックを報告します。 このような空の 'catch' ブロックは意図的な場合もありますが、デバッグを困難にする可能性があります。 また、'catch' パラメーターを無視するのは不適切である可能性があります。 さらに、静的コード解析ツールは、'catch' ブロックが 'NullPointerException' などの重要な VM 例外を通知なしで無視する可能性があることを検出した場合に報告します。 このような例外を (ログに記録したり再スローしたりせずに) 無視すると、バグに気付かなくなる可能性があります。 このインスペクションは、'ignore' または 'ignored' という名前の 'catch' パラメーターを報告しません。 その逆に、このインスペクションは 'ignore' または 'ignored' という名前の 'catch' パラメーターで、実際に使用されているものについて警告します。 さらに、このインスペクションは 'expected' または 'ok' という名前のテストソースにある 'catch' パラメーターを報告しません。 例外の名前を 'ignored' に変更するクイックフィックスを使用できます。 空の catch ブロックの場合、catch の本体を生成する追加のクイックフィックスが提案されます。 「設定 | エディター | ファイルおよびコードテンプレート」のコードタブで、\"Catch Statement Body\" テンプレートを変更できます。 例: 'try {\n    throwingMethod();\n  } catch (IOException ex) {\n\n  }' クイックフィックス適用後: 'try {\n    System.out.println(System.in.read());\n  } catch (IOException ignored) {\n\n  }' インスペクションの構成: コメント付きの 'catch' ブロックを無視するには、「'catch' ブロックにコメントがある場合は警告しない」オプションを使用します。 内部にステートメントまたはコメントがあるものの、変数そのものが使用されていない 'catch' ブロックを無視するには、「'catch' ブロックが空でない場合は警告しない」オプションを使用します。 'ignored' という名前の変数が使用されている場合に無視するには、「'ignore(d)' という例外が実際に無視されていない場合に警告しない」オプションを使用します。 2018.1 の新機能です",
                  "markdown": "空であるか、例外を無視する可能性がある `catch` ブロックを報告します。\n\nこのような空の `catch` ブロックは意図的な場合もありますが、デバッグを困難にする可能性があります。\nまた、`catch` パラメーターを無視するのは不適切である可能性があります。\nさらに、静的コード解析ツールは、`catch` ブロックが `NullPointerException` などの重要な VM 例外を通知なしで無視する可能性があることを検出した場合に報告します。 このような例外を (ログに記録したり再スローしたりせずに) 無視すると、バグに気付かなくなる可能性があります。\n\n\nこのインスペクションは、`ignore` または `ignored` という名前の `catch` パラメーターを報告しません。\nその逆に、このインスペクションは `ignore` または `ignored` という名前の `catch` パラメーターで、実際に使用されているものについて警告します。\nさらに、このインスペクションは `expected` または `ok` という名前のテストソースにある `catch` パラメーターを報告しません。\n\n\n例外の名前を `ignored` に変更するクイックフィックスを使用できます。\n空の **catch** ブロックの場合、**catch** の本体を生成する追加のクイックフィックスが提案されます。\n「[設定 \\| エディター \\| ファイルおよびコードテンプレート](settings://fileTemplates)」のコードタブで、\"Catch Statement Body\" テンプレートを変更できます。\n\n**例:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nクイックフィックス適用後:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nインスペクションの構成:\n\n* コメント付きの `catch` ブロックを無視するには、「**'catch' ブロックにコメントがある場合は警告しない**」オプションを使用します。\n* 内部にステートメントまたはコメントがあるものの、変数そのものが使用されていない `catch` ブロックを無視するには、「**'catch' ブロックが空でない場合は警告しない**」オプションを使用します。\n* `ignored` という名前の変数が使用されている場合に無視するには、「**'ignore(d)' という例外が実際に無視されていない場合に警告しない**」オプションを使用します。\n\n2018.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CatchMayIgnoreException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithTooManyDependents",
                "shortDescription": {
                  "text": "他からの依存関係が多すぎるクラス"
                },
                "fullDescription": {
                  "text": "他のクラスからの直接的な非依存関係が多すぎるクラスを報告します。 このようなクラスに修正を加えると他の多くのクラスを変更する必要が生じるため、コストが高くなる可能性があります。 トップレベルのクラスのみが報告されます。 クラスで許容される非依存関係数の最大値を指定するには、以下のフィールドを使用します。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "他のクラスからの直接的な非依存関係が多すぎるクラスを報告します。\n\nこのようなクラスに修正を加えると他の多くのクラスを変更する必要が生じるため、コストが高くなる可能性があります。\n\nトップレベルのクラスのみが報告されます。\n\nクラスで許容される非依存関係数の最大値を指定するには、以下のフィールドを使用します。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyDependents",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依存関係の問題",
                      "index": 86,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RecordStoreResource",
                "shortDescription": {
                  "text": "'RecordStore' を開きましたが、安全に閉じられていません"
                },
                "fullDescription": {
                  "text": "'try' ブロックの前で開かれておらず、または対応する 'finally' ブロックで閉じられていない Java ME の 'javax.microedition.rms.RecordStore' リソースを報告します。 リソースがクローズされる前に例外がスローされる場合、思わぬリソースリークが発生する可能性があります。 このインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。 このインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。 例: 'void foo1() throws RecordStoreException {\n      RecordStore rs = RecordStore.openRecordStore(\"bar\", true); // 警告\n  }\n  void foo2() throws RecordStoreException {\n      RecordStore rs = RecordStore.openRecordStore(\"bar\", true); // 警告なし\n      try {\n          /* ... */\n      } finally {\n          rs.closeRecordStore();\n      }\n  }'",
                  "markdown": "`try` ブロックの前で開かれておらず、または対応する `finally` ブロックで閉じられていない Java ME の `javax.microedition.rms.RecordStore` リソースを報告します。\n\nリソースがクローズされる前に例外がスローされる場合、思わぬリソースリークが発生する可能性があります。\n\n\nこのインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。\nこのインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。\n\n**例:**\n\n\n      void foo1() throws RecordStoreException {\n          RecordStore rs = RecordStore.openRecordStore(\"bar\", true); // 警告\n      }\n      void foo2() throws RecordStoreException {\n          RecordStore rs = RecordStore.openRecordStore(\"bar\", true); // 警告なし\n          try {\n              /* ... */\n          } finally {\n              rs.closeRecordStore();\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RecordStoreOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス/組み込み",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WrongPackageStatement",
                "shortDescription": {
                  "text": "不正な package 文"
                },
                "fullDescription": {
                  "text": "プロジェクトのディレクトリ構造に一致していない 'package' ステートメントを検出します。 また、'package' ステートメントのないクラスのうち、ソースルートディレクトリに直接配置されていないものも報告します。 Java 言語が厳密に要求しているわけではありませんが、'com.example.myapp' パッケージのクラスはソースルート直下の 'com/example/myapp' ディレクトリ内に配置することをお勧めします。 そうしなかった場合はコードを読む人が混乱し、一部のツールが正しく機能しなくなる可能性があります。",
                  "markdown": "プロジェクトのディレクトリ構造に一致していない `package` ステートメントを検出します。 また、`package` ステートメントのないクラスのうち、ソースルートディレクトリに直接配置されていないものも報告します。\n\nJava 言語が厳密に要求しているわけではありませんが、`com.example.myapp` パッケージのクラスはソースルート直下の `com/example/myapp` ディレクトリ内に配置することをお勧めします。 そうしなかった場合はコードを読む人が混乱し、一部のツールが正しく機能しなくなる可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "WrongPackageStatement",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectsEqualsCanBeSimplified",
                "shortDescription": {
                  "text": "'Objects.equals()' は 'equals()' に置換できます"
                },
                "fullDescription": {
                  "text": "最初の引数が非 null だと静的に分かっている 'Objects.equals(a, b)' の呼び出しを報告します。 このような呼び出しは、両方の引数がプリミティブである場合に 'a.equals(b)' または 'a == b' に安全に置換できます。 例: 'String defaultName = \"default\";\n  boolean isDefault = Objects.equals(defaultName, name);' クイックフィックス適用後: 'String defaultName = \"default\";\n  boolean isDefault = defaultName.equals(name);' 2018.3 の新機能です このインスペクションは Java 7 以降で使用できる Java の機能 'java.util.Objects API' に依存しています。",
                  "markdown": "最初の引数が非 null だと静的に分かっている `Objects.equals(a, b)` の呼び出しを報告します。\n\nこのような呼び出しは、両方の引数がプリミティブである場合に `a.equals(b)` または `a == b` に安全に置換できます。\n\n例:\n\n\n      String defaultName = \"default\";\n      boolean isDefault = Objects.equals(defaultName, name);\n\nクイックフィックス適用後:\n\n\n      String defaultName = \"default\";\n      boolean isDefault = defaultName.equals(name);\n\n2018.3 の新機能です\n\nこのインスペクションは Java 7 以降で使用できる Java の機能 'java.util.Objects API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectsEqualsCanBeSimplified",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassLoaderInstantiation",
                "shortDescription": {
                  "text": "'ClassLoader' のインスタンス化"
                },
                "fullDescription": {
                  "text": "'java.lang.ClassLoader' クラスのインスタンス化を報告します。 多くの場合は無害ですが、'ClassLoader' のインスタンス化はセキュリティ監査で詳細に調査すべきです。 例: 'Class<?> loadExtraClass(String name) throws Exception {\n      try(URLClassLoader loader =\n          new URLClassLoader(new URL[]{new URL(\"extraClasses/\")})) {\n        return loader.loadClass(name);\n      }\n    }'",
                  "markdown": "`java.lang.ClassLoader` クラスのインスタンス化を報告します。\n\n多くの場合は無害ですが、`ClassLoader` のインスタンス化はセキュリティ監査で詳細に調査すべきです。\n\n**例:**\n\n        Class<?> loadExtraClass(String name) throws Exception {\n          try(URLClassLoader loader =\n              new URLClassLoader(new URL[]{new URL(\"extraClasses/\")})) {\n            return loader.loadClass(name);\n          }\n        }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassLoaderInstantiation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldNotUsedInToString",
                "shortDescription": {
                  "text": "'toString()' メソッドで使用されていないフィールド"
                },
                "fullDescription": {
                  "text": "クラスの 'toString()' メソッドで使用されていないフィールドを報告します。 'toString()' メソッドが最後に更新された後に追加されたフィールドを発見するのに役立ちます。 クイックフィックスを使用すると、'toString()' メソッドが再生成されます。 「生成 | toString()」ダイアログでは、このチェックからフィールドを除外することができます。 このダイアログで「コード生成で getter を有効にする」オプションが有効な場合、このインスペクションは getter メソッドに関する問題もチェックします。 例: 'public class Relevant {\n    private String name; // toString() で使用されていません\n    private int index;\n    private int length;\n\n    @Override\n    public String toString() {\n        return \"Relevant{\" + \"index=\" + index +\n          \", length=\" + length + '}';\n    }\n  }' クイックフィックス適用後: 'public class Relevant {\n    private String name;\n    private int index;\n    private int length;\n\n    @Override\n    public String toString() {\n        return \"Relevant{\" + \"name='\" + name + '\\'' +\n          \", index=\" + index + \", length=\" + length + '}';\n    }\n  }'",
                  "markdown": "クラスの `toString()` メソッドで使用されていないフィールドを報告します。\n\n`toString()` メソッドが最後に更新された後に追加されたフィールドを発見するのに役立ちます。\nクイックフィックスを使用すると、`toString()` メソッドが再生成されます。\n\n\n「**生成 \\| toString()** 」ダイアログでは、このチェックからフィールドを除外することができます。\nこのダイアログで「*コード生成で getter を有効にする*」オプションが有効な場合、このインスペクションは getter メソッドに関する問題もチェックします。\n\n例:\n\n\n      public class Relevant {\n        private String name; // toString() で使用されていません\n        private int index;\n        private int length;\n\n        @Override\n        public String toString() {\n            return \"Relevant{\" + \"index=\" + index +\n              \", length=\" + length + '}';\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public class Relevant {\n        private String name;\n        private int index;\n        private int length;\n\n        @Override\n        public String toString() {\n            return \"Relevant{\" + \"name='\" + name + '\\'' +\n              \", index=\" + index + \", length=\" + length + '}';\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldNotUsedInToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/toString() の問題",
                      "index": 123,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CovariantEquals",
                "shortDescription": {
                  "text": "共変な 'equals()'"
                },
                "fullDescription": {
                  "text": "'java.lang.Object' 以外の引数の型を取る 'equals()' メソッドがあり、その包含クラスに 'java.lang.Object' を引数の型として取る 'equals()' のオーバーロードが他にない場合に報告します。 'equals()'の共変バージョンは、'Object.equals(Object)' メソッドをオーバーライドしません。 そのため、実行時に予期しない動作が発生する可能性があります。 たとえば、クラスが標準コレクションクラスの 1 つを構築するために使用される場合、'Object.equals(Object)' メソッドがオーバーライドされることが予想されます。 例: 'class Foo {\n      public boolean equals(Foo foo) {  // 警告\n          return false;\n      }\n  }\n  class Bar {\n      public boolean equals(Bar bar) {  // ここでは警告は表示されません\n          return false;\n      }\n      @Override\n      public boolean equals(Object obj) {\n          return false;\n      }\n  }'",
                  "markdown": "`java.lang.Object` 以外の引数の型を取る `equals()` メソッドがあり、その包含クラスに `java.lang.Object` を引数の型として取る `equals()` のオーバーロードが他にない場合に報告します。\n\n\n`equals()`の共変バージョンは、`Object.equals(Object)` メソッドをオーバーライドしません。 そのため、実行時に予期しない動作が発生する可能性があります。 たとえば、クラスが標準コレクションクラスの 1 つを構築するために使用される場合、`Object.equals(Object)` メソッドがオーバーライドされることが予想されます。\n\n**例:**\n\n\n      class Foo {\n          public boolean equals(Foo foo) {  // 警告\n              return false;\n          }\n      }\n      class Bar {\n          public boolean equals(Bar bar) {  // ここでは警告は表示されません\n              return false;\n          }\n          @Override\n          public boolean equals(Object obj) {\n              return false;\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CovariantEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Convert2Lambda",
                "shortDescription": {
                  "text": "ラムダに置換可能な匿名型"
                },
                "fullDescription": {
                  "text": "ラムダ式に置換できる匿名クラスを報告します。 例: 'new Thread(new Runnable() {\n    @Override\n    public void run() {\n      // スレッドを実行\n    }\n  });' クイックフィックス適用後: 'new Thread(() -> {\n    // スレッドを実行\n  });' 匿名クラスがステートレスなラムダに変換されると、Java ランタイムが後続の呼び出しで同じラムダのオブジェクトを再利用することができます。 一方、匿名クラスが使用される際には毎回別のオブジェクトが作成されます。 そのため、匿名クラスインスタンスが 'HashMap' キーとして使用されているようなまれなケースでは、このクイックフィックスを適用した際にセマンティクスが変更される可能性があります。 匿名クラスが '@FunctionalInterface' アノテーションが付いていないインターフェースを実装する場合を無視するには、「インターフェースに @FunctionalInterface アノテーションがない場合に報告する」オプションを使用します。 このインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。",
                  "markdown": "ラムダ式に置換できる匿名クラスを報告します。\n\n例:\n\n\n      new Thread(new Runnable() {\n        @Override\n        public void run() {\n          // スレッドを実行\n        }\n      });\n\nクイックフィックス適用後:\n\n\n      new Thread(() -> {\n        // スレッドを実行\n      });\n\n\n匿名クラスがステートレスなラムダに変換されると、Java ランタイムが後続の呼び出しで同じラムダのオブジェクトを再利用することができます。 一方、匿名クラスが使用される際には毎回別のオブジェクトが作成されます。 そのため、匿名クラスインスタンスが `HashMap` キーとして使用されているようなまれなケースでは、このクイックフィックスを適用した際にセマンティクスが変更される可能性があります。\n\n\n匿名クラスが `@FunctionalInterface` アノテーションが付いていないインターフェースを実装する場合を無視するには、「**インターフェースに @FunctionalInterface アノテーションがない場合に報告する**」オプションを使用します。\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Convert2Lambda",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NativeMethods",
                "shortDescription": {
                  "text": "ネイティブメソッド"
                },
                "fullDescription": {
                  "text": "'native' 宣言されているメソッドを報告します。 ネイティブメソッドは本質的に移植性がありません。",
                  "markdown": "`native` 宣言されているメソッドを報告します。 ネイティブメソッドは本質的に移植性がありません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NativeMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ポータビリティ",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableIfStatement",
                "shortDescription": {
                  "text": "'if' ステートメントは条件式またはブール式に置換できます"
                },
                "fullDescription": {
                  "text": "'&&'、'||'、'=='、'!='、または '?:' 演算子を使用する条件式に置換できる 'if' ステートメントを報告します。 多くの場合、置換後のコードは短くなります。ただし、分かりやすくなるとは限らないため、あらゆるケースでこのクイックフィックスを使用することはお勧めしません。 例: 'if (condition) return true; else return foo;' クイックフィックス適用後: 'return condition || foo;' インスペクションの構成: '?:' 演算子が提案される際に発生する警告を無効にするには、「'?:' 演算子を提案しない」オプションを使用します。 この場合は、'&&'、'||'、'=='、および '!=' の提案だけがハイライトされます。 エディターでは、引き続きクイックフィックスを使用できます。 'if-else' チェーンの警告を無効にするには、「チェーンになった 'if' ステートメントを無視する」オプションを使用します。 エディターでは、引き続きクイックフィックスを使用できます。 2018.2 の新機能です",
                  "markdown": "`&&`、`||`、`==`、`!=`、または `?:` 演算子を使用する条件式に置換できる `if` ステートメントを報告します。\n\n多くの場合、置換後のコードは短くなります。ただし、分かりやすくなるとは限らないため、あらゆるケースでこのクイックフィックスを使用することはお勧めしません。\n\n例:\n\n\n      if (condition) return true; else return foo;\n\nクイックフィックス適用後:\n\n\n      return condition || foo;\n\nインスペクションの構成:\n\n* `?:` 演算子が提案される際に発生する警告を無効にするには、「**'?:' 演算子を提案しない** 」オプションを使用します。 この場合は、`&&`、`||`、`==`、および `!=` の提案だけがハイライトされます。 エディターでは、引き続きクイックフィックスを使用できます。\n* `if-else` チェーンの警告を無効にするには、「**チェーンになった 'if' ステートメントを無視する**」オプションを使用します。 エディターでは、引き続きクイックフィックスを使用できます。\n\n2018.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifiableIfStatement",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsWithItself",
                "shortDescription": {
                  "text": "自身に対する 'equals()' 呼び出し"
                },
                "fullDescription": {
                  "text": "'equals()'、'compareTo()'、またはこれらと同等の呼び出しのうち、オブジェクトと自身との等価比較が行われているものを報告します。 これらのメソッドのメソッド契約は、このような呼び出しが 'equals()' の場合は 'true' を、'compareTo()' の場合は '0' を常に返すことを指定しています。 このインスペクションは、'Objects.equals()'、'Objects.deepEquals()'、'Arrays.equals()'、'Comparator.compare()'、テストフレームワーク (JUnit, TestNG, AssertJ) の 'assertEquals()' メソッド、'Integer.compare()'、'Integer.compareUnsigned()' およびこれらと同等のメソッドへの呼び出しもチェックします。 まれなケースですが、このインスペクションが false を返す 'equals()' を報告する場合があることに注意してください。これは両辺の式が同じであっても、それらの式が別々のオブジェクトを生成し、オブジェクトの内容ではなく参照に対して比較が行われることが原因で発生します。 最も簡単な例は 'new Object().equals(new Object())' です。 いずれにしても、そのような呼び出しは疑わしく、何か他のことを意図していた可能性があります。 例: 'class Foo {\n    boolean foo(Object o) {\n        return o.equals(o); // 警告\n    }\n\n    boolean bar(String[] ss) {\n        return Arrays.equals(ss, ss); // 警告\n    }\n}'",
                  "markdown": "`equals()`、`compareTo()`、またはこれらと同等の呼び出しのうち、オブジェクトと自身との等価比較が行われているものを報告します。 これらのメソッドのメソッド契約は、このような呼び出しが `equals()` の場合は `true` を、`compareTo()` の場合は `0` を常に返すことを指定しています。 このインスペクションは、`Objects.equals()`、`Objects.deepEquals()`、`Arrays.equals()`、`Comparator.compare()`、テストフレームワーク (JUnit, TestNG, AssertJ) の `assertEquals()` メソッド、`Integer.compare()`、`Integer.compareUnsigned()` およびこれらと同等のメソッドへの呼び出しもチェックします。\n\n\nまれなケースですが、このインスペクションが false を返す `equals()` を報告する場合があることに注意してください。これは両辺の式が同じであっても、それらの式が別々のオブジェクトを生成し、オブジェクトの内容ではなく参照に対して比較が行われることが原因で発生します。\n最も簡単な例は `new Object().equals(new Object())` です。 いずれにしても、そのような呼び出しは疑わしく、何か他のことを意図していた可能性があります。\n\n**例:**\n\n\n      class Foo {\n        boolean foo(Object o) {\n            return o.equals(o); // 警告\n        }\n\n        boolean bar(String[] ss) {\n            return Arrays.equals(ss, ss); // 警告\n        }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsWithItself",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowCaughtLocally",
                "shortDescription": {
                  "text": "'try' ステートメント内でキャッチされる 'throw'"
                },
                "fullDescription": {
                  "text": "外側の 'try' ステートメントで常に例外がキャッチされている 'throw' ステートメントを報告します。 制御のローカルフローを変更するために 'throw' ステートメントを \"goto\" として使用すると混乱を招くばかりか、パフォーマンスが低下します。 例: 'try {\n    if (!Files.isDirectory(PROJECTS)) {\n        throw new IllegalStateException(\"Directory not found.\"); // 警告: 'try' ステートメント内で 'throw' がキャッチされています\n    }\n    ...\n  } catch (Exception e) {\n      LOG.error(\"run failed\");\n  }' 再スローされる例外を無視するには、「再スローされる例外を無視する」オプションを使用します。",
                  "markdown": "外側の `try` ステートメントで常に例外がキャッチされている `throw` ステートメントを報告します。\n\n制御のローカルフローを変更するために `throw` ステートメントを \"goto\" として使用すると混乱を招くばかりか、パフォーマンスが低下します。\n\n**例:**\n\n\n      try {\n        if (!Files.isDirectory(PROJECTS)) {\n            throw new IllegalStateException(\"Directory not found.\"); // 警告: 'try' ステートメント内で 'throw' がキャッチされています\n        }\n        ...\n      } catch (Exception e) {\n          LOG.error(\"run failed\");\n      }\n\n再スローされる例外を無視するには、「**再スローされる例外を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowCaughtLocally",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassInheritanceDepth",
                "shortDescription": {
                  "text": "継承ツリーが深すぎるクラス"
                },
                "fullDescription": {
                  "text": "継承階層が深すぎるクラスを報告します。 継承が深すぎるクラスは混乱を招く可能性があるため、リファクタリングが必要な可能性があります。 ライブラリ内のすべてのスーパークラスは単一のスーパークラスとして扱われ、ライブラリは変更不可能と見なされます。 クラスで許容される継承の深さの最大値を指定するには、「継承の深さ制限」フィールドを使用します。",
                  "markdown": "継承階層が深すぎるクラスを報告します。\n\n継承が深すぎるクラスは混乱を招く可能性があるため、リファクタリングが必要な可能性があります。\n\nライブラリ内のすべてのスーパークラスは単一のスーパークラスとして扱われ、ライブラリは変更不可能と見なされます。\n\nクラスで許容される継承の深さの最大値を指定するには、「**継承の深さ制限**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassTooDeepInInheritanceTree",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラスメトリクス",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkedForRemoval",
                "shortDescription": {
                  "text": "廃止予定 API の使用"
                },
                "fullDescription": {
                  "text": "'@Deprecated(forRemoval=true)' アノテーションで削除予定と示されている非推奨 API (クラス、フィールド、メソッド) の使用箇所を報告します。 削除予定と示されている API を使用するコードでは、API の今後のバージョンで実行時にエラーが発生する可能性があります。 このインスペクションについて推奨されている重要度が エラー となっているのはそのためです。 普通の非推奨機能の場合と同じコードハイライト機能を使用する場合は、重要度を 警告 に変更できます。 2017.3 の新機能です",
                  "markdown": "`@Deprecated(`**forRemoval**`=true)` アノテーションで削除予定と示されている非推奨 API (クラス、フィールド、メソッド) の使用箇所を報告します。\n\n\n削除予定と示されている API を使用するコードでは、API の今後のバージョンで実行時にエラーが発生する可能性があります。 このインスペクションについて推奨されている重要度が\n*エラー* となっているのはそのためです。\n\n\n普通の非推奨機能の場合と同じコードハイライト機能を使用する場合は、重要度を *警告* に変更できます。\n\n2017.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "removal",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コード成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizeOnValueBasedClass",
                "shortDescription": {
                  "text": "値ベースの警告"
                },
                "fullDescription": {
                  "text": "Java 16 以降でコンパイル時に警告を発生させ、実行時に例外を引き起こす値ベースのクラスのインスタンスで同期を試みていることを報告します。 たとえば、'java.lang.Double' は 'jdk.internal.ValueBased' でアノテーションが付与されているため、次のコードではコンパイル時に警告が発生します。 'Double d = 20.0;\nsynchronized (d) { ... } // javac の警告' 2021.1 の新機能です",
                  "markdown": "Java 16 以降でコンパイル時に警告を発生させ、実行時に例外を引き起こす値ベースのクラスのインスタンスで同期を試みていることを報告します。\n\n\nたとえば、`java.lang.Double` は `jdk.internal.ValueBased` でアノテーションが付与されているため、次のコードではコンパイル時に警告が発生します。\n\n\n    Double d = 20.0;\n    synchronized (d) { ... } // javac の警告\n\n2021.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "synchronization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コンパイラー関連の問題",
                      "index": 87,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableWithSerialVersionUIDField",
                "shortDescription": {
                  "text": "'serialVersionUID' を持つ非 Serializable クラス"
                },
                "fullDescription": {
                  "text": "'serialVersionUID' フィールドを定義している非 'Serializable' クラスを報告します。 多くの場合、'serialVersionUID' フィールドがこのコンテキストで使用されているのは誤りです。このフィールドは無視され、クラスがシリアル化されないためです。 例: 'public class IWantToSerializeThis {\n    private static final long serialVersionUID = 2669293150219020249L;\n  }'",
                  "markdown": "`serialVersionUID` フィールドを定義している非 `Serializable` クラスを報告します。 多くの場合、`serialVersionUID` フィールドがこのコンテキストで使用されているのは誤りです。このフィールドは無視され、クラスがシリアル化されないためです。\n\n**例:**\n\n\n      public class IWantToSerializeThis {\n        private static final long serialVersionUID = 2669293150219020249L;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableClassWithSerialVersionUID",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedConditionalExpression",
                "shortDescription": {
                  "text": "ネストした条件式"
                },
                "fullDescription": {
                  "text": "大きな混乱を招く可能性がある、ネストした条件式を報告します。 例: 'int y = a == 10 ? b == 20 ? 10 : a : b;'",
                  "markdown": "大きな混乱を招く可能性がある、ネストした条件式を報告します。\n\n例:\n\n\n      int y = a == 10 ? b == 20 ? 10 : a : b;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedConditionalExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitNumericConversion",
                "shortDescription": {
                  "text": "暗黙の数値変換"
                },
                "fullDescription": {
                  "text": "数値型同士の暗黙的な変換を報告します。 暗黙的な数値変換そのものは問題ではありませんが、意図的なものでない場合はバグのトレースを困難にする可能性があります。 例: 'double m(int i) {\n    return i * 10;\n  }' クイックフィックス適用後: 'double m(int i) {\n    return (double) (i * 10);\n  }' インスペクションの構成: データ損失を引き起こさない暗黙の変換 ('int'->'long' など) を無視するには、「変換の拡大を無視する」オプションを使用します。 'char' との間の変換を無視するには、「'char' との間の変換を無視する」オプションを使用します。 浮動小数点数との間の変換は引き続き報告されます。 リテラルおよびコンパイル時定数からの変換をインスペクションに無視させるには、定数とリテラルからの変換を無視する を使用します。",
                  "markdown": "数値型同士の暗黙的な変換を報告します。\n\n暗黙的な数値変換そのものは問題ではありませんが、意図的なものでない場合はバグのトレースを困難にする可能性があります。\n\n**例:**\n\n\n      double m(int i) {\n        return i * 10;\n      }\n\nクイックフィックス適用後:\n\n\n      double m(int i) {\n        return (double) (i * 10);\n      }\n\nインスペクションの構成:\n\n* データ損失を引き起こさない暗黙の変換 (`int`-\\>`long` など) を無視するには、「**変換の拡大を無視する**」オプションを使用します。\n* `char` との間の変換を無視するには、「**'char' との間の変換を無視する**」オプションを使用します。 浮動小数点数との間の変換は引き続き報告されます。\n* リテラルおよびコンパイル時定数からの変換をインスペクションに無視させるには、**定数とリテラルからの変換を無視する** を使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ImplicitNumericConversion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BulkFileAttributesRead",
                "shortDescription": {
                  "text": "一括 'Files.readAttributes()' 呼び出しを使用できます"
                },
                "fullDescription": {
                  "text": "次のような連続する複数の 'java.io.File' 属性チェックを報告します。 'isDirectory()' 'isFile()' 'lastModified()' 'length()' このような呼び出しは 'Files.readAttributes()' の一括呼び出しに置換できます。 通常、複数の属性チェックを個別に使用するよりもパフォーマンスが向上します。 例: 'boolean isNewFile(File file, long lastModified) throws IOException {\n    return file.isFile() && file.lastModified() > lastModified;\n  }' クイックフィックス適用後: 'boolean isNewFile(File file, long lastModified) throws IOException {\n    var fileAttributes = Files.readAttributes(file.toPath(), BasicFileAttributes.class);\n    return fileAttributes.isRegularFile() && fileAttributes.lastModifiedTime().toMillis() > lastModified;\n  }' このインスペクションは 'IOException' が現在のコンテキストで処理されていない場合は警告を表示しませんが、その場合でもクイックフィックスは使用できます。 ただし、置換内容は通常はまったく同じとは限らないため、注意して適用する必要があります。 特に、ファイルがまったく存在しない場合に動作が異なる場合があります。 このインスペクションは、プロジェクトまたはモジュールの言語レベルが 7 以上の場合にのみ報告します。 2022.1 の新機能です",
                  "markdown": "次のような連続する複数の `java.io.File` 属性チェックを報告します。\n\n* `isDirectory()`\n* `isFile()`\n* `lastModified()`\n* `length()`\n\nこのような呼び出しは `Files.readAttributes()` の一括呼び出しに置換できます。 通常、複数の属性チェックを個別に使用するよりもパフォーマンスが向上します。\n\n例:\n\n\n      boolean isNewFile(File file, long lastModified) throws IOException {\n        return file.isFile() && file.lastModified() > lastModified;\n      }\n\nクイックフィックス適用後:\n\n\n      boolean isNewFile(File file, long lastModified) throws IOException {\n        var fileAttributes = Files.readAttributes(file.toPath(), BasicFileAttributes.class);\n        return fileAttributes.isRegularFile() && fileAttributes.lastModifiedTime().toMillis() > lastModified;\n      }\n\nこのインスペクションは `IOException` が現在のコンテキストで処理されていない場合は警告を表示しませんが、その場合でもクイックフィックスは使用できます。\n\nただし、置換内容は通常はまったく同じとは限らないため、注意して適用する必要があります。 特に、ファイルがまったく存在しない場合に動作が異なる場合があります。\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 7 以上の場合にのみ報告します。\n\n2022.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BulkFileAttributesRead",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WhileCanBeForeach",
                "shortDescription": {
                  "text": "拡張 'for' ループに置換可能な 'while' ループ"
                },
                "fullDescription": {
                  "text": "コレクションを反復処理し、拡張 'for' ループ (foreach 反復構文) に置換できる 'while' ループを報告します。 例: 'Iterator it = c.iterator();\n  while(it.hasNext()) {\n    Object obj = it.next();\n    System.out.println(obj);\n  }' 上のコードは下のコードに置換できます。 'for (Object obj : c) {\n    System.out.println(obj);\n  }' このインスペクションは Java 5 以降で使用できる Java の機能 'For-each ループ' に依存しています。",
                  "markdown": "コレクションを反復処理し、拡張 `for` ループ (foreach 反復構文) に置換できる `while` ループを報告します。\n\n**例:**\n\n\n      Iterator it = c.iterator();\n      while(it.hasNext()) {\n        Object obj = it.next();\n        System.out.println(obj);\n      }\n\n上のコードは下のコードに置換できます。\n\n\n      for (Object obj : c) {\n        System.out.println(obj);\n      }\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 'For-each ループ' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WhileLoopReplaceableByForEach",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NotNullFieldNotInitialized",
                "shortDescription": {
                  "text": "初期化されていない @NotNull フィールド"
                },
                "fullDescription": {
                  "text": "非 null のアノテーションが付いたフィールドで、コンストラクターで初期化されていないものを報告します。 例: 'public class MyClass {\n  private @NotNull String value;\n\n  public void setValue(@NotNull String value) {\n    this.value = value;\n  }\n\n  public @NotNull String getValue() {\n    return value;\n  }\n}' このようなフィールドは 非 null 制約に違反している可能性があります。 上記の例では、'setValue' のパラメーターに非 null のアノテーションが付いていますが、'getValue' は setter が呼び出されない場合に null を返す可能性があります。",
                  "markdown": "非 null のアノテーションが付いたフィールドで、コンストラクターで初期化されていないものを報告します。\n\n例:\n\n    public class MyClass {\n      private @NotNull String value;\n\n      public void setValue(@NotNull String value) {\n        this.value = value;\n      }\n\n      public @NotNull String getValue() {\n        return value;\n      }\n    }\n\n\nこのようなフィールドは 非 null 制約に違反している可能性があります。 上記の例では、`setValue` のパラメーターに非 null のアノテーションが付いていますが、`getValue` は setter が呼び出されない場合に null を返す可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NotNullFieldNotInitialized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ/null 許容性の問題",
                      "index": 119,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyComplexBooleanExpression",
                "shortDescription": {
                  "text": "過度に複雑なブール式"
                },
                "fullDescription": {
                  "text": "項が多すぎるブール式を報告します。 このような式は混乱を招く可能性があり、バグを誘発しやすくします。 例: 'cond(x1) && cond(x2) ^ cond(x3) && cond(x4);' インスペクションの構成: ブール式に使用できる最大項数を指定するには、「最大項数」フィールドを使用します。 単一のブール演算子のみを繰り返し使用しているブール式を無視するには、「純粋な論理積と論理和を無視する」オプションを使用します。",
                  "markdown": "項が多すぎるブール式を報告します。 このような式は混乱を招く可能性があり、バグを誘発しやすくします。\n\n例:\n\n\n      cond(x1) && cond(x2) ^ cond(x3) && cond(x4);\n\nインスペクションの構成:\n\n* ブール式に使用できる最大項数を指定するには、「**最大項数**」フィールドを使用します。\n* 単一のブール演算子のみを繰り返し使用しているブール式を無視するには、「**純粋な論理積と論理和を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexBooleanExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NotifyCalledOnCondition",
                "shortDescription": {
                  "text": "'java.util.concurrent.locks.Condition' オブジェクトに対する 'notify()' または 'notifyAll()' 呼び出し"
                },
                "fullDescription": {
                  "text": "'java.util.concurrent.locks.Condition' オブジェクトに対して行われている 'notify()' または 'notifyAll()' の呼び出しを報告します。 このような呼び出しはプログラミングの誤りであり、代わりに 'signal()' または 'signalAll()' メソッドのバリアントが意図されていた可能性があります。そうでない場合は、'IllegalMonitorStateException' が発生する可能性があります。 例: 'class C {\n    final Lock l = new ReentrantLock();\n    final Condition c = l.newCondition();\n\n    void release() {\n      l.lock();\n      try {\n        c.notifyAll(); // ここでは 'signalAll()' が意図されていた可能性があります\n      } finally {\n        l.unlock();\n      }\n    }\n  }'",
                  "markdown": "`java.util.concurrent.locks.Condition` オブジェクトに対して行われている `notify()` または `notifyAll()` の呼び出しを報告します。\n\n\nこのような呼び出しはプログラミングの誤りであり、代わりに `signal()` または `signalAll()` メソッドのバリアントが意図されていた可能性があります。そうでない場合は、`IllegalMonitorStateException` が発生する可能性があります。\n\n**例:**\n\n\n      class C {\n        final Lock l = new ReentrantLock();\n        final Condition c = l.newCondition();\n\n        void release() {\n          l.lock();\n          try {\n            c.notifyAll(); // ここでは 'signalAll()' が意図されていた可能性があります\n          } finally {\n            l.unlock();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NotifyCalledOnCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementsWithoutDefault",
                "shortDescription": {
                  "text": "'default' 分岐のない 'switch' 文"
                },
                "fullDescription": {
                  "text": "'default' ラベルが含まれていない 'switch' ステートメントを報告します。 'default' ラベルを追加すると、起こり得るすべてのシナリオが確実にカバーされるため、プログラムの現在の状態が推測しやすくなります。 デフォルトでは、このインスペクションは列挙型または 'sealed' クラスのすべての case がカバーされている場合は 'switch' ステートメントを報告しません。 この動作を変更したい場合は、「完全な switch ステートメントを無視する」オプションを使用します。",
                  "markdown": "`default` ラベルが含まれていない `switch` ステートメントを報告します。\n\n`default` ラベルを追加すると、起こり得るすべてのシナリオが確実にカバーされるため、プログラムの現在の状態が推測しやすくなります。\n\n\nデフォルトでは、このインスペクションは列挙型または `sealed` クラスのすべての case がカバーされている場合は `switch` ステートメントを報告しません。\nこの動作を変更したい場合は、「**完全な switch ステートメントを無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SwitchStatementWithoutDefaultBranch",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncompatibleMask",
                "shortDescription": {
                  "text": "互換性のないビットマスク演算"
                },
                "fullDescription": {
                  "text": "必ず 'true' または 'false' に評価されるビット演算マスク式を報告します。 このインスペクションは、'constant1' と 'constant2' が互換性のないビットマスク定数の '(var & constant1) == constant2' または '(var | constant1) == constant2' の形式の式をチェックします。 例: '// 互換性のないマスク: マスクが 00 で終わっているため、\n  // 結果は 0x1234 ではなく 0x1200 になる可能性があります\n  if ((mask & 0xFF00) == 0x1234) {...}'",
                  "markdown": "必ず `true` または `false` に評価されるビット演算マスク式を報告します。\n\n\nこのインスペクションは、`constant1`\nと `constant2` が互換性のないビットマスク定数の `(var & constant1) == constant2` または `(var | constant1) == constant2` の形式の式をチェックします。\n\n**例:**\n\n      // 互換性のないマスク: マスクが 00 で終わっているため、\n      // 結果は 0x1234 ではなく 0x1200 になる可能性があります\n      if ((mask & 0xFF00) == 0x1234) {...}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IncompatibleBitwiseMaskOperation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ビット演算関連の問題",
                      "index": 97,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewMethodNamingConvention",
                "shortDescription": {
                  "text": "メソッドの命名規則"
                },
                "fullDescription": {
                  "text": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないメソッドを報告します。 ライブラリのメソッドとコンストラクターをオーバーライドするインスタンスメソッドは、このインスペクションでは無視されます。 例: このインスペクションが static メソッドに対して有効になっており、メソッド名の最小文字数に 4 (デフォルト) が指定されている場合、次の static メソッドはメソッド名の文字数が 4 未満の 3 であるため、警告が発生します: 'public static int max(int a, int b)' このようなメソッドの名前を変更するクイックフィックスは、エディターでのみ使用できます。 インスペクションの構成: チェック対象のメソッドを指定するには、「オプション」セクション内のリストを使用します。 チェック対象外にするメソッドタイプのチェックボックスからはチェックを外してください。 対応するチェックをスキップするには、長さフィールドに 0 を指定します。 正規表現は標準的な 'java.util.regex' 形式で指定する必要があります。",
                  "markdown": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないメソッドを報告します。\n\nライブラリのメソッドとコンストラクターをオーバーライドするインスタンスメソッドは、このインスペクションでは無視されます。\n\n**例:** このインスペクションが static メソッドに対して有効になっており、メソッド名の最小文字数に 4 (デフォルト) が指定されている場合、次の static メソッドはメソッド名の文字数が 4 未満の 3 であるため、警告が発生します: `public static int max(int a, int b)`\n\nこのようなメソッドの名前を変更するクイックフィックスは、エディターでのみ使用できます。\n\nインスペクションの構成:\n\nチェック対象のメソッドを指定するには、「**オプション** 」セクション内のリストを使用します。 チェック対象外にするメソッドタイプのチェックボックスからはチェックを外してください。 対応するチェックをスキップするには、長さフィールドに **0** を指定します。\n\n正規表現は標準的な `java.util.regex` 形式で指定する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewMethodNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規則/メソッド",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExplicitArgumentCanBeLambda",
                "shortDescription": {
                  "text": "ラムダにできる明示的な引数"
                },
                "fullDescription": {
                  "text": "非自明な式を受け取り、代わりにラムダを受け取る同等のメソッド呼び出しに置換できるメソッド呼び出しを報告します。 式をラムダに変換すると、メソッド内で使用されない式は確実に評価されなくなります。 たとえば、'optional.orElse(createDefaultValue())' は 'optional.orElseGet(this::createDefaultValue)' に変換できます。 2018.1 の新機能です このインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。",
                  "markdown": "非自明な式を受け取り、代わりにラムダを受け取る同等のメソッド呼び出しに置換できるメソッド呼び出しを報告します。\n\n\n式をラムダに変換すると、メソッド内で使用されない式は確実に評価されなくなります。 たとえば、`optional.orElse(createDefaultValue())` は `optional.orElseGet(this::createDefaultValue)` に変換できます。\n\n2018.1 の新機能です\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ExplicitArgumentCanBeLambda",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyStrongTypeCast",
                "shortDescription": {
                  "text": "強すぎる型キャスト"
                },
                "fullDescription": {
                  "text": "強すぎる型のキャストを報告します。 たとえば、オブジェクトを 'List' にキャストする際は 'ArrayList' にキャストしても同じ効果を得ることができます。 注意:「冗長な型キャスト」インスペクションと同様に、'ClassCastException' を発生させる目的で強すぎる型のキャストを意図的に使用している場合、このインスペクションに対応する修正を適用するとプログラムのセマンティクスが変更される可能性があります。 例: 'interface Super {\n    void doSmth();\n  }\n  interface Sub extends Super { }\n\n  void use(Object obj) {\n    // 警告: ((Super)obj).doSmth() を使用できます\n    ((Sub)obj).doSmth();\n  }' コードに一致する 'instanceof' チェックがあるときにキャストを無視するには、以下のチェックボックスを使用します。",
                  "markdown": "強すぎる型のキャストを報告します。 たとえば、オブジェクトを `List` にキャストする際は `ArrayList` にキャストしても同じ効果を得ることができます。\n\n\n**注意:** 「*冗長な型キャスト* 」インスペクションと同様に、`ClassCastException` を発生させる目的で強すぎる型のキャストを意図的に使用している場合、このインスペクションに対応する修正を適用するとプログラムのセマンティクスが変更される可能性があります。\n\n例:\n\n\n      interface Super {\n        void doSmth();\n      }\n      interface Sub extends Super { }\n\n      void use(Object obj) {\n        // 警告: ((Super)obj).doSmth() を使用できます\n        ((Sub)obj).doSmth();\n      }\n\n\nコードに一致する `instanceof` チェックがあるときにキャストを無視するには、以下のチェックボックスを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyStrongTypeCast",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsCalledOnEnumConstant",
                "shortDescription": {
                  "text": "列挙値での 'equals()' 呼び出し"
                },
                "fullDescription": {
                  "text": "列挙型定数に対する 'equals()' 呼び出しを報告します。 このような呼び出しは識別子の比較 ('==') に置換できます。2 つの列挙型定数が等しくなるのは、識別子が同じ場合のみであるためです。 呼び出しを比較に変更するクイックフィックスを使用できます。 例: 'boolean foo(MyEnum value) {\n    return value.equals(MyEnum.FOO);\n  }' クイックフィックス適用後: 'boolean foo(MyEnum value) {\n    return value == MyEnum.FOO;\n  }'",
                  "markdown": "列挙型定数に対する `equals()` 呼び出しを報告します。\n\nこのような呼び出しは識別子の比較 (`==`) に置換できます。2 つの列挙型定数が等しくなるのは、識別子が同じ場合のみであるためです。\n\n呼び出しを比較に変更するクイックフィックスを使用できます。\n\n**例:**\n\n\n      boolean foo(MyEnum value) {\n        return value.equals(MyEnum.FOO);\n      }\n\nクイックフィックス適用後:\n\n\n      boolean foo(MyEnum value) {\n        return value == MyEnum.FOO;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsCalledOnEnumConstant",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaLangImport",
                "shortDescription": {
                  "text": "'java.lang' パッケージからの不要なインポート"
                },
                "fullDescription": {
                  "text": "'java.lang' パッケージを参照している 'import' ステートメントを報告します。 'java.lang' クラスは常に暗黙的にインポートされるため、このような import ステートメントは冗長で混乱を招きます。 IntelliJ IDEA は「インポートの最適化」コマンドでこのようなステートメントを自動的に検出して修正できるため、このインスペクションは変更を意図していないコードベースについて主にオフラインで報告させる目的で主に役立ちます。",
                  "markdown": "`java.lang` パッケージを参照している `import` ステートメントを報告します。\n\n\n`java.lang` クラスは常に暗黙的にインポートされるため、このような import ステートメントは冗長で混乱を招きます。\n\n\nIntelliJ IDEA は「**インポートの最適化**」コマンドでこのようなステートメントを自動的に検出して修正できるため、このインスペクションは変更を意図していないコードベースについて主にオフラインで報告させる目的で主に役立ちます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaLangImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/インポート",
                      "index": 23,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UtilityClass",
                "shortDescription": {
                  "text": "ユーティリティクラス"
                },
                "fullDescription": {
                  "text": "ユーティリティクラスを報告します。 ユーティリティクラスではすべてのフィールドとメソッドが 'static' で宣言されています。また、ユーティリティクラスが存在しているということは、オブジェクト指向設計に不備がある可能性があります。 特別なアノテーションを指定するには、「次のアノテーションが付いている場合は無視」オプションを使用します。 このインスペクションは、ここで指定されたアノテーションのいずれかが付いているクラスを無視します。",
                  "markdown": "ユーティリティクラスを報告します。\n\nユーティリティクラスではすべてのフィールドとメソッドが `static` で宣言されています。また、ユーティリティクラスが存在しているということは、オブジェクト指向設計に不備がある可能性があります。\n\n\n特別なアノテーションを指定するには、「**次のアノテーションが付いている場合は無視**」オプションを使用します。 このインスペクションは、ここで指定されたアノテーションのいずれかが付いているクラスを無視します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UtilityClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNameDiffersFromFileName",
                "shortDescription": {
                  "text": "ファイル名と異なるクラス名"
                },
                "fullDescription": {
                  "text": "トップレベルのクラス名のうち、それを含んでいるファイルの名前と一致していないものを報告します。 Java の仕様ではこのような非 'public' のクラスを命名できますが、名前が一致しないファイルを使用すると混乱を招き、さまざまなソフトウェアツールの効果が低下する可能性があります。",
                  "markdown": "トップレベルのクラス名のうち、それを含んでいるファイルの名前と一致していないものを報告します。\n\nJava の仕様ではこのような非 `public` のクラスを命名できますが、名前が一致しないファイルを使用すると混乱を招き、さまざまなソフトウェアツールの効果が低下する可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassNameDiffersFromFileName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HardcodedLineSeparators",
                "shortDescription": {
                  "text": "ハードコードされた改行コード"
                },
                "fullDescription": {
                  "text": "文字列リテラル、文字リテラル、またはテキストブロックで使用されているラインフィード ('\\n') およびキャリッジリターン ('\\r') の文字エスケープシーケンスを報告します。 これらの文字は行区切り文字としてよく使用されているため、ハードコードすると移植性に問題が生じる可能性があります。 例: 'String count = \"first\\nsecond\\rthird\";'",
                  "markdown": "文字列リテラル、文字リテラル、またはテキストブロックで使用されているラインフィード (`\\n`) およびキャリッジリターン (`\\r`) の文字エスケープシーケンスを報告します。 これらの文字は行区切り文字としてよく使用されているため、ハードコードすると移植性に問題が生じる可能性があります。\n\n**例:**\n\n\n      String count = \"first\\nsecond\\rthird\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HardcodedLineSeparator",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ポータビリティ",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryConstantArrayCreationExpression",
                "shortDescription": {
                  "text": "定数配列の作成における冗長な 'new' 式"
                },
                "fullDescription": {
                  "text": "配列イニシャライザーに置換できる不変の new 配列式を報告します。 配列イニシャライザーの型はすでに代入の左側で指定されているため、省略できます。 例: 'int[] foo = new int[] {42};' クイックフィックス適用後: 'int[] foo = {42};'",
                  "markdown": "配列イニシャライザーに置換できる不変の new 配列式を報告します。 配列イニシャライザーの型はすでに代入の左側で指定されているため、省略できます。\n\n**例:**\n\n\n      int[] foo = new int[] {42};\n\nクイックフィックス適用後:\n\n\n      int[] foo = {42};\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryConstantArrayCreationExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LabeledStatement",
                "shortDescription": {
                  "text": "ラベル付きステートメント"
                },
                "fullDescription": {
                  "text": "リファクタリングを複雑にし、メソッドのフローを制御している可能性のあるラベル付きステートメントを報告します。 例: 'label:\n  while (true) {\n      // コード\n  }'",
                  "markdown": "リファクタリングを複雑にし、メソッドのフローを制御している可能性のあるラベル付きステートメントを報告します。\n\n例:\n\n\n      label:\n      while (true) {\n          // コード\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LabeledStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IndexOfReplaceableByContains",
                "shortDescription": {
                  "text": "'contains()' に置換可能な 'String.indexOf()' 式"
                },
                "fullDescription": {
                  "text": "'String.indexOf()' 呼び出しとの比較で、'String.contains()' メソッドの呼び出しに置換できるものを報告します。 例: 'boolean b = \"abcd\".indexOf('e') >= 0;' クイックフィックス適用後: 'boolean b = \"abcd\".contains('e');' このインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以上の場合にのみ報告します。",
                  "markdown": "`String.indexOf()` 呼び出しとの比較で、`String.contains()` メソッドの呼び出しに置換できるものを報告します。\n\n**例:**\n\n\n      boolean b = \"abcd\".indexOf('e') >= 0;\n\nクイックフィックス適用後:\n\n\n      boolean b = \"abcd\".contains('e');\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以上の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IndexOfReplaceableByContains",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationArgumentToLogCall",
                "shortDescription": {
                  "text": "ロギング呼び出しの引数に定数でない文字列連結を使用"
                },
                "fullDescription": {
                  "text": "SLF4J および Log4j 2 ロギングメソッドの引数として使用されている非定数の文字列連結を報告します。 非定数の連結は、ロギングメッセージがログに記録されない場合でも実行時に評価されます。そのため、パフォーマンスに否定的な影響を及ぼす可能性があります。 代わりに、ロギングが無効な場合には評価されないパラメーター化されたログメッセージを使用することをお勧めします。 例: 'public class Vital {\n    private static final Logger LOG = LoggerFactory.getLogger(Vital.class);\n\n    public void saveTheWorld(int i, String s, boolean b) {\n      LOG.info(\"saveTheWorld(\" + i + \", \" + s + \", \"  + b + \")\");\n      // todo\n    }\n  }' クイックフィックス適用後: 'public class Vital {\n    private static final Logger LOG = LoggerFactory.getLogger(Vital.class);\n\n    public void saveTheWorld(int i, String s, boolean b) {\n      LOG.info(\"saveTheWorld({}, {}, {})\", i, s, b);\n      // todo\n    }\n  }' インスペクションの構成: 特定のより高いロギングレベルを無視するには、「警告対象」リストを使用します。 より高いロギングレベルはプロダクションでも有効にできます。また、引数は常に評価されます。",
                  "markdown": "**SLF4J** および **Log4j 2** ロギングメソッドの引数として使用されている非定数の文字列連結を報告します。 非定数の連結は、ロギングメッセージがログに記録されない場合でも実行時に評価されます。そのため、パフォーマンスに否定的な影響を及ぼす可能性があります。 代わりに、ロギングが無効な場合には評価されないパラメーター化されたログメッセージを使用することをお勧めします。\n\n**例:**\n\n\n      public class Vital {\n        private static final Logger LOG = LoggerFactory.getLogger(Vital.class);\n\n        public void saveTheWorld(int i, String s, boolean b) {\n          LOG.info(\"saveTheWorld(\" + i + \", \" + s + \", \"  + b + \")\");\n          // todo\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public class Vital {\n        private static final Logger LOG = LoggerFactory.getLogger(Vital.class);\n\n        public void saveTheWorld(int i, String s, boolean b) {\n          LOG.info(\"saveTheWorld({}, {}, {})\", i, s, b);\n          // todo\n        }\n      }\n\n\nインスペクションの構成:\n\n* 特定のより高いロギングレベルを無視するには、「**警告対象**」リストを使用します。 より高いロギングレベルはプロダクションでも有効にできます。また、引数は常に評価されます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "StringConcatenationArgumentToLogCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ログ関連",
                      "index": 91,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousNameCombination",
                "shortDescription": {
                  "text": "疑わしい変数とパラメーター名の組み合わせ"
                },
                "fullDescription": {
                  "text": "代入または関数呼び出しで、ターゲット変数または関数パラメーターの名前と代入値の名前が一致していないものを報告します。 例 1: 'int x = 0;\n  int y = x; // x を y 座標として使用している' 例 2: 'int x = 0, y = 0;\n  // x を y 座標として使用し、y を x 座標として使用している\n  Rectangle rc = new Rectangle(y, x, 20, 20);' インスペクションの構成: 一緒に使用すべきではない名前を指定するには、「名前グループ」エリアを使用します。パラメーター名または代入ターゲットの名前がこのグループの単語を含み、代入または渡される変数の名前が異なるグループの単語を含んでいる場合エラーが報告されます。 チェックする必要はないものの、疑わしい名前を持つと思われるメソッドを指定するには、「メソッドを無視」エリアを使用します。 たとえば、'Integer.compare()' のパラメーター名は 'x' と 'y' ですが、座標とは無関係です。",
                  "markdown": "代入または関数呼び出しで、ターゲット変数または関数パラメーターの名前と代入値の名前が一致していないものを報告します。\n\n例 1:\n\n\n      int x = 0;\n      int y = x; // x を y 座標として使用している\n      \n例 2:\n\n\n      int x = 0, y = 0;\n      // x を y 座標として使用し、y を x 座標として使用している\n      Rectangle rc = new Rectangle(y, x, 20, 20);\n\nインスペクションの構成:\n\n一緒に使用すべきではない名前を指定するには、「**名前グループ**」エリアを使用します。パラメーター名または代入ターゲットの名前がこのグループの単語を含み、代入または渡される変数の名前が異なるグループの単語を含んでいる場合エラーが報告されます。\n\nチェックする必要はないものの、疑わしい名前を持つと思われるメソッドを指定するには、「**メソッドを無視** 」エリアを使用します。\nたとえば、`Integer.compare()` のパラメーター名は `x` と `y` ですが、座標とは無関係です。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousNameCombination",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitDefaultCharsetUsage",
                "shortDescription": {
                  "text": "暗黙的なプラットフォームのデフォルト文字セット"
                },
                "fullDescription": {
                  "text": "プラットフォームのデフォルト文字セットを暗黙的に使用しているメソッドとコンストラクターの呼び出しを報告します。 このような呼び出しは、異なるデフォルト文字セットを使用するシステム間では結果が変わる可能性があり、予期しない動作が発生する場合があります。 例: 'void foo(byte[] bytes) {\n  String s = new String(bytes);\n}'\n 対応するオーバーロードメソッドを使用できる場合、明示的な UTF-8 文字セットを指定するクイックフィックスを使用できます。 クイックフィックス適用後: 'void foo(byte[] bytes) {\n  String s = new String(bytes, StandardCharsets.UTF_8);\n}'",
                  "markdown": "プラットフォームのデフォルト文字セットを暗黙的に使用しているメソッドとコンストラクターの呼び出しを報告します。 このような呼び出しは、異なるデフォルト文字セットを使用するシステム間では結果が変わる可能性があり、予期しない動作が発生する場合があります。\n\n**例:**\n\n    void foo(byte[] bytes) {\n      String s = new String(bytes);\n    }\n\n対応するオーバーロードメソッドを使用できる場合、明示的な UTF-8 文字セットを指定するクイックフィックスを使用できます。\nクイックフィックス適用後:\n\n    void foo(byte[] bytes) {\n      String s = new String(bytes, StandardCharsets.UTF_8);\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ImplicitDefaultCharsetUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DesignForExtension",
                "shortDescription": {
                  "text": "拡張のための設計"
                },
                "fullDescription": {
                  "text": "'static'、'private'、'final'、または 'abstract' でないメソッドで、その本体が空でないメソッドを報告します。 このようなメソッドを避けるようにコーディングすると、クラスの契約がサブクラスによって破られるのを防ぐことができます。 このようにコーディングするメリットは、サブクラスがスーパーメソッドを呼び出し忘れることでスーパークラスの状態が破損する可能性がなくなることです。 その代償として、サブクラスがスーパークラス内のコードの実行を阻止できないなど、サブクラスの柔軟性が制限されます。 クイックフィックスを使用すると、欠落している修飾子が追加されます。 例: 'class Foo {\n    public boolean equals(Object o) { return true; }\n  }' クイックフィックス適用後: 'class Foo {\n    public final boolean equals(Object o) { return true; }\n  }' このインスペクションは安全な環境で使用されるコードを想定しており、制限が少ない環境には適さない可能性があります。",
                  "markdown": "`static`、`private`、`final`、または `abstract` でないメソッドで、その本体が空でないメソッドを報告します。\n\n\nこのようなメソッドを避けるようにコーディングすると、クラスの契約がサブクラスによって破られるのを防ぐことができます。 このようにコーディングするメリットは、サブクラスがスーパーメソッドを呼び出し忘れることでスーパークラスの状態が破損する可能性がなくなることです。 その代償として、サブクラスがスーパークラス内のコードの実行を阻止できないなど、サブクラスの柔軟性が制限されます。 クイックフィックスを使用すると、欠落している修飾子が追加されます。\n\n**例:**\n\n\n      class Foo {\n        public boolean equals(Object o) { return true; }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        public final boolean equals(Object o) { return true; }\n      }\n\nこのインスペクションは安全な環境で使用されるコードを想定しており、制限が少ない環境には適さない可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DesignForExtension",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyStreamApiCallChains",
                "shortDescription": {
                  "text": "単純化できる Stream API 呼び出しチェーン"
                },
                "fullDescription": {
                  "text": "単純化できる Steam API の呼び出しチェーンを報告します。 単純化すると、多くの場合はコレクションを走査中に一時的なオブジェクトが作成されるのを回避できます。 このインスペクションは次の呼び出しチェーンを置換します。 'collection.stream().forEach()' → 'collection.forEach()' 'collection.stream().collect(toList/toSet/toCollection())' → 'new CollectionType<>(collection)' 'collection.stream().toArray()' → 'collection.toArray()' 'Arrays.asList().stream()' → 'Arrays.stream()' または 'Stream.of()' 'IntStream.range(0, array.length).mapToObj(idx -> array[idx])' → 'Arrays.stream(array)' 'IntStream.range(0, list.size()).mapToObj(idx -> list.get(idx))' → 'list.stream()' 'Collections.singleton().stream()' → 'Stream.of()' 'Collections.emptyList().stream()' → 'Stream.empty()' 'stream.filter().findFirst().isPresent()' → 'stream.anyMatch()' 'stream.collect(counting())' → 'stream.count()' 'stream.collect(maxBy())' → 'stream.max()' 'stream.collect(mapping())' → 'stream.map().collect()' 'stream.collect(reducing())' → 'stream.reduce()' 'stream.collect(summingInt())' → 'stream.mapToInt().sum()' 'stream.mapToObj(x -> x)' → 'stream.boxed()' 'stream.map(x -> {...; return x;})' → 'stream.peek(x -> ...)' '!stream.anyMatch()' → 'stream.noneMatch()' '!stream.anyMatch(x -> !(...))' → 'stream.allMatch()' 'stream.map().anyMatch(Boolean::booleanValue)' → 'stream.anyMatch()' 'IntStream.range(expr1, expr2).mapToObj(x -> array[x])' → 'Arrays.stream(array, expr1, expr2)' 'Collection.nCopies(count, ...)' → 'Stream.generate().limit(count)' 'stream.sorted(comparator).findFirst()' → 'Stream.min(comparator)' 'optional.orElseGet(() -> { throw new ...; })' → 'optional.orElseThrow()' 置換のセマンティクスは、場合によって多少異なることに注意してください。 たとえば、'Collections.synchronizedList(...).stream().forEach()' は同期されませんが、'Collections.synchronizedList(...).forEach()' は同期されます。 同様に、'collect(Collectors.maxBy())' は結果の要素が 'null' の場合は空の 'Optional' を返しますが、'Stream.max()' は 'NullPointerException' をスローします。 このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "単純化できる Steam API の呼び出しチェーンを報告します。 単純化すると、多くの場合はコレクションを走査中に一時的なオブジェクトが作成されるのを回避できます。\n\n\nこのインスペクションは次の呼び出しチェーンを置換します。\n\n* `collection.stream().forEach()` → `collection.forEach()`\n* `collection.stream().collect(toList/toSet/toCollection())` → `new CollectionType<>(collection)`\n* `collection.stream().toArray()` → `collection.toArray()`\n* `Arrays.asList().stream()` → `Arrays.stream()` または `Stream.of()`\n* `IntStream.range(0, array.length).mapToObj(idx -> array[idx])` → `Arrays.stream(array)`\n* `IntStream.range(0, list.size()).mapToObj(idx -> list.get(idx))` → `list.stream()`\n* `Collections.singleton().stream()` → `Stream.of()`\n* `Collections.emptyList().stream()` → `Stream.empty()`\n* `stream.filter().findFirst().isPresent()` → `stream.anyMatch()`\n* `stream.collect(counting())` → `stream.count()`\n* `stream.collect(maxBy())` → `stream.max()`\n* `stream.collect(mapping())` → `stream.map().collect()`\n* `stream.collect(reducing())` → `stream.reduce()`\n* `stream.collect(summingInt())` → `stream.mapToInt().sum()`\n* `stream.mapToObj(x -> x)` → `stream.boxed()`\n* `stream.map(x -> {...; return x;})` → `stream.peek(x -> ...)`\n* `!stream.anyMatch()` → `stream.noneMatch()`\n* `!stream.anyMatch(x -> !(...))` → `stream.allMatch()`\n* `stream.map().anyMatch(Boolean::booleanValue)` → `stream.anyMatch()`\n* `IntStream.range(expr1, expr2).mapToObj(x -> array[x])` → `Arrays.stream(array, expr1, expr2)`\n* `Collection.nCopies(count, ...)` → `Stream.generate().limit(count)`\n* `stream.sorted(comparator).findFirst()` → `Stream.min(comparator)`\n* `optional.orElseGet(() -> { throw new ...; })` → `optional.orElseThrow()`\n\n\n置換のセマンティクスは、場合によって多少異なることに注意してください。 たとえば、`Collections.synchronizedList(...).stream().forEach()` は同期されませんが、`Collections.synchronizedList(...).forEach()` は同期されます。\n同様に、`collect(Collectors.maxBy())` は結果の要素が `null` の場合は空の `Optional` を返しますが、`Stream.max()` は `NullPointerException` をスローします。\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifyStreamApiCallChains",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalContainsCollection",
                "shortDescription": {
                  "text": "配列またはコレクションを含む 'Optional'"
                },
                "fullDescription": {
                  "text": "配列またはコレクション型のパラメーターを使用している 'java.util.Optional' または 'com.google.common.base.Optional' 型を報告します。 このような場合は、空の配列かコレクションを使用して結果がないことを示すほうが分かりやすくなります。 例: 'Optional<List<Integer>> foo() {\n    return Optional.empty();\n  }' このコードは次のように書けます: 'List<Integer> foo() {\n    return List.of();\n  }' このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "配列またはコレクション型のパラメーターを使用している `java.util.Optional` または `com.google.common.base.Optional` 型を報告します。\n\nこのような場合は、空の配列かコレクションを使用して結果がないことを示すほうが分かりやすくなります。\n\n**例:**\n\n\n      Optional<List<Integer>> foo() {\n        return Optional.empty();\n      }\n\nこのコードは次のように書けます:\n\n\n      List<Integer> foo() {\n        return List.of();\n      }\n      \nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalContainsCollection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnknownGuard",
                "shortDescription": {
                  "text": "不明な '@GuardedBy' フィールド"
                },
                "fullDescription": {
                  "text": "不明なガード対象フィールドを指定している '@GuardedBy' アノテーションを報告します。 例: 'private Object state;\n\n    @GuardedBy(\"lock\") //ガードの参照先が不明\n    public void bar() {\n        state = new Object();\n    }' サポート対象の '@GuardedBy' アノテーションは以下の通りです。 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "不明なガード対象フィールドを指定している `@GuardedBy` アノテーションを報告します。\n\n例:\n\n\n        private Object state;\n\n        @GuardedBy(\"lock\") //ガードの参照先が不明\n        public void bar() {\n            state = new Object();\n        }\n\nサポート対象の `@GuardedBy` アノテーションは以下の通りです。\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnknownGuard",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/並行処理に関するアノテーションの問題",
                      "index": 58,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InterfaceMethodClashesWithObject",
                "shortDescription": {
                  "text": "インターフェースメソッドが 'Object' 内のメソッドと衝突しています"
                },
                "fullDescription": {
                  "text": "インターフェースのメソッドで、'java.lang.Object' クラスの protected メソッドの 'clone()' および 'finalize()' と競合しているものを報告します。 インターフェースでは、このようなメソッドを 'java.lang.Object' のメソッドと互換性のない戻り値の型を使用して宣言することができます。 このようなインターフェースを実装するクラスはコンパイルできません。 このインターフェースが機能している場合も、それからラムダを作成することは可能ですが、お勧めしません。 例: '// 警告: このインターフェースはどのクラスも実装できません。\n  // ラムダもしくはメソッド参照でのみ実装可能です。\n  interface MyInterface {\n    double clone();\n  }'",
                  "markdown": "インターフェースのメソッドで、`java.lang.Object` クラスの **protected** メソッドの `clone()` および `finalize()` と競合しているものを報告します。\n\nインターフェースでは、このようなメソッドを `java.lang.Object` のメソッドと互換性のない戻り値の型を使用して宣言することができます。\nこのようなインターフェースを実装するクラスはコンパイルできません。\nこのインターフェースが機能している場合も、それからラムダを作成することは可能ですが、お勧めしません。\n\n例:\n\n\n      // 警告: このインターフェースはどのクラスも実装できません。\n      // ラムダもしくはメソッド参照でのみ実装可能です。\n      interface MyInterface {\n        double clone();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InterfaceMethodClashesWithObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoadLibraryWithNonConstantString",
                "shortDescription": {
                  "text": "非定数文字列で 'System.loadLibrary()' を呼び出し"
                },
                "fullDescription": {
                  "text": "動的に作成される文字列をライブラリ名として受け取っている 'java.lang.System.loadLibrary()'、'java.lang.System.load()'、'java.lang.Runtime.loadLibrary()'、'java.lang.Runtime.load()' の呼び出しを報告します。 動的に作成されるライブラリ名文字列は、一般的にセキュリティ違反の元になります。 このインスペクションはデフォルトではコンパイル時の定数を無視します。 例: 'void test(int i) {\n    System.loadLibrary(\"foo\" + i);\n  }' すべての 'static' フィールドを定数と見なすには、インスペクション設定を使用します。 このオプションが有効な場合、次のような文字列は無視されますので注意してください。 'private static final String LIBRARY = getUserInput();'",
                  "markdown": "動的に作成される文字列をライブラリ名として受け取っている `java.lang.System.loadLibrary()`、`java.lang.System.load()`、`java.lang.Runtime.loadLibrary()`、`java.lang.Runtime.load()` の呼び出しを報告します。\n\n\n動的に作成されるライブラリ名文字列は、一般的にセキュリティ違反の元になります。\nこのインスペクションはデフォルトではコンパイル時の定数を無視します。\n\n**例:**\n\n\n      void test(int i) {\n        System.loadLibrary(\"foo\" + i);\n      }\n\n\nすべての `static` フィールドを定数と見なすには、インスペクション設定を使用します。\nこのオプションが有効な場合、次のような文字列は無視されますので注意してください。\n\n\n      private static final String LIBRARY = getUserInput();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoadLibraryWithNonConstantString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableAssertion",
                "shortDescription": {
                  "text": "単純化できるアサーション"
                },
                "fullDescription": {
                  "text": "より単純な同等の呼び出しに置換できる 'assert' の呼び出しを報告します。 例 → 置換 'assertEquals(true, x());' 'assertTrue(x());' 'assertTrue(y() != null);' 'assertNotNull(y());' 'assertTrue(z == z());' 'assertSame(z, z());' 'assertTrue(a.equals(a()));' 'assertEquals(a, a());' 'assertTrue(false);' 'fail();'",
                  "markdown": "より単純な同等の呼び出しに置換できる `assert` の呼び出しを報告します。\n\n|                例                 | → |           置換            |\n|----------------------------------|---|-------------------------|\n| `assertEquals(`**true**`, x());` |   | `assertTrue(x());`      |\n| `assertTrue(y() != null);`       |   | `assertNotNull(y());`   |\n| `assertTrue(z == z());`          |   | `assertSame(z, z());`   |\n| `assertTrue(a.equals(a()));`     |   | `assertEquals(a, a());` |\n| `assertTrue(`**false**`);`       |   | `fail();`               |"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableAssertion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/テストフレームワーク",
                      "index": 96,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticMethodOnlyUsedInOneClass",
                "shortDescription": {
                  "text": "1つの他のクラスからのみ使用される static メンバー"
                },
                "fullDescription": {
                  "text": "包含クラス以外のクラスのみで使用されている 'static' メソッドとフィールドを報告します。 このようなメンバーは、その使用しているクラスに移動できます。 このインスペクションでは、メンバーのクラス内の匿名クラスからアクセスされているファクトリメソッドとメンバーは無視されます。 同じクラスにある同じ名前のメソッドで、よりパラメーター数が少ないものを呼び出している簡易オーバーロードも無視されます。 static メンバーがテストクラスからのみ使用されている場合にこのインスペクションを抑止するには、最初のチェックボックスを使用します。 匿名クラス、ローカルクラス、または非 static の内部クラス内からのメンバーの使用を無視するには、下にある 2 番目のチェックボックスを使用します。 問題なく移動できないメンバーに関して警告しないようにするには、下にある 3 番目のチェックボックスを使用します。たとえば、ターゲットクラスにまったく同じシグネチャーを持つメソッドがすでに存在する場合や、そのメソッドを移動するとメソッド内で使用されているフィールドまたはメソッドにアクセスできなくなるなどの問題があります。 ユーティリティクラスにあるメンバーを無視するには、4 番目のチェックボックスを使用します。",
                  "markdown": "包含クラス以外のクラスのみで使用されている `static` メソッドとフィールドを報告します。 このようなメンバーは、その使用しているクラスに移動できます。 このインスペクションでは、メンバーのクラス内の匿名クラスからアクセスされているファクトリメソッドとメンバーは無視されます。 同じクラスにある同じ名前のメソッドで、よりパラメーター数が少ないものを呼び出している簡易オーバーロードも無視されます。\n\n\nstatic メンバーがテストクラスからのみ使用されている場合にこのインスペクションを抑止するには、最初のチェックボックスを使用します。\n\n\n匿名クラス、ローカルクラス、または非 static の内部クラス内からのメンバーの使用を無視するには、下にある 2 番目のチェックボックスを使用します。\n\n\n問題なく移動できないメンバーに関して警告しないようにするには、下にある 3 番目のチェックボックスを使用します。たとえば、ターゲットクラスにまったく同じシグネチャーを持つメソッドがすでに存在する場合や、そのメソッドを移動するとメソッド内で使用されているフィールドまたはメソッドにアクセスできなくなるなどの問題があります。\n\n\nユーティリティクラスにあるメンバーを無視するには、4 番目のチェックボックスを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticMethodOnlyUsedInOneClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractClassExtendsConcreteClass",
                "shortDescription": {
                  "text": "具象クラスを継承した抽象クラス"
                },
                "fullDescription": {
                  "text": "具象クラスを拡張している 'abstract' クラスを報告します。",
                  "markdown": "具象クラスを拡張している `abstract` クラスを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractClassExtendsConcreteClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantEscapeInRegexReplacement",
                "shortDescription": {
                  "text": "正規表現置換文字列の冗長なエスケープ"
                },
                "fullDescription": {
                  "text": "正規表現メソッドの置換文字列にある冗長なエスケープを報告します。 正規表現の置換文字列では文字をエスケープできますが、 '$' または '\\' 文字だけはエスケープが必要です。 例: 'string.replaceAll(\"a\", \"\\\\b\");' クイックフィックス適用後: 'string.replaceAll(\"a\", \"b\");' 2022.3 の新機能です",
                  "markdown": "正規表現メソッドの置換文字列にある冗長なエスケープを報告します。 正規表現の置換文字列では文字をエスケープできますが、 `$` または `\\` 文字だけはエスケープが必要です。\n\n**例:**\n\n\n      string.replaceAll(\"a\", \"\\\\b\");\n\nクイックフィックス適用後:\n\n\n      string.replaceAll(\"a\", \"b\");\n\n2022.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantEscapeInRegexReplacement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8CollectionRemoveIf",
                "shortDescription": {
                  "text": "ループは 'Collection.removeIf()' に置換できます"
                },
                "fullDescription": {
                  "text": "単一の 'Collection.removeIf()' の呼び出しに縮小できるループを報告します。 例: 'for (Iterator<String> it = collection.iterator(); it.hasNext(); ) {\n    String aValue = it.next();\n    if(shouldBeRemoved(aValue)) {\n      it.remove();\n    }\n  }' クイックフィックス適用後: 'collection.removeIf(aValue -> shouldBeRemoved(aValue));' このインスペクションは Java 8 以降で使用できる Java の機能 'コレクション内のラムダメソッド' に依存しています。",
                  "markdown": "単一の `Collection.removeIf()` の呼び出しに縮小できるループを報告します。\n\n例:\n\n\n      for (Iterator<String> it = collection.iterator(); it.hasNext(); ) {\n        String aValue = it.next();\n        if(shouldBeRemoved(aValue)) {\n          it.remove();\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      collection.removeIf(aValue -> shouldBeRemoved(aValue));\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'コレクション内のラムダメソッド' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8CollectionRemoveIf",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LogStatementNotGuardedByLogCondition",
                "shortDescription": {
                  "text": "ログ条件でガードされていないロギング呼び出し"
                },
                "fullDescription": {
                  "text": "ガード条件で囲まれていないロギング呼び出しを報告します。 呼び出しの引数の評価にはコストがかかる可能性があります。 ロギング呼び出しをガード節で囲むと、ロギングステートメントで使用されているレベルでロギングが無効になっている場合のコストを抑えることができます。 これは、プロダクション環境では往々にして無効になっている最も深刻度の低いロギング呼び出しのレベル (trace, debug, finest) で特に役立ちます。 例: 'public class TestObject {\n    void test(Object object) {\n      LOG.debug(\"some logging \" + expensiveCalculation(1));\n    }\n  }' クイックフィックス適用後: 'public class TestObject {\n    void test(Object object) {\n      if(LOG.isDebugEnabled()){\n        LOG.debug(\"some logging \" + expensiveCalculation(1));\n      }\n    }\n  }' このインスペクションは Log4j2 および SLF4J ロギングフレームワークをサポートします (ビルダーを除く)。 2024.2 の新機能です",
                  "markdown": "ガード条件で囲まれていないロギング呼び出しを報告します。 呼び出しの引数の評価にはコストがかかる可能性があります。 ロギング呼び出しをガード節で囲むと、ロギングステートメントで使用されているレベルでロギングが無効になっている場合のコストを抑えることができます。 これは、プロダクション環境では往々にして無効になっている最も深刻度の低いロギング呼び出しのレベル (trace, debug, finest) で特に役立ちます。\n\n**例:**\n\n\n      public class TestObject {\n        void test(Object object) {\n          LOG.debug(\"some logging \" + expensiveCalculation(1));\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public class TestObject {\n        void test(Object object) {\n          if(LOG.isDebugEnabled()){\n            LOG.debug(\"some logging \" + expensiveCalculation(1));\n          }\n        }\n      }\n\nこのインスペクションは *Log4j2* および *SLF4J* ロギングフレームワークをサポートします (ビルダーを除く)。\n\n2024.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LogStatementNotGuardedByLogCondition",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語/ログ関連",
                      "index": 45,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizedOnLiteralObject",
                "shortDescription": {
                  "text": "リテラルで初期化されたオブジェクトの同期"
                },
                "fullDescription": {
                  "text": "リテラルで初期化されるオブジェクトをロックしている 'synchronized' ブロックを報告します。 文字列リテラルはインターン処理され、'Character'、'Boolean'、'Number' リテラルはキャッシュから割り当てることができます。 このため、同じリテラルで初期化されるオブジェクトを使用しているシステムの他の部分に、まったく同じオブジェクトへの参照を実際に保持しているものがある可能性があります。 その結果、ロックオブジェクトが private であると見なされた場合に予期しないデッドロック状態が発生する可能性があります。 例: 'class Main {\n    final String mutex = \"Mutex\";\n    void method() {\n      synchronized (mutex) {\n      }\n    }\n  }' 'String'、'Character'、'Boolean' そして 'Number' オブジェクトのすべての同期を報告するには、「可能な限りすべてのリテラルを警告する」オプションを使用します。",
                  "markdown": "リテラルで初期化されるオブジェクトをロックしている `synchronized` ブロックを報告します。\n\n\n文字列リテラルはインターン処理され、`Character`、`Boolean`、`Number` リテラルはキャッシュから割り当てることができます。\nこのため、同じリテラルで初期化されるオブジェクトを使用しているシステムの他の部分に、まったく同じオブジェクトへの参照を実際に保持しているものがある可能性があります。 その結果、ロックオブジェクトが private であると見なされた場合に予期しないデッドロック状態が発生する可能性があります。\n\n**例:**\n\n\n      class Main {\n        final String mutex = \"Mutex\";\n        void method() {\n          synchronized (mutex) {\n          }\n        }\n      }\n\n\n`String`、`Character`、`Boolean` そして `Number` オブジェクトのすべての同期を報告するには、「**可能な限りすべてのリテラルを警告する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizedOnLiteralObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9ReflectionClassVisibility",
                "shortDescription": {
                  "text": "モジュール間のリフレクションアクセス問題"
                },
                "fullDescription": {
                  "text": "Java 9 モジュールのアクセシビリティルールが原因で現在のスコープでは見えなくなっているクラスへのアクセスを試みている 'Class.forName()' および 'ClassLoader.loadClass()' の呼び出しを報告します。 このインスペクションは Java 9 以降で使用できる Java の機能 'モジュール' に依存しています。",
                  "markdown": "Java 9 モジュールのアクセシビリティルールが原因で現在のスコープでは見えなくなっているクラスへのアクセスを試みている `Class.forName()` および `ClassLoader.loadClass()` の呼び出しを報告します。\n\nこのインスペクションは Java 9 以降で使用できる Java の機能 'モジュール' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java9ReflectionClassVisibility",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/リフレクションアクセス",
                      "index": 98,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CharsetObjectCanBeUsed",
                "shortDescription": {
                  "text": "標準の 'Charset' オブジェクトを使用できます"
                },
                "fullDescription": {
                  "text": "メソッドやコンストラクターで、定数の文字セットである 'String' リテラル ('\"UTF-8\"' など) を定義済みの 'StandardCharsets.UTF_8'コードに置換できるものを報告します。 修正後は文字セットの検出が不要になるため、コードの処理速度がアップする可能性があります。 また、'UnsupportedEncodingException' をキャッチする必要もなくなる場合があります。 この場合、 catch ブロックは自動的に除去されます。 例: 'try {\n    byte[] bytes = \"str\".getBytes(\"UTF-8\");\n  } catch (UnsupportedEncodingException e) {\n  }' クイックフィックス適用後: 'byte[] bytes = \"str\".getBytes(StandardCharsets.UTF_8);' このインスペクションは Java 7 以降のバージョンで使用できます。 2018.2 の新機能です",
                  "markdown": "メソッドやコンストラクターで、定数の文字セットである `String` リテラル (`\"UTF-8\"` など) を定義済みの `StandardCharsets.UTF_8`コードに置換できるものを報告します。\n\n修正後は文字セットの検出が不要になるため、コードの処理速度がアップする可能性があります。\nまた、`UnsupportedEncodingException` をキャッチする必要もなくなる場合があります。 この場合、\ncatch ブロックは自動的に除去されます。\n\n例:\n\n\n      try {\n        byte[] bytes = \"str\".getBytes(\"UTF-8\");\n      } catch (UnsupportedEncodingException e) {\n      }\n\nクイックフィックス適用後:\n\n\n      byte[] bytes = \"str\".getBytes(StandardCharsets.UTF_8);\n\nこのインスペクションは Java 7 以降のバージョンで使用できます。\n\n2018.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CharsetObjectCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SafeVarargsDetector",
                "shortDescription": {
                  "text": "パラメーター化された可変引数型からヒープ汚染の可能性"
                },
                "fullDescription": {
                  "text": "可変引数を持つメソッドで、'@SafeVarargs' アノテーションを付与できるものを報告します。 @SafeVarargs アノテーションは、呼び出しサイトでのパラメーター化された配列の作成に関する未チェックの警告を抑制します。 例: 'public class Foo<T> {\n    private List<T> list = new ArrayList<>();\n\n    public final void safeVarargs(T... elements) {\n      Collections.addAll(list, elements);\n    }\n  }' クイックフィックス適用後: 'public class Foo<T> {\n    private List<T> list = new ArrayList<>();\n\n    @SafeVarargs\n    public final void safeVarargs(T... elements) {\n      Collections.addAll(list, elements);\n    }\n  }' このアノテーションは、Java 1.6 以前の JVM ではサポートされていません。",
                  "markdown": "可変引数を持つメソッドで、`@SafeVarargs` アノテーションを付与できるものを報告します。 @SafeVarargs アノテーションは、呼び出しサイトでのパラメーター化された配列の作成に関する未チェックの警告を抑制します。\n\n**例:**\n\n\n      public class Foo<T> {\n        private List<T> list = new ArrayList<>();\n\n        public final void safeVarargs(T... elements) {\n          Collections.addAll(list, elements);\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public class Foo<T> {\n        private List<T> list = new ArrayList<>();\n\n        @SafeVarargs\n        public final void safeVarargs(T... elements) {\n          Collections.addAll(list, elements);\n        }\n      }\n\n\nこのアノテーションは、Java 1.6 以前の JVM ではサポートされていません。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "unchecked",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 7",
                      "index": 114,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfSunClasses",
                "shortDescription": {
                  "text": "'sun.*' クラスの使用"
                },
                "fullDescription": {
                  "text": "'sun.*' 階層にあるクラスが使用されていることを報告します。 このようなクラスは異なる JVM 間で移植不可能です。",
                  "markdown": "`sun.*` 階層にあるクラスが使用されていることを報告します。 このようなクラスは異なる JVM 間で移植不可能です。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfSunClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ポータビリティ",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparatorMethodParameterNotUsed",
                "shortDescription": {
                  "text": "疑わしい 'Comparator.compare()' の実装"
                },
                "fullDescription": {
                  "text": "'Comparator.compare()' および 'Comparable.compareTo()' 実装にある問題を報告します。 次のケースが報告されます。 パラメーターが使用されていない。 これはタイポであり、他のパラメーターがそれ自体と比較されているか、メソッドが正しく実装されていない可能性が高いです。 メソッドが同じ要素に対して '0' を返さないことが明らかである。 このような比較メソッドは契約に違反しており、等しい要素に遭遇すると予測できない結果を引き起こす可能性があります。 特に、データによっては並べ替えが例外を伴って失敗する場合があります。 比較メソッドが正または負の値を返すことはない。 契約を満たすためには、比較メソッドが正の値を返す場合、 引数が逆順に提供される場合に負の値を返す必要もあります。 比較メソッドが 'Integer.MIN_VALUE' を返している。 契約で許されていますが、一部の呼び出しサイトは比較メソッドの戻り値を単項マイナス演算子を使用して誤って反転しようとする場合があるため、エラーが発生しやすい場合があります。 'Integer.MIN_VALUE' の否定された値は 'Integer.MIN_VALUE' です。 例: 'Comparator<String> lambda =\n    (a, b) -> a.length() > b.length()\n              ? 0\n              : Math.random() > 0.5 ? -1 : 1;'",
                  "markdown": "`Comparator.compare()` および `Comparable.compareTo()` 実装にある問題を報告します。\n\n次のケースが報告されます。\n\n* パラメーターが使用されていない。 これはタイポであり、他のパラメーターがそれ自体と比較されているか、メソッドが正しく実装されていない可能性が高いです。\n* メソッドが同じ要素に対して `0` を返さないことが明らかである。 このような比較メソッドは契約に違反しており、等しい要素に遭遇すると予測できない結果を引き起こす可能性があります。 特に、データによっては並べ替えが例外を伴って失敗する場合があります。\n* 比較メソッドが正または負の値を返すことはない。 契約を満たすためには、比較メソッドが正の値を返す場合、 引数が逆順に提供される場合に負の値を返す必要もあります。\n* 比較メソッドが `Integer.MIN_VALUE` を返している。 契約で許されていますが、一部の呼び出しサイトは比較メソッドの戻り値を単項マイナス演算子を使用して誤って反転しようとする場合があるため、エラーが発生しやすい場合があります。 `Integer.MIN_VALUE` の否定された値は `Integer.MIN_VALUE` です。\n\n**例:**\n\n\n      Comparator<String> lambda =\n        (a, b) -> a.length() > b.length()\n                  ? 0\n                  : Math.random() > 0.5 ? -1 : 1;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparatorMethodParameterNotUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantCast",
                "shortDescription": {
                  "text": "冗長な型キャスト"
                },
                "fullDescription": {
                  "text": "不要なキャスト式を報告します。 例: 'static Object toObject(String s) {\n    return (Object) s;\n  }' 次のような 'Object' が必要なコレクション呼び出しにあるキャストのように、明確化を目的としているキャストを無視するには以下のチェックボックスを使用します。 'static void removeFromList(List<String> l, Object o) {\n    l.remove((String)o);\n  }'",
                  "markdown": "不要なキャスト式を報告します。\n\n例:\n\n\n      static Object toObject(String s) {\n        return (Object) s;\n      }\n\n\n次のような `Object` が必要なコレクション呼び出しにあるキャストのように、明確化を目的としているキャストを無視するには以下のチェックボックスを使用します。\n\n\n      static void removeFromList(List<String> l, Object o) {\n        l.remove((String)o);\n      } \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantCast",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousInnerClass",
                "shortDescription": {
                  "text": "匿名クラスは内部クラスに置換できます"
                },
                "fullDescription": {
                  "text": "匿名クラスを報告します。 匿名クラスを内部クラスに置換すると、コードの可読性とメンテナンス性が向上する場合があります。 一部のコード標準は匿名クラスを推奨していません。 例: 'class Example {\n    public static void main(String[] args) {\n      new Thread() {\n        public void run() {\n          work()\n        }\n\n        private void work() {}\n      }.start();\n    }\n  }' クイックフィックス適用後: 'class Example {\n    public static void main(String[] args) {\n      new MyThread().start();\n    }\n\n    private static class MyThread extends Thread {\n      public void run() {\n        work();\n      }\n\n      private void work() {}\n    }\n  }'",
                  "markdown": "匿名クラスを報告します。\n\n匿名クラスを内部クラスに置換すると、コードの可読性とメンテナンス性が向上する場合があります。\n一部のコード標準は匿名クラスを推奨していません。\n\n**例:**\n\n\n      class Example {\n        public static void main(String[] args) {\n          new Thread() {\n            public void run() {\n              work()\n            }\n\n            private void work() {}\n          }.start();\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Example {\n        public static void main(String[] args) {\n          new MyThread().start();\n        }\n\n        private static class MyThread extends Thread {\n          public void run() {\n            work();\n          }\n\n          private void work() {}\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AnonymousInnerClass",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyCollector",
                "shortDescription": {
                  "text": "単純化できるコレクター"
                },
                "fullDescription": {
                  "text": "単純化できるコレクターを報告します。 特に、カスケードされた 'groupingBy()' コレクターはより単純な 'toMap()' コレクターを使用して表現できる可能性があります。その場合、パフォーマンスも向上する可能性があります。 例: 'Collectors.groupingByConcurrent(String::length, Collectors.collectingAndThen(Collectors.maxBy(String::compareTo), Optional::get));' クイックフィックス適用後: 'Collectors.toConcurrentMap(String::length, Function.identity(), BinaryOperator.maxBy(String::compareTo));' 2017.1 の新機能です このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "単純化できるコレクターを報告します。\n\n特に、カスケードされた `groupingBy()` コレクターはより単純な `toMap()` コレクターを使用して表現できる可能性があります。その場合、パフォーマンスも向上する可能性があります。\n\n例:\n\n\n      Collectors.groupingByConcurrent(String::length, Collectors.collectingAndThen(Collectors.maxBy(String::compareTo), Optional::get));\n\nクイックフィックス適用後:\n\n\n      Collectors.toConcurrentMap(String::length, Function.identity(), BinaryOperator.maxBy(String::compareTo));\n\n2017.1 の新機能です\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifyCollector",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Annotation",
                "shortDescription": {
                  "text": "アノテーション"
                },
                "fullDescription": {
                  "text": "アノテーションを報告します。 アノテーションは Java 1.4 以前の JVM ではサポートされていません。",
                  "markdown": "アノテーションを報告します。 アノテーションは Java 1.4 以前の JVM ではサポートされていません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Annotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java の言語レベル関連の問題",
                      "index": 61,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultipleTopLevelClassesInFile",
                "shortDescription": {
                  "text": "1 つのファイル内の複数のトップレベルクラス"
                },
                "fullDescription": {
                  "text": "1 つの Java ファイルに含まれている複数のトップレベルクラスを報告します。 複数のトップレベルクラスを 1 つのファイルに含めると誤解を招き、さまざまなソフトウェアツールの効果が低下する可能性がります。",
                  "markdown": "1 つの Java ファイルに含まれている複数のトップレベルクラスを報告します。\n\n複数のトップレベルクラスを 1 つのファイルに含めると誤解を招き、さまざまなソフトウェアツールの効果が低下する可能性がります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MultipleTopLevelClassesInFile",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryUnicodeEscape",
                "shortDescription": {
                  "text": "不必要な Unicode エスケープシーケンス"
                },
                "fullDescription": {
                  "text": "不要な Unicode エスケープシーケンスを報告します。 たとえば、ファイルエンコーディングによって文字をエスケープせずに処理できる場合が挙げられます。 Unicode 制御文字は、このインスペクションでは報告されません (改行とタブは例外)。 例: 'String s = \"\\u0062\";'",
                  "markdown": "不要な Unicode エスケープシーケンスを報告します。 たとえば、ファイルエンコーディングによって文字をエスケープせずに処理できる場合が挙げられます。 Unicode 制御文字は、このインスペクションでは報告されません (改行とタブは例外)。\n\n**例:**\n\n    String s = \"\\u0062\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryUnicodeEscape",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringTokenizer",
                "shortDescription": {
                  "text": "'StringTokenizer' の使用"
                },
                "fullDescription": {
                  "text": "'StringTokenizer' クラスの使用箇所を報告します。 国際化環境で 'StringTokenizer' を過度に使用するのは不適切です。",
                  "markdown": "`StringTokenizer` クラスの使用箇所を報告します。 国際化環境で `StringTokenizer` を過度に使用するのは不適切です。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfStringTokenizer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PrimitiveArrayArgumentToVariableArgMethod",
                "shortDescription": {
                  "text": "紛らわしい可変引数メソッドのプリミティブ配列引数"
                },
                "fullDescription": {
                  "text": "可変長引数メソッドの呼び出しで、可変長引数パラメーターの位置にプリミティブの配列があるものを報告します ('System.out.printf(\"%s\", new int[]{1, 2, 3})' など)。 このようなプリミティブの配列の引数は混乱を招く可能性があります。個々の要素が期待どおりにボクシングされておらず、1 つの要素の配列としてラップされているためです。 例: 'String.format(\"%s\", new int[]{1, 2, 3});' クイックフィックス適用後: 'String.format(\"%s\", (Object) new int[]{1, 2, 3});' このインスペクションは Java 5 以降で使用できる Java の機能 '可変引数メソッド' に依存しています。",
                  "markdown": "可変長引数メソッドの呼び出しで、可変長引数パラメーターの位置にプリミティブの配列があるものを報告します (`System.out.printf(\"%s\", new int[]{1, 2, 3})` など)。 このようなプリミティブの配列の引数は混乱を招く可能性があります。個々の要素が期待どおりにボクシングされておらず、1 つの要素の配列としてラップされているためです。\n\n**例:**\n\n\n      String.format(\"%s\", new int[]{1, 2, 3});\n\nクイックフィックス適用後:\n\n\n      String.format(\"%s\", (Object) new int[]{1, 2, 3});\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 '可変引数メソッド' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PrimitiveArrayArgumentToVarargsMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IteratorNextDoesNotThrowNoSuchElementException",
                "shortDescription": {
                  "text": "'NoSuchElementException' をスローできない Iterator.next()"
                },
                "fullDescription": {
                  "text": "'java.util.NoSuchElementException' をスローできない 'Iterator.next()' の実装を報告します。 このような実装は 'java.util.Iterator' の契約に違反しており、イテレーターが非標準的な方法で使用されている場合にバグの検出が困難になります。 例: 'class Numbers implements Iterator<Integer> {\n    @Override\n    public Integer next() { //警告\n        if (hasNext()) {\n            return generateNext();\n        } else {\n            return null; //代わりに NoSuchElementException をスローします\n        }\n    }\n\n    ...\n  }'",
                  "markdown": "`java.util.NoSuchElementException` をスローできない `Iterator.next()` の実装を報告します。\n\n\nこのような実装は `java.util.Iterator` の契約に違反しており、イテレーターが非標準的な方法で使用されている場合にバグの検出が困難になります。\n\n**例:**\n\n\n      class Numbers implements Iterator<Integer> {\n        @Override\n        public Integer next() { //警告\n            if (hasNext()) {\n                return generateNext();\n            } else {\n                return null; //代わりに NoSuchElementException をスローします\n            }\n        }\n\n        ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IteratorNextCanNotThrowNoSuchElementException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncorrectMessageFormat",
                "shortDescription": {
                  "text": "正しくない 'MessageFormat' パターン"
                },
                "fullDescription": {
                  "text": "不正なメッセージフォーマットパターン、またはプレースホルダーの不正なインデックスを報告します 次のエラーが報告されます。 インデックスが未解析または負になっている 波括弧が閉じられていない 引用符が対になっていない。 この場合、パターンの一部が使用されない可能性があります 引用符の数が不正だと思われる ネストした choice パターンの下限が不正である プレースホルダーのインデックスが不正である。 この場合、プレースホルダーが置換されないか、引数が使用されない可能性があります 例: 'MessageFormat.format(\"{wrong}\", 1); // インデックスが不正\n  MessageFormat.format(\"{0\", 1); // 波括弧が閉じられていない\n  MessageFormat.format(\"'{0}\", 1); // 引用符が対になっていない\n  MessageFormat.format(\"It''''s {0}\", 1); // \"It's\" の代わりに \"It''s\" が出力される\n  MessageFormat.format(\"{0}\", 1, 2); // インデックスが '1' の引数はパターンで使用されない' Custom MessageFormat メソッドテーブルを使用して、MessageFormat パターンとして引数をチェックする必要があるメソッド呼び出しを指定します。 テーブルには、包含クラスとメソッド呼び出しの名前を一致させるために、完全修飾されたクラス名とメソッド名正規表現のペアが含まれています。 クラス名はサブクラスとも一致します。 2023.2 の新機能です",
                  "markdown": "不正なメッセージフォーマットパターン、またはプレースホルダーの不正なインデックスを報告します\n\n次のエラーが報告されます。\n\n* インデックスが未解析または負になっている\n* 波括弧が閉じられていない\n* 引用符が対になっていない。 この場合、パターンの一部が使用されない可能性があります\n* 引用符の数が不正だと思われる\n* ネストした choice パターンの下限が不正である\n* プレースホルダーのインデックスが不正である。 この場合、プレースホルダーが置換されないか、引数が使用されない可能性があります\n\n例:\n\n\n      MessageFormat.format(\"{wrong}\", 1); // インデックスが不正\n      MessageFormat.format(\"{0\", 1); // 波括弧が閉じられていない\n      MessageFormat.format(\"'{0}\", 1); // 引用符が対になっていない\n      MessageFormat.format(\"It''''s {0}\", 1); // \"It's\" の代わりに \"It''s\" が出力される\n      MessageFormat.format(\"{0}\", 1, 2); // インデックスが '1' の引数はパターンで使用されない\n\n\n**Custom MessageFormat メソッド**テーブルを使用して、MessageFormat パターンとして引数をチェックする必要があるメソッド呼び出しを指定します。\nテーブルには、包含クラスとメソッド呼び出しの名前を一致させるために、完全修飾されたクラス名とメソッド名正規表現のペアが含まれています。\nクラス名はサブクラスとも一致します。\n\n2023.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IncorrectMessageFormat",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousTernaryOperatorInVarargsCall",
                "shortDescription": {
                  "text": "可変引数メソッドの呼び出しにある疑わしい三項演算子"
                },
                "fullDescription": {
                  "text": "配列の分岐と配列でない分岐が混在した三項演算子を使用している可変長引数メソッドを報告します。 コンパイル時には両方の分岐が配列にラップされます。 その結果、配列の分岐は二次元配列になってしまうため、問題が発生する可能性があります。 このクイックフィックスは配列でない分岐を配列にラップし、コンパイラーがこのような変換を行わないようにします。 例: 'static void bar(boolean flag) {\n        Object[] a = {1, 2};\n        Object b = \"hello\";\n        foo(flag ? a : b);\n    }\n    static void foo(Object... obj) {\n    }' クイックフィックス適用後: 'static void bar(boolean flag) {\n        Object[] a = {1, 2};\n        Object b = \"hello\";\n        foo(flag ? a : new Object[]{b});\n    }\n    static void foo(Object... obj) {\n    }' 2020.3 の新機能です このインスペクションは Java 5 以降で使用できる Java の機能 '可変引数メソッド' に依存しています。",
                  "markdown": "配列の分岐と配列でない分岐が混在した三項演算子を使用している可変長引数メソッドを報告します。\n\n\nコンパイル時には両方の分岐が配列にラップされます。 その結果、配列の分岐は二次元配列になってしまうため、問題が発生する可能性があります。\n\n\nこのクイックフィックスは配列でない分岐を配列にラップし、コンパイラーがこのような変換を行わないようにします。\n\n**例:**\n\n\n        static void bar(boolean flag) {\n            Object[] a = {1, 2};\n            Object b = \"hello\";\n            foo(flag ? a : b);\n        }\n        static void foo(Object... obj) {\n        }\n\nクイックフィックス適用後:\n\n\n        static void bar(boolean flag) {\n            Object[] a = {1, 2};\n            Object b = \"hello\";\n            foo(flag ? a : new Object[]{b});\n        }\n        static void foo(Object... obj) {\n        }\n\n2020.3 の新機能です\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 '可変引数メソッド' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousTernaryOperatorInVarargsCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseBulkOperation",
                "shortDescription": {
                  "text": "一括処理に置換可能なイテレーション処理"
                },
                "fullDescription": {
                  "text": "ループ内にある単一演算のうち、一括メソッドに置換できるものを報告します。 一括メソッドを使用するとコードがより簡潔になるだけでなく、パフォーマンスが向上する場合もあります。 例: 'void test(Collection<Integer> numbers) {\n    List<Integer> result = new ArrayList<>();\n    for (Integer i : numbers) {\n      result.add(i);\n    }\n  }' クイックフィックス適用後: 'void test(Collection<Integer> numbers) {\n    List<Integer> result = new ArrayList<>();\n    result.addAll(numbers);\n  }' 一括メソッドにコレクションが必要な場合でも配列を報告させるには、「Arrays.asList() を使用して配列をラップする」オプションを使用します。 この場合、クイックフィックスは 'Arrays.asList()' の呼び出しで配列を自動的にラップします。 2017.1 の新機能です",
                  "markdown": "ループ内にある単一演算のうち、一括メソッドに置換できるものを報告します。\n\n\n一括メソッドを使用するとコードがより簡潔になるだけでなく、パフォーマンスが向上する場合もあります。\n\n**例:**\n\n      void test(Collection<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        for (Integer i : numbers) {\n          result.add(i);\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      void test(Collection<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        result.addAll(numbers);\n      }\n\n\n一括メソッドにコレクションが必要な場合でも配列を報告させるには、「**Arrays.asList() を使用して配列をラップする** 」オプションを使用します。\nこの場合、クイックフィックスは `Arrays.asList()` の呼び出しで配列を自動的にラップします。\n\n2017.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseBulkOperation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BigDecimalEquals",
                "shortDescription": {
                  "text": "'BigDecimal' での 'equals()' 呼び出し"
                },
                "fullDescription": {
                  "text": "2 つの 'java.math.BigDecimal' 数値を比較している '.equals()' の呼び出しを報告します。 2 つの 'java.math.BigDecimal' 数値が等しくなるのは値とスケールの両方が一致している場合だけであるため、これは一般的に誤りとされています。 例: 'if (new BigDecimal(\"2.0\").equals(\n    new BigDecimal(\"2.00\"))) {} // false' クイックフィックス適用後: 'if (new BigDecimal(\"2.0\").compareTo(\n    new BigDecimal(\"2.00\")) == 0) {} // true'",
                  "markdown": "2 つの `java.math.BigDecimal` 数値を比較している `.equals()` の呼び出しを報告します。 2 つの `java.math.BigDecimal` 数値が等しくなるのは値とスケールの両方が一致している場合だけであるため、これは一般的に誤りとされています。\n\n**例:**\n\n\n      if (new BigDecimal(\"2.0\").equals(\n        new BigDecimal(\"2.00\"))) {} // false\n\nクイックフィックス適用後:\n\n\n      if (new BigDecimal(\"2.0\").compareTo(\n        new BigDecimal(\"2.00\")) == 0) {} // true\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BigDecimalEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AccessToNonThreadSafeStaticFieldFromInstance",
                "shortDescription": {
                  "text": "スレッドセーフではない 'static' フィールドアクセス"
                },
                "fullDescription": {
                  "text": "スレッドセーフではない型の 'static' フィールドへのアクセスを報告します。 'static' フィールドがインスタンスメソッドまたは非同期のブロックからアクセスされる場合、複数のスレッドがそのフィールドにアクセスできます。 これにより、例外や不正確な結果といった原因不明の副作用が発生する可能性があります。 例: 'class Sample {\n    private static final SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n    String method() {\n      return df.format(\"\");\n    }\n  }' スレッドセーフではないと見なす型を指定できます。 指定した型、または指定した型で初期化されているフィールドのみが報告されます。指定した型のスレッドセーフなサブクラスが存在する可能性があるためです。",
                  "markdown": "スレッドセーフではない型の `static` フィールドへのアクセスを報告します。\n\n\n`static` フィールドがインスタンスメソッドまたは非同期のブロックからアクセスされる場合、複数のスレッドがそのフィールドにアクセスできます。\nこれにより、例外や不正確な結果といった原因不明の副作用が発生する可能性があります。\n\n**例:**\n\n\n      class Sample {\n        private static final SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n        String method() {\n          return df.format(\"\");\n        }\n      }\n\n\nスレッドセーフではないと見なす型を指定できます。\n指定した型、または指定した型で初期化されているフィールドのみが報告されます。指定した型のスレッドセーフなサブクラスが存在する可能性があるためです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessToNonThreadSafeStaticField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToCatchBlockParameter",
                "shortDescription": {
                  "text": "'catch' ブロックパラメーターへの代入"
                },
                "fullDescription": {
                  "text": "'catch' ブロックパラメーターへの代入を報告します。 'catch' ブロックパラメーターの変更は大きな混乱を招きやすいため、推奨されません。 このクイックフィックスは新しい変数の宣言を追加します。 例: 'void processFile(String fileName) throws Exception {\n    try {\n      doProcessFile(fileName);\n    } catch(Exception ex) {\n      if (ex instanceof UncheckedIOException) {\n        // 警告: catch ブロックパラメーターが再代入されました\n        ex = ((UncheckedIOException) ex).getCause();\n      }\n      throw ex;\n    }\n  }' クイックフィックス適用後: 'void processFile(String fileName) throws Exception {\n    try {\n      doProcessFile(fileName);\n    } catch(Exception ex) {\n      Exception unwrapped = ex;\n      if (unwrapped instanceof UncheckedIOException) {\n        unwrapped = ((UncheckedIOException)\n          unwrapped).getCause();\n      }\n      throw unwrapped;\n    }\n  }'",
                  "markdown": "`catch` ブロックパラメーターへの代入を報告します。\n\n`catch` ブロックパラメーターの変更は大きな混乱を招きやすいため、推奨されません。\n\nこのクイックフィックスは新しい変数の宣言を追加します。\n\n**例:**\n\n\n      void processFile(String fileName) throws Exception {\n        try {\n          doProcessFile(fileName);\n        } catch(Exception ex) {\n          if (ex instanceof UncheckedIOException) {\n            // 警告: catch ブロックパラメーターが再代入されました\n            ex = ((UncheckedIOException) ex).getCause();\n          }\n          throw ex;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      void processFile(String fileName) throws Exception {\n        try {\n          doProcessFile(fileName);\n        } catch(Exception ex) {\n          Exception unwrapped = ex;\n          if (unwrapped instanceof UncheckedIOException) {\n            unwrapped = ((UncheckedIOException)\n              unwrapped).getCause();\n          }\n          throw unwrapped;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToCatchBlockParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代入関連の問題",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractMethodOverridesAbstractMethod",
                "shortDescription": {
                  "text": "抽象メソッドをオーバーライドする抽象メソッド"
                },
                "fullDescription": {
                  "text": "'abstract' メソッドをオーバーライドしている 'abstract' メソッドを報告します。 具象子クラスはいかなる場合も抽象メソッドを実装する必要があるため、このようなメソッドは意味がありません。 戻り値の型、例外宣言、アノテーション、または修飾子がオーバーライドされたメソッドと異なるメソッドは、このインスペクションでは報告されません。 インスペクションの構成: JavaDoc コメントがスーパーメソッドと異なる抽象メソッドを無視するには、「Javadoc がスーパーメソッドとは異なるメソッドを無視する」オプションを使用します。",
                  "markdown": "`abstract` メソッドをオーバーライドしている `abstract` メソッドを報告します。\n\n具象子クラスはいかなる場合も抽象メソッドを実装する必要があるため、このようなメソッドは意味がありません。\n\n\n戻り値の型、例外宣言、アノテーション、または修飾子がオーバーライドされたメソッドと異なるメソッドは、このインスペクションでは報告されません。\n\n\nインスペクションの構成:\n\n* JavaDoc コメントがスーパーメソッドと異なる抽象メソッドを無視するには、「**Javadoc がスーパーメソッドとは異なるメソッドを無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractMethodOverridesAbstractMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableInnerClassHasSerialVersionUIDField",
                "shortDescription": {
                  "text": "'serialVersionUID' 指定のない Serializable な非 static 内部クラス"
                },
                "fullDescription": {
                  "text": "'java.io.Serializable' を実装しているものの、'serialVersionUID' フィールドを定義していない非 static の内部クラスを報告します。 'serialVersionUID' フィールドがない状態でクラスを変更すると、以前にシリアル化されたバージョンが読み取れなくなります。 'Serializable' の非 static 内部クラスには 'serialVersionUID' フィールドを含めることを強くお勧めします。そうしない場合、デフォルトのシリアル化アルゴリズムにより、合成アクセサーメソッドが異なるコンパイラー間でシリアル化されたバージョンの互換性が失われる可能性があります。 欠落している 'serialVersionUID' フィールドを追加するクイックフィックスが提案されます。 例: 'class Outer {\n      class Inner implements Serializable {}\n  }' クイックフィックス適用後: 'class Outer {\n      class Inner implements Serializable {\n          private static final long serialVersionUID = -7004458730436243902L;\n      }\n  }' このインスペクションは、次のオプションを使用して構成できます。 このインスペクションで継承先を報告対象外とするクラスをリストする。 これは、スーパークラスの 'Serializable' を継承しているものの、シリアル化を目的としていないクラスを対象としています。 'Serializable' 匿名クラスを無視するかどうか。",
                  "markdown": "`java.io.Serializable` を実装しているものの、`serialVersionUID` フィールドを定義していない非 static の内部クラスを報告します。\n\n\n`serialVersionUID` フィールドがない状態でクラスを変更すると、以前にシリアル化されたバージョンが読み取れなくなります。 `Serializable` の非 static 内部クラスには `serialVersionUID` フィールドを含めることを強くお勧めします。そうしない場合、デフォルトのシリアル化アルゴリズムにより、合成アクセサーメソッドが異なるコンパイラー間でシリアル化されたバージョンの互換性が失われる可能性があります。\n\n\n欠落している `serialVersionUID` フィールドを追加するクイックフィックスが提案されます。\n\n**例:**\n\n\n      class Outer {\n          class Inner implements Serializable {}\n      }\n\nクイックフィックス適用後:\n\n\n      class Outer {\n          class Inner implements Serializable {\n              private static final long serialVersionUID = -7004458730436243902L;\n          }\n      }\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* このインスペクションで継承先を報告対象外とするクラスをリストする。 これは、スーパークラスの `Serializable` を継承しているものの、シリアル化を目的としていないクラスを対象としています。\n* `Serializable` 匿名クラスを無視するかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableNonStaticInnerClassWithoutSerialVersionUID",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoopStatementsThatDontLoop",
                "shortDescription": {
                  "text": "ループしないループステートメント"
                },
                "fullDescription": {
                  "text": "本体が 1 回までしか実行されない 'for' / 'while' / 'do' ステートメントのインスタンスを報告します。 大抵の場合、これはバグの可能性があります。 foreach ループを無視するには、「ループの拡張を無視する」オプションを使用します。 このようなステートメントは、繰り返しの最初の項目のみに手短にアクションを実行する目的で使用される場合があります。 例: 'for (String s : stringIterable) {\n    doSomethingOnFirstString(s);\n    break;\n  }'",
                  "markdown": "本体が 1 回までしか実行されない `for` / `while` / `do` ステートメントのインスタンスを報告します。 大抵の場合、これはバグの可能性があります。\n\n\nforeach ループを無視するには、「**ループの拡張を無視する**」オプションを使用します。\nこのようなステートメントは、繰り返しの最初の項目のみに手短にアクションを実行する目的で使用される場合があります。\n\n例:\n\n\n      for (String s : stringIterable) {\n        doSomethingOnFirstString(s);\n        break;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoopStatementThatDoesntLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayCreationWithoutNewKeyword",
                "shortDescription": {
                  "text": "'new' 式を持たない配列の作成"
                },
                "fullDescription": {
                  "text": "'new' 配列式を持たない配列イニシャライザーの報告と、追加の提案を行います。 例: 'int[] a = {42}' クイックフィックス適用後: 'int[] a = new int[]{42}'",
                  "markdown": "`new` 配列式を持たない配列イニシャライザーの報告と、追加の提案を行います。\n\n例:\n\n\n      int[] a = {42}\n\nクイックフィックス適用後:\n\n\n      int[] a = new int[]{42}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ArrayCreationWithoutNewKeyword",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfusingOctalEscape",
                "shortDescription": {
                  "text": "混乱する 8 進エスケープシーケンス"
                },
                "fullDescription": {
                  "text": "8 進数のエスケープシーケンスの直後に数字が続いている文字列リテラルを報告します。 このようなステートメントは混乱を招く可能性があり、多くの場合はエスケープコードの作成に間違いがあることが原因です。 例: 'System.out.println(\"\\1234\"); // 8 進数のエスケープシーケンス '\\123' の直後に数字が続いています'",
                  "markdown": "8 進数のエスケープシーケンスの直後に数字が続いている文字列リテラルを報告します。\n\nこのようなステートメントは混乱を招く可能性があり、多くの場合はエスケープコードの作成に間違いがあることが原因です。\n\n**例:**\n\n\n      System.out.println(\"\\1234\"); // 8 進数のエスケープシーケンス '\\123' の直後に数字が続いています\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfusingOctalEscapeSequence",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterNameDiffersFromOverriddenParameter",
                "shortDescription": {
                  "text": "オーバーライドまたはオーバーロードされたメソッドと異なるパラメーター名"
                },
                "fullDescription": {
                  "text": "パラメーターのうち、それがオーバーライドまたはオーバーロードしているメソッドの対応するパラメーターと名前が異なっているものを報告します。 このような矛盾した名前は Java では有効ですが、混乱を招く可能性があり、適切な命名規則に従ってドキュメント化を行うメリットが損なわれてしまいます。 例: 'class Person {\n    Person(String fullName) {}\n  }\n  class Child extends Person {\n    Child(String name) { super(name); }\n  }' クイックフィックス適用後: 'class Person {\n    Person(String fullName) {}\n  }\n  class Child extends Person {\n    Child(String fullName) { super(fullName); }\n  }' 長さが 1 文字しかない、またはライブラリメソッド由来のオーバーライドされたパラメーターを無視するかどうかを指定するには、オプションを使用します。 どちらのオプションも、ライブラリで使用されている疑わしい命名規則に縛られたくない場合には便利です。",
                  "markdown": "パラメーターのうち、それがオーバーライドまたはオーバーロードしているメソッドの対応するパラメーターと名前が異なっているものを報告します。 このような矛盾した名前は Java では有効ですが、混乱を招く可能性があり、適切な命名規則に従ってドキュメント化を行うメリットが損なわれてしまいます。\n\n**例:**\n\n\n      class Person {\n        Person(String fullName) {}\n      }\n      class Child extends Person {\n        Child(String name) { super(name); }\n      }\n\nクイックフィックス適用後:\n\n\n      class Person {\n        Person(String fullName) {}\n      }\n      class Child extends Person {\n        Child(String fullName) { super(fullName); }\n      }\n\n\n長さが 1 文字しかない、またはライブラリメソッド由来のオーバーライドされたパラメーターを無視するかどうかを指定するには、オプションを使用します。 どちらのオプションも、ライブラリで使用されている疑わしい命名規則に縛られたくない場合には便利です。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterNameDiffersFromOverriddenParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規約",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OctalLiteral",
                "shortDescription": {
                  "text": "8 進整数"
                },
                "fullDescription": {
                  "text": "8 進数の整数リテラルを報告します。 コーディング標準には、10 進リテラルと混乱しやすいため、8 進リテラルの使用を禁止しているものもあります。 例: 'int i = 015;\n  int j = 0_777;' このインスペクションには 2 種類のクイックフィックスがあります。 「8 進リテラルを 10 進リテラルに変換」クイックフィックスが適用されると、コードは次のように変更されます。 'int i = 13;\n  int j = 511;' 「先頭のゼロを除去して小数点以下を切り捨てる」クイックフィックスが適用されると、コードは次のように変更されます。 'int i = 15;\n  int j = 777;'",
                  "markdown": "8 進数の整数リテラルを報告します。 コーディング標準には、10 進リテラルと混乱しやすいため、8 進リテラルの使用を禁止しているものもあります。\n\n例:\n\n\n      int i = 015;\n      int j = 0_777;\n\nこのインスペクションには 2 種類のクイックフィックスがあります。\n「**8 進リテラルを 10 進リテラルに変換**」クイックフィックスが適用されると、コードは次のように変更されます。\n\n\n      int i = 13;\n      int j = 511;\n\n「**先頭のゼロを除去して小数点以下を切り捨てる**」クイックフィックスが適用されると、コードは次のように変更されます。\n\n\n      int i = 15;\n      int j = 777;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OctalInteger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaParameterHidingMemberVariable",
                "shortDescription": {
                  "text": "フィールドを非表示にするラムダパラメーター"
                },
                "fullDescription": {
                  "text": "外部クラスのフィールドと名前がまったく同じラムダパラメーターを報告します。 このような命名を行うと、まったく同じ名前のフィールドを使用することが意図されている場合にラムダパラメーターを誤って使用する可能性があります。 ラムダパラメーターの名前を変更するクイックフィックスが提案されます。 例: 'public class MyClass {\n    public Object foo;\n\n    void sort(List<Integer> list) {\n      list.sort((foo, bar) -> foo - bar);\n    }\n  }' ラムダ式から見えないフィールドを無視するかどうかを選択するには、オプションを使用します。 たとえば、スーパークラスの private フィールドが挙げられます。 このインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。",
                  "markdown": "外部クラスのフィールドと名前がまったく同じラムダパラメーターを報告します。 このような命名を行うと、まったく同じ名前のフィールドを使用することが意図されている場合にラムダパラメーターを誤って使用する可能性があります。\n\nラムダパラメーターの名前を変更するクイックフィックスが提案されます。\n\n**例:**\n\n\n      public class MyClass {\n        public Object foo;\n\n        void sort(List<Integer> list) {\n          list.sort((foo, bar) -> foo - bar);\n        }\n      }\n\n\nラムダ式から見えないフィールドを無視するかどうかを選択するには、オプションを使用します。\nたとえば、スーパークラスの private フィールドが挙げられます。\n\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LambdaParameterHidesMemberVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReadWriteStringCanBeUsed",
                "shortDescription": {
                  "text": "'Files.readString()' または 'Files.writeString()' を使用可能"
                },
                "fullDescription": {
                  "text": "'java.nio.file.Files' を使用して 'String' をバイトとして読み取り、または書き込みを行っているメソッド呼び出しを報告します。 このような呼び出しは Java 11 で導入された 'Files.readString()' および 'Files.writeString()' メソッドの呼び出しに置換できます。 例: 'String s = \"example\";\n  Files.write(Paths.get(\"out.txt\"), s.getBytes(StandardCharsets.UTF_8), StandardOpenOption.WRITE);\n  s = new String(Files.readAllBytes(Paths.get(\"in.txt\")), StandardCharsets.ISO_8859_1);' クイックフィックス適用後: 'String s = \"example\";\n  Files.writeString(Paths.get(\"out.txt\"), s, StandardOpenOption.WRITE);\n  s = Files.readString(Paths.get(\"in.txt\"), StandardCharsets.ISO_8859_1);' 2018.3 の新機能です",
                  "markdown": "`java.nio.file.Files` を使用して `String` をバイトとして読み取り、または書き込みを行っているメソッド呼び出しを報告します。 このような呼び出しは Java 11 で導入された `Files.readString()` および `Files.writeString()` メソッドの呼び出しに置換できます。\n\n**例:**\n\n\n      String s = \"example\";\n      Files.write(Paths.get(\"out.txt\"), s.getBytes(StandardCharsets.UTF_8), StandardOpenOption.WRITE);\n      s = new String(Files.readAllBytes(Paths.get(\"in.txt\")), StandardCharsets.ISO_8859_1);\n\nクイックフィックス適用後:\n\n\n      String s = \"example\";\n      Files.writeString(Paths.get(\"out.txt\"), s, StandardOpenOption.WRITE);\n      s = Files.readString(Paths.get(\"in.txt\"), StandardCharsets.ISO_8859_1);\n\n2018.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReadWriteStringCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 11",
                      "index": 125,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantMathCall",
                "shortDescription": {
                  "text": "'Math' への定数呼び出し"
                },
                "fullDescription": {
                  "text": "単純なコンパイル時の定数に置換できる 'java.lang.Math' メソッドまたは 'java.lang.StrictMath' メソッドの呼び出しを報告します。 例: 'double v = Math.sin(0.0);' クイックフィックス適用後: 'double v = 0.0;'",
                  "markdown": "単純なコンパイル時の定数に置換できる `java.lang.Math` メソッドまたは `java.lang.StrictMath` メソッドの呼び出しを報告します。\n\n**例:**\n\n    double v = Math.sin(0.0);\n\nクイックフィックス適用後:\n\n    double v = 0.0;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantMathCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissortedModifiers",
                "shortDescription": {
                  "text": "未ソートの修飾子"
                },
                "fullDescription": {
                  "text": "(Java 言語の仕様で記載されている) 標準的な優先順序で列挙されていない宣言修飾子を報告します。 例: 'class Foo {\n    native public final void foo();\n  }' クイックフィックス適用後: 'class Foo {\n    public final native void foo();\n  }'",
                  "markdown": "(Java 言語の仕様で記載されている) 標準的な優先順序で列挙されていない宣言修飾子を報告します。\n\n**例:**\n\n\n      class Foo {\n        native public final void foo();\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        public final native void foo();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MissortedModifiers",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TransientFieldInNonSerializableClass",
                "shortDescription": {
                  "text": "非 Serializable クラスの Transient フィールド"
                },
                "fullDescription": {
                  "text": "'java.io.Serializable' を実装していないクラスにある 'transient' フィールドを報告します。 例: 'public class NonSerializableClass {\n    private transient String password;\n  }' クイックフィックス適用後: 'public class NonSerializableClass {\n    private String password;\n  }'",
                  "markdown": "`java.io.Serializable` を実装していないクラスにある `transient` フィールドを報告します。\n\n**例:**\n\n\n      public class NonSerializableClass {\n        private transient String password;\n      }\n\nクイックフィックス適用後:\n\n\n      public class NonSerializableClass {\n        private String password;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TransientFieldInNonSerializableClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CyclomaticComplexity",
                "shortDescription": {
                  "text": "過度に複雑なメソッド"
                },
                "fullDescription": {
                  "text": "分岐点が多すぎるメソッドを報告します。 分岐点とは以下のいずれかを指します: ループステートメント 'if' ステートメント 三項式 'catch' セクション 1 つ以上の '&&' または '||' 演算子を含む式 デフォルト以外の以外の分岐を持つ 'switch' ブロック サイクロマティック複雑度が高すぎるメソッドは混乱を招き、テストを実行しにくい可能性があります。 メソッドで許容されるサイクロマティック複雑度の最大値を指定するには、「メソッド複雑度の制限」フィールドを使用します。",
                  "markdown": "分岐点が多すぎるメソッドを報告します。\n\n分岐点とは以下のいずれかを指します:\n\n* ループステートメント\n* `if` ステートメント\n* 三項式\n* `catch` セクション\n* 1 つ以上の `&&` または `||` 演算子を含む式\n* デフォルト以外の以外の分岐を持つ `switch` ブロック\n\nサイクロマティック複雑度が高すぎるメソッドは混乱を招き、テストを実行しにくい可能性があります。\n\nメソッドで許容されるサイクロマティック複雑度の最大値を指定するには、「**メソッド複雑度の制限**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メソッドメトリクス",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SlowListContainsAll",
                "shortDescription": {
                  "text": "'list.containsAll(collection)' の呼び出しはパフォーマンスの低下を招く場合があります\n"
                },
                "fullDescription": {
                  "text": "'java.util.List' に対する 'containsAll()' の呼び出しを報告します。 このメソッド呼び出しの時間計算量は O(n·m) です。n はメソッドが呼び出されるリストの要素数で、m はメソッドにパラメーターとして渡されるコレクションの要素数です。 リストが大きい場合、この処理は非常に負荷が高くなる可能性があります。 クイックフィックスを使用すると、リストが 'new java.util.HashSet<>()' で囲まれます。'java.util.List' から 'java.util.HashSet' を作成し、'java.util.HashSet' で 'containsAll()' を実行するために必要な時間が O(n+m) になるためです。 例: 'public boolean check(List<String> list, Collection<String> collection) {\n    // O(n·m) 複雑度\n    return list.containsAll(collection);\n  }' クイックフィックス適用後: 'public boolean check(List<String> list, Collection<String> collection) {\n    // O(n+m) 複雑度\n    return new HashSet<>(list).containsAll(collection);\n  }' 2022.1 の新機能です",
                  "markdown": "`java.util.List` に対する `containsAll()` の呼び出しを報告します。\n\n\nこのメソッド呼び出しの時間計算量は O(n·m) です。n はメソッドが呼び出されるリストの要素数で、m はメソッドにパラメーターとして渡されるコレクションの要素数です。\nリストが大きい場合、この処理は非常に負荷が高くなる可能性があります。\n\n\nクイックフィックスを使用すると、リストが `new java.util.HashSet<>()` で囲まれます。`java.util.List` から `java.util.HashSet` を作成し、`java.util.HashSet` で `containsAll()` を実行するために必要な時間が O(n+m) になるためです。\n\n**例:**\n\n      public boolean check(List<String> list, Collection<String> collection) {\n        // O(n·m) 複雑度\n        return list.containsAll(collection);\n      }\n\nクイックフィックス適用後:\n\n      public boolean check(List<String> list, Collection<String> collection) {\n        // O(n+m) 複雑度\n        return new HashSet<>(list).containsAll(collection);\n      }\n\n2022.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SlowListContainsAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AwaitNotInLoop",
                "shortDescription": {
                  "text": "ループ内で呼び出されていない 'await()'"
                },
                "fullDescription": {
                  "text": "'java.util.concurrent.locks.Condition.await()' がループ内で呼び出されていないことを報告します。 'await()' とその関連メソッドは通常、ある条件が true になるまでスレッドを一時停止するために使用されます。 このようなスレッドは別の理由で呼び起こされている可能性があるため、'await()' を呼び出した後は条件を確認する必要があります。 これを実現するには、ループを使用するのが簡単です。 例: 'void acquire(Condition released) throws InterruptedException {\n    released.await();\n  }' 次のようなコードが適切です: 'void acquire(Condition released) throws InterruptedException {\n    while (acquired) {\n      released.await();\n    }\n  }'",
                  "markdown": "`java.util.concurrent.locks.Condition.await()` がループ内で呼び出されていないことを報告します。\n\n\n`await()` とその関連メソッドは通常、ある条件が true になるまでスレッドを一時停止するために使用されます。\nこのようなスレッドは別の理由で呼び起こされている可能性があるため、`await()` を呼び出した後は条件を確認する必要があります。\nこれを実現するには、ループを使用するのが簡単です。\n\n**例:**\n\n\n      void acquire(Condition released) throws InterruptedException {\n        released.await();\n      }\n\n次のようなコードが適切です:\n\n\n      void acquire(Condition released) throws InterruptedException {\n        while (acquired) {\n          released.await();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AwaitNotInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticVariableUninitializedUse",
                "shortDescription": {
                  "text": "初期化の前に使用される static フィールド"
                },
                "fullDescription": {
                  "text": "初期化する前に読み込まれている 'static' 変数を報告します。 このインスペクションは 'null' による等価チェックを無視します。 例: 'class Foo {\n    public static int bar;\n\n    public static void main(String[] args) {\n      System.out.println(bar);\n    }\n  }' このインスペクションは非常に保守的なデータフローアルゴリズムを使用しており、'static' 変数を初期化されていないものとして誤って報告する場合があります。 初期化されているものとして報告される変数は、常に初期化されます。 初期化されていないプリミティブフィールドを無視するには、「プリミティブフィールドを無視」オプションを使用します。",
                  "markdown": "初期化する前に読み込まれている `static` 変数を報告します。\n\nこのインスペクションは `null` による等価チェックを無視します。\n\n**例:**\n\n\n      class Foo {\n        public static int bar;\n\n        public static void main(String[] args) {\n          System.out.println(bar);\n        }\n      }\n\nこのインスペクションは非常に保守的なデータフローアルゴリズムを使用しており、`static` 変数を初期化されていないものとして誤って報告する場合があります。 初期化されているものとして報告される変数は、常に初期化されます。\n\n初期化されていないプリミティブフィールドを無視するには、「**プリミティブフィールドを無視**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticVariableUsedBeforeInitialization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初期化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExceptionPackage",
                "shortDescription": {
                  "text": "例外パッケージ"
                },
                "fullDescription": {
                  "text": "'java.lang.Throwable' を直接的または間接的に拡張しているクラスのみを含むパッケージを報告します。 一般的に例外は実装に際して他のクラスに依存することはありませんが、普通は単独で使用されません。 多くの場合、例外はそれを使用するクラスと同じパッケージ内に配置するのが良い設計とされています。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "`java.lang.Throwable` を直接的または間接的に拡張しているクラスのみを含むパッケージを報告します。\n\n一般的に例外は実装に際して他のクラスに依存することはありませんが、普通は単独で使用されません。\n多くの場合、例外はそれを使用するクラスと同じパッケージ内に配置するのが良い設計とされています。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExceptionPackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パッケージ関連の問題",
                      "index": 37,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CyclicClassDependency",
                "shortDescription": {
                  "text": "循環クラス依存関係"
                },
                "fullDescription": {
                  "text": "他のクラスと相互に依存している、または循環依存関係を持っているクラスを報告します。 このような循環的依存関係は、コードの脆弱化とメンテナンス性の低下を招きます。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "他のクラスと相互に依存している、または循環依存関係を持っているクラスを報告します。\n\nこのような循環的依存関係は、コードの脆弱化とメンテナンス性の低下を招きます。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CyclicClassDependency",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依存関係の問題",
                      "index": 86,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringBufferReplaceableByStringBuilder",
                "shortDescription": {
                  "text": "'StringBuilder' にできる 'StringBuffer'"
                },
                "fullDescription": {
                  "text": "'StringBuffer' として宣言されている変数を報告し、'StringBuilder' に置換することを提案します。 'StringBuilder' は 'StringBuffer' を置き換えるものですが、スレッドセーフではありません。 このインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以上の場合にのみ報告します。",
                  "markdown": "`StringBuffer` として宣言されている変数を報告し、`StringBuilder` に置換することを提案します。 `StringBuilder` は `StringBuffer` を置き換えるものですが、スレッドセーフではありません。\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以上の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringBufferMayBeStringBuilder",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeParameterExtendsObject",
                "shortDescription": {
                  "text": "明示的に 'Object' を拡張する型パラメーター"
                },
                "fullDescription": {
                  "text": "型パラメーターとワイルドカード型の引数で、'java.lang.Object' を拡張すると明示的に宣言されているものを報告します。 'java.lang.Object' はすべてのクラスのスーパータイプであるため、このような 'extends' 節は冗長です。 例: 'class ClassA<T extends Object> {}' アノテーションのために 'extends Object' 節を保持する必要がある場合は、「java.lang.Object にアノテーションが付いている場合は無視するオ」プションを無効にします。 これは、nullness アナライザーを使用し、'extends Object' 節が '@Nullable'/'@NotNull' アノテーションを保持している場合などに役立つことがあります。 例: 'class MyClass<T extends @NotNull Object> {}'",
                  "markdown": "型パラメーターとワイルドカード型の引数で、`java.lang.Object` を拡張すると明示的に宣言されているものを報告します。\n\n`java.lang.Object` はすべてのクラスのスーパータイプであるため、このような 'extends' 節は冗長です。\n\n**例:**\n\n      class ClassA<T extends Object> {}\n\n\nアノテーションのために 'extends Object' 節を保持する必要がある場合は、「**java.lang.Object にアノテーションが付いている場合は無視する** オ」プションを無効にします。\nこれは、nullness アナライザーを使用し、'extends Object' 節が `@Nullable`/`@NotNull` アノテーションを保持している場合などに役立つことがあります。\n\n**例:**\n\n      class MyClass<T extends @NotNull Object> {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeParameterExplicitlyExtendsObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizedMethod",
                "shortDescription": {
                  "text": "'synchronized' メソッド"
                },
                "fullDescription": {
                  "text": "メソッドの 'synchronized' 修飾子を報告します。 メソッドの 'synchronized' 修飾子が良くない理由はいくつかあります。 ロック状態で実行する作業はできるだけ少なくする必要があります。 したがって、多くの場合は 'synchronized' ブロックを使用して、共有状態で機能するコードのみを保持することをお勧めします。 同期はメソッドのインターフェースに組み込まれます。 その結果、異なるロック機構への移行が難しくなります。 所定のオブジェクトをロックしているコードを追跡するのが難しくなります。 意図的か偶発的かを問わず、メソッドのクラスを継承する際に DoS (サービス拒否) 攻撃が可能になります。 代わりに、'private final' ロックオブジェクトでの同期を検討してください。この場合、ロックオブジェクトへのアクセスを完全に制御できます。 メソッド本体を 'synchronized' でラップするためのクイックフィックスが提供されています。 例: 'class Main {\n    public synchronized void fooBar() {\n    }\n  }' クイックフィックス適用後: 'class Main {\n    public void fooBar() {\n      synchronized (this) {\n      }\n    }\n  }' このインスペクションでは、以下のオプションを構成できます。 ネイティブメソッドを含める - ネイティブメソッドをインスペクションの範囲に含めます。 synchronized メソッドをオーバーライドするメソッドを無視する - 'synchronized' メソッドをオーバーライドするメソッドを報告しません。",
                  "markdown": "メソッドの `synchronized` 修飾子を報告します。\n\n\nメソッドの `synchronized` 修飾子が良くない理由はいくつかあります。\n\n1. ロック状態で実行する作業はできるだけ少なくする必要があります。 したがって、多くの場合は `synchronized` ブロックを使用して、共有状態で機能するコードのみを保持することをお勧めします。\n2. 同期はメソッドのインターフェースに組み込まれます。 その結果、異なるロック機構への移行が難しくなります。\n3. 所定のオブジェクトをロックしているコードを追跡するのが難しくなります。\n4. 意図的か偶発的かを問わず、メソッドのクラスを継承する際に DoS (サービス拒否) 攻撃が可能になります。\n\n\n代わりに、`private final` ロックオブジェクトでの同期を検討してください。この場合、ロックオブジェクトへのアクセスを完全に制御できます。\n\nメソッド本体を `synchronized` でラップするためのクイックフィックスが提供されています。\n\n**例:**\n\n\n      class Main {\n        public synchronized void fooBar() {\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Main {\n        public void fooBar() {\n          synchronized (this) {\n          }\n        }\n      }\n\nこのインスペクションでは、以下のオプションを構成できます。\n\n1. **ネイティブメソッドを含める** - ネイティブメソッドをインスペクションの範囲に含めます。\n2. **synchronized メソッドをオーバーライドするメソッドを無視する** - `synchronized` メソッドをオーバーライドするメソッドを報告しません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationInsideStringBufferAppend",
                "shortDescription": {
                  "text": "文字列連結を 'StringBuilder.append()' の呼び出し引数に使用"
                },
                "fullDescription": {
                  "text": "'StringBuffer.append()'、'StringBuilder.append()' または 'Appendable.append()' の引数として使用されている 'String' 連結を報告します。 このような呼び出しは、既存の 'StringBuffer/Builder/Appendable' に対する append の連鎖呼び出しに変換し、不必要な 'StringBuffer/Builder' の割り当てコストを削減するのが得策かもしれません。 このインスペクションはコンパイル時に評価される 'String' 連結を無視します。このような場合は、変換してもパフォーマンスが悪化するだけだからです。 例: 'void bar(StringBuilder builder, String name) {\n    builder.append(\"Hello,\" + name);    //警告\n    builder.append(\"Hello,\" + \"world\"); //警告なし\n  }'",
                  "markdown": "`StringBuffer.append()`、`StringBuilder.append()` または `Appendable.append()` の引数として使用されている `String` 連結を報告します。\n\n\nこのような呼び出しは、既存の `StringBuffer/Builder/Appendable` に対する append の連鎖呼び出しに変換し、不必要な `StringBuffer/Builder` の割り当てコストを削減するのが得策かもしれません。\nこのインスペクションはコンパイル時に評価される `String` 連結を無視します。このような場合は、変換してもパフォーマンスが悪化するだけだからです。\n\n**例:**\n\n\n      void bar(StringBuilder builder, String name) {\n        builder.append(\"Hello,\" + name);    //警告\n        builder.append(\"Hello,\" + \"world\"); //警告なし\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationInsideStringBufferAppend",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractMethodWithMissingImplementations",
                "shortDescription": {
                  "text": "実装が欠落した抽象メソッド"
                },
                "fullDescription": {
                  "text": "すべての具象サブクラスで実装されていない 'abstract' メソッドを報告します。 このようなメソッドがあると、サブクラスでコンパイル時エラーが発生します。このインスペクションは抽象メソッドの時点で問題を報告するため、問題をより迅速に検出することができます。",
                  "markdown": "すべての具象サブクラスで実装されていない `abstract` メソッドを報告します。\n\n\nこのようなメソッドがあると、サブクラスでコンパイル時エラーが発生します。このインスペクションは抽象メソッドの時点で問題を報告するため、問題をより迅速に検出することができます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractMethodWithMissingImplementations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FeatureEnvy",
                "shortDescription": {
                  "text": "Feature Envy"
                },
                "fullDescription": {
                  "text": "Feature Envy なコードの臭いを報告します。 あるメソッドが他のクラスのメソッドを 3 回以上呼び出している場合に警告がスローされます。 ライブラリクラス、親クラス、および包含されるクラスまたは包含するクラスへの呼び出しは、このインスペクションでは考慮されません。 Feature Envy は多くの場合、対象の機能が不適切なクラスにあることを示しています。 例: 'class JobManager {\n    // 警告: このメソッドは Job クラスの\n    // 3 つのメソッドを呼び出しています。\n    // この一連の呼び出しは Job クラス自体に\n    // 移動したほうが賢明です。\n    void performJob(Job job) {\n      job.beforeStart();\n      job.process();\n      job.afterProcessing();\n    }\n  }'",
                  "markdown": "*Feature Envy* なコードの臭いを報告します。 あるメソッドが他のクラスのメソッドを 3 回以上呼び出している場合に警告がスローされます。 ライブラリクラス、親クラス、および包含されるクラスまたは包含するクラスへの呼び出しは、このインスペクションでは考慮されません。 Feature Envy は多くの場合、対象の機能が不適切なクラスにあることを示しています。\n\n例:\n\n\n      class JobManager {\n        // 警告: このメソッドは Job クラスの\n        // 3 つのメソッドを呼び出しています。\n        // この一連の呼び出しは Job クラス自体に\n        // 移動したほうが賢明です。\n        void performJob(Job job) {\n          job.beforeStart();\n          job.process();\n          job.afterProcessing();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FeatureEnvy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BoxingBoxedValue",
                "shortDescription": {
                  "text": "すでにボックス化した値のボクシング"
                },
                "fullDescription": {
                  "text": "すでにボクシングされた値のボクシングを報告します。 ボクシングされた値は最初に自動的にアンボクシングされてから再度ボクシングされるため、このような処理は冗長です。 このような処理が内部ループ内で行われると、パフォーマンスの問題が発生する場合があります。 例: 'Integer value = 1;\n  method(Integer.valueOf(value));' クイックフィックス適用後: 'Integer value = 1;\n  method(value);'",
                  "markdown": "すでにボクシングされた値のボクシングを報告します。\n\n\nボクシングされた値は最初に自動的にアンボクシングされてから再度ボクシングされるため、このような処理は冗長です。 このような処理が内部ループ内で行われると、パフォーマンスの問題が発生する場合があります。\n\n**例:**\n\n\n      Integer value = 1;\n      method(Integer.valueOf(value));\n\nクイックフィックス適用後:\n\n\n      Integer value = 1;\n      method(value);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BoxingBoxedValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Convert2MethodRef",
                "shortDescription": {
                  "text": "メソッド参照に置換可能なラムダ"
                },
                "fullDescription": {
                  "text": "メソッド参照に置換できるラムダを報告します。 これは概して好みの問題ですが、メソッド参照はラムダよりも理解しやすく、読みやすいと言えます。 例: 'Runnable r = () -> System.out.println();' クイックフィックス適用後: 'Runnable r = System.out::println;' このインスペクションは、ラムダが全くメソッドを呼び出さない場合でも、メソッド参照を提案する場合があります ('obj -> obj != null' から 'Objects::nonNull' への置換など)。 特別なメソッド参照を設定する場合は、「設定 | エディター | コードスタイル | Java | コード生成」設定を使用します。 このインスペクションは以下の Java 機能に依存しています: メソッド参照 ラムダ式 これらの機能は Java 8 以降で使用できます。",
                  "markdown": "メソッド参照に置換できるラムダを報告します。 これは概して好みの問題ですが、メソッド参照はラムダよりも理解しやすく、読みやすいと言えます。\n\n例:\n\n\n      Runnable r = () -> System.out.println();\n\nクイックフィックス適用後:\n\n\n      Runnable r = System.out::println;\n\n\nこのインスペクションは、ラムダが全くメソッドを呼び出さない場合でも、メソッド参照を提案する場合があります (`obj -> obj != null` から `Objects::nonNull` への置換など)。\n特別なメソッド参照を設定する場合は、「[設定 \\| エディター \\| コードスタイル \\| Java \\| コード生成](settings://preferences.sourceCode.Java?Lambda%20Body)」設定を使用します。\n\nこのインスペクションは以下の Java 機能に依存しています:\n\n* メソッド参照\n* ラムダ式\n\nこれらの機能は Java 8 以降で使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Convert2MethodRef",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantCollectionOperation",
                "shortDescription": {
                  "text": "冗長な 'Collection' 操作"
                },
                "fullDescription": {
                  "text": "より単純に表現できる、不必要に複雑なコレクション操作を報告します。 例: 'void f(String[] array, Collection<String> collection) {\n    String[] strings = Arrays.asList(array).subList(0, 10).toArray(new String[0]);\n    boolean contains = collection.containsAll(Collections.singletonList(\"x\"));\n  }' クイックフィックス適用後: 'void f(String[] array, Collection<String> collection) {\n    String[] strings = Arrays.copyOf(array, 10);\n    boolean contains = collection.contains(\"x\");\n  }' 2018.1 の新機能です",
                  "markdown": "より単純に表現できる、不必要に複雑なコレクション操作を報告します。\n\n例:\n\n\n      void f(String[] array, Collection<String> collection) {\n        String[] strings = Arrays.asList(array).subList(0, 10).toArray(new String[0]);\n        boolean contains = collection.containsAll(Collections.singletonList(\"x\"));\n      }\n\nクイックフィックス適用後:\n\n\n      void f(String[] array, Collection<String> collection) {\n        String[] strings = Arrays.copyOf(array, 10);\n        boolean contains = collection.contains(\"x\");\n      }\n\n2018.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantCollectionOperation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuppressionAnnotation",
                "shortDescription": {
                  "text": "インスペクション抑止アノテーション"
                },
                "fullDescription": {
                  "text": "インスペクションを抑止しているコメントまたはアノテーションを報告します。 このインスペクションは、将来的にレビューする目的で抑止を意図的に残す場合に役立ちます。 例: '@SuppressWarnings(\"unused\")\nstatic Stream<String> stringProvider() {\n    return Stream.of(\"foo\", \"bar\");\n}'",
                  "markdown": "インスペクションを抑止しているコメントまたはアノテーションを報告します。\n\nこのインスペクションは、将来的にレビューする目的で抑止を意図的に残す場合に役立ちます。\n\n**例:**\n\n\n    @SuppressWarnings(\"unused\")\n    static Stream<String> stringProvider() {\n        return Stream.of(\"foo\", \"bar\");\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuppressionAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassOnlyUsedInOnePackage",
                "shortDescription": {
                  "text": "他のパッケージからのみ使用されるクラス"
                },
                "fullDescription": {
                  "text": "自身は所属するパッケージ内の他のクラスに依存せず、別パッケージのクラスに依存しており、このような別パッケージのクラスに対してのみ依存関係になっているクラスを報告します。 このようなクラスは、依存しているパッケージに移動することを検討してください。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "自身は所属するパッケージ内の他のクラスに依存せず、別パッケージのクラスに依存しており、このような別パッケージのクラスに対してのみ依存関係になっているクラスを報告します。 このようなクラスは、依存しているパッケージに移動することを検討してください。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassOnlyUsedInOnePackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パッケージ関連の問題",
                      "index": 37,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryToStringCall",
                "shortDescription": {
                  "text": "'toString()' への不要な呼び出し"
                },
                "fullDescription": {
                  "text": "以下の場所で使用されている 'toString()' の呼び出しを報告します。 文字列結合の中 'java.lang.StringBuilder#append()' メソッドまたは 'java.lang.StringBuffer#append()' メソッドの中 'java.io.PrintWriter' または 'java.io.PrintStream' のメソッドの中 'org.slf4j.Logger' メソッドの中 これらの場所での文字列への変換は基本的なライブラリメソッドによって処理されるため、'toString()' を明示的に呼び出す必要はありません。 冗長な 'toString()' 呼び出しを除去することでパフォーマンスが向上し、オブジェクトの割り当てが減る可能性があります。 例: 'System.out.println(this.toString())' クイックフィックス適用後: 'System.out.println(this)' 'toString()' の呼び出しがないと、コードのセマンティクスが変更される場合があります。式が null の場合は、'NullPointerException' をスローする代わりに、'null' 文字列が使用されます。 null になり得る値に関する警告を無視する場合は、「修飾子が null でないことがわかっている場合にのみ報告する」オプションを使用します。 このような場合に明示的な 'toString()' を除去すると、値が 'null' の場合に 'NullPointException' をスローせずに警告なしで値を受け入れるように実行時のセマンティクスが変更されます。",
                  "markdown": "以下の場所で使用されている `toString()` の呼び出しを報告します。\n\n* 文字列結合の中\n* `java.lang.StringBuilder#append()` メソッドまたは `java.lang.StringBuffer#append()` メソッドの中\n* `java.io.PrintWriter` または `java.io.PrintStream` のメソッドの中\n* `org.slf4j.Logger` メソッドの中\n\nこれらの場所での文字列への変換は基本的なライブラリメソッドによって処理されるため、`toString()` を明示的に呼び出す必要はありません。\n冗長な `toString()` 呼び出しを除去することでパフォーマンスが向上し、オブジェクトの割り当てが減る可能性があります。\n\n例:\n\n\n      System.out.println(this.toString())\n\nクイックフィックス適用後:\n\n\n      System.out.println(this)\n\n\n`toString()` の呼び出しがないと、コードのセマンティクスが変更される場合があります。式が null の場合は、`NullPointerException` をスローする代わりに、`null` 文字列が使用されます。\n\nnull になり得る値に関する警告を無視する場合は、「**修飾子が null でないことがわかっている場合にのみ報告する** 」オプションを使用します。\nこのような場合に明示的な `toString()` を除去すると、値が `null` の場合に `NullPointException` をスローせずに警告なしで値を受け入れるように実行時のセマンティクスが変更されます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryToStringCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverriddenMethodCallDuringObjectConstruction",
                "shortDescription": {
                  "text": "オブジェクト構築中のオーバーライドされたメソッド呼び出し"
                },
                "fullDescription": {
                  "text": "現在のクラスのオーバーライドされたメソッドが、オブジェクト構築中に呼び出されていることを報告します。 この状況は、次の項目内でオブジェクトが構築されている場合に発生します。 コンストラクター 非 static インスタンスイニシャライザー 非 static フィールドイニシャライザー 'clone()' 'readObject()' 'readObjectNoData()' このような呼び出しはバグの検出を困難にします。オブジェクトがメソッド呼び出しの前に初期化されるとは限らないためです。 例: 'abstract class Parent {\n    void someMethod() { }\n  }\n\n  class Child extends Parent {\n    Child() {\n      someMethod();\n    }\n\n    @Override\n    void someMethod() { }\n  }' このインスペクションは以下のインスペクションと機能を共有しています。 オブジェクト構築中の抽象メソッド呼び出し インスペクション オブジェクト構築中のオーバーライド可能なメソッド呼び出し インスペクション 警告の重複を避けるため、同時に 1 つのインスペクションのみを有効にしてください。",
                  "markdown": "現在のクラスのオーバーライドされたメソッドが、オブジェクト構築中に呼び出されていることを報告します。 この状況は、次の項目内でオブジェクトが構築されている場合に発生します。\n\n* コンストラクター\n* 非 static インスタンスイニシャライザー\n* 非 static フィールドイニシャライザー\n* `clone()`\n* `readObject()`\n* `readObjectNoData()`\n\nこのような呼び出しはバグの検出を困難にします。オブジェクトがメソッド呼び出しの前に初期化されるとは限らないためです。\n\n例:\n\n\n      abstract class Parent {\n        void someMethod() { }\n      }\n\n      class Child extends Parent {\n        Child() {\n          someMethod();\n        }\n\n        @Override\n        void someMethod() { }\n      }\n\nこのインスペクションは以下のインスペクションと機能を共有しています。\n\n* **オブジェクト構築中の抽象メソッド呼び出し** インスペクション\n* **オブジェクト構築中のオーバーライド可能なメソッド呼び出し** インスペクション\n\n警告の重複を避けるため、同時に 1 つのインスペクションのみを有効にしてください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverriddenMethodCallDuringObjectConstruction",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初期化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractClassWithoutAbstractMethods",
                "shortDescription": {
                  "text": "'abstract' メソッドのない抽象クラス"
                },
                "fullDescription": {
                  "text": "'abstract' メソッドがない 'abstract' クラスを報告します。 多くの場合、'abstract' メソッドがない 'abstract' クラスには意味がなく、'abstract' 修飾子はクラスから削除できます。 インスタンス化を防ぐために 'abstract' クラスが宣言されていた場合、多くの場合は 'private' コンストラクターを宣言してインスタンス化を防ぐほうが適切です。 例: 'abstract class Example {\n    public String getName() {\n      return \"IntelliJ IDEA\";\n    }\n  }' ユーティリティクラスを無視するには、オプションを使用します。",
                  "markdown": "`abstract` メソッドがない `abstract` クラスを報告します。 多くの場合、`abstract` メソッドがない `abstract` クラスには意味がなく、`abstract` 修飾子はクラスから削除できます。 インスタンス化を防ぐために `abstract` クラスが宣言されていた場合、多くの場合は `private` コンストラクターを宣言してインスタンス化を防ぐほうが適切です。\n\n**例:**\n\n\n      abstract class Example {\n        public String getName() {\n          return \"IntelliJ IDEA\";\n        }\n      }\n\nユーティリティクラスを無視するには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractClassWithoutAbstractMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizeOnNonFinalField",
                "shortDescription": {
                  "text": "非 final フィールドでの同期"
                },
                "fullDescription": {
                  "text": "非 'final' フィールド参照で構成されている 'synchronized' ステートメントロック式を報告します。 このようなステートメントが有効なセマンティクスを持つ可能性は低いです。同じオブジェクトに対する操作を行っている場合も、異なるスレッドが別のロックを獲得する可能性があるためです。 例: 'private Object o;\n  public void foo() {\n    synchronized (o) // 非 final フィールドでの同期\n    { }\n  }'",
                  "markdown": "非 `final` フィールド参照で構成されている `synchronized` ステートメントロック式を報告します。 このようなステートメントが有効なセマンティクスを持つ可能性は低いです。同じオブジェクトに対する操作を行っている場合も、異なるスレッドが別のロックを獲得する可能性があるためです。\n\n**例:**\n\n\n      private Object o;\n      public void foo() {\n        synchronized (o) // 非 final フィールドでの同期\n        { }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizeOnNonFinalField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnSeparatedFromComputation",
                "shortDescription": {
                  "text": "演算結果から分離された 'return'"
                },
                "fullDescription": {
                  "text": "ローカル変数を返す 'return' ステートメントで、その変数の値が同じメソッド内の別の場所で計算されているものを報告します。 クイックフィックスを使用すると、変数の値が計算される場所に return ステートメントが移動され、返される変数がインライン化されます。 戻り値を 'return' ステートメントの中にインライン化できない場合、このクイックフィックスは、戻り値を計算するコードに return ステートメントを可能な限り近づけようとします。 例: 'int n = -1;\n  for (int i = 0; i < a.length; i++) {\n    if (a[i] == b) {\n      n = i;\n      break;\n    }\n  }\n  return n;' クイックフィックス適用後: 'int n = -1;\n  for (int i = 0; i < a.length; i++) {\n    if (a[i] == b) {\n      return i;\n    }\n  }\n  return n;'",
                  "markdown": "ローカル変数を返す `return` ステートメントで、その変数の値が同じメソッド内の別の場所で計算されているものを報告します。\n\nクイックフィックスを使用すると、変数の値が計算される場所に return ステートメントが移動され、返される変数がインライン化されます。\n戻り値を `return` ステートメントの中にインライン化できない場合、このクイックフィックスは、戻り値を計算するコードに return ステートメントを可能な限り近づけようとします。\n\n例:\n\n\n      int n = -1;\n      for (int i = 0; i < a.length; i++) {\n        if (a[i] == b) {\n          n = i;\n          break;\n        }\n      }\n      return n;\n\nクイックフィックス適用後:\n\n\n      int n = -1;\n      for (int i = 0; i < a.length; i++) {\n        if (a[i] == b) {\n          return i;\n        }\n      }\n      return n;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReturnSeparatedFromComputation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastThatLosesPrecision",
                "shortDescription": {
                  "text": "精度が低下する数値キャスト"
                },
                "fullDescription": {
                  "text": "精度の低下を招く可能性のあるプリミティブな数値型同士のキャスト演算を報告します。 このようなキャストは必ずしも問題ではありませんが、予期しない精度の低下が発生した場合はバグのトレースが困難になる可能性があります。 例: 'int a = 420;\n  byte b = (byte) a;' 'int' から 'char' へのキャストを無視するには、「int から char へのキャストを無視する」オプションを使用します。 この種のキャストは I/O 操作を実装する際によく使用されます。なぜなら、'java.io.Reader' クラスの 'read()' メソッドが 'int' を返すからです。 定数値 (128-255) の 'int' から 'byte' へのキャストを無視するには、「int 128-255 から byte へのキャストを無視する」オプションを使用します。 このような値は負の数値にオーバーフローしますが、バイトの範囲内に収まります。",
                  "markdown": "精度の低下を招く可能性のあるプリミティブな数値型同士のキャスト演算を報告します。\n\nこのようなキャストは必ずしも問題ではありませんが、予期しない精度の低下が発生した場合はバグのトレースが困難になる可能性があります。\n\n**例:**\n\n\n      int a = 420;\n      byte b = (byte) a;\n\n`int` から `char` へのキャストを無視するには、「**int から char へのキャストを無視する** 」オプションを使用します。\nこの種のキャストは I/O 操作を実装する際によく使用されます。なぜなら、`java.io.Reader` クラスの `read()` メソッドが `int` を返すからです。\n\n定数値 (128-255) の `int` から `byte` へのキャストを無視するには、「**int 128-255 から byte へのキャストを無視する**」オプションを使用します。\nこのような値は負の数値にオーバーフローしますが、バイトの範囲内に収まります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NumericCastThatLosesPrecision",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値の問題/キャスト",
                      "index": 104,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SameReturnValue",
                "shortDescription": {
                  "text": "メソッドは常に同じ値を返します"
                },
                "fullDescription": {
                  "text": "常に同じ定数を返すメソッドとメソッド階層を報告します。 このインスペクションは、バッチモード (「コード | コードのインスペクション」と「コード | コードの解析 | インスペクション名を指定して実行」からアクセス) とエディターでオンザフライで実行する場合とでは動作が異なります。 バッチモードの場合、このインスペクションは常に同じ定数を返すメソッドおよびメソッド階層を報告します。 エディターの場合、このインスペクションは 1 つ以上の 'return' ステートメントがあり、super メソッドがなく、オーバーライドできないメソッドのみを報告します。 メソッドがメソッドをオーバーライドまたは実装する場合、契約が特定の定数を返すためにメソッドを必要とする可能性がありますが、同時に複数の終了ポイントを持つことをお勧めします。 メソッドをオーバーライドできる場合、異なる値がサブクラスで返される可能性があります。 例: 'class X {\n                // バッチモードでのみ警告。\n    int xxx() { // メソッド 'xxx()' とそのすべてのオーバーライドメソッドは常に '0' を返します\n      return 0;\n    }\n  }\n\n  class Y extends X {\n    @Override\n    int xxx() {\n        return 0;\n    }\n\n                // バッチモードでのみ警告。\n    int yyy() { // メソッド 'yyy()' は常に '0' を返します\n        return 0;\n    }\n\n                                  // バッチモードとオンザフライの両方で警告。\n    final int zzz(boolean flag) { // メソッド 'zzz()' は常に '0' を返します\n        if (Math.random() > 0.5) {\n            return 0;\n        }\n        return 0;\n    }\n  }'",
                  "markdown": "常に同じ定数を返すメソッドとメソッド階層を報告します。\n\n\nこのインスペクションは、バッチモード (「**コード \\| コードのインスペクション** 」と「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からアクセス) とエディターでオンザフライで実行する場合とでは動作が異なります。\n\n* バッチモードの場合、このインスペクションは常に同じ定数を返すメソッドおよびメソッド階層を報告します。\n* エディターの場合、このインスペクションは 1 つ以上の `return` ステートメントがあり、super メソッドがなく、オーバーライドできないメソッドのみを報告します。 メソッドがメソッドをオーバーライドまたは実装する場合、契約が特定の定数を返すためにメソッドを必要とする可能性がありますが、同時に複数の終了ポイントを持つことをお勧めします。 メソッドをオーバーライドできる場合、異なる値がサブクラスで返される可能性があります。\n\n**例:**\n\n\n      class X {\n                    // バッチモードでのみ警告。\n        int xxx() { // メソッド 'xxx()' とそのすべてのオーバーライドメソッドは常に '0' を返します\n          return 0;\n        }\n      }\n\n      class Y extends X {\n        @Override\n        int xxx() {\n            return 0;\n        }\n\n                    // バッチモードでのみ警告。\n        int yyy() { // メソッド 'yyy()' は常に '0' を返します\n            return 0;\n        }\n\n                                      // バッチモードとオンザフライの両方で警告。\n        final int zzz(boolean flag) { // メソッド 'zzz()' は常に '0' を返します\n            if (Math.random() > 0.5) {\n                return 0;\n            }\n            return 0;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SameReturnValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowablePrintStackTrace",
                "shortDescription": {
                  "text": "'printStackTrace()' の呼び出し"
                },
                "fullDescription": {
                  "text": "引数がない 'Throwable.printStackTrace()' の呼び出しを報告します。 このようなステートメントは一時的なデバッグによく使用されるため、プロダクションコードから除去するか、より堅牢なログ機能に置換する必要があります。",
                  "markdown": "引数がない `Throwable.printStackTrace()` の呼び出しを報告します。\n\nこのようなステートメントは一時的なデバッグによく使用されるため、プロダクションコードから除去するか、より堅牢なログ機能に置換する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToPrintStackTrace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コード成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringBufferMustHaveInitialCapacity",
                "shortDescription": {
                  "text": "初期容量なしの 'StringBuilder'"
                },
                "fullDescription": {
                  "text": "初期容量を指定せずに新しい 'StringBuffer' または 'StringBuilder' オブジェクトがインスタンス化されようとしていることを報告します。 初期容量が指定されていない場合はデフォルトの容量が使用されますが、これが最適であることはめったにありません。 'StringBuffer' の初期容量を指定しなかった場合、初期容量を超えた時点で空き領域を再割り当てしてメモリをコピーする必要がある場合にパフォーマンスに問題が生じる可能性があります。 例: '// 容量が指定されていません\n  var sb = new StringBuilder();'",
                  "markdown": "初期容量を指定せずに新しい `StringBuffer` または `StringBuilder` オブジェクトがインスタンス化されようとしていることを報告します。\n\n\n初期容量が指定されていない場合はデフォルトの容量が使用されますが、これが最適であることはめったにありません。\n`StringBuffer` の初期容量を指定しなかった場合、初期容量を超えた時点で空き領域を再割り当てしてメモリをコピーする必要がある場合にパフォーマンスに問題が生じる可能性があります。\n\n例:\n\n\n      // 容量が指定されていません\n      var sb = new StringBuilder();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringBufferWithoutInitialCapacity",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayObjectsEquals",
                "shortDescription": {
                  "text": "配列でのシャドーもしくは 'Objects' メソッドの併用"
                },
                "fullDescription": {
                  "text": "不適切な方法を使用して配列の等価性の判別、またはハッシュコードの計算を行っていると思われる式を報告します。 次のメソッド呼び出しが報告されます。 配列の場合に対する 'Object.equals()' 多次元配列に対する 'Arrays.equals()' 多次元配列に対する 'Arrays.hashCode()'",
                  "markdown": "不適切な方法を使用して配列の等価性の判別、またはハッシュコードの計算を行っていると思われる式を報告します。\n\n次のメソッド呼び出しが報告されます。\n\n* 配列の場合に対する `Object.equals()`\n* 多次元配列に対する `Arrays.equals()`\n* 多次元配列に対する `Arrays.hashCode()`"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayObjectsEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadWithDefaultRunMethod",
                "shortDescription": {
                  "text": "デフォルトの 'run()' メソッドによる 'Thread' のインスタンス化"
                },
                "fullDescription": {
                  "text": "'Runnable' パラメーターを指定していないか、'run()' メソッドをオーバーライドしていない 'Thread' またはその継承のインスタンス化を報告します。 このようなスレッドは無意味です。 例: 'new Thread().start();'",
                  "markdown": "`Runnable` パラメーターを指定していないか、`run()` メソッドをオーバーライドしていない `Thread` またはその継承のインスタンス化を報告します。 このようなスレッドは無意味です。\n\n**例:**\n\n\n      new Thread().start();\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstantiatingAThreadWithDefaultRunMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreeNegationsPerMethod",
                "shortDescription": {
                  "text": "4 つ以上の否定を含むメソッド"
                },
                "fullDescription": {
                  "text": "否定が 3 つ以上あるメソッドを報告します。 このようなメソッド名は混乱を招く可能性があります。 例: 'void doSmth(int a, int b, boolean flag1, boolean flag2) {\n    if (!flag && !flag2) {\n      if (a != b) {\n        doOther();\n      }\n    }\n  }' 否定がなければ、メソッドがより分かりやすくなります。 'void doSmth(int a, int b, boolean flag1, boolean flag2) {\n    if (flag1 || flag2 || a == b) return;\n    doOther();\n  }' インスペクションの構成: 'equals()' メソッド内でこのインスペクションを無効にするには、「'equals()' メソッドの否定を無視する」オプションを使用します。 'assert' 内でこのインスペクションを無効にするには、'assert' ステートメントの否定を無視する を使用します。",
                  "markdown": "否定が 3 つ以上あるメソッドを報告します。 このようなメソッド名は混乱を招く可能性があります。\n\n**例:**\n\n\n      void doSmth(int a, int b, boolean flag1, boolean flag2) {\n        if (!flag && !flag2) {\n          if (a != b) {\n            doOther();\n          }\n        }\n      }\n\n否定がなければ、メソッドがより分かりやすくなります。\n\n\n      void doSmth(int a, int b, boolean flag1, boolean flag2) {\n        if (flag1 || flag2 || a == b) return;\n        doOther();\n      }\n\nインスペクションの構成:\n\n* `equals()` メソッド内でこのインスペクションを無効にするには、「**'equals()' メソッドの否定を無視する**」オプションを使用します。\n* `assert` 内でこのインスペクションを無効にするには、**'assert' ステートメントの否定を無視する** を使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithMoreThanThreeNegations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メソッドメトリクス",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8MapApi",
                "shortDescription": {
                  "text": "単純化できる 'Map' 操作"
                },
                "fullDescription": {
                  "text": "一般的な 'java.util.Map' の使用パターンを報告し、 'getOrDefault()'、'computeIfAbsent()'、'putIfAbsent()'、'merge()'、または 'replaceAll()' への置換を提案します。 例: 'map.containsKey(key) ? map.get(key) : \"default\";' クイックフィックス適用後: 'map.getOrDefault(key, \"default\");' 例: 'List<String> list = map.get(key);\n  if (list == null) {\n    list = new ArrayList<>();\n    map.put(key, list);\n  }' クイックフィックス適用後: 'map.computeIfAbsent(key, localKey -> new ArrayList<>());' 例: 'Integer val = map.get(key);\n  if (val == null) map.put(key, 1);\n  else map.put(key, val + 1);' クイックフィックス適用後: 'map.merge(key, 1, (localKey, localValue) -> localValue + 1);' 例: 'for (Map.Entry<String, String> entry : map.entrySet()) {\n    map.put(entry.getKey(), transform(entry.getValue()));\n  }' クイックフィックス適用後: 'map.replaceAll((localKey, localValue) -> transform(localValue));' ラムダ式に抽出されるコードが同じ 'Map' を修飾している場合、一部の 'Map' の実装では 'computeIfAbsent()' または 'merge()' への置換が正常に機能しない可能性があります。 このコードに副作用があると思われる場合でも、デフォルトでは警告は表示されません。 警告を常に表示する必要がある場合は、「ラムダに副作用があると思われる場合も置換を提案する」オプションを有効にします。 'put()' のような古いメソッドや 'computeIfAbsent()' / 'merge()' のような新しいメソッドでは 'null' 値の処理が異なるため、セマンティクスが変更される可能性があります。指定の 'Map' に 'null' 値を格納することが重要な場合、この事を考慮する必要があります。 対象の値が静的に nullable であると分かっている場合、このインスペクションは置換を提案しません。ただし、null 許容性が不明な値については、置換が提案されます。 そのような場合は、警告を抑止して、説明用のコメントを追加することをお勧めします。 このインスペクションは Java 8 以降で使用できる Java の機能 'コレクション内のラムダメソッド' に依存しています。",
                  "markdown": "一般的な `java.util.Map` の使用パターンを報告し、 `getOrDefault()`、`computeIfAbsent()`、`putIfAbsent()`、`merge()`、または `replaceAll()` への置換を提案します。\n\n例:\n\n\n      map.containsKey(key) ? map.get(key) : \"default\";\n\nクイックフィックス適用後:\n\n\n      map.getOrDefault(key, \"default\");\n\n例:\n\n\n      List<String> list = map.get(key);\n      if (list == null) {\n        list = new ArrayList<>();\n        map.put(key, list);\n      }\n\nクイックフィックス適用後:\n\n\n      map.computeIfAbsent(key, localKey -> new ArrayList<>());\n\n例:\n\n\n      Integer val = map.get(key);\n      if (val == null) map.put(key, 1);\n      else map.put(key, val + 1);\n\nクイックフィックス適用後:\n\n\n      map.merge(key, 1, (localKey, localValue) -> localValue + 1);\n\n例:\n\n\n      for (Map.Entry<String, String> entry : map.entrySet()) {\n        map.put(entry.getKey(), transform(entry.getValue()));\n      }\n\nクイックフィックス適用後:\n\n\n      map.replaceAll((localKey, localValue) -> transform(localValue));\n\nラムダ式に抽出されるコードが同じ `Map` を修飾している場合、一部の `Map` の実装では `computeIfAbsent()` または `merge()` への置換が正常に機能しない可能性があります。 このコードに副作用があると思われる場合でも、デフォルトでは警告は表示されません。 警告を常に表示する必要がある場合は、「**ラムダに副作用があると思われる場合も置換を提案する**」オプションを有効にします。\n\n`put()` のような古いメソッドや `computeIfAbsent()` / `merge()` のような新しいメソッドでは `null` 値の処理が異なるため、セマンティクスが変更される可能性があります。指定の `Map` に `null` 値を格納することが重要な場合、この事を考慮する必要があります。 対象の値が静的に nullable であると分かっている場合、このインスペクションは置換を提案しません。ただし、null 許容性が不明な値については、置換が提案されます。 そのような場合は、警告を抑止して、説明用のコメントを追加することをお勧めします。\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'コレクション内のラムダメソッド' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8MapApi",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestOnlyProblems",
                "shortDescription": {
                  "text": "テスト専用のものをプロダクションコードで使用"
                },
                "fullDescription": {
                  "text": "'@TestOnly' および '@VisibleForTesting' アノテーションが付いたメソッドとクラスで、プロダクションコードで使用されているものを報告します。 また、同じ要素に対して '@TestOnly' と '@VisibleForTesting' が適用されていることも報告します。 このようなメソッドまたはクラスが以下から参照されている場合、問題は報告されません。 Test Sources フォルダーの下にあるコード。 テストクラス (JUnit/TestNG) '@TestOnly' アノテーションが付いた別のメソッド 例 (プロダクションコード): '@TestOnly\n  fun foo() { ... }\n\n  fun main () {\n    foo()\n  }'",
                  "markdown": "`@TestOnly` および `@VisibleForTesting` アノテーションが付いたメソッドとクラスで、プロダクションコードで使用されているものを報告します。 また、同じ要素に対して `@TestOnly` と `@VisibleForTesting` が適用されていることも報告します。\n\nこのようなメソッドまたはクラスが以下から参照されている場合、問題は報告されません。\n\n* **Test Sources** フォルダーの下にあるコード。\n* テストクラス (JUnit/TestNG)\n* `@TestOnly` アノテーションが付いた別のメソッド\n\n**例 (プロダクションコード):**\n\n\n      @TestOnly\n      fun foo() { ... }\n\n      fun main () {\n        foo()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TestOnlyProblems",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語/テストフレームワーク",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MeaninglessRecordAnnotationInspection",
                "shortDescription": {
                  "text": "無意味なレコードのアノテーション"
                },
                "fullDescription": {
                  "text": "無効なレコードコンポーネントに対して使用されているアノテーションを報告します。 これは次の 2 つの場合に発生する可能性があります。 報告対象アノテーションのターゲットは METHOD だが、対応するアクセサーが明示的に定義されている。 報告対象アノテーションのターゲットは PARAMETER だが、カノニカルコンストラクターが明示的に定義されている。 例: '@Target(ElementType.METHOD)\n@interface A { }\n  \n// アノテーションはアクセサーに反映されるべきですが、\n// アクセサーが明示的に定義されているため、バイトコードにまったく現れません。 \nrecord R(@A int x) {\n  public int x() { return x; }\n}' 2021.1 の新機能です このインスペクションは Java 16 以降で使用できる Java の機能 'レコード' に依存しています。",
                  "markdown": "無効なレコードコンポーネントに対して使用されているアノテーションを報告します。\n\nこれは次の 2 つの場合に発生する可能性があります。\n\n* 報告対象アノテーションのターゲットは METHOD だが、対応するアクセサーが明示的に定義されている。\n* 報告対象アノテーションのターゲットは PARAMETER だが、カノニカルコンストラクターが明示的に定義されている。\n\n例:\n\n\n    @Target(ElementType.METHOD)\n    @interface A { }\n      \n    // アノテーションはアクセサーに反映されるべきですが、\n    // アクセサーが明示的に定義されているため、バイトコードにまったく現れません。 \n    record R(@A int x) {\n      public int x() { return x; }\n    }\n\n2021.1 の新機能です\n\nこのインスペクションは Java 16 以降で使用できる Java の機能 'レコード' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MeaninglessRecordAnnotationInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsWhichDoesntCheckParameterClass",
                "shortDescription": {
                  "text": "パラメーターのクラスをチェックしない 'equals()' メソッド"
                },
                "fullDescription": {
                  "text": "パラメータの型をチェックしていない 'equals()' メソッドを報告します。 'equals()' メソッドでパラメーターの型をチェックしないと、オブジェクトが型指定されていないコレクションで使用されている場合に潜在的なエラーが発生する可能性があります。 例: 'class MyClass {\n    int x;\n\n    @Override\n    public boolean equals(Object obj) {\n      // obj が MyClass でない場合、equals メソッドは false を返す必要があります\n      return ((MyClass)obj).x == x;\n    }\n  }'",
                  "markdown": "パラメータの型をチェックしていない `equals()` メソッドを報告します。\n\n`equals()` メソッドでパラメーターの型をチェックしないと、オブジェクトが型指定されていないコレクションで使用されている場合に潜在的なエラーが発生する可能性があります。\n\n**例:**\n\n\n      class MyClass {\n        int x;\n\n        @Override\n        public boolean equals(Object obj) {\n          // obj が MyClass でない場合、equals メソッドは false を返す必要があります\n          return ((MyClass)obj).x == x;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsDoesntCheckParameterClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseHashCodeMethodInspection",
                "shortDescription": {
                  "text": "標準の 'hashCode()' メソッドを使用できます"
                },
                "fullDescription": {
                  "text": "'Long.hashCode()' または 'Double.hashCode()' メソッドの呼び出しに置換できるビット演算を報告します。 このインスペクションは 'x' が 'long' 型の変数、または先行する 'Double.doubleToLongBits()' 呼び出しの結果になっているコンストラクト '(int)(x ^ (x >>> 32))' を検出します。 この置換によってコードが短縮され、読みやすくなります。 例: 'int result = (int)(var ^ (var >>> 32));' クイックフィックス適用後: 'int result = Long.hashCode(var);' このインスペクションは、プロジェクトまたはモジュールの言語レベルが 8 以上の場合にのみ報告します。 2024.1 の新機能です",
                  "markdown": "`Long.hashCode()` または `Double.hashCode()` メソッドの呼び出しに置換できるビット演算を報告します。 このインスペクションは `x` が `long` 型の変数、または先行する `Double.doubleToLongBits()` 呼び出しの結果になっているコンストラクト `(int)(x ^ (x >>> 32))` を検出します。 この置換によってコードが短縮され、読みやすくなります。\n\n**例:**\n\n\n      int result = (int)(var ^ (var >>> 32));\n\nクイックフィックス適用後:\n\n\n      int result = Long.hashCode(var);\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 8 以上の場合にのみ報告します。\n\n2024.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseHashCodeMethodInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 8",
                      "index": 60,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToSuperclassField",
                "shortDescription": {
                  "text": "コンストラクターがスーパークラスで定義されたフィールドに値を代入"
                },
                "fullDescription": {
                  "text": "サブクラスのコンストラクターからスーパークラスで宣言されているフィールドへの代入、または変更を報告します。 スーパークラスのフィールドは自身のコンストラクターで初期化し、サブクラス内でそのコンストラクターに委譲することが望ましいとされています。 これにより、あるフィールドがコンストラクターを実行後に変更されていない場合に 'final' として宣言することも可能になります。 例: 'class Super {\n    int x;\n  }\n  class Sub extends Super {\n    Sub(int _x) {\n      // 警告: x はスーパークラスで宣言されています\n      x = _x;\n    }\n  }' この問題を回避するため、スーパークラスのコンストラクターを宣言します: 'class Super {\n    final int x;\n\n    Super(int _x) {\n      x = _x;\n    }\n  }\n  class Sub extends Super {\n    Sub(int _x) {\n      super(_x);\n    }\n  }'",
                  "markdown": "サブクラスのコンストラクターからスーパークラスで宣言されているフィールドへの代入、または変更を報告します。\n\nスーパークラスのフィールドは自身のコンストラクターで初期化し、サブクラス内でそのコンストラクターに委譲することが望ましいとされています。 これにより、あるフィールドがコンストラクターを実行後に変更されていない場合に `final` として宣言することも可能になります。\n\n**例:**\n\n\n      class Super {\n        int x;\n      }\n      class Sub extends Super {\n        Sub(int _x) {\n          // 警告: x はスーパークラスで宣言されています\n          x = _x;\n        }\n      }\n\nこの問題を回避するため、スーパークラスのコンストラクターを宣言します:\n\n\n      class Super {\n        final int x;\n\n        Super(int _x) {\n          x = _x;\n        }\n      }\n      class Sub extends Super {\n        Sub(int _x) {\n          super(_x);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToSuperclassField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代入関連の問題",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousIndentAfterControlStatement",
                "shortDescription": {
                  "text": "波括弧のない制御ステートメントの後の疑わしいインデント"
                },
                "fullDescription": {
                  "text": "波括弧のない制御ステートメントの後続ステートメントの疑わしいインデントを報告します。 このようなインデントがある場合、問題のステートメントは制御ステートメント内にあるように見えますが、実際には制御ステートメントに続けて無条件に実行されます。 例: 'class Bar {\n      void foo(int i) {\n          if (i == 0)\n              System.out.println(\"foo\");\n              System.out.println(\"bar\"); // 警告\n          if (i == 1);\n              System.out.println(\"great\"); // 警告\n          if (i == 42)\n              System.out.println(\"answer\");\n                  System.out.println(\"question\"); // 警告\n      }\n  }'",
                  "markdown": "波括弧のない制御ステートメントの後続ステートメントの疑わしいインデントを報告します。\n\n\nこのようなインデントがある場合、問題のステートメントは制御ステートメント内にあるように見えますが、実際には制御ステートメントに続けて無条件に実行されます。\n\n**例:**\n\n\n      class Bar {\n          void foo(int i) {\n              if (i == 0)\n                  System.out.println(\"foo\");\n                  System.out.println(\"bar\"); // 警告\n              if (i == 1);\n                  System.out.println(\"great\"); // 警告\n              if (i == 42)\n                  System.out.println(\"answer\");\n                      System.out.println(\"question\"); // 警告\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousIndentAfterControlStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NumericOverflow",
                "shortDescription": {
                  "text": "数値のオーバーフロー"
                },
                "fullDescription": {
                  "text": "計算中にオーバーフローする式を報告します。 通常、これは偶然に発生し、バグの存在を示唆しています。 具体的には、間違った型が使用されている、または反対方向へシフトすべきである、といった例が挙げられます。 例: 'float a = 1.0f/0.0f;\n  long b = 30 * 24 * 60 * 60 * 1000;\n  long c = 1000L << 62;'",
                  "markdown": "計算中にオーバーフローする式を報告します。 通常、これは偶然に発生し、バグの存在を示唆しています。 具体的には、間違った型が使用されている、または反対方向へシフトすべきである、といった例が挙げられます。\n\n**例:**\n\n\n      float a = 1.0f/0.0f;\n      long b = 30 * 24 * 60 * 60 * 1000;\n      long c = 1000L << 62;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NumericOverflow",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FillPermitsList",
                "shortDescription": {
                  "text": "同一ファイルのサブクラスが sealed クラスの permit 句にありません"
                },
                "fullDescription": {
                  "text": "明示的な 'permits' リストがない 'sealed' クラスを報告します。 同じファイル内にのみサブクラスがある sealed クラスは、明示的な 'permits' リストを指定する必要はありません。 このインスペクションはデフォルトではエディター内をハイライトせず、修正のみを提供します。 例: 'sealed class A {}\n  final class B extends A {}' クイックフィックス適用後: 'sealed class A permits B {}\n  final class B extends A {}' 2020.3 の新機能です このインスペクションは Java 17 以降で使用できる Java の機能 'Sealed クラス' に依存しています。",
                  "markdown": "明示的な `permits` リストがない `sealed` クラスを報告します。 同じファイル内にのみサブクラスがある sealed クラスは、明示的な `permits` リストを指定する必要はありません。 このインスペクションはデフォルトではエディター内をハイライトせず、修正のみを提供します。\n\n例:\n\n\n      sealed class A {}\n      final class B extends A {}\n\nクイックフィックス適用後:\n\n\n      sealed class A permits B {}\n      final class B extends A {}\n\n2020.3 の新機能です\n\nこのインスペクションは Java 17 以降で使用できる Java の機能 'Sealed クラス' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FillPermitsList",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNewInstance",
                "shortDescription": {
                  "text": "安全でない Class.newInstance() の呼び出し"
                },
                "fullDescription": {
                  "text": "'java.lang.Class.newInstance()' の呼び出しを報告します。 このメソッドはチェック例外を含め、引数なしのコンストラクターによってスローされた例外を伝播します。 このメソッドを使用すると、その他の場合にはコンパイラーによって実行されるコンパイル時の例外チェックが事実上バイパスされます。 この呼び出しを 'java.lang.reflect.Constructor.newInstance()' メソッドの呼び出しに置換し、コンストラクターによってスローされる例外を (チェックされた) 'java.lang.reflect.InvocationTargetException' でラップして問題を回避するためのクイックフィックスが提案されます。 例: 'clazz.newInstance()' クイックフィックス適用後: 'clazz.getConstructor().newInstance();'",
                  "markdown": "`java.lang.Class.newInstance()` の呼び出しを報告します。\n\n\nこのメソッドはチェック例外を含め、引数なしのコンストラクターによってスローされた例外を伝播します。 このメソッドを使用すると、その他の場合にはコンパイラーによって実行されるコンパイル時の例外チェックが事実上バイパスされます。\n\n\nこの呼び出しを `java.lang.reflect.Constructor.newInstance()` メソッドの呼び出しに置換し、コンストラクターによってスローされる例外を (チェックされた) `java.lang.reflect.InvocationTargetException` でラップして問題を回避するためのクイックフィックスが提案されます。\n\n**例:**\n\n\n      clazz.newInstance()\n\nクイックフィックス適用後:\n\n\n      clazz.getConstructor().newInstance();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassNewInstance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousDateFormat",
                "shortDescription": {
                  "text": "疑わしい日付形式パターン"
                },
                "fullDescription": {
                  "text": "誤って使用されている可能性のある日付形式のパターンを報告します。 次のパターンが報告されます。 大文字の \"Y\" (\"w\" が近くにある場合を除く)。 これは \"Week year\" (暦週の基準年) の略で、通常の \"Year\" (小文字の \"y\" パターン) とほぼ同様ですが、翌年の 12 月末を指す場合があります。 \"H\" または \"K\"、 \"h\"、\"k\" (時間) に近い大文字の \"M\" (月)。 小文字の \"m\" (分) が意図されていた可能性があります。 \"y\" (年) または \"d\" (月における日) に近い小文字の \"m\" (分)。 大文字の \"M\" (月) が意図されていた可能性があります。 \"M\" または \"L\" (月) に近い大文字の \"D\" (年における日)。 小文字の \"d\" (月における日) が意図されていた可能性があります。 \"m\" (分) に近い大文字の \"S\" (ミリ秒)。 小文字の \"s\" (秒) が意図されていた可能性があります。 例: 'new SimpleDateFormat(\"YYYY-MM-dd\")': '\"yyyy-MM-dd\"' が意図されていた可能性があります。 'new SimpleDateFormat(\"yyyy-MM-DD\")': '\"yyyy-MM-dd\"' が意図されていた可能性があります。 'new SimpleDateFormat(\"HH:MM\")': '\"HH:mm\"' が意図されていた可能性があります。 2020.1 の新機能です",
                  "markdown": "誤って使用されている可能性のある日付形式のパターンを報告します。\n\n次のパターンが報告されます。\n\n* 大文字の \"Y\" (\"w\" が近くにある場合を除く)。 これは \"Week year\" (暦週の基準年) の略で、通常の \"Year\" (小文字の \"y\" パターン) とほぼ同様ですが、翌年の 12 月末を指す場合があります。\n* \"H\" または \"K\"、 \"h\"、\"k\" (時間) に近い大文字の \"M\" (月)。 小文字の \"m\" (分) が意図されていた可能性があります。\n* \"y\" (年) または \"d\" (月における日) に近い小文字の \"m\" (分)。 大文字の \"M\" (月) が意図されていた可能性があります。\n* \"M\" または \"L\" (月) に近い大文字の \"D\" (年における日)。 小文字の \"d\" (月における日) が意図されていた可能性があります。\n* \"m\" (分) に近い大文字の \"S\" (ミリ秒)。 小文字の \"s\" (秒) が意図されていた可能性があります。\n\n\n例:   \n\n`new SimpleDateFormat(\"YYYY-MM-dd\")`: `\"yyyy-MM-dd\"` が意図されていた可能性があります。  \n\n`new SimpleDateFormat(\"yyyy-MM-DD\")`: `\"yyyy-MM-dd\"` が意図されていた可能性があります。  \n\n`new SimpleDateFormat(\"HH:MM\")`: `\"HH:mm\"` が意図されていた可能性があります。\n\n2020.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousDateFormat",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MagicConstant",
                "shortDescription": {
                  "text": "マジック定数"
                },
                "fullDescription": {
                  "text": "「マジック」定数と置換できる式を報告します。 例 1: '// 素のリテラル \"2\" を使用。警告が発生します。\n  Font font = new Font(\"Arial\", 2)' 例 2: '// 定義済み定数を使用。適切です。\n  Font font = new Font(\"Arial\", Font.ITALIC)' 可能な場合、クイックフィックスを使用すると適切な定義済み定数が挿入されます。 このインスペクションの動作は 'org.intellij.lang.annotations.MagicConstant' アノテーションにより制御されます。 一部の標準 Java ライブラリメソッドには事前にアノテーションが付いていますが、コード内でこのアノテーションを使用することもできます。",
                  "markdown": "「マジック」定数と置換できる式を報告します。\n\n例 1:\n\n\n      // 素のリテラル \"2\" を使用。警告が発生します。\n      Font font = new Font(\"Arial\", 2)\n\n例 2:\n\n\n      // 定義済み定数を使用。適切です。\n      Font font = new Font(\"Arial\", Font.ITALIC)\n\n\n可能な場合、クイックフィックスを使用すると適切な定義済み定数が挿入されます。\n\n\nこのインスペクションの動作は `org.intellij.lang.annotations.MagicConstant` アノテーションにより制御されます。\n一部の標準 Java ライブラリメソッドには事前にアノテーションが付いていますが、コード内でこのアノテーションを使用することもできます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MagicConstant",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LimitedScopeInnerClass",
                "shortDescription": {
                  "text": "ローカルクラス"
                },
                "fullDescription": {
                  "text": "ローカルクラスを報告します。 ローカルクラスとは、コードブロック内で宣言されている名前付きのネストしたクラスを意味します。 ローカルクラスは一般的ではないため、混乱を招く可能性があります。 また、一部のコード標準はローカルクラスの使用を推奨していません。 例: 'class Example {\n    void test() {\n      class Local { // ここ\n      }\n      new Local();\n    }\n  }' クイックフィックス適用後: 'class Example {\n    void test() {\n      new Local();\n    }\n\n    private static class Local { // ここ\n    }\n  }'",
                  "markdown": "ローカルクラスを報告します。\n\nローカルクラスとは、コードブロック内で宣言されている名前付きのネストしたクラスを意味します。\nローカルクラスは一般的ではないため、混乱を招く可能性があります。\nまた、一部のコード標準はローカルクラスの使用を推奨していません。\n\n**例:**\n\n\n      class Example {\n        void test() {\n          class Local { // ここ\n          }\n          new Local();\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Example {\n        void test() {\n          new Local();\n        }\n\n        private static class Local { // ここ\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LimitedScopeInnerClass",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultiplyOrDivideByPowerOfTwo",
                "shortDescription": {
                  "text": "2 の累乗による乗算または除算"
                },
                "fullDescription": {
                  "text": "2 の累乗で表現可能な、整数の定数による整数値の乗算を報告します。 このような式は、パフォーマンス向上を期待して右または左シフト演算に置換できます。 このインスペクションは、最新の JVM (HotSpot や OpenJ9 など) には適用されません。それらの JIT コンパイラーでは、この最適化が行われるためです。 このインスペクションは、JIT コンパイルが実行されない一部の組み込みシステムでのみ有効です。 例: 'int y = x * 4;' シフト演算による乗算または除算を置換するクイックフィックスが提案されます。 'int y = x << 2;' インスペクションに 2 の累乗による除算も報告させるには、オプションを使用します。 負の数値については、2 の累乗をシフトに置換できません。",
                  "markdown": "2 の累乗で表現可能な、整数の定数による整数値の乗算を報告します。 このような式は、パフォーマンス向上を期待して右または左シフト演算に置換できます。\n\n\nこのインスペクションは、最新の JVM (HotSpot や OpenJ9 など) には適用されません。それらの JIT コンパイラーでは、この最適化が行われるためです。\nこのインスペクションは、JIT コンパイルが実行されない一部の組み込みシステムでのみ有効です。\n\n**例:**\n\n\n      int y = x * 4;\n\nシフト演算による乗算または除算を置換するクイックフィックスが提案されます。\n\n\n      int y = x << 2;\n\n\nインスペクションに 2 の累乗による除算も報告させるには、オプションを使用します。\n負の数値については、2 の累乗をシフトに置換できません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MultiplyOrDivideByPowerOfTwo",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス/組み込み",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodCallInLoopCondition",
                "shortDescription": {
                  "text": "ループ条件内でのメソッド呼び出し"
                },
                "fullDescription": {
                  "text": "ループステートメントの条件部にあるメソッドの呼び出しを報告します。 リソースの使用が大幅に制限されている環境では、このような呼び出しはパフォーマンスに悪影響を及ぼす可能性があります。 このインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。 このインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。 例: 'String s = \"example\";\n  for (int i = 0; i < s.length(); i++) {\n    System.out.println(s.charAt(i));\n  }' クイックフィックス適用後: 'String s = \"example\";\n  int length = s.length();\n  for (int i = 0; i < length; i++) {\n    System.out.println(s.charAt(i));\n  }' 'Iterator.hasNext()' のような一般的な Java の繰り返しメソッドや 'Atomic*.compareAndSet' のような副作用を持つ既知のメソッドの呼び出しを無視するには、オプションを使用します。",
                  "markdown": "ループステートメントの条件部にあるメソッドの呼び出しを報告します。 リソースの使用が大幅に制限されている環境では、このような呼び出しはパフォーマンスに悪影響を及ぼす可能性があります。\n\n\nこのインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。\nこのインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。\n\n**例:**\n\n\n      String s = \"example\";\n      for (int i = 0; i < s.length(); i++) {\n        System.out.println(s.charAt(i));\n      }\n\nクイックフィックス適用後:\n\n\n      String s = \"example\";\n      int length = s.length();\n      for (int i = 0; i < length; i++) {\n        System.out.println(s.charAt(i));\n      }\n\n\n`Iterator.hasNext()` のような一般的な Java の繰り返しメソッドや `Atomic*.compareAndSet` のような副作用を持つ既知のメソッドの呼び出しを無視するには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodCallInLoopCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス/組み込み",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NumericToString",
                "shortDescription": {
                  "text": "'Number.toString()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'Number' を拡張するクラスのオブジェクトに対する 'toString()' の呼び出しを報告します。 このような呼び出しは通常、国際化環境では不適切です。代わりにロケール固有の書式を使う必要がある場合があります。 例: 'void print(Double d) {\n    System.out.println(d.toString());\n  }' この問題は、次のような方法で修正可能です。 'void print(Double d) {\n    System.out.printf(\"%f%n\", d);\n  }' これにより、JVM の起動中にホスト環境に基づいて設定されるデフォルトのロケールを使用して数値の書式を設定します。",
                  "markdown": "`Number` を拡張するクラスのオブジェクトに対する `toString()` の呼び出しを報告します。 このような呼び出しは通常、国際化環境では不適切です。代わりにロケール固有の書式を使う必要がある場合があります。\n\n**例:**\n\n\n      void print(Double d) {\n        System.out.println(d.toString());\n      }\n\nこの問題は、次のような方法で修正可能です。\n\n\n      void print(Double d) {\n        System.out.printf(\"%f%n\", d);\n      }\n\nこれにより、JVM の起動中にホスト環境に基づいて設定されるデフォルトのロケールを使用して数値の書式を設定します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToNumericToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodCount",
                "shortDescription": {
                  "text": "メソッドが多すぎるクラス"
                },
                "fullDescription": {
                  "text": "メソッド数が指定された最大値を超えているクラスを報告します。 メソッド数が多すぎるクラスは多くの場合、実行しようとしている処理の数が多すぎます。 このようなクラスは、より小さな複数のクラスに分割することを検討してください。 インスペクションの構成: クラスで許容されるメソッド数の最大値を指定するには、「メソッド数の制限」フィールドを使用します。 単純な getter と setter を無視してメソッド数にカウントしないようにするには、「単純な getter メソッドと setter メソッドを無視する」オプションを使用します。 スーパークラスのメソッドをオーバーライドまたは実装するメソッドを無視するには、メソッドのオーバーライド/スーパーメソッドの実装を無視する を使用します。",
                  "markdown": "メソッド数が指定された最大値を超えているクラスを報告します。\n\nメソッド数が多すぎるクラスは多くの場合、実行しようとしている処理の数が多すぎます。 このようなクラスは、より小さな複数のクラスに分割することを検討してください。\n\nインスペクションの構成:\n\n* クラスで許容されるメソッド数の最大値を指定するには、「**メソッド数の制限**」フィールドを使用します。\n* 単純な getter と setter を無視してメソッド数にカウントしないようにするには、「**単純な getter メソッドと setter メソッドを無視する**」オプションを使用します。\n* スーパークラスのメソッドをオーバーライドまたは実装するメソッドを無視するには、**メソッドのオーバーライド/スーパーメソッドの実装を無視する** を使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラスメトリクス",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForLoopReplaceableByWhile",
                "shortDescription": {
                  "text": "'while' ループで置換可能な 'for' ループ"
                },
                "fullDescription": {
                  "text": "初期化コンポーネントも更新コンポーネントも含まれていない 'for' ループを報告し、'while' ループに変換することを提案します。 この変換を行うと、コードが読みやすくなります。 例: 'for(; exitCondition(); ) {\n    process();\n  }' クイックフィックス適用後: 'while(exitCondition()) {\n    process();\n  }' このクイックフィックスは他の 'for' ループにも使用できるため、どんな 'for' ループでも 'while' ループに置換できます。 自明な条件または存在しない条件を含む 'for' ループを無視する場合は、「条件のない for 無限ループを無視する」オプションを使用します。",
                  "markdown": "初期化コンポーネントも更新コンポーネントも含まれていない `for` ループを報告し、`while` ループに変換することを提案します。 この変換を行うと、コードが読みやすくなります。\n\n例:\n\n\n      for(; exitCondition(); ) {\n        process();\n      }\n\nクイックフィックス適用後:\n\n\n      while(exitCondition()) {\n        process();\n      }\n\nこのクイックフィックスは他の `for` ループにも使用できるため、どんな `for` ループでも `while` ループに置換できます。\n\n自明な条件または存在しない条件を含む `for` ループを無視する場合は、「**条件のない for 無限ループを無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForLoopReplaceableByWhile",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryDefault",
                "shortDescription": {
                  "text": "列挙型の 'switch' ステートメントに不要な 'default'"
                },
                "fullDescription": {
                  "text": "想定されるすべての値が 'case' 分岐で網羅されているため、絶対に 'default' 分岐に入らない列挙型の 'switch' ステートメントまたは式を報告します。 特に 'switch' 式の場合、このような要素は冗長です。すべての列挙型定数が 'case' 分岐で網羅されていない場合、このような要素はコンパイルされないためです。 'switch' 式を報告するには、言語レベルを 14 に構成する必要があります。 提供されているクイックフィックスは、'default' 分岐を除去します。 例: 'enum E { A, B }\n  int foo(E e) {\n    return switch (e) {\n      case A -> 1;\n      case B -> 2;\n      default -> 3;\n    };\n  }' クイックフィックス適用後: 'enum E { A, B }\n  int foo(E e) {\n    return switch (e) {\n      case A -> 1;\n      case B -> 2;\n    };\n  }' switch 式の冗長な 'default' 分岐のみを報告するには、「switch 式のみを報告する」オプションを使用します。",
                  "markdown": "想定されるすべての値が `case` 分岐で網羅されているため、絶対に `default` 分岐に入らない列挙型の `switch` ステートメントまたは式を報告します。\n\n特に `switch` 式の場合、このような要素は冗長です。すべての列挙型定数が `case` 分岐で網羅されていない場合、このような要素はコンパイルされないためです。\n\n\n`switch` 式を報告するには、言語レベルを 14 に構成する必要があります。\n\n提供されているクイックフィックスは、`default` 分岐を除去します。\n\n例:\n\n\n      enum E { A, B }\n      int foo(E e) {\n        return switch (e) {\n          case A -> 1;\n          case B -> 2;\n          default -> 3;\n        };\n      }\n\nクイックフィックス適用後:\n\n\n      enum E { A, B }\n      int foo(E e) {\n        return switch (e) {\n          case A -> 1;\n          case B -> 2;\n        };\n      }\n\nswitch 式の冗長な `default` 分岐のみを報告するには、「**switch 式のみを報告する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryDefault",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticFieldReferenceOnSubclass",
                "shortDescription": {
                  "text": "サブクラスを介して参照される static フィールド"
                },
                "fullDescription": {
                  "text": "static フィールドへのアクセスのうち、呼び出しが宣言クラス自体ではなく、宣言クラスのサブクラスによって修飾されているものを報告します。 Java ではこのような修飾が可能ですが、このようなアクセスは継承とオーバーライドが微妙に混同されている可能性を示しています。 例: 'class Parent {\n    static int foo = 0;\n  }\n\n  class Child extends Parent { }\n\n  void bar() {\n    System.out.println(Child.foo);\n  }' クイックフィックスを適用した結果: 'class Parent {\n    static int foo = 0;\n  }\n\n  class Child extends Parent { }\n\n  void bar() {\n    System.out.println(Parent.foo);\n  }'",
                  "markdown": "static フィールドへのアクセスのうち、呼び出しが宣言クラス自体ではなく、宣言クラスのサブクラスによって修飾されているものを報告します。\n\n\nJava ではこのような修飾が可能ですが、このようなアクセスは継承とオーバーライドが微妙に混同されている可能性を示しています。\n\n**例:**\n\n\n      class Parent {\n        static int foo = 0;\n      }\n\n      class Child extends Parent { }\n\n      void bar() {\n        System.out.println(Child.foo);\n      }\n\nクイックフィックスを適用した結果:\n\n\n      class Parent {\n        static int foo = 0;\n      }\n\n      class Child extends Parent { }\n\n      void bar() {\n        System.out.println(Parent.foo);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticFieldReferencedViaSubclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VolatileArrayField",
                "shortDescription": {
                  "text": "volatile 配列フィールド"
                },
                "fullDescription": {
                  "text": "'volatile' で宣言されている配列フィールドを報告します。 このような宣言は誤解を招く可能性があります。配列自体へのアクセスは 'volatile' フィールドのルールに従っていますが、配列の内容へのアクセスでは同じルールに従っていないためです。 例: 'class Data {\n    private volatile int[] idx = new int[0];\n  }' 配列の内容に対してこのような volatile アクセスが必要な場合は、代わりに 'java.util.concurrent.atomic' クラスの使用を検討してください。 'class Data {\n    private final AtomicIntegerArray idx = new AtomicIntegerArray(new int[0]);\n  }'",
                  "markdown": "`volatile` で宣言されている配列フィールドを報告します。 このような宣言は誤解を招く可能性があります。配列自体へのアクセスは `volatile` フィールドのルールに従っていますが、配列の内容へのアクセスでは同じルールに従っていないためです。\n\n**例:**\n\n\n      class Data {\n        private volatile int[] idx = new int[0];\n      }\n\n\n配列の内容に対してこのような volatile アクセスが必要な場合は、代わりに `java.util.concurrent.atomic` クラスの使用を検討してください。\n\n\n      class Data {\n        private final AtomicIntegerArray idx = new AtomicIntegerArray(new int[0]);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VolatileArrayField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryInheritDoc",
                "shortDescription": {
                  "text": "不要な '{@inheritDoc}' Javadoc コメント"
                },
                "fullDescription": {
                  "text": "'{@inheritDoc}' タグのみを含む Javadoc コメントを報告します。 Javadoc はコメントが存在しない場合にスーパークラスのコメントをコピーするため、'{@inheritDoc}' のみを含むコメントがある場合は何も追加されません。 また、'{@inheritDoc}' がフィールド内などの不適切な場所で使用されている場合も報告します。 不要な Javadoc コメントの除去を提案します。 例: 'class Example implements Comparable<Example> {\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int compareTo(Example o) {\n      return 0;\n    }\n  }' クイックフィックス適用後: 'class Example implements Comparable<Example> {\n    @Override\n    public int compareTo(Example o) {\n      return 0;\n    }\n  }'",
                  "markdown": "`{@inheritDoc}` タグのみを含む Javadoc コメントを報告します。 Javadoc はコメントが存在しない場合にスーパークラスのコメントをコピーするため、`{@inheritDoc}` のみを含むコメントがある場合は何も追加されません。\n\nまた、`{@inheritDoc}` がフィールド内などの不適切な場所で使用されている場合も報告します。\n\n不要な Javadoc コメントの除去を提案します。\n\n**例:**\n\n\n      class Example implements Comparable<Example> {\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int compareTo(Example o) {\n          return 0;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Example implements Comparable<Example> {\n        @Override\n        public int compareTo(Example o) {\n          return 0;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryInheritDoc",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BlockingMethodInNonBlockingContext",
                "shortDescription": {
                  "text": "ノンブロッキングコンテキストでブロッキング呼び出しの可能性あり"
                },
                "fullDescription": {
                  "text": "スレッドをブロックしてはならないコードフラグメント内にあるスレッドブロックメソッド呼び出しを報告します。 例 (プロジェクト Reactor): 'Flux.just(\"1\").flatMap(f -> {\n    Flux<String> just = loadUsersFromDatabase();\n    just.toIterable(); // エラー: 非ブロックスコープ内でのブロック演算子の呼び出し\n    return just;\n  }\n);' 'Schedulers.boundedElastic()' などの適切なスケジューラーでブロックコードを実行することを検討するか、代替の非ブロック API を見つけてください。 例 (Kotlin コルーチン): 'suspend fun exampleFun() {\n    Thread.sleep(100); // エラー: suspend 関数内でブロックメソッドを呼び出しています\n}' 'Dispatchers.IO' などの特別なディスパッチャーでブロックコードを実行することを検討するか、代替の非ブロック API を見つけてください。 インスペクションの構成: 「ブロックアノテーション」リストでは、スレッドブロックメソッドをマークするアノテーションを指定します。 「非ブロックアノテーション」リストでは、非ブロックメソッドをマークするアノテーションを指定します。 指定したアノテーションは外部アノテーションとして使用できます。",
                  "markdown": "スレッドをブロックしてはならないコードフラグメント内にあるスレッドブロックメソッド呼び出しを報告します。\n\n**例 (プロジェクト Reactor):**\n\n\n    Flux.just(\"1\").flatMap(f -> {\n        Flux<String> just = loadUsersFromDatabase();\n        just.toIterable(); // エラー: 非ブロックスコープ内でのブロック演算子の呼び出し\n        return just;\n      }\n    );\n\n`Schedulers.boundedElastic()` などの[適切なスケジューラーで](https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking)ブロックコードを実行することを検討するか、代替の非ブロック API を見つけてください。\n\n**例 (Kotlin コルーチン):**\n\n\n    suspend fun exampleFun() {\n        Thread.sleep(100); // エラー: suspend 関数内でブロックメソッドを呼び出しています\n    }\n\n`Dispatchers.IO` などの[特別なディスパッチャーで](https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html)ブロックコードを実行することを検討するか、代替の非ブロック API を見つけてください。\n\nインスペクションの構成:\n\n* 「**ブロックアノテーション**」リストでは、スレッドブロックメソッドをマークするアノテーションを指定します。\n* 「**非ブロックアノテーション**」リストでは、非ブロックメソッドをマークするアノテーションを指定します。\n\n指定したアノテーションは[外部アノテーション](https://www.jetbrains.com/help/idea/external-annotations.html)として使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BlockingMethodInNonBlockingContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IgnoreResultOfCall",
                "shortDescription": {
                  "text": "メソッド呼び出しの結果を無視"
                },
                "fullDescription": {
                  "text": "結果が無視されているメソッド呼び出しを報告します。 多くのメソッドでは結果を無視してもまったく問題ありませんが、一部のメソッドではほぼ間違いなくエラーになります。 結果を無視するとエラーが発生する可能性が高いメソッドの例には、実際に読み込んだバイト数を返す 'java.io.inputStream.read()' や、'java.lang.String' または 'java.math.BigInteger' のメソッドなどが挙げられます。 これらのメソッドは副作用を引き起こさないため、結果が無視されている場合は無意味です。 次のメソッドの呼び出しが検査されます。 単純な getter (フィールドを返す以外は何もしない) このインスペクションの設定で指定されているメソッド 'org.jetbrains.annotations.Contract(pure=true)' アノテーションが付いたメソッド .*.'CheckReturnValue' アノテーションが付いたメソッド 'javax.annotation.CheckReturnValue' アノテーションが付いたクラスまたはパッケージのメソッド すべての非ライブラリメソッド (オプション) Error Prone または AssertJ の '@CanIgnoreReturnValue' アノテーションが付いたメソッドの呼び出しは報告されません。 チェック対象のクラスを指定するには、インスペクションの設定を使用します。 メソッドの名前または名前パターンの照合には、Java の正規表現構文が使用されます。 クラスには、完全修飾名を使用してください。 各エントリは、クラスとそのすべての継承の両方に適用されます。",
                  "markdown": "結果が無視されているメソッド呼び出しを報告します。\n\n多くのメソッドでは結果を無視してもまったく問題ありませんが、一部のメソッドではほぼ間違いなくエラーになります。 結果を無視するとエラーが発生する可能性が高いメソッドの例には、実際に読み込んだバイト数を返す `java.io.inputStream.read()` や、`java.lang.String` または `java.math.BigInteger` のメソッドなどが挙げられます。 これらのメソッドは副作用を引き起こさないため、結果が無視されている場合は無意味です。\n\n次のメソッドの呼び出しが検査されます。\n\n* 単純な getter (フィールドを返す以外は何もしない)\n* このインスペクションの設定で指定されているメソッド\n* `org.jetbrains.annotations.Contract(pure=true)` アノテーションが付いたメソッド\n* .\\*.`CheckReturnValue` アノテーションが付いたメソッド\n* `javax.annotation.CheckReturnValue` アノテーションが付いたクラスまたはパッケージのメソッド\n* すべての非ライブラリメソッド (オプション)\n\nError Prone または AssertJ の `@CanIgnoreReturnValue` アノテーションが付いたメソッドの呼び出しは報告されません。\n\n\nチェック対象のクラスを指定するには、インスペクションの設定を使用します。\nメソッドの名前または名前パターンの照合には、Java の正規表現構文が使用されます。\nクラスには、完全修飾名を使用してください。 各エントリは、クラスとそのすべての継承の両方に適用されます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ResultOfMethodCallIgnored",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonReproducibleMathCall",
                "shortDescription": {
                  "text": "'Math' への再現不可能な呼び出し"
                },
                "fullDescription": {
                  "text": "常に同じ結果が保証されるとは限らない 'java.lang.Math' メソッドの呼び出しを報告します。 常に同じ結果が要求される状況では、'java.lang.StrictMath' を代わりに使用してください。",
                  "markdown": "常に同じ結果が保証されるとは限らない `java.lang.Math` メソッドの呼び出しを報告します。\n\n常に同じ結果が要求される状況では、`java.lang.StrictMath` を代わりに使用してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonReproducibleMathCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParametersPerConstructor",
                "shortDescription": {
                  "text": "パラメーターが多すぎるコンストラクター"
                },
                "fullDescription": {
                  "text": "パラメーター数が指定された最大値を超えているコンストラクターを報告します。 このようなオブジェクトは、パラメーターの一部が省略可能になっている場合などにインスタンス化するのが困難です。 パラメーターが多すぎるコンストラクターは、リファクタリングが必要な可能性があります。 たとえば、Builder パターンを適用することを検討してください。 例: 'public BankAccount(long accountNumber,\n                     String owner,\n                     double balance,\n                     double interestRate) {\n    // フィールドの初期化\n  }' インスペクションの構成: コンストラクターで許容されるパラメーター数の最大値を指定するには、「パラメーターの制限」フィールドを使用します。 特定の可視性を持つコンストラクターをこのインスペクションが無視するかどうかを指定するには、この可視性を持つコンストラクターを無視する リストを使用します。",
                  "markdown": "パラメーター数が指定された最大値を超えているコンストラクターを報告します。 このようなオブジェクトは、パラメーターの一部が省略可能になっている場合などにインスタンス化するのが困難です。 パラメーターが多すぎるコンストラクターは、リファクタリングが必要な可能性があります。 たとえば、Builder パターンを適用することを検討してください。\n\n**例:**\n\n\n      public BankAccount(long accountNumber,\n                         String owner,\n                         double balance,\n                         double interestRate) {\n        // フィールドの初期化\n      }\n\nインスペクションの構成:\n\n* コンストラクターで許容されるパラメーター数の最大値を指定するには、「**パラメーターの制限**」フィールドを使用します。\n* 特定の可視性を持つコンストラクターをこのインスペクションが無視するかどうかを指定するには、**この可視性を持つコンストラクターを無視する** リストを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstructorWithTooManyParameters",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メソッドメトリクス",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertBetweenInconvertibleTypes",
                "shortDescription": {
                  "text": "互換性のない型のオブジェクト間の 'assertEquals()'"
                },
                "fullDescription": {
                  "text": "\"expected\" 引数と \"actual\" 引数の型に互換性がないアサーションメソッドの呼び出しを報告します。 このような呼び出しの存在は多くの場合、テストにバグがあることを示しています。 このインスペクションは、関連する JUnit、TestNG、および AssertJ メソッドをチェックします。 例: 'assertEquals(\"1\", 1);\n  assertNotSame(new int[0], 0);\n\n  // 弱い警告、equals() 契約をテストしているだけの可能性もあります\n  assertThat(foo).as(\"user type\").isNotEqualTo(bar);'",
                  "markdown": "\"expected\" 引数と \"actual\" 引数の型に互換性がないアサーションメソッドの呼び出しを報告します。\n\nこのような呼び出しの存在は多くの場合、テストにバグがあることを示しています。\nこのインスペクションは、関連する JUnit、TestNG、および AssertJ メソッドをチェックします。\n\n**例:**\n\n\n      assertEquals(\"1\", 1);\n      assertNotSame(new int[0], 0);\n\n      // 弱い警告、equals() 契約をテストしているだけの可能性もあります\n      assertThat(foo).as(\"user type\").isNotEqualTo(bar);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertBetweenInconvertibleTypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語/テストフレームワーク",
                      "index": 93,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MappingBeforeCount",
                "shortDescription": {
                  "text": "count() 前のマッピング呼び出し"
                },
                "fullDescription": {
                  "text": "'count()' 呼び出し直前の 'map()' または 'boxed()' などの冗長な 'Stream' API 呼び出しを報告します。 このような呼び出しは最終カウントを変更しないため、除去できます。 コードがこのような map 呼び出し内のラムダによる副作用に依存している可能性があります。 ただし、stream チェーン内の副作用に依存するのは非常に悪いやり方です。 この呼び出しが今後の Java バージョンで最適化されないという保証はありません。 例: '// map() の呼び出しは冗長です\n  long count = list.stream().filter(s -> !s.isEmpty()).map(s -> s.trim()).count();' 2024.1 の新機能です このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "`count()` 呼び出し直前の `map()` または `boxed()` などの冗長な `Stream` API 呼び出しを報告します。\n\n\nこのような呼び出しは最終カウントを変更しないため、除去できます。 コードがこのような map 呼び出し内のラムダによる副作用に依存している可能性があります。 ただし、stream チェーン内の副作用に依存するのは非常に悪いやり方です。 この呼び出しが今後の Java バージョンで最適化されないという保証はありません。\n\n**例:**\n\n\n      // map() の呼び出しは冗長です\n      long count = list.stream().filter(s -> !s.isEmpty()).map(s -> s.trim()).count();\n\n2024.1 の新機能です\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MappingBeforeCount",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchExpressionCanBePushedDown",
                "shortDescription": {
                  "text": "共通の部分式を 'switch' から抽出できます"
                },
                "fullDescription": {
                  "text": "各分岐に共通のサブ式があるため、switch を内側に移動できる 'switch' 式とステートメントを報告します。 そのように処理することで、コード量を削減できます。 多くの場合において、結果の switch 式を個別の変数またはメソッドに抽出することは適切です。 例: 'switch (value) {\n    case 0 -> System.out.println(\"zero\");\n    case 1 -> System.out.println(\"one\");\n    case 2, 3, 4 -> System.out.println(\"few\");\n    default -> System.out.println(\"many\");\n  }' クイックフィックス適用後: 'System.out.println(switch (value) {\n    case 0 -> \"zero\";\n    case 1 -> \"one\";\n    case 2, 3, 4 -> \"few\";\n    default -> \"many\";\n  });' このインスペクションはアロー構文を使用する拡張 switch にのみ適用できます。 2022.3 の新機能です このインスペクションは Java 14 以降で使用できる Java の機能 ''switch' 式' に依存しています。",
                  "markdown": "各分岐に共通のサブ式があるため、switch を内側に移動できる `switch` 式とステートメントを報告します。 そのように処理することで、コード量を削減できます。 多くの場合において、結果の switch 式を個別の変数またはメソッドに抽出することは適切です。\n\n例:\n\n\n      switch (value) {\n        case 0 -> System.out.println(\"zero\");\n        case 1 -> System.out.println(\"one\");\n        case 2, 3, 4 -> System.out.println(\"few\");\n        default -> System.out.println(\"many\");\n      }\n\nクイックフィックス適用後:\n\n\n      System.out.println(switch (value) {\n        case 0 -> \"zero\";\n        case 1 -> \"one\";\n        case 2, 3, 4 -> \"few\";\n        default -> \"many\";\n      });\n\n\nこのインスペクションはアロー構文を使用する拡張 switch にのみ適用できます。\n\n2022.3 の新機能です\n\nこのインスペクションは Java 14 以降で使用できる Java の機能 ''switch' 式' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SwitchExpressionCanBePushedDown",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonExtendableApiUsage",
                "shortDescription": {
                  "text": "拡張してはいけないクラス、インターフェース、またはメソッド"
                },
                "fullDescription": {
                  "text": "'@ApiStatus.NonExtendable' でマークされている API 要素を拡張、実装、またはオーバーライドしているクラス、インターフェース、メソッドを報告します。 '@ApiStatus.NonExtendable' アノテーションは、クラス、インターフェースまたはメソッドが 拡張、実装、またはオーバーライドしてはならないことを示します。 このようなインターフェースとクラスを内部ライブラリの実装にキャストすることはかなり一般的であるため、クライアントが異なる実装を提供している場合は、'ClassCastException' がスローされます。 このようなクラスとインターフェースに新規の抽象メソッドを追加すると、クライアントの実装との互換性が失われます。",
                  "markdown": "`@ApiStatus.NonExtendable` でマークされている API 要素を拡張、実装、またはオーバーライドしているクラス、インターフェース、メソッドを報告します。\n\n\n`@ApiStatus.NonExtendable` アノテーションは、クラス、インターフェースまたはメソッドが **拡張、実装、またはオーバーライドしてはならない** ことを示します。\nこのようなインターフェースとクラスを内部ライブラリの実装にキャストすることはかなり一般的であるため、クライアントが異なる実装を提供している場合は、`ClassCastException` がスローされます。\nこのようなクラスとインターフェースに新規の抽象メソッドを追加すると、クライアントの実装との互換性が失われます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonExtendableApiUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnqualifiedFieldAccess",
                "shortDescription": {
                  "text": "インスタンスのフィールドアクセスが 'this' で修飾されていません"
                },
                "fullDescription": {
                  "text": "'this' またはその他の修飾子で修飾されていないフィールドアクセス演算を報告します。 一部のコードスタイルは、ローカル変数またはパラメーターアクセスとの混同を避けるため、すべてのフィールドアクセス演算に修飾子を付けることを要求しています。 例: 'class Foo {\n    int foo;\n\n    void bar() {\n      foo += 1;\n    }\n  }' クイックフィックス適用後: 'class Foo {\n    int foo;\n\n    void bar() {\n      this.foo += 1;\n    }\n  }'",
                  "markdown": "`this` またはその他の修飾子で修飾されていないフィールドアクセス演算を報告します。\n\n\n一部のコードスタイルは、ローカル変数またはパラメーターアクセスとの混同を避けるため、すべてのフィールドアクセス演算に修飾子を付けることを要求しています。\n\n**例:**\n\n\n      class Foo {\n        int foo;\n\n        void bar() {\n          foo += 1;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        int foo;\n\n        void bar() {\n          this.foo += 1;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnqualifiedFieldAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedCollectionQueryUpdate",
                "shortDescription": {
                  "text": "コレクションのクエリおよび更新の不一致"
                },
                "fullDescription": {
                  "text": "内容が照会されているが更新されていない、または更新されているが照会されていないコレクションを報告します。 このような一貫性のない照会と更新は無意味であり、デッドコードかタイポの可能性があります。 更新または照会メソッドに対応する名前パターンを指定するには、インスペクションの設定を使用します。 要素を返す照会メソッドは自動的に検出されるため、出力パラメーター ('OutputStream' など) にデータを書き込む照会メソッドのみを指定する必要があります。 例: 次のようなメソッド 'store()' を持つ独自の 'FixedStack' クラスがあるとします。 'public class FixedStack<T> extends Collection<T> {\n    public T store(T t) {\n      // 実装\n    }\n  }' 次のように、不一致の照会を報告するために更新メソッドのテーブルに 'store' を追加できます。 'void test(int i) {\n    FixedStack<Integer> stack = new FixedStack<>();\n    stack.store(i);\n  }'",
                  "markdown": "内容が照会されているが更新されていない、または更新されているが照会されていないコレクションを報告します。\n\n\nこのような一貫性のない照会と更新は無意味であり、デッドコードかタイポの可能性があります。\n\n\n更新または照会メソッドに対応する名前パターンを指定するには、インスペクションの設定を使用します。\n要素を返す照会メソッドは自動的に検出されるため、出力パラメーター (`OutputStream` など) にデータを書き込む照会メソッドのみを指定する必要があります。\n\n\n**例:**\n\n次のようなメソッド `store()` を持つ独自の `FixedStack` クラスがあるとします。\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // 実装\n        }\n      }\n\n次のように、不一致の照会を報告するために更新メソッドのテーブルに `store` を追加できます。\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedQueryAndUpdateOfCollection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CharacterComparison",
                "shortDescription": {
                  "text": "文字比較"
                },
                "fullDescription": {
                  "text": "'char' 値の序数比較を報告します。 国際化環境では、このような比較が正しいことはめったにありません。",
                  "markdown": "`char` 値の序数比較を報告します。 国際化環境では、このような比較が正しいことはめったにありません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CharacterComparison",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InnerClassReferencedViaSubclass",
                "shortDescription": {
                  "text": "サブクラスで参照される内部クラス"
                },
                "fullDescription": {
                  "text": "内部クラスおよびネストしたクラスのアクセスのうち、呼び出しが宣言クラス自体ではなく、宣言クラスのサブクラスによって修飾されているものを報告します。 Java ではこのような修飾が可能ですが、このようなアクセスは継承とオーバーライドが微妙に混同されている可能性を示しています。 例: 'class Super {\n    static class Inner {}\n  }\n\n  class Sub extends Super {\n    void test() {\n      Sub.Inner s = new Sub.Inner(); // 'Inner' クラスは 'Super' クラスで宣言されていますが、 'Sub' クラス経由で参照されています\n    }\n  }' クイックフィックス適用後: 'class Super {\n    static class Inner {}\n  }\n\n  class Sub extends Super {\n    void test() {\n      Super.Inner s = new Super.Inner();\n    }\n  }'",
                  "markdown": "内部クラスおよびネストしたクラスのアクセスのうち、呼び出しが宣言クラス自体ではなく、宣言クラスのサブクラスによって修飾されているものを報告します。\n\n\nJava ではこのような修飾が可能ですが、このようなアクセスは継承とオーバーライドが微妙に混同されている可能性を示しています。\n\n**例:**\n\n\n      class Super {\n        static class Inner {}\n      }\n\n      class Sub extends Super {\n        void test() {\n          Sub.Inner s = new Sub.Inner(); // 'Inner' クラスは 'Super' クラスで宣言されていますが、 'Sub' クラス経由で参照されています\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Super {\n        static class Inner {}\n      }\n\n      class Sub extends Super {\n        void test() {\n          Super.Inner s = new Super.Inner();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassReferencedViaSubclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfusingElse",
                "shortDescription": {
                  "text": "冗長な 'else'"
                },
                "fullDescription": {
                  "text": "'if'—'else' ステートメントとステートメントチェーンにある冗長な 'else' キーワードを報告します。 'else' キーワードは、先行するすべての分岐が 'return'、'throw'、'break'、または 'continue' ステートメントで終わっている場合には冗長です。 この場合は、'else' 分岐のステートメントを 'if' ステートメントの後に記述し、'else' キーワードを除去できます。 例: 'if (name == null) {\n      throw new IllegalArgumentException();\n  } else {\n      System.out.println(name);\n  }' クイックフィックス適用後: 'if (name == null) {\n      throw new IllegalArgumentException();\n  }\n  System.out.println(name);' コードブロックの最後のステートメントが 'if'—'else' ステートメントである場合を無視するには、「'if' ステートメントの後にステートメントが存在しない場合に報告する」オプションを無効にします。",
                  "markdown": "`if`---`else` ステートメントとステートメントチェーンにある冗長な `else` キーワードを報告します。\n\n\n`else` キーワードは、先行するすべての分岐が `return`、`throw`、`break`、または `continue` ステートメントで終わっている場合には冗長です。 この場合は、`else` 分岐のステートメントを `if` ステートメントの後に記述し、`else` キーワードを除去できます。\n\n**例:**\n\n\n      if (name == null) {\n          throw new IllegalArgumentException();\n      } else {\n          System.out.println(name);\n      }\n\nクイックフィックス適用後:\n\n\n      if (name == null) {\n          throw new IllegalArgumentException();\n      }\n      System.out.println(name);\n\nコードブロックの最後のステートメントが `if`---`else` ステートメントである場合を無視するには、「**'if' ステートメントの後にステートメントが存在しない場合に報告する**」オプションを無効にします。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConfusingElseBranch",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChannelResource",
                "shortDescription": {
                  "text": "'Channel' を開きましたが、安全に閉じられていません"
                },
                "fullDescription": {
                  "text": "安全に閉じられていない 'Channel' リソースを報告します (ファイルまたはソケットリソースで 'getChannel()' を呼び出すことによって作成されたインスタンスも対象です)。 デフォルトでは、このインスペクションは名前に 'close' または 'cleanup' を含む任意のメソッドでリソースを閉じることができると想定しています。 例: 'void send(Socket socket) throws IOException {\n    SocketChannel channel = socket.getChannel(); //警告\n    channel.write(ByteBuffer.wrap(\"message\".getBytes()));\n  }' このインスペクションは、次のオプションを使用して構成できます。 'try' ブロック内で 'Channel' リソースを開くことを許可するかどうか。 このスタイルは 'try' ブロックの前で 'Channel' を開く場合よりも冗長であるため、あまり望ましくありません。 リソースが引数として渡されている任意のメソッド呼び出しでリソースを閉じることができるかどうか。",
                  "markdown": "安全に閉じられていない `Channel` リソースを報告します (ファイルまたはソケットリソースで `getChannel()` を呼び出すことによって作成されたインスタンスも対象です)。\n\n\nデフォルトでは、このインスペクションは名前に 'close' または 'cleanup' を含む任意のメソッドでリソースを閉じることができると想定しています。\n\n**例:**\n\n\n      void send(Socket socket) throws IOException {\n        SocketChannel channel = socket.getChannel(); //警告\n        channel.write(ByteBuffer.wrap(\"message\".getBytes()));\n      }\n\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* `try` ブロック内で `Channel` リソースを開くことを許可するかどうか。 このスタイルは `try` ブロックの前で `Channel` を開く場合よりも冗長であるため、あまり望ましくありません。\n* リソースが引数として渡されている任意のメソッド呼び出しでリソースを閉じることができるかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ChannelOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/リソース管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ScheduledThreadPoolExecutorWithZeroCoreThreads",
                "shortDescription": {
                  "text": "コアスレッドがゼロの 'ScheduledThreadPoolExecutor'"
                },
                "fullDescription": {
                  "text": "'setCorePoolSize' メソッドまたはオブジェクトコンストラクターを介して、'corePoolSize' がゼロに設定されている 'java.util.concurrent.ScheduledThreadPoolExecutor' インスタンスを報告します。 コアスレッドがゼロの 'ScheduledThreadPoolExecutor' は何も実行しません。 例: 'void foo(int corePoolSize) {\n      if (corePoolSize != 0) return;\n      ThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(corePoolSize); // 警告\n      executor.setCorePoolSize(corePoolSize); // 警告\n  }'",
                  "markdown": "`setCorePoolSize` メソッドまたはオブジェクトコンストラクターを介して、`corePoolSize` がゼロに設定されている `java.util.concurrent.ScheduledThreadPoolExecutor` インスタンスを報告します。\n\n\nコアスレッドがゼロの `ScheduledThreadPoolExecutor` は何も実行しません。\n\n**例:**\n\n\n      void foo(int corePoolSize) {\n          if (corePoolSize != 0) return;\n          ThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(corePoolSize); // 警告\n          executor.setCorePoolSize(corePoolSize); // 警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ScheduledThreadPoolExecutorWithZeroCoreThreads",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizeOnThis",
                "shortDescription": {
                  "text": "'this' の同期"
                },
                "fullDescription": {
                  "text": "'this' または 'class' 式での同期を報告します。 報告対象のコンストラクトには、'synchronized' ブロック、'wait()'、'notify()' または 'notifyAll()' の呼び出しが含まれます。 'this' または 'class' 式での同期が良くない理由はいくつかあります。 同期がクラスの外部インターフェースに組み込まれるため、将来的に異なるロック機構に変更するのが難しくなる。 所定のオブジェクトをロックしているコードを単に追跡するのが難しくなる。 サービス拒否攻撃の原因になり得る。意図的な場合もあれば、サブクラス化の際に偶発的に発生しやすくなる場合も考えられます。 代わりに、'private final' ロックオブジェクトでの同期を検討してください。この場合、ロックオブジェクトへのアクセスを完全に制御できます。 例: 'public void print() {\n    synchronized(this) { // 警告: 'this' に対してロック操作を行うと、予期しない副作用が発生する可能性があります\n      System.out.println(\"synchronized\");\n    }\n  }'",
                  "markdown": "`this` または `class` 式での同期を報告します。 報告対象のコンストラクトには、`synchronized` ブロック、`wait()`、`notify()` または `notifyAll()` の呼び出しが含まれます。\n\n`this` または `class` 式での同期が良くない理由はいくつかあります。\n\n1. 同期がクラスの外部インターフェースに組み込まれるため、将来的に異なるロック機構に変更するのが難しくなる。\n2. 所定のオブジェクトをロックしているコードを単に追跡するのが難しくなる。\n3. サービス拒否攻撃の原因になり得る。意図的な場合もあれば、サブクラス化の際に偶発的に発生しやすくなる場合も考えられます。\n\n代わりに、`private final` ロックオブジェクトでの同期を検討してください。この場合、ロックオブジェクトへのアクセスを完全に制御できます。\n\n**例:**\n\n\n      public void print() {\n        synchronized(this) { // 警告: 'this' に対してロック操作を行うと、予期しない副作用が発生する可能性があります\n          System.out.println(\"synchronized\");\n        }\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizeOnThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaEmptyModuleInfoFile",
                "shortDescription": {
                  "text": "空の 'module-info.java' ファイル"
                },
                "fullDescription": {
                  "text": "空の 'module-info.java' ファイルを報告し、未解決のモジュール依存関係があることを示します。 また、インポートを検査して自動的に必要な 'requires' ステートメントを追加します。 この警告を抑制するには、以下のようにモジュールステートメントの本体内にコメントを書いてください。 'module module.name {\n    // 依存関係なし\n}' クイックフィックス: 「モジュール依存関係の補完 」により、ソースコードのインポートに基づいて足りない 'requires' が補完されます。 2024.1 の新機能です",
                  "markdown": "空の `module-info.java` ファイルを報告し、未解決のモジュール依存関係があることを示します。 また、インポートを検査して自動的に必要な `requires` ステートメントを追加します。 この警告を抑制するには、以下のようにモジュールステートメントの本体内にコメントを書いてください。\n\n\n    module module.name {\n        // 依存関係なし\n    }\n\n**クイックフィックス:** 「*モジュール依存関係の補完* 」により、ソースコードのインポートに基づいて足りない `requires` が補完されます。 2024.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaEmptyModuleInfoFile",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedAssignment",
                "shortDescription": {
                  "text": "使用されない代入"
                },
                "fullDescription": {
                  "text": "代入後に使用されていない代入値を報告します。 代入値が使用されていない場合は、その代入を除去してコードを短縮し、冗長な代入を回避することをお勧めします。 次のケースが報告されます。 代入後にまったく読み取られていない変数 読み取られる前に常に新しい値で上書きされている変数 (上記の 2 つの理由のうち 1 つが原因で) 冗長になっている変数のイニシャライザー インスペクションの構成: 冗長なイニシャライザーを報告するには、「冗長なイニシャライザーを報告する」オプションを使用します。 'int getI() {\n    int i = 0; // 冗長な初期化\n    i = 2;\n    return i;\n  }' '++i' 式を 'i + 1' に置換できる状況を報告するには、「二項式に置換できる前置式を報告する」オプションを使用します。 'int preInc(int value) {\n    int res = value;\n    return ++res;\n  }' 'i' の値が後で使用されていない 'i++' がある状況を報告するには、「変更された値が使用されていない後置式を報告する」オプションを使用します。 'int postInc(int value) {\n    int res = value;\n    return res++;\n  }' パターン変数の値が読み取られる前に上書きされている状況を報告するには、「値が使用されていないパターン変数を報告する」オプションを報告します。 'if (object instanceof String s) {\n      s = \"hello\";\n      System.out.println(s);\n  }' 強化された 'for' ステートメントの反復パラメーター値が読み取られる前に上書きされている状況を報告するには、「値が使用されていない反復パラメーターを報告する」オプションを使用します。 'for (String arg : args) {\n      arg = \"test\";\n      System.out.println(arg);\n  }'",
                  "markdown": "代入後に使用されていない代入値を報告します。 代入値が使用されていない場合は、その代入を除去してコードを短縮し、冗長な代入を回避することをお勧めします。\n\n次のケースが報告されます。\n\n* 代入後にまったく読み取られていない変数\n* 読み取られる前に常に新しい値で上書きされている変数\n* (上記の 2 つの理由のうち 1 つが原因で) 冗長になっている変数のイニシャライザー\n\nインスペクションの構成:\n\n\n冗長なイニシャライザーを報告するには、「**冗長なイニシャライザーを報告する**」オプションを使用します。\n\n\n      int getI() {\n        int i = 0; // 冗長な初期化\n        i = 2;\n        return i;\n      }\n\n\n`++i` 式を `i + 1` に置換できる状況を報告するには、「**二項式に置換できる前置式を報告する**」オプションを使用します。\n\n\n      int preInc(int value) {\n        int res = value;\n        return ++res;\n      }\n\n\n`i` の値が後で使用されていない `i++` がある状況を報告するには、「**変更された値が使用されていない後置式を報告する**」オプションを使用します。\n\n\n      int postInc(int value) {\n        int res = value;\n        return res++;\n      }\n\n\nパターン変数の値が読み取られる前に上書きされている状況を報告するには、「**値が使用されていないパターン変数を報告する**」オプションを報告します。\n\n\n      if (object instanceof String s) {\n          s = \"hello\";\n          System.out.println(s);\n      }\n\n\n強化された `for` ステートメントの反復パラメーター値が読み取られる前に上書きされている状況を報告するには、「**値が使用されていない反復パラメーターを報告する**」オプションを使用します。\n\n\n      for (String arg : args) {\n          arg = \"test\";\n          System.out.println(arg);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HashCodeUsesNonFinalVariable",
                "shortDescription": {
                  "text": "'hashCode()' で参照される非 final のフィールド"
                },
                "fullDescription": {
                  "text": "非 'final' 変数にアクセスしている 'hashCode()' の実装を報告します。 このようなアクセスを行うと、'hashCode()' がオブジェクトのライフサイクルのさまざまな時点で異なる値を返す可能性があります。その結果、標準コレクションクラスを使用する際に問題が発生する可能性があります。 例: 'class Drink {\n    String name;\n    Drink(String name) { this.name = name; }\n    @Override public int hashCode() {\n      return Objects.hash(name); //警告\n    }\n  }\n  ...\n    Drink coffee = new Drink(\"Coffee\");\n    priceMap.put(coffee, 10.0);\n    coffee.name = \"Tea\";\n    double coffeePrice = priceMap.get(coffee); //見つかりません' フィールドを final にするクイックフィックスが提案されます。 'class Drink {\n    final String name;\n    ...\n  }'",
                  "markdown": "非 `final` 変数にアクセスしている `hashCode()` の実装を報告します。\n\n\nこのようなアクセスを行うと、`hashCode()` がオブジェクトのライフサイクルのさまざまな時点で異なる値を返す可能性があります。その結果、標準コレクションクラスを使用する際に問題が発生する可能性があります。\n\n**例:**\n\n\n      class Drink {\n        String name;\n        Drink(String name) { this.name = name; }\n        @Override public int hashCode() {\n          return Objects.hash(name); //警告\n        }\n      }\n      ...\n        Drink coffee = new Drink(\"Coffee\");\n        priceMap.put(coffee, 10.0);\n        coffee.name = \"Tea\";\n        double coffeePrice = priceMap.get(coffee); //見つかりません\n\nフィールドを final にするクイックフィックスが提案されます。\n\n\n      class Drink {\n        final String name;\n        ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldReferencedInHashCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProtectedField",
                "shortDescription": {
                  "text": "protected フィールド"
                },
                "fullDescription": {
                  "text": "'protected' フィールドを報告します。 定数 (すなわち、'static' または 'final' が付いた変数) は報告されません。 例: 'public class A {\n    protected Object object;              // 警告\n    protected final static int MODE = 0;  // 定数、警告なし\n  }'",
                  "markdown": "`protected` フィールドを報告します。\n\n定数 (すなわち、`static` または `final` が付いた変数) は報告されません。\n\n**例:**\n\n\n      public class A {\n        protected Object object;              // 警告\n        protected final static int MODE = 0;  // 定数、警告なし\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProtectedField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/カプセル化",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentUsedAsCondition",
                "shortDescription": {
                  "text": "条件として使用されている代入"
                },
                "fullDescription": {
                  "text": "'if'、'while'、'for'、'do' ステートメント、または条件式の条件として使用されている代入を報告します。 このような使用方法は意図的な場合もありますが、混乱を招き、タイポ ('==' ではなく '=' など) である可能性もあります。 このクイックフィックスは '=' を '==' に置換します。 例: 'void update(String str, boolean empty) {\n    // 警告: 'empty' が str.isEmpty() と\n    // 比較されることなく代入されています\n    if (empty = str.isEmpty()) {\n      ...\n    }\n  }' クイックフィックス適用後: 'void update(String str, boolean empty) {\n    if (empty == str.isEmpty()) {\n      ...\n    }\n  }'",
                  "markdown": "`if`、`while`、`for`、`do` ステートメント、または条件式の条件として使用されている代入を報告します。\n\nこのような使用方法は意図的な場合もありますが、混乱を招き、タイポ (`==` ではなく `=` など) である可能性もあります。\n\nこのクイックフィックスは `=` を `==` に置換します。\n\n**例:**\n\n\n      void update(String str, boolean empty) {\n        // 警告: 'empty' が str.isEmpty() と\n        // 比較されることなく代入されています\n        if (empty = str.isEmpty()) {\n          ...\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      void update(String str, boolean empty) {\n        if (empty == str.isEmpty()) {\n          ...\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentUsedAsCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代入関連の問題",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceofThis",
                "shortDescription": {
                  "text": "'this' の 'instanceof' チェック"
                },
                "fullDescription": {
                  "text": "'this' 式がチェックされている 'instanceof' または 'getClass() == SomeClass.class' の使用箇所を報告します。 このような式はオブジェクト指向設計に不備があることを示しており、ポリモーフィックな構文に置換する必要があります。 例: 'class Super {\n  void process() {\n    if (this instanceof Sub) { // 警告\n      doSomething();\n    } else {\n      doSomethingElse();\n    }\n  }\n}\n  \nclass Sub extends Super {}' この問題を解決するには、オーバーライドするメソッドを使用します。 'class Super {\n  void process() {\n    doSomethingElse();\n  }\n}\n  \nclass Sub extends Super {\n  @Override\n  void process() {\n    doSomething();\n  }\n}'",
                  "markdown": "`this` 式がチェックされている `instanceof` または `getClass() == SomeClass.class` の使用箇所を報告します。\n\nこのような式はオブジェクト指向設計に不備があることを示しており、ポリモーフィックな構文に置換する必要があります。\n\n例:\n\n\n    class Super {\n      void process() {\n        if (this instanceof Sub) { // 警告\n          doSomething();\n        } else {\n          doSomethingElse();\n        }\n      }\n    }\n      \n    class Sub extends Super {}\n\nこの問題を解決するには、オーバーライドするメソッドを使用します。\n\n\n    class Super {\n      void process() {\n        doSomethingElse();\n      }\n    }\n      \n    class Sub extends Super {\n      @Override\n      void process() {\n        doSomething();\n      }\n    }  \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceofThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassMayBeInterface",
                "shortDescription": {
                  "text": "'interface' にできる抽象 'class'"
                },
                "fullDescription": {
                  "text": "インターフェースに変換できる 'abstract' クラスを報告します。 Java では複数クラスの継承はサポートされていませんが、クラスが複数のインターフェースを実装することは可能です。このため、クラスではなく、インターフェースを使用することをお勧めします。 (Object 以外の) スーパークラスを持たず、'public static final' フィールド、'public abstract' メソッド、および 'public' 内部クラスのみを持つクラスはインターフェースに変換できます。 例: 'abstract class Example {\n    public static final int MY_CONST = 42;\n    public abstract void foo();\n}\n\nclass Inheritor extends Example {\n    @Override\n    public void foo() {\n        System.out.println(MY_CONST);\n    }\n}' クイックフィックス適用後: 'interface Example {\n    int MY_CONST = 42;\n    void foo();\n}\n\nclass Inheritor implements Example {\n    @Override\n    public void foo() {\n        System.out.println(MY_CONST);\n    }\n}' インスペクションの構成: 'default' メソッドに変換できる 'static' メソッドと非 abstract メソッドを持つクラスのみを報告するには、「Java 8 の使用時に非抽象メソッドを含むクラスを報告する」オプションを使用します (言語レベルが 8 以降の場合のみ)。",
                  "markdown": "インターフェースに変換できる `abstract` クラスを報告します。\n\nJava では複数クラスの継承はサポートされていませんが、クラスが複数のインターフェースを実装することは可能です。このため、クラスではなく、インターフェースを使用することをお勧めします。\n\n(Object 以外の) スーパークラスを持たず、`public static final` フィールド、`public abstract` メソッド、および `public` 内部クラスのみを持つクラスはインターフェースに変換できます。\n\n\n例:\n\n\n    abstract class Example {\n        public static final int MY_CONST = 42;\n        public abstract void foo();\n    }\n\n    class Inheritor extends Example {\n        @Override\n        public void foo() {\n            System.out.println(MY_CONST);\n        }\n    }\n\nクイックフィックス適用後:\n\n\n    interface Example {\n        int MY_CONST = 42;\n        void foo();\n    }\n\n    class Inheritor implements Example {\n        @Override\n        public void foo() {\n            System.out.println(MY_CONST);\n        }\n    }\n\nインスペクションの構成:\n\n\n`default` メソッドに変換できる `static` メソッドと非 abstract メソッドを持つクラスのみを報告するには、「**Java 8 の使用時に非抽象メソッドを含むクラスを報告する**」オプションを使用します (言語レベルが 8 以降の場合のみ)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ClassMayBeInterface",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageInMultipleModules",
                "shortDescription": {
                  "text": "複数のモジュールにクラスがあるパッケージ"
                },
                "fullDescription": {
                  "text": "複数モジュールに存在する空でないパッケージを報告します。 パッケージが複数のモジュールに含まれている場合、2 つのモジュールで同じ名前のクラスが作成される可能性が高まります。 これらのモジュールに依存するモジュールがそのようなクラスを使用しようとする場合、競合が発生します。 Java Platform Module System では、複数のモジュールに含まれているパッケージ (分割パッケージとも呼ばれる) は許可されません。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "複数モジュールに存在する空でないパッケージを報告します。 パッケージが複数のモジュールに含まれている場合、2 つのモジュールで同じ名前のクラスが作成される可能性が高まります。 これらのモジュールに依存するモジュールがそのようなクラスを使用しようとする場合、競合が発生します。 Java Platform Module System では、複数のモジュールに含まれているパッケージ (*分割パッケージ* とも呼ばれる) は許可されません。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageInMultipleModules",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パッケージ関連の問題",
                      "index": 37,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryCallToStringValueOf",
                "shortDescription": {
                  "text": "不要な 'String' への変換"
                },
                "fullDescription": {
                  "text": "'String.valueOf()' または 'Integer.toString()' など、パラメーターを文字列に変換する static メソッドへの不要な呼び出しを報告します。 このような呼び出しは文字列連結で使用される場合には不要です。 例: 'System.out.println(\"Number: \" + Integer.toString(count));' クイックフィックス適用後: 'System.out.println(\"Number: \" + count);' また、このような呼び出しは独自の文字列変換を行うライブラリメソッドの引数として使用される場合には不要です。 独自の文字列変換を行うライブラリメソッドの例をいくつか以下に示します。 クラス 'java.io.PrintWriter'、'java.io.PrintStream' 'print()'、'println()' クラス 'java.lang.StringBuilder'、'java.lang.StringBuffer' 'append()' クラス 'org.slf4j.Logger' 'trace()'、'debug()'、'info()'、'warn()'、'error()' 空文字列との連結を 'String.valueOf()' への呼び出しの代わりに使用できる状況も報告するには、「空文字列との連結に置換できる呼び出しを報告する」オプションを使用します。",
                  "markdown": "`String.valueOf()` または `Integer.toString()` など、パラメーターを文字列に変換する static メソッドへの不要な呼び出しを報告します。 このような呼び出しは文字列連結で使用される場合には不要です。\n\n例:\n\n\n      System.out.println(\"Number: \" + Integer.toString(count));\n\nクイックフィックス適用後:\n\n\n      System.out.println(\"Number: \" + count);\n\nまた、このような呼び出しは独自の文字列変換を行うライブラリメソッドの引数として使用される場合には不要です。 独自の文字列変換を行うライブラリメソッドの例をいくつか以下に示します。\n\n* クラス `java.io.PrintWriter`、`java.io.PrintStream`\n  * `print()`、`println()`\n* クラス `java.lang.StringBuilder`、`java.lang.StringBuffer`\n  * `append()`\n* クラス `org.slf4j.Logger`\n  * `trace()`、`debug()`、`info()`、`warn()`、`error()`\n\n\n空文字列との連結を `String.valueOf()` への呼び出しの代わりに使用できる状況も報告するには、「**空文字列との連結に置換できる呼び出しを報告する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryCallToStringValueOf",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FloatingPointEquality",
                "shortDescription": {
                  "text": "浮動小数点のイコール比較"
                },
                "fullDescription": {
                  "text": "'==' または '!=' 演算子を使用して比較されている浮動小数点値を報告します。 浮動小数点値は本質的に不正確であり、浮動小数点値が厳密に等価であるかどうかを比較しても望ましいセマンティクスになることはほぼありません。 このインスペクションはゼロおよび無限大リテラルを無視します。 例: 'void m(double d1, double d2) {\n    if (d1 == d2) {}\n  }'",
                  "markdown": "`==` または `!=` 演算子を使用して比較されている浮動小数点値を報告します。\n\n浮動小数点値は本質的に不正確であり、浮動小数点値が厳密に等価であるかどうかを比較しても望ましいセマンティクスになることはほぼありません。\n\nこのインスペクションはゼロおよび無限大リテラルを無視します。\n\n**例:**\n\n\n      void m(double d1, double d2) {\n        if (d1 == d2) {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FloatingPointEquality",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringReplaceableByStringBuffer",
                "shortDescription": {
                  "text": "非定数の 'String' は 'StringBuilder' に置換できます"
                },
                "fullDescription": {
                  "text": "'java.lang.String' で宣言され、繰り返し追記されている変数を報告します。 このような変数は、'java.lang.StringBuffer' または 'java.lang.StringBuilder' で宣言したほうが効率的な可能性があります。 例: 'String s = \"\";\n  for (int i = 0; i < names.length; i++) {\n    String name = names[i] + (i == names.length - 1 ? \"\" : \" \");\n    s = s + name;\n  }' このようなループは以下のように置換できます。 'StringBuilder s = new StringBuilder();\n  for (int i = 0; i < names.length; i++) {\n    String name = names[i] + (i == names.length - 1 ? \"\" : \" \");\n    s.append(name);\n  }' または、次に置換することもできます。 'String s = String.join(\" \", names);' このインスペクションに変数がループ内で追記されている場合にのみ報告させるには、オプションを使用します。",
                  "markdown": "`java.lang.String` で宣言され、繰り返し追記されている変数を報告します。 このような変数は、`java.lang.StringBuffer` または `java.lang.StringBuilder` で宣言したほうが効率的な可能性があります。\n\n**例:**\n\n\n      String s = \"\";\n      for (int i = 0; i < names.length; i++) {\n        String name = names[i] + (i == names.length - 1 ? \"\" : \" \");\n        s = s + name;\n      }\n\nこのようなループは以下のように置換できます。\n\n\n      StringBuilder s = new StringBuilder();\n      for (int i = 0; i < names.length; i++) {\n        String name = names[i] + (i == names.length - 1 ? \"\" : \" \");\n        s.append(name);\n      }\n\nまたは、次に置換することもできます。\n\n\n      String s = String.join(\" \", names);\n\n\nこのインスペクションに変数がループ内で追記されている場合にのみ報告させるには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonConstantStringShouldBeStringBuffer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SequencedCollectionMethodCanBeUsed",
                "shortDescription": {
                  "text": "SequencedCollection メソッドを使用できます"
                },
                "fullDescription": {
                  "text": "'SequencedCollection' メソッドを使用して単純化できるコレクション API メソッドの呼び出しを報告します。 次の変換がサポートされています。 'list.add(0, element)' → 'list.addFirst(element);' 'list.get(0)' → 'list.getFirst();' 'list.get(list.size() - 1)' → 'list.getLast();' 'list.remove(0)' → 'list.removeFirst();' 'list.remove(list.size() - 1)' → 'list.removeLast();' 'collection.iterator().next()' → 'collection.getFirst();' 2023.3 の新機能です このインスペクションは Java 21 以降で使用できる Java の機能 '順序付きコレクション' に依存しています。",
                  "markdown": "`SequencedCollection` メソッドを使用して単純化できるコレクション API メソッドの呼び出しを報告します。\n\n次の変換がサポートされています。\n\n* `list.add(0, element)` → `list.addFirst(element);`\n* `list.get(0)` → `list.getFirst();`\n* `list.get(list.size() - 1)` → `list.getLast();`\n* `list.remove(0)` → `list.removeFirst();`\n* `list.remove(list.size() - 1)` → `list.removeLast();`\n* `collection.iterator().next()` → `collection.getFirst();`\n\n2023.3 の新機能です\n\nこのインスペクションは Java 21 以降で使用できる Java の機能 '順序付きコレクション' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SequencedCollectionMethodCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 21",
                      "index": 75,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicField",
                "shortDescription": {
                  "text": "'public' フィールド"
                },
                "fullDescription": {
                  "text": "'public' フィールドを報告します。 定数 ('static' と 'final' が付いたフィールド) は報告されません。 例: 'class Main {\n    public String name;\n  }' クイックフィックス適用後: 'class Main {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n  }' インスペクションの構成: 無視するアノテーションを指定するには、「次のアノテーションが付いている場合は無視」リストを使用します。 このインスペクションは、対象のアノテーションが付いたフィールドを無視します。 'enum' 型の 'public final' フィールドを無視するには、「列挙型の 'public final' フィールドを無視する」オプションを使用します。",
                  "markdown": "`public` フィールドを報告します。 定数 (`static` と `final` が付いたフィールド) は報告されません。\n\n**例:**\n\n\n      class Main {\n        public String name;\n      }\n\nクイックフィックス適用後:\n\n\n      class Main {\n        private String name;\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n      }\n\nインスペクションの構成:\n\n* 無視するアノテーションを指定するには、「**次のアノテーションが付いている場合は無視**」リストを使用します。 このインスペクションは、対象のアノテーションが付いたフィールドを無視します。\n* `enum` 型の `public final` フィールドを無視するには、「**列挙型の 'public final' フィールドを無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PublicField",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/カプセル化",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinallyBlockCannotCompleteNormally",
                "shortDescription": {
                  "text": "正常終了できない 'finally' ブロック"
                },
                "fullDescription": {
                  "text": "'finally' ブロック内で使用されている 'return'、'throw'、'break'、'continue'、'yield' ステートメントを報告します。 このようなステートメントがある場合、'finally' ブロックは正常に完了しますが、突然完了します。 同じ 'try'-'catch' ステートメントの 'try' および 'catch' ブロックからスローされる例外はすべて抑止されます。 例: 'void x() {\n    try {\n      throw new RuntimeException();\n    } finally {\n      // bar() が true を返す場合、RuntimeException は抑止されます\n      if (bar()) return;\n    }\n  }'",
                  "markdown": "`finally` ブロック内で使用されている `return`、`throw`、`break`、`continue`、`yield` ステートメントを報告します。 このようなステートメントがある場合、`finally` ブロックは正常に完了しますが、突然完了します。 同じ `try`-`catch` ステートメントの `try` および `catch` ブロックからスローされる例外はすべて抑止されます。\n\n**例:**\n\n\n      void x() {\n        try {\n          throw new RuntimeException();\n        } finally {\n          // bar() が true を返す場合、RuntimeException は抑止されます\n          if (bar()) return;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "finally",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantOnWrongSideOfComparison",
                "shortDescription": {
                  "text": "間違った位置にある比較内の定数"
                },
                "fullDescription": {
                  "text": "定数値の位置が間違っている比較演算を報告します。 コーディング規則の中には、定数を比較の左または右のどちらかに配置すべきかを定めているものがあります。 例: 'boolean compare(int x) {\n    return 1 > x; // 比較の左側に定数 '1' があります\n  }' クイックフィックス適用後: 'boolean compare(int x) {\n    return x < 1;\n  }' 比較演算に含まれる定数の配置を選択し、'null' リテラルの配置が間違っている場合に警告するかどうかを選択するには、インスペクションの設定を使用します。 2019.2 の新機能です",
                  "markdown": "定数値の位置が間違っている比較演算を報告します。\n\nコーディング規則の中には、定数を比較の左または右のどちらかに配置すべきかを定めているものがあります。\n\n**例:**\n\n\n      boolean compare(int x) {\n        return 1 > x; // 比較の左側に定数 '1' があります\n      }\n\nクイックフィックス適用後:\n\n\n      boolean compare(int x) {\n        return x < 1;\n      }\n\n\n比較演算に含まれる定数の配置を選択し、`null` リテラルの配置が間違っている場合に警告するかどうかを選択するには、インスペクションの設定を使用します。\n\n2019.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantOnWrongSideOfComparison",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerialAnnotationUsedOnWrongMember",
                "shortDescription": {
                  "text": "不適切なメンバーで使用されている '@Serial' アノテーション"
                },
                "fullDescription": {
                  "text": "'java.io.Serial' アノテーションを付けるのに適していない 'Serializable' および 'Externalizable' クラスのメソッドとフィールドを報告します。 例: 'class Test implements Serializable {\n  @Serial // アノテーションが付いたフィールドは final ではないためシリアル化機構に組み込まれていません\n  private static long serialVersionUID = 7874493593505141603L;\n\n  @Serial // アノテーションが付いたメソッドは private ではないためシリアル化機構に組み込まれていません\n  void writeObject(ObjectOutputStream out) throws IOException {\n  }\n}' 'class Test implements Externalizable {\n  @Serial // アノテーションが付いたメソッドは Externalizable クラス内にあるため、シリアライズ機構に組み込まれていません\n  private void writeObject(ObjectOutputStream out) throws IOException {\n  }\n}' すべての有効なケースに関する詳細は、'java.io.Serial' クラスの Javadoc を参照してください。 2020.3 の新機能です このインスペクションは Java 14 以降で使用できる Java の機能 '@Serial アノテーション' に依存しています。",
                  "markdown": "`java.io.Serial` アノテーションを付けるのに適していない `Serializable` および `Externalizable` クラスのメソッドとフィールドを報告します。\n\n**例:**\n\n\n    class Test implements Serializable {\n      @Serial // アノテーションが付いたフィールドは final ではないためシリアル化機構に組み込まれていません\n      private static long serialVersionUID = 7874493593505141603L;\n\n      @Serial // アノテーションが付いたメソッドは private ではないためシリアル化機構に組み込まれていません\n      void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\n\n    class Test implements Externalizable {\n      @Serial // アノテーションが付いたメソッドは Externalizable クラス内にあるため、シリアライズ機構に組み込まれていません\n      private void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\nすべての有効なケースに関する詳細は、`java.io.Serial` クラスの Javadoc を参照してください。\n\n2020.3 の新機能です\n\nこのインスペクションは Java 14 以降で使用できる Java の機能 '@Serial アノテーション' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "serial",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectToString",
                "shortDescription": {
                  "text": "デフォルトの 'toString()' を呼び出し"
                },
                "fullDescription": {
                  "text": "'java.lang.Object' のデフォルトの実装を使用している 'toString()' の呼び出しを報告します。 デフォルトの実装が意図的に使用されていることはめったにありませんが、誤って使用されている可能性はあります。 'java.lang.Object'、インターフェース、または抽象クラス型のオブジェクトに対する 'toString()' の呼び出しは、このインスペクションでは無視されます。 例: 'class Bar {\n      void foo1(Bar bar) {\n          String s = bar.toString(); // 警告\n          /* ... */\n      }\n\n      void foo2(Object obj) {\n          String s = obj.toString(); // ここでは警告は表示されません\n          /* ... */\n      }\n  }'",
                  "markdown": "`java.lang.Object` のデフォルトの実装を使用している `toString()` の呼び出しを報告します。\n\nデフォルトの実装が意図的に使用されていることはめったにありませんが、誤って使用されている可能性はあります。\n\n\n`java.lang.Object`、インターフェース、または抽象クラス型のオブジェクトに対する `toString()` の呼び出しは、このインスペクションでは無視されます。\n\n**例:**\n\n\n      class Bar {\n          void foo1(Bar bar) {\n              String s = bar.toString(); // 警告\n              /* ... */\n          }\n\n          void foo2(Object obj) {\n              String s = obj.toString(); // ここでは警告は表示されません\n              /* ... */\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ObjectToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarilyQualifiedStaticallyImportedElement",
                "shortDescription": {
                  "text": "不必要に修飾され static インポートしている要素"
                },
                "fullDescription": {
                  "text": "static インポートされ、その包含クラス名で修飾されているメンバーが使用されていることを報告します。 このような修飾は不要であり、除去できます。static インポートされたメンバーには、メンバー名で直接アクセスできるからです。 例: 'import static foo.Test.WIDTH;\n\n  class Bar {\n    void bar() {\n      System.out.println(Test.WIDTH);\n    }\n  }' クイックフィックス適用後: 'import static foo.Test.WIDTH;\n\n  class Bar {\n    void bar() {\n      System.out.println(WIDTH);\n    }\n  }'",
                  "markdown": "static インポートされ、その包含クラス名で修飾されているメンバーが使用されていることを報告します。\n\nこのような修飾は不要であり、除去できます。static インポートされたメンバーには、メンバー名で直接アクセスできるからです。\n\n**例:**\n\n\n      import static foo.Test.WIDTH;\n\n      class Bar {\n        void bar() {\n          System.out.println(Test.WIDTH);\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      import static foo.Test.WIDTH;\n\n      class Bar {\n        void bar() {\n          System.out.println(WIDTH);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessarilyQualifiedStaticallyImportedElement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfJDBCDriverClass",
                "shortDescription": {
                  "text": "具象 JDBC ドライバークラスの使用"
                },
                "fullDescription": {
                  "text": "特定の JDBC ドライバークラスが使用されていることを報告します。 このようなクラスを使用すると、プロジェクトが特定のデータベースとドライバーに関連付けられるため、JDBC の目的が無意味になってしまい、結果的に移植性が損なわれます。 例: 'import java.sql.Driver;\n\n  abstract class Sample implements Driver {\n    public void foo() {\n        Sample sample;\n    }\n  }'",
                  "markdown": "特定の JDBC ドライバークラスが使用されていることを報告します。 このようなクラスを使用すると、プロジェクトが特定のデータベースとドライバーに関連付けられるため、JDBC の目的が無意味になってしまい、結果的に移植性が損なわれます。\n\n**例:**\n\n\n      import java.sql.Driver;\n\n      abstract class Sample implements Driver {\n        public void foo() {\n            Sample sample;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfJDBCDriverClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ポータビリティ",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JDBCResource",
                "shortDescription": {
                  "text": "安全に閉じられていない JDBC リソース"
                },
                "fullDescription": {
                  "text": "安全に閉じられていない JDBC リソースを報告します。 このインスペクションで報告される JDBC リソースには'java.sql.Connection'、'java.sql.Statement'、'java.sql.PreparedStatement'、'java.sql.CallableStatement'、'java.sql.ResultSet' です。 デフォルトでは、このインスペクションは名前に 'close' または 'cleanup' を含む任意のメソッドでリソースを閉じることができると想定しています。 例: 'ResultSet findAllElements(Connection connection) throws SQLException {\n    PreparedStatement statement = connection.prepareStatement(\"SELECT * FROM TABLE\");//ステートメントが閉じられていません\n    statement.execute();\n    return statement.getResultSet();\n  }' このインスペクションは、次のオプションを使用して構成できます。 try ブロック内で JDBC リソースを開くことを許可するかどうか。 この方法は 'try' ブロックの前でリソースを開く方法よりも冗長であるため、あまり望ましくありません。 リソースが引数として渡されている任意のメソッド呼び出しでリソースを閉じることができるかどうか。",
                  "markdown": "安全に閉じられていない JDBC リソースを報告します。 このインスペクションで報告される JDBC リソースには`java.sql.Connection`、`java.sql.Statement`、`java.sql.PreparedStatement`、`java.sql.CallableStatement`、`java.sql.ResultSet` です。\n\n\nデフォルトでは、このインスペクションは名前に 'close' または 'cleanup' を含む任意のメソッドでリソースを閉じることができると想定しています。\n\n**例:**\n\n\n      ResultSet findAllElements(Connection connection) throws SQLException {\n        PreparedStatement statement = connection.prepareStatement(\"SELECT * FROM TABLE\");//ステートメントが閉じられていません\n        statement.execute();\n        return statement.getResultSet();\n      }\n\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* try ブロック内で JDBC リソースを開くことを許可するかどうか。 この方法は `try` ブロックの前でリソースを開く方法よりも冗長であるため、あまり望ましくありません。\n* リソースが引数として渡されている任意のメソッド呼び出しでリソースを閉じることができるかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JDBCResourceOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/リソース管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowsRuntimeException",
                "shortDescription": {
                  "text": "'throws' 節で宣言されている非チェック例外"
                },
                "fullDescription": {
                  "text": "メソッドの 'throws' 節にある非チェック例外 ('java.lang.RuntimeException' またはそのサブクラスにあるもの) の宣言を報告します。 非チェック例外の宣言は不要であり、削除するか、Javadoc の '@throws' タグに移動できます。 例: 'public class InvalidDataException extends RuntimeException {}\n\n  class TextEditor {\n    void readSettings() throws InvalidDataException {} // 警告: 非チェック例外 'InvalidDataException' が 'throws' 節で宣言されています\n  }'",
                  "markdown": "メソッドの `throws` 節にある非チェック例外 (`java.lang.RuntimeException` またはそのサブクラスにあるもの) の宣言を報告します。\n\n非チェック例外の宣言は不要であり、削除するか、Javadoc の `@throws` タグに移動できます。\n\n**例:**\n\n\n      public class InvalidDataException extends RuntimeException {}\n\n      class TextEditor {\n        void readSettings() throws InvalidDataException {} // 警告: 非チェック例外 'InvalidDataException' が 'throws' 節で宣言されています\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowsRuntimeException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewObjectEquality",
                "shortDescription": {
                  "text": "'==' を使って比較されている新しいオブジェクト"
                },
                "fullDescription": {
                  "text": "'equals()' を呼び出す代わりに、新しく代入されたオブジェクトに '==' または '!=' を適用しているコードを報告します。 新しく代入されたオブジェクトの参照では既存のオブジェクトを指すことができないため、比較は常に 'false' と評価されます。 このインスペクションは、単純なメソッドから返される新しく作成されたオブジェクトも報告する場合があります。 例: 'void test(Object obj) {\n    if (new Object() == obj) {...}\n  }' クイックフィックス適用後: 'void test(Object obj) {\n    if (new Object().equals(obj)) {...}\n  }' 2018.3 の新機能です",
                  "markdown": "`equals()` を呼び出す代わりに、新しく代入されたオブジェクトに `==` または `!=` を適用しているコードを報告します。\n\n\n新しく代入されたオブジェクトの参照では既存のオブジェクトを指すことができないため、比較は常に `false` と評価されます。 このインスペクションは、単純なメソッドから返される新しく作成されたオブジェクトも報告する場合があります。\n\n**例:**\n\n\n      void test(Object obj) {\n        if (new Object() == obj) {...}\n      }\n\nクイックフィックス適用後:\n\n\n      void test(Object obj) {\n        if (new Object().equals(obj)) {...}\n      }\n\n\n2018.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewObjectEquality",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JNDIResource",
                "shortDescription": {
                  "text": "安全に閉じられていない JNDI リソース"
                },
                "fullDescription": {
                  "text": "安全に閉じられていない JNDI リソースを報告します。 このリソースで報告される JNDI リソースは 'javax.naming.InitialContext' と 'javax.naming.NamingEnumeration' です。 デフォルトでは、このインスペクションは名前に 'close' または 'cleanup' を含む任意のメソッドでリソースを閉じることができると想定しています。 例: 'Object findObject(Properties properties, String name) throws NamingException {\n    Context context = new InitialContext(properties); //コンテキストが閉じられていません\n    return context.lookup(name);\n  }' このインスペクションは、次のオプションを使用して構成できます。 'try' ブロック内で JNDI リソースを開くことを許可するかどうか。 このスタイルは try ブロックの前でリソースを開く場合よりも冗長であるため、あまり望ましくありません。 リソースが引数として渡されている任意のメソッド呼び出しでリソースを閉じることができるかどうか。",
                  "markdown": "安全に閉じられていない JNDI リソースを報告します。 このリソースで報告される JNDI リソースは `javax.naming.InitialContext` と `javax.naming.NamingEnumeration` です。\n\n\nデフォルトでは、このインスペクションは名前に 'close' または 'cleanup' を含む任意のメソッドでリソースを閉じることができると想定しています。\n\n**例:**\n\n\n      Object findObject(Properties properties, String name) throws NamingException {\n        Context context = new InitialContext(properties); //コンテキストが閉じられていません\n        return context.lookup(name);\n      }\n\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* `try` ブロック内で JNDI リソースを開くことを許可するかどうか。 このスタイルは try ブロックの前でリソースを開く場合よりも冗長であるため、あまり望ましくありません。\n* リソースが引数として渡されている任意のメソッド呼び出しでリソースを閉じることができるかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JNDIResourceOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/リソース管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TryWithIdenticalCatches",
                "shortDescription": {
                  "text": "'try' ステートメント内の同じ 'catch' 分岐"
                },
                "fullDescription": {
                  "text": "1 つの 'try' ステートメント内にある内容がまったく同じ 'catch' セクションを報告します。 そのようなセクションを 1 つの複数 catch ブロックにまとめると、重複コードを削減できるほか、1 つの 'catch' セクションだけが更新され、他のセクションが更新されないといった状況を防ぐことができます。 例: 'try {\n        doSmth();\n    }\n    catch (IOException e) {\n        LOG.error(e);\n    }\n    catch (URISyntaxException e) {\n        LOG.error(e);\n    }' このようなコードを簡潔にするクイックフィックスを使用できます。 'try {\n        doSmth();\n    }\n    catch (IOException | URISyntaxException e) {\n        LOG.error(e);\n    }' このインスペクションは Java 7 以降で使用できる Java の機能 '複数 catch' に依存しています。",
                  "markdown": "1 つの `try` ステートメント内にある内容がまったく同じ `catch` セクションを報告します。\n\nそのようなセクションを 1 つの*複数 catch* ブロックにまとめると、重複コードを削減できるほか、1 つの `catch` セクションだけが更新され、他のセクションが更新されないといった状況を防ぐことができます。\n\n**例:**\n\n\n        try {\n            doSmth();\n        }\n        catch (IOException e) {\n            LOG.error(e);\n        }\n        catch (URISyntaxException e) {\n            LOG.error(e);\n        }\n\nこのようなコードを簡潔にするクイックフィックスを使用できます。\n\n\n        try {\n            doSmth();\n        }\n        catch (IOException | URISyntaxException e) {\n            LOG.error(e);\n        }\n\nこのインスペクションは Java 7 以降で使用できる Java の機能 '複数 catch' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TryWithIdenticalCatches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 7",
                      "index": 114,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggingSimilarMessage",
                "shortDescription": {
                  "text": "識別不可能なロギング呼び出し"
                },
                "fullDescription": {
                  "text": "'logger.info(\"message: {}\", key)' など、1 つのクラス内で同様のログメッセージを出力している SLF4J、Log4j2 のロギング呼び出しを報告します。 このような呼び出しは互いに区別できない可能性があり、特定のログメッセージの出力元を把握するのを難しくします。 例 (Java): 'private static void request1(String text) {\n      log.info(\"Message: {}\", text); //同様の呼び出し\n      doSomething1();\n  }\n\n  private static void request2(int i) {\n      log.info(\"Message: {}\", i); //同様の呼び出し\n      doSomething2();\n  }' 呼び出しが報告された後の類似シーケンスの最小長を設定するには、「類似シーケンスの最小長」オプションを使用します `error` ログレベルのメッセージと例外がある場合を無視するには、「'error' ログレベルでの呼び出しを報告しない」オプションを使用します。 それでもスタックトレースを使用して呼び出しサイトを特定することはできるため、この警告を非表示にすると便利かもしれません。 2024.1 の新機能です",
                  "markdown": "`logger.info(\"message: {}\", key)` など、1 つのクラス内で同様のログメッセージを出力している SLF4J、Log4j2 のロギング呼び出しを報告します。 このような呼び出しは互いに区別できない可能性があり、特定のログメッセージの出力元を把握するのを難しくします。\n\n**例 (Java):**\n\n\n      private static void request1(String text) {\n          log.info(\"Message: {}\", text); //同様の呼び出し\n          doSomething1();\n      }\n\n      private static void request2(int i) {\n          log.info(\"Message: {}\", i); //同様の呼び出し\n          doSomething2();\n      }\n\n* 呼び出しが報告された後の類似シーケンスの最小長を設定するには、「**類似シーケンスの最小長**」オプションを使用します\n* \\`error\\` ログレベルのメッセージと例外がある場合を無視するには、「'error' ログレベルでの呼び出しを報告しない」オプションを使用します。 それでもスタックトレースを使用して呼び出しサイトを特定することはできるため、この警告を非表示にすると便利かもしれません。\n\n2024.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LoggingSimilarMessage",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語/ログ関連",
                      "index": 45,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantCompareCall",
                "shortDescription": {
                  "text": "冗長な 'compare()' メソッドの呼び出し"
                },
                "fullDescription": {
                  "text": "不必要な 'compare' メソッドの比較を報告します。 例: 'boolean result = Integer.compare(a, b) == 0;' クイックフィックス適用後: 'boolean result = a == b;' 2018.2 の新機能です",
                  "markdown": "不必要な `compare` メソッドの比較を報告します。\n\n例:\n\n\n      boolean result = Integer.compare(a, b) == 0;\n\nクイックフィックス適用後:\n\n\n      boolean result = a == b;\n\n2018.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantCompareCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaCanBeReplacedWithAnonymous",
                "shortDescription": {
                  "text": "匿名クラスに置換可能なラムダ"
                },
                "fullDescription": {
                  "text": "匿名クラスに置換できるラムダ式を報告します。 ラムダ式の匿名クラスへの展開は、匿名クラスの中で別のメソッドを実装する必要がある場合に役立つ場合があります。 例: 's -> System.out.println(s)' クイックフィックス適用後: 'new Consumer<String>() {\n  @Override\n  public void accept(String s) {\n    System.out.println(s);\n  }\n}' このインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。",
                  "markdown": "匿名クラスに置換できるラムダ式を報告します。\n\n\nラムダ式の匿名クラスへの展開は、匿名クラスの中で別のメソッドを実装する必要がある場合に役立つ場合があります。\n\n例:\n\n\n      s -> System.out.println(s)\n\nクイックフィックス適用後:\n\n    new Consumer<String>() {\n      @Override\n      public void accept(String s) {\n        System.out.println(s);\n      }\n    }\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LambdaCanBeReplacedWithAnonymous",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfCanBeAssertion",
                "shortDescription": {
                  "text": "'assert' または 'Objects.requireNonNull' に置換可能なステートメント"
                },
                "fullDescription": {
                  "text": "'then' 分岐から 'java.lang.Throwable' のみをスローし、'else' 分岐を持たない 'if' ステートメントを報告します。 このようなステートメントは、よりコンパクトな 'assert' ステートメントに変換できます。 このインスペクションは、Guava の 'Preconditions.checkNotNull()' も報告します。 このようなステートメントは 'Objects.requireNonNull()' の呼び出しに置換できるため、ライブラリは不要な場合があります。 例: 'if (x == 2) throw new RuntimeException(\"fail\");\n  if (y == null) throw new AssertionError();\n  Preconditions.checkNotNull(z, \"z\");' クイックフィックス適用後: 'assert x != 2 : \"fail\";\n  Objects.requireNonNull(y);\n  Objects.requireNonNull(z, \"z\");' デフォルトでは、このインスペクションはエディター内でコードハイライトなしのクイックフィックスを提供します。 このインスペクションは Java 1.4 以降で使用できる Java の機能 'アサーション' に依存しています。",
                  "markdown": "`then` 分岐から `java.lang.Throwable` のみをスローし、`else` 分岐を持たない `if` ステートメントを報告します。 このようなステートメントは、よりコンパクトな `assert` ステートメントに変換できます。\n\n\nこのインスペクションは、Guava の `Preconditions.checkNotNull()` も報告します。\nこのようなステートメントは `Objects.requireNonNull()` の呼び出しに置換できるため、ライブラリは不要な場合があります。\n\n例:\n\n\n      if (x == 2) throw new RuntimeException(\"fail\");\n      if (y == null) throw new AssertionError();\n      Preconditions.checkNotNull(z, \"z\");\n\nクイックフィックス適用後:\n\n\n      assert x != 2 : \"fail\";\n      Objects.requireNonNull(y);\n      Objects.requireNonNull(z, \"z\");\n\nデフォルトでは、このインスペクションはエディター内でコードハイライトなしのクイックフィックスを提供します。\n\nこのインスペクションは Java 1.4 以降で使用できる Java の機能 'アサーション' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IfCanBeAssertion",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TextBlockBackwardMigration",
                "shortDescription": {
                  "text": "テキストブロックは通常の文字列リテラルに置換できます"
                },
                "fullDescription": {
                  "text": "通常の文字列リテラルに置換できるテキストブロックを報告します。 このインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。 例: 'Object obj = engine.eval(\"\"\"\n                           function hello() {\n                             print('\"Hello, world\"');\n                           }\n\n                           hello();\n                           \"\"\");' クイックフィックス適用後: 'Object obj = engine.eval(\"function hello() {\\n\" +\n                           \"  print('\\\"Hello, world\\\"');\\n\" +\n                           \"}\\n\" +\n                           \"\\n\" +\n                           \"hello();\\n\");' 2019.3 の新機能です このインスペクションは Java 15 以降で使用できる Java の機能 'テキストブロックリテラル' に依存しています。",
                  "markdown": "通常の文字列リテラルに置換できるテキストブロックを報告します。 このインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。\n\n**例:**\n\n\n      Object obj = engine.eval(\"\"\"\n                               function hello() {\n                                 print('\"Hello, world\"');\n                               }\n\n                               hello();\n                               \"\"\");\n\nクイックフィックス適用後:\n\n\n      Object obj = engine.eval(\"function hello() {\\n\" +\n                               \"  print('\\\"Hello, world\\\"');\\n\" +\n                               \"}\\n\" +\n                               \"\\n\" +\n                               \"hello();\\n\");\n\n2019.3 の新機能です\n\nこのインスペクションは Java 15 以降で使用できる Java の機能 'テキストブロックリテラル' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TextBlockBackwardMigration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 15",
                      "index": 100,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyClass",
                "shortDescription": {
                  "text": "空のクラス"
                },
                "fullDescription": {
                  "text": "空のクラスと空の Java ファイルを報告します。 フィールド、メソッド、コンストラクター、イニシャライザーのいずれも含んでいないクラスは空だと見なされます。 空のクラスは大規模な変更やリファクタリングを行った後に残っていることがあります。 例: 'class Example {\n    List<String> getList() {\n       return new ArrayList<>() {\n\n       };\n    }\n  }' クイックフィックス適用後: 'class Example {\n    List<String> getList() {\n       return new ArrayList<>();\n    }\n  }' インスペクションの構成: 特別なアノテーションを指定するには、「次のアノテーションが付いている場合は無視」オプションを使用します。 このインスペクションは、ここで指定されたクラスを無視します。 スーパークラスをパラメーター化しているクラスを無視するには、「スーパータイプのパラメーター化であればクラスを無視」オプションを使用します。 例: 'class MyList extends ArrayList<String> {}' 'java.lang.Throwable' を拡張しているクラスを無視するには、「java.lang.Throwable のサブクラスを無視」を使用します。 コメントを含むクラスを無視するには、「コメントをコンテンツと見なす」オプションを使用します。",
                  "markdown": "空のクラスと空の Java ファイルを報告します。\n\nフィールド、メソッド、コンストラクター、イニシャライザーのいずれも含んでいないクラスは空だと見なされます。 空のクラスは大規模な変更やリファクタリングを行った後に残っていることがあります。\n\n**例:**\n\n\n      class Example {\n        List<String> getList() {\n           return new ArrayList<>() {\n\n           };\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Example {\n        List<String> getList() {\n           return new ArrayList<>();\n        }\n      }\n\nインスペクションの構成:\n\n* 特別なアノテーションを指定するには、「**次のアノテーションが付いている場合は無視**」オプションを使用します。 このインスペクションは、ここで指定されたクラスを無視します。\n*\n  スーパークラスをパラメーター化しているクラスを無視するには、「**スーパータイプのパラメーター化であればクラスを無視**」オプションを使用します。 例:\n\n      class MyList extends ArrayList<String> {}\n\n* `java.lang.Throwable` を拡張しているクラスを無視するには、「**java.lang.Throwable のサブクラスを無視**」を使用します。\n* コメントを含むクラスを無視するには、「**コメントをコンテンツと見なす**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocDeclaration",
                "shortDescription": {
                  "text": "Javadoc 宣言の問題"
                },
                "fullDescription": {
                  "text": "次の問題がある Javadoc のコメントとタグを報告します。 無効なタグ名がある タグの説明が不完全である タグが重複している Javadoc の説明が欠落している 例: '/**\n   * 無効なタグ名\n   * @poram param description\n   */\n  public void sample(int param){\n  }' 例: '/**\n   * 自己参照 {@link #sample(int)}\n   */\n  public void sample(int param){\n  }' クイックフィックスを使用すると、不明な Javadoc のタグがユーザー定義の追加タグのリストに追加されます。 追加の Javadoc タグを定義するには、下のテキストフィールドを使用します。 重複する 'throws' タグを無視するには 1 つめのチェックボックスを使用します。 説明の最初の文章がないか不完全である問題を無視するには、2 つめのチェックボックスを使用します。 自己参照を無視するには、3 つめのチェックボックスを使用します。",
                  "markdown": "次の問題がある Javadoc のコメントとタグを報告します。\n\n* 無効なタグ名がある\n* タグの説明が不完全である\n* タグが重複している\n* Javadoc の説明が欠落している\n\n例:\n\n\n      /**\n       * 無効なタグ名\n       * @poram param description\n       */\n      public void sample(int param){\n      }\n\n例:\n\n\n      /**\n       * 自己参照 {@link #sample(int)}\n       */\n      public void sample(int param){\n      }\n\nクイックフィックスを使用すると、不明な Javadoc のタグがユーザー定義の追加タグのリストに追加されます。\n\n追加の Javadoc タグを定義するには、下のテキストフィールドを使用します。\n\n重複する 'throws' タグを無視するには 1 つめのチェックボックスを使用します。\n\n説明の最初の文章がないか不完全である問題を無視するには、2 つめのチェックボックスを使用します。\n\n自己参照を無視するには、3 つめのチェックボックスを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavadocDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalCanBeOptional",
                "shortDescription": {
                  "text": "Optional に置換できる条件演算子"
                },
                "fullDescription": {
                  "text": "null チェックを行う条件式を報告し、'Optional' チェーンに置換することを提案します。 例: 'return str == null ? \"\" : str.trim();' クイックフィックス適用後: 'return Optional.ofNullable(str).map(String::trim).orElse(\"\");' 置換後のコードは置換前よりも長くなる場合がありますが、リファクタリングを続けて行うときは便利な場合があります (メソッドの戻り値を 'Optional' に変更する場合など)。 ただし、null 以外の条件分岐が null を返している場合は、対応するマッピング手順で空の 'Optional' が作成されるため、セマンティクスが変更される恐れがあります。 セマンティクスが維持されることが静的に証明できない場合は、クイックフィックスアクションの名前に「(セマンティクスを変更する可能性あり)」という注意書きが含まれ、インスペクションのハイライトがオフになります。 2018.1 の新機能です このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "null チェックを行う条件式を報告し、`Optional` チェーンに置換することを提案します。\n\n例:\n\n\n      return str == null ? \"\" : str.trim();\n\nクイックフィックス適用後:\n\n\n      return Optional.ofNullable(str).map(String::trim).orElse(\"\");\n\n置換後のコードは置換前よりも長くなる場合がありますが、リファクタリングを続けて行うときは便利な場合があります (メソッドの戻り値を `Optional` に変更する場合など)。\n\nただし、null 以外の条件分岐が null を返している場合は、対応するマッピング手順で空の `Optional` が作成されるため、セマンティクスが変更される恐れがあります。 セマンティクスが維持されることが静的に証明できない場合は、クイックフィックスアクションの名前に「(セマンティクスを変更する可能性あり)」という注意書きが含まれ、インスペクションのハイライトがオフになります。\n\n2018.1 の新機能です\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConditionalCanBeOptional",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToMethodParameter",
                "shortDescription": {
                  "text": "メソッドパラメーターへの代入"
                },
                "fullDescription": {
                  "text": "メソッドパラメーターへの代入、または変更を報告します。 意図している場合もありますが、このようなコンストラクトは混乱を招く可能性があるため、一部の Java プロジェクトでは禁止されています。 このクイックフィックスは新しい変数の宣言を追加します。 例: 'void printTrimmed(String s) {\n    s = s.trim();\n    System.out.println(s);\n  }' クイックフィックス適用後: 'void printTrimmed(String s) {\n    String trimmed = s.trim();\n    System.out.println(trimmed);\n  }' 先行する値に基づいてパラメーター値を変更する代入を無視するには、「代入が元のパラメーターの変換である場合は無視する」オプションを使用します。",
                  "markdown": "メソッドパラメーターへの代入、または変更を報告します。\n\n意図している場合もありますが、このようなコンストラクトは混乱を招く可能性があるため、一部の Java プロジェクトでは禁止されています。\n\nこのクイックフィックスは新しい変数の宣言を追加します。\n\n**例:**\n\n\n      void printTrimmed(String s) {\n        s = s.trim();\n        System.out.println(s);\n      }\n\nクイックフィックス適用後:\n\n\n      void printTrimmed(String s) {\n        String trimmed = s.trim();\n        System.out.println(trimmed);\n      }\n\n\n先行する値に基づいてパラメーター値を変更する代入を無視するには、「**代入が元のパラメーターの変換である場合は無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToMethodParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代入関連の問題",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToLambdaParameter",
                "shortDescription": {
                  "text": "ラムダパラメーターへの代入"
                },
                "fullDescription": {
                  "text": "ラムダパラメーターへの代入、または変更を報告します。 意図している場合もありますが、このようなコンストラクトは混乱を招く可能性があり、誤った変数の使用によって生じていることがしばしばです。 このクイックフィックスは新しい変数の宣言を追加します。 例: 'list.forEach(s -> {\n    s = s.trim();\n    System.out.println(\"String: \" + s);\n  });' クイックフィックス適用後: 'list.forEach(s -> {\n    String trimmed = s.trim();\n    System.out.println(\"String: \" + trimmed);\n  });' 先行する値に基づいてパラメーター値を変更する代入を無視するには、「代入が元のパラメーターの変換である場合は無視する」オプションを使用します。 このインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。",
                  "markdown": "ラムダパラメーターへの代入、または変更を報告します。 意図している場合もありますが、このようなコンストラクトは混乱を招く可能性があり、誤った変数の使用によって生じていることがしばしばです。\n\nこのクイックフィックスは新しい変数の宣言を追加します。\n\n**例:**\n\n\n      list.forEach(s -> {\n        s = s.trim();\n        System.out.println(\"String: \" + s);\n      });\n\nクイックフィックス適用後:\n\n\n      list.forEach(s -> {\n        String trimmed = s.trim();\n        System.out.println(\"String: \" + trimmed);\n      });\n\n先行する値に基づいてパラメーター値を変更する代入を無視するには、「**代入が元のパラメーターの変換である場合は無視する**」オプションを使用します。\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToLambdaParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代入関連の問題",
                      "index": 35,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LocalVariableHidingMemberVariable",
                "shortDescription": {
                  "text": "フィールドを非表示にするローカル変数"
                },
                "fullDescription": {
                  "text": "外部クラスのフィールドと名前がまったく同じローカル変数を報告します。 このような命名を行うと、まったく同じ名前のフィールドが意図されている場合に変数を誤って使用する可能性があります。 変数の名前を変更するクイックフィックスが提案されます。 例: 'public class Foo {\n    public Object foo;\n\n    void bar() {\n      Object o = new Object() {\n        void baz() {\n          Object foo; // ローカル変数 'foo' は 'Foo' クラスのフィールドを不可視にします\n        }\n      };\n    }\n  }' このインスペクションでは、以下のオプションを構成できます。 アクセスできないフィールドを無視する - 不可視 (フィールドが private の場合など) のスーパークラスのフィールドと名前がまったく同じローカル変数を無視します。 非 static フィールドを不可視にする static コンテキストのローカル変数を無視する - たとえば、ローカル変数が static メソッド内または static 内部クラスのメソッド内にある場合に無視します。",
                  "markdown": "外部クラスのフィールドと名前がまったく同じローカル変数を報告します。 このような命名を行うと、まったく同じ名前のフィールドが意図されている場合に変数を誤って使用する可能性があります。\n\n変数の名前を変更するクイックフィックスが提案されます。\n\n**例:**\n\n\n      public class Foo {\n        public Object foo;\n\n        void bar() {\n          Object o = new Object() {\n            void baz() {\n              Object foo; // ローカル変数 'foo' は 'Foo' クラスのフィールドを不可視にします\n            }\n          };\n        }\n      }\n\n\nこのインスペクションでは、以下のオプションを構成できます。\n\n1. **アクセスできないフィールドを無視する** - 不可視 (フィールドが private の場合など) のスーパークラスのフィールドと名前がまったく同じローカル変数を無視します。\n2. **非 static フィールドを不可視にする static コンテキストのローカル変数を無視する** - たとえば、ローカル変数が static メソッド内または static 内部クラスのメソッド内にある場合に無視します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LocalVariableHidesMemberVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryTemporaryOnConversionToString",
                "shortDescription": {
                  "text": "'String' への変換に不要な一時オブジェクト"
                },
                "fullDescription": {
                  "text": "プリミティブ型から 'String' に変換する際に不要な一時オブジェクトの作成が行われていることを報告します。 例: 'String foo = new Integer(3).toString();' クイックフィックス適用後: 'String foo = Integer.toString(3);'",
                  "markdown": "プリミティブ型から `String` に変換する際に不要な一時オブジェクトの作成が行われていることを報告します。\n\n**例:**\n\n\n      String foo = new Integer(3).toString();\n\nクイックフィックス適用後:\n\n\n      String foo = Integer.toString(3);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryTemporaryOnConversionToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemGetenv",
                "shortDescription": {
                  "text": "'System.getenv()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'System.getenv()' の呼び出しを報告します。 'System.getenv()' の呼び出しは本質的に移植性がありません。",
                  "markdown": "`System.getenv()` の呼び出しを報告します。 `System.getenv()` の呼び出しは本質的に移植性がありません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemGetenv",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ポータビリティ",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InterfaceMayBeAnnotatedFunctional",
                "shortDescription": {
                  "text": "'@FunctionalInterface' アノテーションを付けられるインターフェース"
                },
                "fullDescription": {
                  "text": "'@FunctionalInterface' アノテーションを付与できるインターフェースを報告します。 インターフェースに '@FunctionalInterface' アノテーションを付与すると、そのインターフェースが関数型であり、これ以上 'abstract' メソッドを追加できないことを伝えることができます。 例: 'interface FileProcessor {\n    void execute(File file);\n  }' クイックフィックス適用後: '@FunctionalInterface\n  interface FileProcessor {\n    void execute(File file);\n  }' このインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。",
                  "markdown": "`@FunctionalInterface` アノテーションを付与できるインターフェースを報告します。\n\nインターフェースに `@FunctionalInterface` アノテーションを付与すると、そのインターフェースが関数型であり、これ以上 `abstract` メソッドを追加できないことを伝えることができます。\n\n**例:**\n\n\n      interface FileProcessor {\n        void execute(File file);\n      }\n\nクイックフィックス適用後:\n\n\n      @FunctionalInterface\n      interface FileProcessor {\n        void execute(File file);\n      }\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'ラムダ式' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InterfaceMayBeAnnotatedFunctional",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BreakStatementWithLabel",
                "shortDescription": {
                  "text": "ラベル付きの 'break' ステートメント"
                },
                "fullDescription": {
                  "text": "ラベル付きの 'break' ステートメントを報告します。 ラベル付きの 'break' ステートメントはリファクタリングを複雑にし、混乱を招く可能性があります。 例: 'void handle(List<String> strs) {\n    outer:\n    for (String s: strs) {\n      for (char ch : s.toCharArray()) {\n        if ('s' == ch) break outer;\n        handleChar(ch);\n      }\n    }\n  }'",
                  "markdown": "ラベル付きの `break` ステートメントを報告します。\n\nラベル付きの `break` ステートメントはリファクタリングを複雑にし、混乱を招く可能性があります。\n\n例:\n\n\n      void handle(List<String> strs) {\n        outer:\n        for (String s: strs) {\n          for (char ch : s.toCharArray()) {\n            if ('s' == ch) break outer;\n            handleChar(ch);\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BreakStatementWithLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringEquality",
                "shortDescription": {
                  "text": "'equals()' の代わりに '==' を使用した文字列比較"
                },
                "fullDescription": {
                  "text": "== または != を使用して文字列を比較しているコードを報告します。 これらの演算子は、内容を比較する代わりに参照の等価性を判断しています。 ほとんどの場合、文字列は 'equals()' を使用して比較する必要があります。このメソッドは比較対象の文字列が異なるオブジェクトである場合、文字単位で比較を行います。 例: 'void foo(String s, String t) {\n    final boolean b = t == s;\n  }' 't' が非 null であることがわかっている場合は、「安全でない」クイックフィックスを適用して次のような結果を得ても問題ありません。 'void foo(String s, String t) {\n    final boolean b = t.equals(s);\n  }'",
                  "markdown": "**==** または **!=** を使用して文字列を比較しているコードを報告します。\n\n\nこれらの演算子は、内容を比較する代わりに参照の等価性を判断しています。\nほとんどの場合、文字列は `equals()` を使用して比較する必要があります。このメソッドは比較対象の文字列が異なるオブジェクトである場合、文字単位で比較を行います。\n\n**例:**\n\n\n      void foo(String s, String t) {\n        final boolean b = t == s;\n      }\n\n`t` が非 null であることがわかっている場合は、「安全でない」クイックフィックスを適用して次のような結果を得ても問題ありません。\n\n\n      void foo(String s, String t) {\n        final boolean b = t.equals(s);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringEquality",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousLiteralUnderscore",
                "shortDescription": {
                  "text": "疑わしい数値リテラルのアンダースコア"
                },
                "fullDescription": {
                  "text": "アンダースコアの数値区切り文字を使用する 10 進数リテラルで、3 桁単位でまとまっていないものを報告します。 このようなリテラルには、タイポが含まれている可能性があります。 このインスペクションは、2 つの連続したアンダースコアを含むリテラルについては警告しません。 'double' および 'float' リテラルの小数部分でアンダースコアを省略することもできます。 例: 'int oneMillion = 1_000_0000;'",
                  "markdown": "アンダースコアの数値区切り文字を使用する 10 進数リテラルで、3 桁単位でまとまっていないものを報告します。 このようなリテラルには、タイポが含まれている可能性があります。\n\nこのインスペクションは、2 つの連続したアンダースコアを含むリテラルについては警告しません。\n`double` および `float` リテラルの小数部分でアンダースコアを省略することもできます。\n\n**例:** `int oneMillion = 1_000_0000;`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousLiteralUnderscore",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticCallOnSubclass",
                "shortDescription": {
                  "text": "サブクラスを介して参照される static メソッド"
                },
                "fullDescription": {
                  "text": "static メソッド呼び出しのうち、呼び出しが宣言クラス自体ではなく、宣言クラスのサブクラスによって修飾されているものを報告します。 Java ではこのようなクラス修飾が可能ですが、このような呼び出しは継承とオーバーライドが微妙に混同されている可能性を示しています。 例: 'class Parent {\n    public static void print(String str) {}\n  }\n  class Child extends Parent {}\n\n  Child.print(\"Hello, world!\");' クイックフィックス適用後: 'Parent.print(\"Hello, world!\");'",
                  "markdown": "static メソッド呼び出しのうち、呼び出しが宣言クラス自体ではなく、宣言クラスのサブクラスによって修飾されているものを報告します。\n\n\nJava ではこのようなクラス修飾が可能ですが、このような呼び出しは継承とオーバーライドが微妙に混同されている可能性を示しています。\n\n**例:**\n\n\n      class Parent {\n        public static void print(String str) {}\n      }\n      class Child extends Parent {}\n\n      Child.print(\"Hello, world!\");\n\nクイックフィックス適用後:\n\n\n      Parent.print(\"Hello, world!\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticMethodReferencedViaSubclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantExpression",
                "shortDescription": {
                  "text": "評価可能な定数式"
                },
                "fullDescription": {
                  "text": "値を静的に評価できる定数式を報告し、実際の値への置換を提案します。 たとえば、'2 + 2' を '4' に、または 'Math.sqrt(9.0)' を '3.0' に置換するよう促します。 2018.1 の新機能です",
                  "markdown": "値を静的に評価できる定数式を報告し、実際の値への置換を提案します。 たとえば、`2 + 2` を `4` に、または `Math.sqrt(9.0)` を `3.0` に置換するよう促します。\n\n2018.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConstantExpression",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReadResolveAndWriteReplaceProtected",
                "shortDescription": {
                  "text": "'protected' と宣言されていない 'readResolve()' または 'writeReplace()'"
                },
                "fullDescription": {
                  "text": "'readResolve()' または 'writeReplace()' メソッドが 'protected' で宣言されていない 'java.io.Serializable' を実装しているクラスを報告します。 'readResolve()' および 'writeReplace()' メソッドを 'private' で宣言すると、サブクラスが警告を出すことなくこれらのメソッドを無視するように強制できます。しかし、'public' で宣言している場合は信頼できないコードからの呼び出しが可能になってしまいます。 包含クラスが 'final' で宣言されている場合、これらのメソッドは 'private' で宣言できます。 例: 'class ClassWithSerialization implements Serializable {\n    public Object writeReplace() { // 警告: 'writeReplace()' は protected と宣言されていません\n        ...\n    }\n  }'",
                  "markdown": "`readResolve()` または `writeReplace()` メソッドが `protected` で宣言されていない `java.io.Serializable` を実装しているクラスを報告します。\n\n\n`readResolve()` および `writeReplace()` メソッドを `private` で宣言すると、サブクラスが警告を出すことなくこれらのメソッドを無視するように強制できます。しかし、`public` で宣言している場合は信頼できないコードからの呼び出しが可能になってしまいます。\n\n\n包含クラスが `final` で宣言されている場合、これらのメソッドは `private` で宣言できます。\n\n**例:**\n\n\n      class ClassWithSerialization implements Serializable {\n        public Object writeReplace() { // 警告: 'writeReplace()' は protected と宣言されていません\n            ...\n        }\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReadResolveAndWriteReplaceProtected",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryLabelOnContinueStatement",
                "shortDescription": {
                  "text": "'continue' ステートメントの不要なラベル"
                },
                "fullDescription": {
                  "text": "不要なラベル付きの 'continue' ステートメントを報告します。 例: 'LABEL:\n  while (a > b) {\n    System.out.println(\"Hello\");\n    //以下のコードはループの最後のステートメントであるため、\n    //不要なラベルと continue を除去できます\n    continue LABEL;\n  }'",
                  "markdown": "不要なラベル付きの `continue` ステートメントを報告します。\n\n例:\n\n\n      LABEL:\n      while (a > b) {\n        System.out.println(\"Hello\");\n        //以下のコードはループの最後のステートメントであるため、\n        //不要なラベルと continue を除去できます\n        continue LABEL;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryLabelOnContinueStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageDotHtmlMayBePackageInfo",
                "shortDescription": {
                  "text": "'package-info.java' に変換可能な 'package.html'"
                },
                "fullDescription": {
                  "text": "パッケージのドキュメント生成に使用されている 'package.html' ファイルを報告します。 JDK 1.5 以降は 'package-info.java' ファイルを代わりに使用することが推奨されています。当該ファイルはパッケージのアノテーションも含んでいるためです。 そうすれば、package-info.java がパッケージレベルのアノテーションとドキュメント用の唯一のリポジトリになります。 例: 'package.html' '<html>\n  <body>\n    Documentation example.\n  </body>\n</html>' クイックフィックス適用後: 'package-info.java' '/**\n * Documentation example.\n */\npackage com.sample;'",
                  "markdown": "パッケージのドキュメント生成に使用されている `package.html` ファイルを報告します。\n\nJDK 1.5 以降は `package-info.java` ファイルを代わりに使用することが推奨されています。当該ファイルはパッケージのアノテーションも含んでいるためです。 そうすれば、package-info.java がパッケージレベルのアノテーションとドキュメント用の唯一のリポジトリになります。\n\n例: `package.html`\n\n\n    <html>\n      <body>\n        Documentation example.\n      </body>\n    </html>\n\nクイックフィックス適用後: `package-info.java`\n\n\n    /**\n     * Documentation example.\n     */\n    package com.sample;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageDotHtmlMayBePackageInfo",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LongLiteralsEndingWithLowercaseL",
                "shortDescription": {
                  "text": "'L' の代わりに 'l' で終わっている 'long' リテラル"
                },
                "fullDescription": {
                  "text": "小文字の 'l' で終わっている 'long' リテラルを報告します。 小文字の 'l' はリテラルの '1' (数値) と非常によく似ているため、このようなリテラルは混乱を招く可能性があります。 例: 'long nights = 100l;' クイックフィックス適用後: 'long nights = 100L;'",
                  "markdown": "小文字の 'l' で終わっている `long` リテラルを報告します。 小文字の 'l' はリテラルの '1' (数値) と非常によく似ているため、このようなリテラルは混乱を招く可能性があります。\n\n**例:**\n\n\n      long nights = 100l;\n\nクイックフィックス適用後:\n\n\n      long nights = 100L;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LongLiteralEndingWithLowercaseL",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantArrayCreation",
                "shortDescription": {
                  "text": "冗長な配列の作成"
                },
                "fullDescription": {
                  "text": "可変引数パラメーターとして渡すだけの目的で作成されている配列を報告します。 例: 'Arrays.asList(new String[]{\"Hello\", \"world\"})' クイックフィックスを使用すると、配列イニシャライザーが個々の引数に置換されます。 'Arrays.asList(\"Hello\", \"world\")'",
                  "markdown": "可変引数パラメーターとして渡すだけの目的で作成されている配列を報告します。\n\n例:\n\n`Arrays.asList(new String[]{\"Hello\", \"world\"})`\n\nクイックフィックスを使用すると、配列イニシャライザーが個々の引数に置換されます。\n\n`Arrays.asList(\"Hello\", \"world\")`"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantArrayCreation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterNamingConvention",
                "shortDescription": {
                  "text": "メソッドパラメーターの命名規則"
                },
                "fullDescription": {
                  "text": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないメソッドパラメーターを報告します。 例: 'void fooBar(int X)' は、このインスペクションがパラメーター名の開始文字が小文字であることを要求するデフォルト設定で有効になっている場合に報告されます。 インスペクションの構成: メソッドパラメーターの名前に期待される最小文字数、最大文字数、および正規表現を指定するには、「オプション」セクションのフィールドを使用します。 名前の長さをチェックしない場合は、0 を指定します。 正規表現は標準的な 'java.util.regex' 形式で指定する必要があります。",
                  "markdown": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないメソッドパラメーターを報告します。\n\n**例:** `void fooBar(int X)` は、このインスペクションがパラメーター名の開始文字が小文字であることを要求するデフォルト設定で有効になっている場合に報告されます。\n\nインスペクションの構成:\n\n\nメソッドパラメーターの名前に期待される最小文字数、最大文字数、および正規表現を指定するには、「**オプション** 」セクションのフィールドを使用します。 名前の長さをチェックしない場合は、**0** を指定します。\n\n正規表現は標準的な `java.util.regex` 形式で指定する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodParameterNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規約",
                      "index": 51,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodCanBeVariableArityMethod",
                "shortDescription": {
                  "text": "可変引数パラメーターを指定可能なメソッド"
                },
                "fullDescription": {
                  "text": "可変長引数メソッドに変換できるメソッドを報告します。 例: 'void process(String name, Object[] objects);' クイックフィックス適用後: 'void process(String name, Object... objects);' このインスペクションは Java 5 以降で使用できる Java の機能 '可変引数メソッド' に依存しています。",
                  "markdown": "可変長引数メソッドに変換できるメソッドを報告します。\n\n**例:**\n\n\n      void process(String name, Object[] objects);\n\nクイックフィックス適用後:\n\n\n      void process(String name, Object... objects);\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 '可変引数メソッド' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MethodCanBeVariableArityMethod",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonShortCircuitBoolean",
                "shortDescription": {
                  "text": "非短絡ブール式"
                },
                "fullDescription": {
                  "text": "非短絡形式のブール演算子 'and' および 'or' ('&'、'|'、'&='、'|=') の使用箇所を報告します。 非短絡形式は便利な場合もありますが、多くの場合は短絡形式 ('&&' と '||') が意図されています。また、このような意図しない使用はバグの検出を困難にする可能性があります。 短絡形式を使用するためのクイックフィックスが提案されます。 例: 'void foo(boolean x, boolean y, boolean z) {\n    if (x | y) { x |= z; }\n  }' クイックフィックス適用後: 'void foo(boolean x, boolean y) {\n    if (x || y) { x = x || z; }\n  }'",
                  "markdown": "非短絡形式のブール演算子 'and' および 'or' (`&`、`|`、`&=`、`|=`) の使用箇所を報告します。 非短絡形式は便利な場合もありますが、多くの場合は短絡形式 (`&&` と `||`) が意図されています。また、このような意図しない使用はバグの検出を困難にする可能性があります。\n\n\n短絡形式を使用するためのクイックフィックスが提案されます。\n\n**例:**\n\n\n      void foo(boolean x, boolean y, boolean z) {\n        if (x | y) { x |= z; }\n      }\n\nクイックフィックス適用後:\n\n\n      void foo(boolean x, boolean y) {\n        if (x || y) { x = x || z; }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonShortCircuitBooleanExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractClassNeverImplemented",
                "shortDescription": {
                  "text": "具象サブクラスを持たない抽象クラス"
                },
                "fullDescription": {
                  "text": "具象サブクラスがない 'abstract' クラスを報告します。 非推奨の抽象クラスは報告されません。",
                  "markdown": "具象サブクラスがない `abstract` クラスを報告します。 非推奨の抽象クラスは報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractClassNeverImplemented",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowablePrintedToSystemOut",
                "shortDescription": {
                  "text": "'System.out' に出力されている 'Throwable'"
                },
                "fullDescription": {
                  "text": "例外を引数に取っている 'System.out.println()' の呼び出しを報告します。 例外の記録に print ステートメントを使用すると、スタックトレースがユーザーから見えなくなるため、問題の調査が複雑化する場合があります。 代わりに logger を使用することをお勧めします。 例外を引数に取っている 'System.out.print()'、'System.err.println()'、'System.err.print()' も報告されます。 例外は、logger を使用して記録するのが無難です。 提供されるクイックフィックスは SLF4J と Log4j 2 をサポートしています。 'System.out.println()' の呼び出しをログ呼び出しに置換します 例: 'try {\n      foo();\n  } catch (Exception e) {\n      System.out.println(e);\n  }' クイックフィックス適用後: 'try {\n      foo();\n  } catch (Exception e) {\n    log.error(\"e: \", e);\n  }' メッセージをログに記録するために使用されるメソッドを指定するには、「修正用のログメソッド」オプションを使用します。",
                  "markdown": "例外を引数に取っている `System.out.println()` の呼び出しを報告します。\n\n例外の記録に print ステートメントを使用すると、スタックトレースがユーザーから見えなくなるため、問題の調査が複雑化する場合があります。\n代わりに logger を使用することをお勧めします。\n\n例外を引数に取っている `System.out.print()`、`System.err.println()`、`System.err.print()` も報告されます。 例外は、logger を使用して記録するのが無難です。\n\n提供されるクイックフィックスは **SLF4J** と **Log4j 2** をサポートしています。\n`System.out.println()` の呼び出しをログ呼び出しに置換します\n\n**例:**\n\n\n      try {\n          foo();\n      } catch (Exception e) {\n          System.out.println(e);\n      }\n\nクイックフィックス適用後:\n\n\n      try {\n          foo();\n      } catch (Exception e) {\n        log.error(\"e: \", e);\n      }\n\n\nメッセージをログに記録するために使用されるメソッドを指定するには、「**修正用のログメソッド**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowablePrintedToSystemOut",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コード成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StreamToLoop",
                "shortDescription": {
                  "text": "ループに置換可能な Stream API 呼び出しチェーン"
                },
                "fullDescription": {
                  "text": "従来のループに自動的に変換できる Stream API チェーン、'Iterable.forEach()'、'Map.forEach()' の呼び出しを報告します。 このインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。 例: 'String joinNonEmpty(List<String> list) {\n    return list.stream() // ストリームはループに変換できます\n      .filter(s -> !s.isEmpty())\n      .map(String::trim)\n      .collect(Collectors.joining(\", \"));\n  }' クイックフィックス適用後: 'String joinNonEmpty(List<String> list) {\n    StringJoiner joiner = new StringJoiner(\", \");\n    for (String s : list) {\n      if (!s.isEmpty()) {\n        String trim = s.trim();\n        joiner.add(trim);\n      }\n    }\n    return joiner.toString();\n  }' このインスペクションにより、セマンティクスが僅かに変更される場合があります。ご注意ください。 ストリームが短絡するときに読み取られる要素の実際の数は指定されないため、短絡については特別な配慮が必要です。 インスペクションの構成: ソースを認識できないストリームの変換を提案するには、「Stream.iterator() を介して不明なストリームソースを繰り返す」オプションを使用します。 この場合、イテレーターがストリームから作成されます。 たとえば、ここではチェックボックスが選択されている場合に変換が提案されます。 'List<ProcessHandle> handles = ProcessHandle.allProcesses().collect(Collectors.toList());' この場合は、以下のような結果になります。 'List<ProcessHandle> handles = new ArrayList<>();\n  for (Iterator<ProcessHandle> it = ProcessHandle.allProcesses().iterator(); it.hasNext(); ) {\n    ProcessHandle allProcess = it.next();\n    handles.add(allProcess);\n  }' 2017.1 の新機能です このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "従来のループに自動的に変換できる Stream API チェーン、`Iterable.forEach()`、`Map.forEach()` の呼び出しを報告します。 このインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。\n\n**例:**\n\n\n      String joinNonEmpty(List<String> list) {\n        return list.stream() // ストリームはループに変換できます\n          .filter(s -> !s.isEmpty())\n          .map(String::trim)\n          .collect(Collectors.joining(\", \"));\n      }\n\nクイックフィックス適用後:\n\n\n      String joinNonEmpty(List<String> list) {\n        StringJoiner joiner = new StringJoiner(\", \");\n        for (String s : list) {\n          if (!s.isEmpty()) {\n            String trim = s.trim();\n            joiner.add(trim);\n          }\n        }\n        return joiner.toString();\n      }\n\n\nこのインスペクションにより、セマンティクスが僅かに変更される場合があります。ご注意ください。\nストリームが短絡するときに読み取られる要素の実際の数は指定されないため、短絡については特別な配慮が必要です。\n\nインスペクションの構成:\n\nソースを認識できないストリームの変換を提案するには、「**Stream.iterator() を介して不明なストリームソースを繰り返す**」オプションを使用します。\nこの場合、イテレーターがストリームから作成されます。\nたとえば、ここではチェックボックスが選択されている場合に変換が提案されます。\n\n\n      List<ProcessHandle> handles = ProcessHandle.allProcesses().collect(Collectors.toList());\n\nこの場合は、以下のような結果になります。\n\n\n      List<ProcessHandle> handles = new ArrayList<>();\n      for (Iterator<ProcessHandle> it = ProcessHandle.allProcesses().iterator(); it.hasNext(); ) {\n        ProcessHandle allProcess = it.next();\n        handles.add(allProcess);\n      }\n\n2017.1 の新機能です\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "StreamToLoop",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NotifyWithoutCorrespondingWait",
                "shortDescription": {
                  "text": "対応する 'wait()' のない 'notify()'"
                },
                "fullDescription": {
                  "text": "'Object.notify()' または 'Object.notifyAll()' の呼び出しのうち、対応する 'Object.wait()' の呼び出しが見つからないものを報告します。 このインスペクションは、現在のクラスのフィールドを対象とする呼び出しのみを報告します。 例: 'synchronized (synList) {\n    synList.notify(); //synList.wait() が呼び出されることはありません\n  }'",
                  "markdown": "`Object.notify()` または `Object.notifyAll()` の呼び出しのうち、対応する `Object.wait()` の呼び出しが見つからないものを報告します。\n\nこのインスペクションは、現在のクラスのフィールドを対象とする呼び出しのみを報告します。\n\n**例:**\n\n\n      synchronized (synList) {\n        synList.notify(); //synList.wait() が呼び出されることはありません\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NotifyWithoutCorrespondingWait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantRecordConstructor",
                "shortDescription": {
                  "text": "冗長なレコードコンストラクター"
                },
                "fullDescription": {
                  "text": "Java レコード内で宣言されている冗長なコンストラクターを報告します。 例 1: 'record Point(int x, int y) {\n    public Point {} // 除去可能\n  }\n  \n  record Point(int x, int y) {\n    public Point(int x, int y) { // 除去可能\n      this.x = x;\n      this.y = y;\n    }\n  }' クイックフィックスを使用すると、冗長なコンストラクターが除去されます。 例 2: '// コンパクトコンストラクターに変換可能\n  record Range(int from, int to) {\n    public Range(int from, int to) {\n      if (from > to) throw new IllegalArgumentException();\n      this.from = from;\n      this.to = to;\n    }\n  }' クイックフィックスを使用すると、このコードがコンパクトコンストラクターに変換されます。 2020.1 の新機能です このインスペクションは Java 16 以降で使用できる Java の機能 'レコード' に依存しています。",
                  "markdown": "Java レコード内で宣言されている冗長なコンストラクターを報告します。\n\n**例 1:**\n\n\n      record Point(int x, int y) {\n        public Point {} // 除去可能\n      }\n      \n      record Point(int x, int y) {\n        public Point(int x, int y) { // 除去可能\n          this.x = x;\n          this.y = y;\n        }\n      }\n\nクイックフィックスを使用すると、冗長なコンストラクターが除去されます。\n\n**例 2:**\n\n\n       // コンパクトコンストラクターに変換可能\n      record Range(int from, int to) {\n        public Range(int from, int to) {\n          if (from > to) throw new IllegalArgumentException();\n          this.from = from;\n          this.to = to;\n        }\n      }\n\nクイックフィックスを使用すると、このコードがコンパクトコンストラクターに変換されます。\n\n2020.1 の新機能です\n\nこのインスペクションは Java 16 以降で使用できる Java の機能 'レコード' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantRecordConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AmbiguousMethodCall",
                "shortDescription": {
                  "text": "ローカルメソッド呼び出しに見える継承メソッド呼び出し"
                },
                "fullDescription": {
                  "text": "匿名、内部、またはローカルクラスを囲む外側のコードに同じシグネチャーのメソッドがあり、それらのクラスからスーパークラスのメソッドを呼び出している場合に報告します。 このような場合、実際にはスーパークラスのメソッドの呼び出しであっても、外側のコードのメソッドが呼び出されているように見えるかもしれません。 コードの意図を明確にするために、メソッドの呼び出しに明示的な 'super' 修飾子を追加することをお勧めします。 例: 'class Parent {\n    void ambiguous(){}\n  }\n\n  class Example {\n    void ambiguous(){}\n\n    class Inner extends Parent {\n      void example(){\n        ambiguous(); //警告\n      }\n    }\n  }' クイックフィックス適用後: 'class Parent {\n    void ambiguous(){}\n  }\n\n  class Example {\n    void ambiguous(){}\n\n    class Inner extends Parent {\n      void example(){\n        super.ambiguous();\n      }\n    }\n  }'",
                  "markdown": "匿名、内部、またはローカルクラスを囲む外側のコードに同じシグネチャーのメソッドがあり、それらのクラスからスーパークラスのメソッドを呼び出している場合に報告します。 このような場合、実際にはスーパークラスのメソッドの呼び出しであっても、外側のコードのメソッドが呼び出されているように見えるかもしれません。\n\n\nコードの意図を明確にするために、メソッドの呼び出しに明示的な `super` 修飾子を追加することをお勧めします。\n\n**例:**\n\n\n      class Parent {\n        void ambiguous(){}\n      }\n\n      class Example {\n        void ambiguous(){}\n\n        class Inner extends Parent {\n          void example(){\n            ambiguous(); //警告\n          }\n        }\n      }\n      \nクイックフィックス適用後:\n\n\n      class Parent {\n        void ambiguous(){}\n      }\n\n      class Example {\n        void ambiguous(){}\n\n        class Inner extends Parent {\n          void example(){\n            super.ambiguous();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AmbiguousMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassInitializerMayBeStatic",
                "shortDescription": {
                  "text": "'static' 指定可能なクラスイニシャライザー"
                },
                "fullDescription": {
                  "text": "'static' にできるインスタンスイニシャライザーを報告します。 所属クラスの非 static メンバーを参照していないインスタンスイニシャライザーは static にできます。 インスタンスイニシャライザーはクラスをインスタンス化するたびに実行されますが、static イニシャライザーはクラスが解決されるときに 1 回だけ実行されます。 このインスペクションは空のイニシャライザーと匿名クラスに含まれるインスタンスのイニシャライザーを報告しません。 例: 'class A {\n     public static String CONSTANT;\n     {\n        CONSTANT = \"Hello\";\n     }\n  }' クイックフィックス適用後: 'class A {\n     public static String CONSTANT;\n     static {\n        CONSTANT = \"Hello\"; // クラスごとに 1 回だけ初期化されるようになりました\n     }\n  }'",
                  "markdown": "`static` にできるインスタンスイニシャライザーを報告します。\n\n\n所属クラスの非 static メンバーを参照していないインスタンスイニシャライザーは static にできます。\nインスタンスイニシャライザーはクラスをインスタンス化するたびに実行されますが、static イニシャライザーはクラスが解決されるときに 1 回だけ実行されます。\n\nこのインスペクションは空のイニシャライザーと匿名クラスに含まれるインスタンスのイニシャライザーを報告しません。\n\n**例:**\n\n\n      class A {\n         public static String CONSTANT;\n         {\n            CONSTANT = \"Hello\";\n         }\n      }\n\nクイックフィックス適用後:\n\n\n      class A {\n         public static String CONSTANT;\n         static {\n            CONSTANT = \"Hello\"; // クラスごとに 1 回だけ初期化されるようになりました\n         }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassInitializerMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MagicCharacter",
                "shortDescription": {
                  "text": "マジックキャラクター"
                },
                "fullDescription": {
                  "text": "定数宣言なしで使用されている文字リテラルを報告します。 このような文字があると、コードの可読性が低下する可能性があります。 また、文字がコード内のすべての場所ではなく 1 つの場所でのみ変更された場合にエラーが発生する可能性があります。 例: 'char c = 'c';'",
                  "markdown": "定数宣言なしで使用されている文字リテラルを報告します。 このような文字があると、コードの可読性が低下する可能性があります。 また、文字がコード内のすべての場所ではなく 1 つの場所でのみ変更された場合にエラーが発生する可能性があります。\n\n**例:**\n\n    char c = 'c';\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MagicCharacter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SlowAbstractSetRemoveAll",
                "shortDescription": {
                  "text": "'set.removeAll(list)' の呼び出しは動作が遅い場合があります"
                },
                "fullDescription": {
                  "text": "'java.util.List' 引数を持つ 'java.util.Set.removeAll()' の呼び出しを報告します。 引数のサイズがセットのサイズ以上、かつセットが 'java.util.AbstractSet' のサブクラスである場合、このような呼び出しの処理速度は低下する可能性があります。 このような場合はセットの各要素に対して 'List.contains()' が呼び出され、線形探索が実行されます。 例: 'public void check(String... ss) {\n    // possible O(n^2) complexity\n    mySet.removeAll(List.of(ss));\n  }' クイックフィックス適用後: 'public void check(String... ss) {\n    // O(n) complexity\n    List.of(ss).forEach(mySet::remove);\n  }' 2020.3 の新機能です",
                  "markdown": "`java.util.List` 引数を持つ `java.util.Set.removeAll()` の呼び出しを報告します。\n\n\n引数のサイズがセットのサイズ以上、かつセットが `java.util.AbstractSet` のサブクラスである場合、このような呼び出しの処理速度は低下する可能性があります。\nこのような場合はセットの各要素に対して `List.contains()` が呼び出され、線形探索が実行されます。\n\n**例:**\n\n\n      public void check(String... ss) {\n        // possible O(n^2) complexity\n        mySet.removeAll(List.of(ss));\n      }\n\nクイックフィックス適用後:\n\n\n      public void check(String... ss) {\n        // O(n) complexity\n        List.of(ss).forEach(mySet::remove);\n      }\n\n2020.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SlowAbstractSetRemoveAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayEquality",
                "shortDescription": {
                  "text": "'Arrays.equals()' の代わりに '==' を使用した配列比較"
                },
                "fullDescription": {
                  "text": "配列の等価性をテストするために使用されている演算子 '==' と '!=' を報告します。 このようなコードはほとんどの場合、配列の内容が等しいかどうかをテストすることを目的としています。このテストは、'java.util.Arrays.equals()' メソッドで実行できます。 '==' を 'java.util.Arrays.equals()' に置換するクイックフィックスが提案されます。 例: 'void foo(Object[] x, Object[] y) {\n    boolean comparison = x == y;\n  }' クイックフィックス適用後: 'void foo(Object[] x, Object[] y) {\n    boolean comparison = Arrays.equals(x, y);\n  }'",
                  "markdown": "配列の等価性をテストするために使用されている演算子 `==` と `!=` を報告します。 このようなコードはほとんどの場合、配列の内容が等しいかどうかをテストすることを目的としています。このテストは、`java.util.Arrays.equals()` メソッドで実行できます。\n\n\n`==` を `java.util.Arrays.equals()` に置換するクイックフィックスが提案されます。\n\n**例:**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\nクイックフィックス適用後:\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayEquality",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticInheritance",
                "shortDescription": {
                  "text": "static の継承"
                },
                "fullDescription": {
                  "text": "定数へのアクセスを提供する目的でのみ実装されているインターフェースを報告します。 この種の継承は混乱を招きやすく、重要な依存関係情報を見えなくする可能性があります。",
                  "markdown": "定数へのアクセスを提供する目的でのみ実装されているインターフェースを報告します。 この種の継承は混乱を招きやすく、重要な依存関係情報を見えなくする可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticInheritance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/継承関連の問題",
                      "index": 26,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticCollection",
                "shortDescription": {
                  "text": "static コレクション"
                },
                "fullDescription": {
                  "text": "'Collection' 型の static フィールドを報告します。 これは必ずしも問題ではありませんが、static コレクションは往々にしてメモリリークの原因となるため、一部のコーディング標準では禁止されています。 例: 'public class Example {\n    static List<String> list = new ArrayList<>();\n\n  }' インスペクションの構成: 'java.util.WeakHashMap' 型のフィールドを無視するには、「弱い static コレクションやマップを無視する」オプションを使用します。",
                  "markdown": "`Collection` 型の static フィールドを報告します。 これは必ずしも問題ではありませんが、static コレクションは往々にしてメモリリークの原因となるため、一部のコーディング標準では禁止されています。\n\n**例:**\n\n\n      public class Example {\n        static List<String> list = new ArrayList<>();\n\n      }\n\n\nインスペクションの構成:\n\n* `java.util.WeakHashMap` 型のフィールドを無視するには、「**弱い static コレクションやマップを無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticCollection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メモリ",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantUnmodifiable",
                "shortDescription": {
                  "text": "変更不可能なコレクションラッパーの冗長な使用箇所"
                },
                "fullDescription": {
                  "text": "'Collections' クラスからの変更不可能なコレクションラッパーの冗長な呼び出しを報告します。 変更不可能なコレクションラッパーに渡されている引数がすでにイミュータブルである場合、このようなラッパーは冗長になります。 例: 'List<String> x = Collections.unmodifiableList(Collections.singletonList(\"abc\"));' クイックフィックス適用後: 'List<String> x = Collections.singletonList(\"abc\");' このインスペクションは変更不可能なコレクションを返すメソッドを検出するため、'org.jetbrains.annotations.Unmodifiable' および 'org.jetbrains.annotations.UnmodifiableView' アノテーションを使用します。 これらを使用すると、インスペクションを独自の変更不可能なコレクションラッパーに拡張できます。 2020.3 の新機能です",
                  "markdown": "`Collections` クラスからの変更不可能なコレクションラッパーの冗長な呼び出しを報告します。\n\n変更不可能なコレクションラッパーに渡されている引数がすでにイミュータブルである場合、このようなラッパーは冗長になります。\n\n例:\n\n\n      List<String> x = Collections.unmodifiableList(Collections.singletonList(\"abc\"));\n\nクイックフィックス適用後:\n\n\n      List<String> x = Collections.singletonList(\"abc\");\n\nこのインスペクションは変更不可能なコレクションを返すメソッドを検出するため、`org.jetbrains.annotations.Unmodifiable` および `org.jetbrains.annotations.UnmodifiableView` アノテーションを使用します。\nこれらを使用すると、インスペクションを独自の変更不可能なコレクションラッパーに拡張できます。\n\n2020.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantUnmodifiable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonExceptionNameEndsWithException",
                "shortDescription": {
                  "text": "クラス名が 'Exception' で終わる非例外クラス"
                },
                "fullDescription": {
                  "text": "名前が 'Exception' で終わっている非 'exception' クラスを報告します。 このようなクラスは一般的な命名規則に違反しているため、混乱を招く可能性があり、しばしば 'extends Exception' 節が欠落していることを示しています。 例: 'public class NotStartedException {}' このようなクラスの名前を変更するクイックフィックスは、エディターでのみ使用できます。",
                  "markdown": "名前が `Exception` で終わっている非 `exception` クラスを報告します。\n\nこのようなクラスは一般的な命名規則に違反しているため、混乱を招く可能性があり、しばしば `extends Exception` 節が欠落していることを示しています。\n\n**例:**\n\n    public class NotStartedException {}\n\nこのようなクラスの名前を変更するクイックフィックスは、エディターでのみ使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonExceptionNameEndsWithException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規則/クラス",
                      "index": 68,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantValue",
                "shortDescription": {
                  "text": "定数値"
                },
                "fullDescription": {
                  "text": "true、false、null、またはゼロなど、常に同じ結果になる式と条件を報告します。 そのような式は対応する定数値に置換することができます。 また、非常に多くの場合、コードにバグがあることを示しています。 例: '// 常に true\n  // 根本的な原因: && の代わりに || を使用している\n  if (x > 0 || x < 10) {}\n\n  System.out.println(str.trim());\n  // 常に false\n  // 根本的な原因: 変数が null チェックの前に逆参照された\n  if (str == null) {}' このインスペクションの動作は、nullability アノテーション、'@Contract' アノテーション、'@Range' アノテーションなどのさまざまなアノテーションで制御できます。 インスペクションの構成: 常に true になることが静的に証明されているアサーションの報告を避けるには、「常に true になることが静的に証明されている条件を含むアサーションを報告しない」オプションを使用します。 このような条件には、'if (alwaysFalseCondition) throw new IllegalArgumentException();' なども含まれます。 インスペクションによる 'assert' ステートメントの取り扱いを制御するには、「assert ステートメントを無視する」オプションを使用します。 このオプションは、デフォルトでは無効化されており、アサーションは実行されるものとして扱われます (-ea モード)。 このオプションが有効な場合、アサーションは完全に無視されます (-da モード)。 値が定数であると分かっている変数が使用されている場合に警告を表示するには、「定数が変数に格納された場合に警告する」オプションを使用します。 IntelliJ IDEA 2022.3 より前は、このインスペクションは \"定数条件および例外\" インスペクションの一部でした。 現在、そのインスペクションは \"定数値\" と \"null 許容性とデータフローの問題\" の 2 つのインスペクションに分割されています。",
                  "markdown": "true、false、null、またはゼロなど、常に同じ結果になる式と条件を報告します。 そのような式は対応する定数値に置換することができます。 また、非常に多くの場合、コードにバグがあることを示しています。\n\n例:\n\n      // 常に true\n      // 根本的な原因: && の代わりに || を使用している\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // 常に false\n      // 根本的な原因: 変数が null チェックの前に逆参照された\n      if (str == null) {}\n\n\nこのインスペクションの動作は、[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) アノテーション、[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) アノテーション、`@Range` アノテーションなどのさまざまなアノテーションで制御できます。\n\nインスペクションの構成:\n\n* 常に true になることが静的に証明されているアサーションの報告を避けるには、「**常に true になることが静的に証明されている条件を含むアサーションを報告しない** 」オプションを使用します。 このような条件には、`if (alwaysFalseCondition) throw new IllegalArgumentException();` なども含まれます。\n* インスペクションによる `assert` ステートメントの取り扱いを制御するには、「**assert ステートメントを無視する**」オプションを使用します。 このオプションは、デフォルトでは無効化されており、アサーションは実行されるものとして扱われます (-ea モード)。 このオプションが有効な場合、アサーションは完全に無視されます (-da モード)。\n* 値が定数であると分かっている変数が使用されている場合に警告を表示するには、「**定数が変数に格納された場合に警告する**」オプションを使用します。\n\n\nIntelliJ IDEA 2022.3 より前は、このインスペクションは \"定数条件および例外\" インスペクションの一部でした。 現在、そのインスペクションは \"定数値\" と \"null 許容性とデータフローの問題\" の 2 つのインスペクションに分割されています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastCanBeReplacedWithVariable",
                "shortDescription": {
                  "text": "キャストは変数に置換できます"
                },
                "fullDescription": {
                  "text": "同じ値を持つ既存のローカル変数またはパターン変数に置換できる型キャスト演算を報告します。 例: 'void foo(Object obj) {\n    String s = (String) obj;\n    System.out.println(((String) obj).trim());\n  }' クイックフィックス適用後: 'void foo(Object obj) {\n    String s = (String) obj;\n    System.out.println(s.trim());\n  }' 2022.3 の新機能です",
                  "markdown": "同じ値を持つ既存のローカル変数またはパターン変数に置換できる型キャスト演算を報告します。\n\n例:\n\n\n      void foo(Object obj) {\n        String s = (String) obj;\n        System.out.println(((String) obj).trim());\n      }\n\nクイックフィックス適用後:\n\n\n      void foo(Object obj) {\n        String s = (String) obj;\n        System.out.println(s.trim());\n      }\n\n2022.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CastCanBeReplacedWithVariable",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Convert2Diamond",
                "shortDescription": {
                  "text": "明示的な型は '<>' に置換できます"
                },
                "fullDescription": {
                  "text": "型引数を持つ 'new' 式で、ダイヤモンド型 '<>' に置換できるものを報告します。 例: 'List<String> list = new ArrayList<String>(); // 配列リストの型引数を報告します' クイックフィックス適用後: 'List<String> list = new ArrayList<>();' このインスペクションは Java 7 以降で使用できる Java の機能 'ダイヤモンド型' に依存しています。",
                  "markdown": "型引数を持つ `new` 式で、ダイヤモンド型 `<>` に置換できるものを報告します。\n\n例:\n\n\n      List<String> list = new ArrayList<String>(); // 配列リストの型引数を報告します\n\nクイックフィックス適用後:\n\n\n      List<String> list = new ArrayList<>();\n\nこのインスペクションは Java 7 以降で使用できる Java の機能 'ダイヤモンド型' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Convert2Diamond",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 7",
                      "index": 114,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VarargParameter",
                "shortDescription": {
                  "text": "可変引数メソッド"
                },
                "fullDescription": {
                  "text": "任意の数のパラメーターを受け入れるメソッド (可変引数メソッドとも呼ばれる) を報告します。 例: 'enum EnumConstants {\n  A(null), B, C;\n\n  EnumConstants(String... ss) {}\n}' 可変引数パラメーターを同等の配列パラメーターに置換するクイックフィックスを使用できます。 メソッド呼び出しの関連する引数は、配列イニシャライザー式で囲まれます。 クイックフィックス適用後: 'enum EnumConstants {\n  A(null), B(new String[]{}), C(new String[]{});\n\n  EnumConstants(String[] ss) {}\n}' 可変引数メソッドは Java 5 で登場しました。 このインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。",
                  "markdown": "任意の数のパラメーターを受け入れるメソッド (可変引数メソッドとも呼ばれる) を報告します。\n\n**例:**\n\n\n      enum EnumConstants {\n      A(null), B, C;\n\n      EnumConstants(String... ss) {}\n    }\n\n可変引数パラメーターを同等の配列パラメーターに置換するクイックフィックスを使用できます。 メソッド呼び出しの関連する引数は、配列イニシャライザー式で囲まれます。\nクイックフィックス適用後:\n\n\n      enum EnumConstants {\n      A(null), B(new String[]{}), C(new String[]{});\n\n      EnumConstants(String[] ss) {}\n    }\n\n\n*可変引数メソッド*は Java 5 で登場しました。\nこのインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "VariableArgumentMethod",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java の言語レベル関連の問題",
                      "index": 61,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassComplexity",
                "shortDescription": {
                  "text": "過度に複雑なクラス"
                },
                "fullDescription": {
                  "text": "合計複雑度が指定された最大値を超えているクラスを報告します。 クラスの合計複雑度は、そのクラスで宣言されているすべてのメソッドとイニシャライザーのサイクロマティック複雑度を合計したものです。 継承先のメソッドやイニシャライザーは合計複雑度の考慮対象外です。 複雑度が高すぎる場合は、クラスをより小さな複数のクラスにリファクタリングする必要があります。 クラスで許容される複雑度の最大値を指定するには、以下の「サイクロマティック複雑度の制限」フィールドを使用します。",
                  "markdown": "合計複雑度が指定された最大値を超えているクラスを報告します。\n\nクラスの合計複雑度は、そのクラスで宣言されているすべてのメソッドとイニシャライザーのサイクロマティック複雑度を合計したものです。 継承先のメソッドやイニシャライザーは合計複雑度の考慮対象外です。\n\n複雑度が高すぎる場合は、クラスをより小さな複数のクラスにリファクタリングする必要があります。\n\nクラスで許容される複雑度の最大値を指定するには、以下の「**サイクロマティック複雑度の制限**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラスメトリクス",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemGC",
                "shortDescription": {
                  "text": "'System.gc()' または 'Runtime.gc()' への呼び出し"
                },
                "fullDescription": {
                  "text": "'System.gc()' または 'Runtime.gc()' の呼び出しを報告します。 テストでは便利な場合もありますが、'System.gc()' を使用した明示的なガベージコレクションの呼び出しはプロダクションコードではほぼ推奨されません。また、重大なパフォーマンスの問題を引き起こす可能性があります。",
                  "markdown": "`System.gc()` または `Runtime.gc()` の呼び出しを報告します。 テストでは便利な場合もありますが、`System.gc()` を使用した明示的なガベージコレクションの呼び出しはプロダクションコードではほぼ推奨されません。また、重大なパフォーマンスの問題を引き起こす可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemGC",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メモリ",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayLengthInLoopCondition",
                "shortDescription": {
                  "text": "ループ条件内の Array.length"
                },
                "fullDescription": {
                  "text": "ループステートメントの条件部にある配列の '.length' プロパティへのアクセスを報告します。 リソースの使用が大幅に制限されている環境では、このような呼び出しはパフォーマンスに悪影響を及ぼす可能性があります。 このインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。 このインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。 例: 'void foo(Object[] x) {\n    for (int i = 0; i < x.length; i++) { /**/ }\n  }'",
                  "markdown": "ループステートメントの条件部にある配列の `.length` プロパティへのアクセスを報告します。 リソースの使用が大幅に制限されている環境では、このような呼び出しはパフォーマンスに悪影響を及ぼす可能性があります。\n\n\nこのインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。\nこのインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。\n\n**例:**\n\n\n      void foo(Object[] x) {\n        for (int i = 0; i < x.length; i++) { /**/ }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayLengthInLoopCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス/組み込み",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckForOutOfMemoryOnLargeArrayAllocation",
                "shortDescription": {
                  "text": "OutOfMemoryError チェックなしの大規模配列割り当て"
                },
                "fullDescription": {
                  "text": "'java.lang.OutOfMemoryError' をチェックしていない大規模配列割り当てを報告します。 メモリの使用が制限されている環境で大規模なデータオブジェクトの割り当てを行う場合、メモリが枯渇しないかどうかをチェックする必要があると思われます。 このインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。 このインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。 チェックのない配列割り当てで許容される要素の最大数を指定するには、オプションを使用します。",
                  "markdown": "`java.lang.OutOfMemoryError` をチェックしていない大規模配列割り当てを報告します。 メモリの使用が制限されている環境で大規模なデータオブジェクトの割り当てを行う場合、メモリが枯渇しないかどうかをチェックする必要があると思われます。\n\n\nこのインスペクションは、Java ME やリソースの使用が大幅に制限されているその他の環境を想定しています。\nこのインスペクションの結果をよく考えずに適用した場合、コードの分かりやすさや設計に悪影響を及ぼす可能性があります。\n\n\nチェックのない配列割り当てで許容される要素の最大数を指定するには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CheckForOutOfMemoryOnLargeArrayAllocation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス/組み込み",
                      "index": 20,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithoutConstructor",
                "shortDescription": {
                  "text": "コンストラクターのないクラス"
                },
                "fullDescription": {
                  "text": "コンストラクターのないクラスを報告します。 一部のコーディング標準では、このようなクラスは禁止されています。",
                  "markdown": "コンストラクターのないクラスを報告します。\n\n一部のコーディング標準では、このようなクラスは禁止されています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithoutConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 関連の問題",
                      "index": 34,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverflowingLoopIndex",
                "shortDescription": {
                  "text": "0 回または無限に実行されるループ"
                },
                "fullDescription": {
                  "text": "インデックスがオーバーフローしない限り完了できないループか、まったくループしないループを報告します。 これは通常、更新操作での間違いが原因で起こります。 例: 'void foo(int s) {\n    for (int i = s; i > 12; i++) { // ここでは i-- を使用すべきです\n      System.out.println(i);\n    }\n  }' 2019.1 の新機能です",
                  "markdown": "インデックスがオーバーフローしない限り完了できないループか、まったくループしないループを報告します。 これは通常、更新操作での間違いが原因で起こります。\n\n例:\n\n\n      void foo(int s) {\n        for (int i = s; i > 12; i++) { // ここでは i-- を使用すべきです\n          System.out.println(i);\n        }\n      }\n\n2019.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverflowingLoopIndex",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InnerClassMayBeStatic",
                "shortDescription": {
                  "text": "内部クラスは 'static' 指定可能です"
                },
                "fullDescription": {
                  "text": "'static' にできる内部クラスを報告します。 'static' の内部クラスは、外部インスタンスへの暗黙的な参照を維持しません。 Java 17 以前を使用している場合、これによって一般的なメモリリークの原因が未然に取り除かれ、クラスインスタンスごとのメモリ消費量が削減されます。 例: 'public class Outer {\n    class Inner { // 非 static\n      public void foo() {\n        bar(\"x\");\n      }\n\n      private void bar(String string) {}\n    }\n  }' クイックフィックス適用後: 'public class Outer {\n    static class Inner {\n      public void foo() {\n        bar(\"x\");\n      }\n\n      private void bar(String string) {}\n    }\n  }'",
                  "markdown": "`static` にできる内部クラスを報告します。\n\n`static` の内部クラスは、外部インスタンスへの暗黙的な参照を維持しません。\nJava 17 以前を使用している場合、これによって一般的なメモリリークの原因が未然に取り除かれ、クラスインスタンスごとのメモリ消費量が削減されます。\n\n**例:**\n\n\n      public class Outer {\n        class Inner { // 非 static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メモリ",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9UndeclaredServiceUsage",
                "shortDescription": {
                  "text": "'module-info' で宣言されていないサービスの使用"
                },
                "fullDescription": {
                  "text": "サービスが 'java.util.ServiceLoader' でロードされているものの、'module-info.java' ファイル内では 'uses' 節を使用して宣言されていない状況を報告し、その節を挿入することを提案します。 2018.1 の新機能です このインスペクションは Java 9 以降で使用できる Java の機能 'モジュール' に依存しています。",
                  "markdown": "サービスが `java.util.ServiceLoader` でロードされているものの、`module-info.java` ファイル内では `uses` 節を使用して宣言されていない状況を報告し、その節を挿入することを提案します。\n\n2018.1 の新機能です\n\nこのインスペクションは Java 9 以降で使用できる Java の機能 'モジュール' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java9UndeclaredServiceUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可視性",
                      "index": 56,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SetReplaceableByEnumSet",
                "shortDescription": {
                  "text": "'EnumSet' に置換可能な 'Set'"
                },
                "fullDescription": {
                  "text": "コンテンツの型が列挙型クラスになっている 'java.util.Set' オブジェクトのインスタンス化を報告します。 このような 'Set' オブジェクトは 'java.util.EnumSet' オブジェクトに置換できます。 'EnumSet' で実装すると、他のセットと比較して大幅に効率が良くなります。その基本データ構造がビットベクトルであるためです。 イニシャライザーを 'EnumSet.noneOf()' の呼び出しに置換するには、クイックフィックスを使用します。 このクイックフィックスは、変数の型が 'Set' のサブクラスである場合に使用できます。 例: 'enum MyEnum { FOO, BAR; }\n\n  Set<MyEnum> enums = new HashSet<MyEnum>();' クイックフィックス適用後: 'enum MyEnum { FOO, BAR; }\n\n  Set<MyEnum> enums = EnumSet.noneOf(MyEnum.class);'",
                  "markdown": "コンテンツの型が列挙型クラスになっている `java.util.Set` オブジェクトのインスタンス化を報告します。 このような `Set` オブジェクトは `java.util.EnumSet` オブジェクトに置換できます。\n\n\n`EnumSet` で実装すると、他のセットと比較して大幅に効率が良くなります。その基本データ構造がビットベクトルであるためです。 イニシャライザーを `EnumSet.noneOf()` の呼び出しに置換するには、クイックフィックスを使用します。 このクイックフィックスは、変数の型が `Set` のサブクラスである場合に使用できます。\n\n**例:**\n\n\n      enum MyEnum { FOO, BAR; }\n\n      Set<MyEnum> enums = new HashSet<MyEnum>();\n\nクイックフィックス適用後:\n\n\n      enum MyEnum { FOO, BAR; }\n\n      Set<MyEnum> enums = EnumSet.noneOf(MyEnum.class);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SetReplaceableByEnumSet",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageInfoWithoutPackage",
                "shortDescription": {
                  "text": "'package' ステートメントがない 'package-info.java'"
                },
                "fullDescription": {
                  "text": "'package' ステートメントのない 'package-info.java' ファイルを報告します。 ファイルが他の場所にある場合でも、Javadoc ツールはデフォルトパッケージのこのようなファイルのドキュメントを考慮します。",
                  "markdown": "`package` ステートメントのない `package-info.java` ファイルを報告します。\n\n\nファイルが他の場所にある場合でも、Javadoc ツールはデフォルトパッケージのこのようなファイルのドキュメントを考慮します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageInfoWithoutPackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToSimpleSetterInClass",
                "shortDescription": {
                  "text": "クラス内からの単純な setter の呼び出し"
                },
                "fullDescription": {
                  "text": "プロパティのクラス内からの単純なプロパティ setter の呼び出しを報告します。 単純なプロパティ setter は単にパラメーターの値をフィールドに代入するものとして定義されており、その他の演算は行いません。 このような単純な setter は安全にインライン化できます。 一部のコーディング標準でも、コードの明確化を理由にした単純な setter の使用は推奨されていません。 例: 'class Foo {\n  private int index;\n    public Foo(int idx) {\n       setIndex(idx);\n    }\n    public void setIndex(int idx) {\n       index = idx;\n    }\n  }' クイックフィックス適用後: 'class Foo {\n    private int index;\n    public Foo(int idx) {\n      index = idx;\n    }\n    public void setIndex(int idx) {\n      index = idx;\n    }\n  }' このインスペクションは、次のオプションを使用して構成できます。 パラメーターとして渡された同じ型のオブジェクトではなく、'this' での setter 呼び出しのみを報告するかどうか。 非 'private' の setter を無視するかどうか。",
                  "markdown": "プロパティのクラス内からの単純なプロパティ setter の呼び出しを報告します。\n\n\n単純なプロパティ setter は単にパラメーターの値をフィールドに代入するものとして定義されており、その他の演算は行いません。 このような単純な setter は安全にインライン化できます。\n一部のコーディング標準でも、コードの明確化を理由にした単純な setter の使用は推奨されていません。\n\n**例:**\n\n\n      class Foo {\n      private int index;\n        public Foo(int idx) {\n           setIndex(idx);\n        }\n        public void setIndex(int idx) {\n           index = idx;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        private int index;\n        public Foo(int idx) {\n          index = idx;\n        }\n        public void setIndex(int idx) {\n          index = idx;\n        }\n      }\n\nこのインスペクションは、次のオプションを使用して構成できます。\n\n* パラメーターとして渡された同じ型のオブジェクトではなく、`this` での setter 呼び出しのみを報告するかどうか。\n* 非 `private` の setter を無視するかどうか。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSimpleSetterFromWithinClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneReturnsClassType",
                "shortDescription": {
                  "text": "'clone()' はそのクラスと同じ型を返す必要があります"
                },
                "fullDescription": {
                  "text": "'clone()' メソッドのうち、その戻り値の型が所属しているクラスとは異なっているものを報告します。 多くの場合、'clone()' メソッドの戻り型は 'java.lang.Object' であるため、クライアントが使用するのは困難です。 Effective Java (第 2 版および第 3 版) では、'clone()' メソッドの戻り値の型をそれが返すオブジェクトのクラス型と同じにすることを推奨しています。 例: 'class Foo implements Cloneable {\n    public Object clone() {\n      try {\n        return super.clone();\n      } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n      }\n    }\n  }' クイックフィックス適用後: 'class Foo implements Cloneable {\n    public Foo clone() {\n      try {\n        return (Foo)super.clone();\n      } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n      }\n    }\n  }'",
                  "markdown": "`clone()` メソッドのうち、その戻り値の型が所属しているクラスとは異なっているものを報告します。\n\n多くの場合、`clone()` メソッドの戻り型は `java.lang.Object` であるため、クライアントが使用するのは困難です。\n*Effective Java* (第 2 版および第 3 版) では、`clone()` メソッドの戻り値の型をそれが返すオブジェクトのクラス型と同じにすることを推奨しています。\n\n**例:**\n\n\n      class Foo implements Cloneable {\n        public Object clone() {\n          try {\n            return super.clone();\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo implements Cloneable {\n        public Foo clone() {\n          try {\n            return (Foo)super.clone();\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneReturnsClassType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クローン関連の問題",
                      "index": 79,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableWithSerializationMethods",
                "shortDescription": {
                  "text": "'readObject()' または 'writeObject()' を使用した非 Serializable クラス"
                },
                "fullDescription": {
                  "text": "'readObject()' または 'writeObject()' メソッドを定義している非 'Serializable' クラスを報告します。 多くの場合、このようなメソッドがこのコンテキストで使用されているのは誤りです。 例: 'public class SampleClass {\n    private void readObject(ObjectInputStream str) {}\n    private void writeObject(ObjectOutputStream str) {}\n  }'",
                  "markdown": "`readObject()` または `writeObject()` メソッドを定義している非 `Serializable` クラスを報告します。 多くの場合、このようなメソッドがこのコンテキストで使用されているのは誤りです。\n\n**例:**\n\n\n      public class SampleClass {\n        private void readObject(ObjectInputStream str) {}\n        private void writeObject(ObjectOutputStream str) {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableClassWithSerializationMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalToIf",
                "shortDescription": {
                  "text": "'Optional' は、一連の 'if' ステートメントに置換できます"
                },
                "fullDescription": {
                  "text": "連続する 'if' ステートメントに置換できる 'Optional' の呼び出しチェーンを報告します。 例: 'return Optional.ofNullable(name)\n    .map(this::extractInitials)\n    .map(initials -> initials.toUpperCase(Locale.ENGLISH))\n    .orElseGet(this::getDefault);' クイックフィックス適用後: 'if (name != null) {\n    String initials = extractInitials(name);\n    if (initials != null) return initials.toUpperCase(Locale.ENGLISH);\n  }\n  return getDefault();' このインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。 2020.2 の新機能です このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "連続する `if` ステートメントに置換できる `Optional` の呼び出しチェーンを報告します。\n\n例:\n\n\n      return Optional.ofNullable(name)\n        .map(this::extractInitials)\n        .map(initials -> initials.toUpperCase(Locale.ENGLISH))\n        .orElseGet(this::getDefault);\n\nクイックフィックス適用後:\n\n\n      if (name != null) {\n        String initials = extractInitials(name);\n        if (initials != null) return initials.toUpperCase(Locale.ENGLISH);\n      }\n      return getDefault();\n\n\nこのインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。\n\n2020.2 の新機能です\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "OptionalToIf",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryFinalOnLocalVariableOrParameter",
                "shortDescription": {
                  "text": "ローカル変数またはパラメーターの不要な 'final'"
                },
                "fullDescription": {
                  "text": "不要な 'final' 宣言を持つローカルの変数またはパラメーターを報告します。 一部のコーディング標準は、コードを簡潔にするために変数の 'final' 宣言を認めていません。 例: 'class Foo {\n    Foo(Object o) {}\n\n    void bar(final Object o) {\n      new Foo(o);\n    }\n  }' クイックフィックス適用後: 'class Foo {\n    Foo(Object o) {}\n\n    void bar(Object o) {\n      new Foo(o);\n    }\n  }' 報告対象を切り替えるには、インスペクションのオプションを使用します。 ローカル変数 パラメーター ('catch' ブロックと拡張 'for' ステートメントのパラメーターを含む) また、'abstract' メソッドまたはインターフェースメソッドの 'final' パラメーターのみを報告するようにインスペクションを構成することもできます。そのような記述はメソッドの実装に影響を及ぼさないため、特に不要だと考えられます。",
                  "markdown": "不要な `final` 宣言を持つローカルの変数またはパラメーターを報告します。\n\n一部のコーディング標準は、コードを簡潔にするために変数の `final` 宣言を認めていません。\n\n**例:**\n\n\n      class Foo {\n        Foo(Object o) {}\n\n        void bar(final Object o) {\n          new Foo(o);\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        Foo(Object o) {}\n\n        void bar(Object o) {\n          new Foo(o);\n        }\n      }\n\n\n報告対象を切り替えるには、インスペクションのオプションを使用します。\n\n* ローカル変数\n* パラメーター (`catch` ブロックと拡張 `for` ステートメントのパラメーターを含む)\n\n\nまた、`abstract` メソッドまたはインターフェースメソッドの `final` パラメーターのみを報告するようにインスペクションを構成することもできます。そのような記述はメソッドの実装に影響を及ぼさないため、特に不要だと考えられます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryFinalOnLocalVariableOrParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IllegalDependencyOnInternalPackage",
                "shortDescription": {
                  "text": "内部パッケージの不正な依存関係"
                },
                "fullDescription": {
                  "text": "パッケージに 'module-info.java' がなく、名前付きモジュールからエクスポートされていないモジュールにある参照を報告します。 このような構成が発生する可能性があるのは、プロジェクト内の一部のモジュールがすでに Java モジュールに移行されているものの、それ以外がまだ非モジュラーである場合です。 JDK と同様に、このような非モジュラーコードは明示的にエクスポートされていない名前付きモジュールのコードにアクセスすべきではありません。",
                  "markdown": "パッケージに `module-info.java` がなく、名前付きモジュールからエクスポートされていないモジュールにある参照を報告します。\n\nこのような構成が発生する可能性があるのは、プロジェクト内の一部のモジュールがすでに Java モジュールに移行されているものの、それ以外がまだ非モジュラーである場合です。\nJDK と同様に、このような非モジュラーコードは明示的にエクスポートされていない名前付きモジュールのコードにアクセスすべきではありません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "IllegalDependencyOnInternalPackage",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonBooleanMethodNameMayNotStartWithQuestion",
                "shortDescription": {
                  "text": "疑問詞で始まるべきでない非ブールメソッド名"
                },
                "fullDescription": {
                  "text": "名前が疑問詞で始まる非ブールメソッドを報告します。 このようなメソッド名は混乱を招く可能性があります。 ライブラリメソッドをオーバーライドする非ブールメソッドは、このインスペクションでは無視されます。 例: 'public void hasName(String name) {\n    assert names.contains(name);\n  }' このようなメソッドの名前を変更するクイックフィックスは、エディターでのみ使用できます。 インスペクションの構成: ブールメソッドにのみ疑問詞を使用するように指定するには、ブールメソッド名の接頭辞 リストを使用します。 戻り値の型が 'java.lang.Boolean' のメソッドを無視するには、「戻り値の型が 'java.lang.Boolean' のメソッドを無視する」オプションを使用します。 スーパーを持つメソッドを無視するには、「スーパーメソッドをオーバーライド/実装するメソッドを無視する」オプションを使用します。",
                  "markdown": "名前が疑問詞で始まる非ブールメソッドを報告します。 このようなメソッド名は混乱を招く可能性があります。\n\nライブラリメソッドをオーバーライドする非ブールメソッドは、このインスペクションでは無視されます。\n\n**例:**\n\n\n      public void hasName(String name) {\n        assert names.contains(name);\n      }\n\nこのようなメソッドの名前を変更するクイックフィックスは、エディターでのみ使用できます。\n\nインスペクションの構成:\n\n* ブールメソッドにのみ疑問詞を使用するように指定するには、**ブールメソッド名の接頭辞** リストを使用します。\n* 戻り値の型が `java.lang.Boolean` のメソッドを無視するには、「**戻り値の型が 'java.lang.Boolean' のメソッドを無視する**」オプションを使用します。\n* スーパーを持つメソッドを無視するには、「**スーパーメソッドをオーバーライド/実装するメソッドを無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonBooleanMethodNameMayNotStartWithQuestion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規則/メソッド",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WeakerAccess",
                "shortDescription": {
                  "text": "宣言に対するより限定的なアクセス"
                },
                "fullDescription": {
                  "text": "フィールド、メソッド、クラスのうち、アクセス修飾子を厳しくできるものを報告します。 例: 'class Sample {\n    void foo() {\n        bar(\"foo\", \"foo\");\n    }\n    void bar(String x, String y) { } // private にできます\n  }' クイックフィックス適用後: 'class Sample {\n    void foo() {\n        bar(\"foo\", \"foo\");\n    }\n    private void bar(String x, String y) { }\n  }' 修飾子変更の提案ルールを定義するには、インスペクションのオプションを使用します。",
                  "markdown": "フィールド、メソッド、クラスのうち、アクセス修飾子を厳しくできるものを報告します。\n\n例:\n\n\n      class Sample {\n        void foo() {\n            bar(\"foo\", \"foo\");\n        }\n        void bar(String x, String y) { } // private にできます\n      }\n\nクイックフィックス適用後:\n\n\n      class Sample {\n        void foo() {\n            bar(\"foo\", \"foo\");\n        }\n        private void bar(String x, String y) { }\n      }\n\n修飾子変更の提案ルールを定義するには、インスペクションのオプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WeakerAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceWithJavadoc",
                "shortDescription": {
                  "text": "Javadoc に置換できるコメント"
                },
                "fullDescription": {
                  "text": "フィールド、メソッド、またはクラスに属する通常のコメントで、Javadoc コメントに置換できるものを報告します。 例: 'public class Main {\n    /*\n    * Hello,\n    */\n    // World!\n    void f() {\n    }\n  }' クイックフィックス適用後: 'public class Main {\n    /**\n     * Hello,\n     * World!\n     */\n    void f() {\n    }\n  }'",
                  "markdown": "フィールド、メソッド、またはクラスに属する通常のコメントで、Javadoc コメントに置換できるものを報告します。\n\n**例:**\n\n\n      public class Main {\n        /*\n        * Hello,\n        */\n        // World!\n        void f() {\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public class Main {\n        /**\n         * Hello,\n         * World!\n         */\n        void f() {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceWithJavadoc",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BigDecimalMethodWithoutRoundingCalled",
                "shortDescription": {
                  "text": "丸めモード引数なしの 'BigDecimal' メソッド呼び出し"
                },
                "fullDescription": {
                  "text": "丸めモードの引数なしで 'divide()' または 'setScale()' が呼び出されていることを報告します。 このような呼び出しを行うと、正確な値を計算結果で表現できない場合に 'ArithmeticException' が発生します (計算結果が循環小数になる場合など)。 丸めモードを指定すると、'ArithmeticException' を防ぐことができます。 例: 'BigDecimal.valueOf(1).divide(BigDecimal.valueOf(3));'",
                  "markdown": "丸めモードの引数なしで `divide()` または `setScale()` が呼び出されていることを報告します。\n\nこのような呼び出しを行うと、正確な値を計算結果で表現できない場合に `ArithmeticException` が発生します (計算結果が循環小数になる場合など)。\n\n丸めモードを指定すると、`ArithmeticException` を防ぐことができます。\n\n**例:**\n\n\n      BigDecimal.valueOf(1).divide(BigDecimal.valueOf(3));\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BigDecimalMethodWithoutRoundingCalled",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyComplexArithmeticExpression",
                "shortDescription": {
                  "text": "過度に複雑な算術式"
                },
                "fullDescription": {
                  "text": "項が多すぎる算術式を報告します。 このような式は理解しにくく、間違いがある可能性があります。 パラメーター、フィールド参照、およびその他の主要な式が項としてカウントされます。 例: 'int calc(int a, int b) {\n        return a + a + a + b + b + b + b; // この行には 7 つの項があるため、報告されます。\n    }' 算術式で許容される項数を指定するには、以下のフィールドを使用します。",
                  "markdown": "項が多すぎる算術式を報告します。 このような式は理解しにくく、間違いがある可能性があります。\n\nパラメーター、フィールド参照、およびその他の主要な式が項としてカウントされます。\n\n**例:**\n\n    int calc(int a, int b) {\n            return a + a + a + b + b + b + b; // この行には 7 つの項があるため、報告されます。\n        }\n\n算術式で許容される項数を指定するには、以下のフィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexArithmeticExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数値関連の問題",
                      "index": 27,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DriverManagerGetConnection",
                "shortDescription": {
                  "text": "JDBC 接続を取得するための 'DriverManager' の使用"
                },
                "fullDescription": {
                  "text": "JDBC 接続の取得に 'java.sql.DriverManager' を使用していることを報告します。 'java.sql.DriverManager' は接続プーリングの対応やその他の最適化が実装された 'javax.sql.Datasource' に置き換えられています。 例: 'Connection conn = DriverManager.getConnection(url, username, password);'",
                  "markdown": "JDBC 接続の取得に `java.sql.DriverManager` を使用していることを報告します。\n\n\n`java.sql.DriverManager` は接続プーリングの対応やその他の最適化が実装された `javax.sql.Datasource` に置き換えられています。\n\n**例:**\n\n      Connection conn = DriverManager.getConnection(url, username, password);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToDriverManagerGetConnection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/リソース管理",
                      "index": 47,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WrapperTypeMayBePrimitive",
                "shortDescription": {
                  "text": "プリミティブ型にできるラッパー型"
                },
                "fullDescription": {
                  "text": "主にプリミティブ型として使用されているラッパー型のローカル変数を報告します。 ループ内など、場合によってはボクシングによってパフォーマンスが大幅に低下する場合があります。 ボクシング操作の数を予測するため、ヒューリスティックが適用されます。 たとえば、ループ内の変換ははるかに多いと見なされます。 例: 'public void example() {\n    Integer value = 12;\n    needBox(value);\n    for (int i = 0; i < 10; i++) {\n      // ループの使用頻度は高いと見なされます\n      needPrimitive(value);\n    }\n  }\n\n  void needPrimitive(int value) {}\n  void needBox(Integer value) {}' クイックフィックス適用後: 'public void example() {\n    int value = 12;\n    needBox(value);\n    for (int i = 0; i < 10; i++) {\n      // ループの使用頻度は高いと見なされます\n      needPrimitive(value);\n    }\n  }\n\n  void needPrimitive(int value) {}\n  void needBox(Integer value) {}' 2018.2 の新機能です",
                  "markdown": "主にプリミティブ型として使用されているラッパー型のローカル変数を報告します。\n\nループ内など、場合によってはボクシングによってパフォーマンスが大幅に低下する場合があります。\n\nボクシング操作の数を予測するため、ヒューリスティックが適用されます。 たとえば、ループ内の変換ははるかに多いと見なされます。\n\n**例:**\n\n      public void example() {\n        Integer value = 12;\n        needBox(value);\n        for (int i = 0; i < 10; i++) {\n          // ループの使用頻度は高いと見なされます\n          needPrimitive(value);\n        }\n      }\n\n      void needPrimitive(int value) {}\n      void needBox(Integer value) {}\n\nクイックフィックス適用後:\n\n      public void example() {\n        int value = 12;\n        needBox(value);\n        for (int i = 0; i < 10; i++) {\n          // ループの使用頻度は高いと見なされます\n          needPrimitive(value);\n        }\n      }\n\n      void needPrimitive(int value) {}\n      void needBox(Integer value) {}\n\n\n2018.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WrapperTypeMayBePrimitive",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyStatementBody",
                "shortDescription": {
                  "text": "本体が空のステートメント"
                },
                "fullDescription": {
                  "text": "本体が空の 'if'、'while'、'do'、'for'、'switch' ステートメントを報告します。 このようなコードは意図的な場合もありますが、混乱を招き、多くの場合はタイプミスによるものです。 このインスペクションは JSP ファイルでは無効になります。",
                  "markdown": "本体が空の `if`、`while`、`do`、`for`、`switch` ステートメントを報告します。\n\nこのようなコードは意図的な場合もありますが、混乱を招き、多くの場合はタイプミスによるものです。\n\nこのインスペクションは JSP ファイルでは無効になります。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StatementWithEmptyBody",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyFinallyBlock",
                "shortDescription": {
                  "text": "空の 'finally' ブロック"
                },
                "fullDescription": {
                  "text": "空の 'finally' ブロックを報告します。 空の 'finally' ブロックは多くの場合、コーディングの誤りです。 また、コードリファクタリングの残存物である可能性があり、安全に除去できます。 このインスペクションは JSP ファイルに含まれる空の 'finally' ブロックを報告しません。 例: 'try {\n    Files.readString(Paths.get(\"in.txt\"));\n  } catch (IOException e) {\n    throw new RuntimeException(e);\n  } finally {\n\n  }' クイックフィックス適用後: 'try {\n    Files.readString(Paths.get(\"in.txt\"));\n  } catch (IOException e) {\n    throw new RuntimeException(e);\n  }'",
                  "markdown": "空の `finally` ブロックを報告します。\n\n空の `finally` ブロックは多くの場合、コーディングの誤りです。 また、コードリファクタリングの残存物である可能性があり、安全に除去できます。\n\nこのインスペクションは JSP ファイルに含まれる空の `finally` ブロックを報告しません。\n\n**例:**\n\n\n      try {\n        Files.readString(Paths.get(\"in.txt\"));\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      } finally {\n\n      }\n\nクイックフィックス適用後:\n\n\n      try {\n        Files.readString(Paths.get(\"in.txt\"));\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InconsistentLanguageLevel",
                "shortDescription": {
                  "text": "矛盾する言語レベル設定"
                },
                "fullDescription": {
                  "text": "言語レベルがより高い別のモジュールに依存するモジュールを報告します。 このような依存関係を除去するか、モジュールの言語レベルを上げる必要があります。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "言語レベルがより高い別のモジュールに依存するモジュールを報告します。\n\nこのような依存関係を除去するか、モジュールの言語レベルを上げる必要があります。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InconsistentLanguageLevel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/モジュール化関連の問題",
                      "index": 65,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumerationCanBeIteration",
                "shortDescription": {
                  "text": "イテレーション可能な Enumeration"
                },
                "fullDescription": {
                  "text": "コレクションに対して使用されている 'Enumeration' メソッドの呼び出しで、同等の 'Iterator' コンストラクトに置換できるものを報告します。 例: 'Enumeration<String> keys = map.keys();\n  while (keys.hasMoreElements()) {\n    String name = keys.nextElement();\n  }' クイックフィックス適用後: 'Iterator<String> iterator = map.keySet().iterator();\n  while (iterator.hasNext()) {\n    String name = iterator.next();\n  }'",
                  "markdown": "コレクションに対して使用されている `Enumeration` メソッドの呼び出しで、同等の `Iterator` コンストラクトに置換できるものを報告します。\n\n**例:**\n\n\n      Enumeration<String> keys = map.keys();\n      while (keys.hasMoreElements()) {\n        String name = keys.nextElement();\n      }\n\nクイックフィックス適用後:\n\n\n      Iterator<String> iterator = map.keySet().iterator();\n      while (iterator.hasNext()) {\n        String name = iterator.next();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EnumerationCanBeIteration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援",
                      "index": 52,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadDumpStack",
                "shortDescription": {
                  "text": "'Thread.dumpStack()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'Thread.dumpStack()' の使用箇所を報告します。 このようなステートメントは一時的なデバッグによく使用されるため、プロダクションコードから除去するか、より堅牢なログ機能に置換する必要があります。",
                  "markdown": "`Thread.dumpStack()` の使用箇所を報告します。\n\nこのようなステートメントは一時的なデバッグによく使用されるため、プロダクションコードから除去するか、より堅牢なログ機能に置換する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadDumpStack",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コード成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalMethodInFinalClass",
                "shortDescription": {
                  "text": "'final' クラスの 'final' メソッド"
                },
                "fullDescription": {
                  "text": "'final' クラスにある 'final' メソッドを報告します。 'final' クラスは継承できないため、メソッドを 'final' にする必要はありません。また、結果的に混乱を招く可能性があります。 例: 'record Bar(int a, int b) {\n  public final int sum() { \n     return a + b;\n  }\n}'\n クイックフィックス適用後: 'record Bar(int a, int b) {\n  public int sum() { \n     return a + b;\n  }\n}' 上記の例のように、クラスは明示的または暗黙的に 'final' にすることができます。",
                  "markdown": "`final` クラスにある `final` メソッドを報告します。\n\n`final` クラスは継承できないため、メソッドを `final` にする必要はありません。また、結果的に混乱を招く可能性があります。\n\n**例:**\n\n    record Bar(int a, int b) {\n      public final int sum() { \n         return a + b;\n      }\n    }\n\nクイックフィックス適用後:\n\n    record Bar(int a, int b) {\n      public int sum() { \n         return a + b;\n      }\n    }\n\n上記の例のように、クラスは明示的または暗黙的に `final` にすることができます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalMethodInFinalClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryBlockStatement",
                "shortDescription": {
                  "text": "不要なコードブロック"
                },
                "fullDescription": {
                  "text": "プログラムのセマンティクス的に冗長で、その中身に置換できるコードブロックを報告します。 このインスペクションでは、'if'、 'do'、'while'、'for' のステートメントの本体となっているコードブロックは報告されません。 例: 'void foo() {\n    { // 不要\n      int result = call();\n      analyze(result);\n    } // 不要\n  }' インスペクションの構成: switch ステートメントの分岐として使用されているコードブロックを無視する場合は、「'switch' ステートメントの分岐を無視する」オプションを使用します。",
                  "markdown": "プログラムのセマンティクス的に冗長で、その中身に置換できるコードブロックを報告します。\n\nこのインスペクションでは、`if`、 `do`、`while`、`for` のステートメントの本体となっているコードブロックは報告されません。\n\n例:\n\n\n      void foo() {\n        { // 不要\n          int result = call();\n          analyze(result);\n        } // 不要\n      }\n\nインスペクションの構成:\n\n\nswitch ステートメントの分岐として使用されているコードブロックを無視する場合は、「**'switch' ステートメントの分岐を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessaryCodeBlock",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalPrivateMethod",
                "shortDescription": {
                  "text": "'final' 宣言された 'private' メソッド"
                },
                "fullDescription": {
                  "text": "'final' および 'private' キーワードの両方が付いたメソッドを報告します。 'private' メソッドの可視性を考慮すると、それをオーバーライドすることは無意味です。そのため、'final' 宣言は冗長です。",
                  "markdown": "`final` および `private` キーワードの両方が付いたメソッドを報告します。\n\n`private` メソッドの可視性を考慮すると、それをオーバーライドすることは無意味です。そのため、`final` 宣言は冗長です。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalPrivateMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalStaticMethod",
                "shortDescription": {
                  "text": "'final' 宣言された 'static' メソッド"
                },
                "fullDescription": {
                  "text": "'final' が付いている static フィールドを報告します。 このようなコードは誤りであるか、'final' キーワードの効果を勘違いして記述されている可能性があります。 static メソッドでは実行時ポリモーフィズムが起こりません。そのため、'final' キーワードを static メソッドに使用する目的は、そのメソッドがサブクラスで不可視になるのを防ぐことしかありません。",
                  "markdown": "`final` が付いている static フィールドを報告します。\n\nこのようなコードは誤りであるか、`final` キーワードの効果を勘違いして記述されている可能性があります。\nstatic メソッドでは実行時ポリモーフィズムが起こりません。そのため、`final` キーワードを static メソッドに使用する目的は、そのメソッドがサブクラスで不可視になるのを防ぐことしかありません。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalStaticMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantTypeArguments",
                "shortDescription": {
                  "text": "冗長なタイプ引数"
                },
                "fullDescription": {
                  "text": "パラメーター化されたメソッドの呼び出しで、コンパイラーによって明確に推論されるために明示的な引数の型を省略できるものを報告します。 冗長な型引数の使用は不要であり、コードを読みにくくします。 例: 'List<String> list = Arrays.<String>asList(\"Hello\", \"World\");' 冗長な型引数を削除するためのクイックフィックスが提供されています。 'List<String> list = Arrays.asList(\"Hello\", \"World\");'",
                  "markdown": "パラメーター化されたメソッドの呼び出しで、コンパイラーによって明確に推論されるために明示的な引数の型を省略できるものを報告します。\n\n\n冗長な型引数の使用は不要であり、コードを読みにくくします。\n\n例:\n\n\n      List<String> list = Arrays.<String>asList(\"Hello\", \"World\");\n\n冗長な型引数を削除するためのクイックフィックスが提供されています。\n\n\n      List<String> list = Arrays.asList(\"Hello\", \"World\");\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantTypeArguments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldHasSetterButNoGetter",
                "shortDescription": {
                  "text": "setter があるが getter がないフィールド"
                },
                "fullDescription": {
                  "text": "setter メソッドはあるものの、getter メソッドがないフィールドを報告します。 特定の Bean コンテナーでは、このようなフィールドを Java Bean の仕様内で使用した場合、扱いが難しくなる場合があります。",
                  "markdown": "setter メソッドはあるものの、getter メソッドがないフィールドを報告します。\n\n\n特定の Bean コンテナーでは、このようなフィールドを Java Bean の仕様内で使用した場合、扱いが難しくなる場合があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldHasSetterButNoGetter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 関連の問題",
                      "index": 34,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentOrReturnOfFieldWithMutableType",
                "shortDescription": {
                  "text": "ミュータブルな型のフィールドの代入またはリターン"
                },
                "fullDescription": {
                  "text": "配列または 'Collection'、'Date'、'Map'、'Calendar' などのミュータブル型の返却、またはメソッドパラメーターからこれらへの代入を報告します。 このような型はミュータブルであるため、このコンストラクトが原因で所有クラス外からの予期しないオブジェクトの状態変更が発生する可能性があります。 このコンストラクトはパフォーマンスの面では有益ですが、本質的にバグを引き起こす可能性があります。 次のミュータブルな型が報告されます: 'java.util.Date' 'java.util.Calendar' 'java.util.Collection' 'java.util.Map' 'com.google.common.collect.Multimap' 'com.google.common.collect.Table' クイックフィックスを使用すると、フィールドの '.clone()' メソッドの呼び出しが追加されます。 例: 'class Log {\n    String[] messages;\n    ...\n\n    String[] getMessages() {\n      return messages; // 警告: String[] フィールド 'messages' を返しています\n    }\n  }' クイックフィックス適用後: 'class Log {\n    String[] messages;\n    ...\n\n    String[] getMessages() {\n      return messages.clone();\n    }\n  }' 'private' メソッド内の代入と返却を無視するには、「private メソッドでの代入および private メソッドからの返却を無視する」オプションを使用します。",
                  "markdown": "配列または `Collection`、`Date`、`Map`、`Calendar` などのミュータブル型の返却、またはメソッドパラメーターからこれらへの代入を報告します。\n\nこのような型はミュータブルであるため、このコンストラクトが原因で所有クラス外からの予期しないオブジェクトの状態変更が発生する可能性があります。 このコンストラクトはパフォーマンスの面では有益ですが、本質的にバグを引き起こす可能性があります。\n\n次のミュータブルな型が報告されます:\n\n* `java.util.Date`\n* `java.util.Calendar`\n* `java.util.Collection`\n* `java.util.Map`\n* `com.google.common.collect.Multimap`\n* `com.google.common.collect.Table`\n\nクイックフィックスを使用すると、フィールドの `.clone()` メソッドの呼び出しが追加されます。\n\n**例:**\n\n\n      class Log {\n        String[] messages;\n        ...\n\n        String[] getMessages() {\n          return messages; // 警告: String[] フィールド 'messages' を返しています\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Log {\n        String[] messages;\n        ...\n\n        String[] getMessages() {\n          return messages.clone();\n        }\n      }\n\n`private` メソッド内の代入と返却を無視するには、「**private メソッドでの代入および private メソッドからの返却を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentOrReturnOfFieldWithMutableType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/カプセル化",
                      "index": 57,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RuntimeExecWithNonConstantString",
                "shortDescription": {
                  "text": "非定数文字列による 'Runtime.exec()' の呼び出し"
                },
                "fullDescription": {
                  "text": "動的に作成される文字列を実行コマンドとして受け取っている 'java.lang.Runtime.exec()' の呼び出しを報告します。 動的に作成される実行文字列は、一般的にセキュリティ違反の元になります。 このインスペクションはデフォルトではコンパイル時の定数を無視します。 例: 'String i = getUserInput();\n  Runtime runtime = Runtime.getRuntime();\n  runtime.exec(\"foo\" + i); // 警告を報告します' すべての 'static' 'final' フィールドを定数と見なすには、インスペクションオプションを使用します。 このオプションが有効な場合、次のような文字列は無視されますので注意してください。 'static final String COMMAND = \"ping \" + getDomainFromUserInput() + \"'\";'",
                  "markdown": "動的に作成される文字列を実行コマンドとして受け取っている `java.lang.Runtime.exec()` の呼び出しを報告します。\n\n\n動的に作成される実行文字列は、一般的にセキュリティ違反の元になります。\nこのインスペクションはデフォルトではコンパイル時の定数を無視します。\n\n**例:**\n\n\n      String i = getUserInput();\n      Runtime runtime = Runtime.getRuntime();\n      runtime.exec(\"foo\" + i); // 警告を報告します\n\n\nすべての `static` `final` フィールドを定数と見なすには、インスペクションオプションを使用します。\nこのオプションが有効な場合、次のような文字列は無視されますので注意してください。\n\n\n      static final String COMMAND = \"ping \" + getDomainFromUserInput() + \"'\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToRuntimeExecWithNonConstantString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryUnboxing",
                "shortDescription": {
                  "text": "不要なアンボクシング"
                },
                "fullDescription": {
                  "text": "ラップされたプリミティブ値を明示的にアンラップしているアンボクシングを報告します。 Java 5 以降ではアンボクシングは不要であり、安全に除去できます。 例: 'Integer i = Integer.valueOf(42).intValue();' → 'Integer i = Integer.valueOf(42);' 'int k = Integer.valueOf(42).intValue();' → 'int k = Integer.valueOf(42);' (「本当に不必要にアンボクシングされた式だけを報告する」オプションが無効な場合にのみ報告します) アンボクシングされた値が暗黙的または明示的に即座にボクシングされている場合など、本当に不必要なアンボクシングのみを報告するには、「本当に不必要にアンボクシングされた式だけを報告する」オプションを使用します。 このような場合、アンボクシングとボクシングのステップ全体を除去できます。 このインスペクションは、単純かつ明示的なアンボクシングを報告しません。 このインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以上の場合にのみ報告します。",
                  "markdown": "ラップされたプリミティブ値を明示的にアンラップしているアンボクシングを報告します。\n\nJava 5 以降ではアンボクシングは不要であり、安全に除去できます。\n\n**例:**\n\n* `Integer i = Integer.valueOf(42).intValue();` → `Integer i = Integer.valueOf(42);`\n* `int k = Integer.valueOf(42).intValue();` → `int k = Integer.valueOf(42);`\n\n  (「**本当に不必要にアンボクシングされた式だけを報告する**」オプションが無効な場合にのみ報告します)\n\n\nアンボクシングされた値が暗黙的または明示的に即座にボクシングされている場合など、本当に不必要なアンボクシングのみを報告するには、「**本当に不必要にアンボクシングされた式だけを報告する**」オプションを使用します。\nこのような場合、アンボクシングとボクシングのステップ全体を除去できます。 このインスペクションは、単純かつ明示的なアンボクシングを報告しません。\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以上の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryUnboxing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 5",
                      "index": 53,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalAssignedToNull",
                "shortDescription": {
                  "text": "Optional 型の null 値"
                },
                "fullDescription": {
                  "text": "'Optional' 変数に代入されている、または 'Optional' を返すメソッドから返されている 'null' を報告します。 空の値を意味している場合は、'Optional.empty()' (Guava の場合は 'Optional.absent()') を使用することをお勧めします。 例: 'Optional<Integer> foo(boolean flag) {\n    return flag ? Optional.of(42) : null;\n  }' クイックフィックス適用後: 'Optional<Integer> foo(boolean flag) {\n    return flag ? Optional.of(42) : Optional.empty();\n  }' インスペクションの構成: 'optional == null' などの比較式も報告する場合は、「Optional と null の比較を報告する」オプションを使用します。 これは、まれなケース (optional フィールドが遅延初期化されている場合など) なら正しい場合もありますが、optional 変数が通常 null であることはないため、'optional.isPresent()' が意図されていたと考えられます。 2017.2 の新機能です このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "`Optional` 変数に代入されている、または `Optional` を返すメソッドから返されている `null` を報告します。\n\n空の値を意味している場合は、`Optional.empty()` (Guava の場合は `Optional.absent()`) を使用することをお勧めします。\n\n例:\n\n\n      Optional<Integer> foo(boolean flag) {\n        return flag ? Optional.of(42) : null;\n      }\n\nクイックフィックス適用後:\n\n\n      Optional<Integer> foo(boolean flag) {\n        return flag ? Optional.of(42) : Optional.empty();\n      }\n\nインスペクションの構成:\n\n\n`optional == null` などの比較式も報告する場合は、「**Optional と null の比較を報告する** 」オプションを使用します。 これは、まれなケース (optional フィールドが遅延初期化されている場合など) なら正しい場合もありますが、optional 変数が通常 null であることはないため、`optional.isPresent()` が意図されていたと考えられます。\n\n2017.2 の新機能です\n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalAssignedToNull",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コード成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessIndexOfComparison",
                "shortDescription": {
                  "text": "無意味な 'indexOf()' の比較"
                },
                "fullDescription": {
                  "text": "'.indexOf()' 式を使用した不要な比較を報告します。 このような式には、たとえば '.indexOf()' の結果と -1 未満の数値の比較が挙げられます。",
                  "markdown": "`.indexOf()` 式を使用した不要な比較を報告します。 このような式には、たとえば `.indexOf()` の結果と -1 未満の数値の比較が挙げられます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessIndexOfComparison",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ErrorRethrown",
                "shortDescription": {
                  "text": "再スローされない 'Error'"
                },
                "fullDescription": {
                  "text": "'java.lang.Error' かそのサブクラスをキャッチし、エラーを再スローしていない 'try' ステートメントを報告します。 'java.lang.ThreadDeath' をキャッチするステートメントは報告されません。 例: 'try {\n    executeTests(request);\n  }\n  catch (OutOfMemoryError ex) { // 警告: エラー 'ex' は再スローされません\n    return false;\n  }'",
                  "markdown": "`java.lang.Error` かそのサブクラスをキャッチし、エラーを再スローしていない `try` ステートメントを報告します。\n\n`java.lang.ThreadDeath` をキャッチするステートメントは報告されません。\n\n**例:**\n\n\n      try {\n        executeTests(request);\n      }\n      catch (OutOfMemoryError ex) { // 警告: エラー 'ex' は再スローされません\n        return false;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ErrorNotRethrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IteratorHasNextCallsIteratorNext",
                "shortDescription": {
                  "text": "'next()' を呼び出す 'Iterator.hasNext()'"
                },
                "fullDescription": {
                  "text": "Iterator インスタンスで 'Iterator.next()' または 'ListIterator.previous()' を呼び出している 'Iterator.hasNext()' または 'ListIterator.hasPrevious()' の実装を報告します。 このような呼び出しはほぼ間違いなく誤りです。イテレーターの状態を変更するのは 'hasNext()' のようなメソッドではなく、'next()' のようなメソッドであるべきだからです。 例: 'class MyIterator implements Iterator<Integer> {\n    public boolean hasNext() {\n      return next() != null;\n    }\n  }'",
                  "markdown": "Iterator インスタンスで `Iterator.next()` または `ListIterator.previous()` を呼び出している `Iterator.hasNext()` または `ListIterator.hasPrevious()` の実装を報告します。 このような呼び出しはほぼ間違いなく誤りです。イテレーターの状態を変更するのは `hasNext()` のようなメソッドではなく、`next()` のようなメソッドであるべきだからです。\n\n**例:**\n\n\n      class MyIterator implements Iterator<Integer> {\n        public boolean hasNext() {\n          return next() != null;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IteratorHasNextCallsIteratorNext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsAndHashcode",
                "shortDescription": {
                  "text": "'equals()' と 'hashCode()' が組になっていません"
                },
                "fullDescription": {
                  "text": "'equals()' メソッドをオーバーライドするが 'hashCode()' メソッドをオーバーライドしていないクラス (またはその逆の場合) で、'Collection' または 'HashMap' に追加される際に問題を引き起こす可能性があるクラスを報告します。 クイックフィックスを使用すると、欠落しているメソッドのデフォルトの実装が生成されます。 例: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n}' クイックフィックス適用後: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof StringHolder)) return false;\n\n    StringHolder holder = (StringHolder)o;\n\n    if (s != null ? !s.equals(holder.s) : holder.s != null) return false;\n\n    return true;\n  }\n}'",
                  "markdown": "`equals()` メソッドをオーバーライドするが `hashCode()` メソッドをオーバーライドしていないクラス (またはその逆の場合) で、`Collection` または `HashMap` に追加される際に問題を引き起こす可能性があるクラスを報告します。\n\nクイックフィックスを使用すると、欠落しているメソッドのデフォルトの実装が生成されます。\n\n例:\n\n\n    class StringHolder {\n      String s;\n\n      @Override public int hashCode() {\n        return s != null ? s.hashCode() : 0;\n      }\n    }\n\nクイックフィックス適用後:\n\n\n    class StringHolder {\n      String s;\n\n      @Override public int hashCode() {\n        return s != null ? s.hashCode() : 0;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof StringHolder)) return false;\n\n        StringHolder holder = (StringHolder)o;\n\n        if (s != null ? !s.equals(holder.s) : holder.s != null) return false;\n\n        return true;\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsAndHashcode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CyclicPackageDependency",
                "shortDescription": {
                  "text": "循環パッケージ依存関係"
                },
                "fullDescription": {
                  "text": "他のパッケージと相互に依存している、または循環依存関係を持っているパッケージを報告します。 このような循環的依存関係は、コードの脆弱化とメンテナンス性の低下を招きます。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "他のパッケージと相互に依存している、または循環依存関係を持っているパッケージを報告します。\n\nこのような循環的依存関係は、コードの脆弱化とメンテナンス性の低下を招きます。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CyclicPackageDependency",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依存関係の問題",
                      "index": 86,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringRepeatCanBeUsed",
                "shortDescription": {
                  "text": "String.repeat() を使用可能"
                },
                "fullDescription": {
                  "text": "単一の 'String.repeat()' メソッドに置換できるループを報告します (Java 11 以降で使用できます)。 例: 'void append(StringBuilder sb, int count, Object obj) {\n    for (int i = 0; i < count; i++) {\n      sb.append(obj);\n    }\n  }' クイックフィックス適用後: 'void append(StringBuilder sb, int count, Object obj) {\n    sb.append(String.valueOf(obj).repeat(Math.max(0, count)));\n  }' このインスペクションは 'count' が負の値でないことを静的に証明できない場合、デフォルトでは 'count' を 'Math.max(0, count)' でラップする場合があります。 この処理はセマンティクスの変更を防ぐために行われます。'String.repeat()' は負の数値を拒否するためです。 必要に応じてこの動作を無効にするには、「セマンティクスの変更を回避するために Math.max(0, count) を追加する」オプションを使用します。 同様に、繰り返したい文字列を 'String.valueOf' でラップし、'null' になる可能性があるかどうかが分からない場合に 'NullPointerException' を防ぐことができます。 このインスペクションは、プロジェクトまたはモジュールの言語レベルが 11 以上の場合にのみ報告します。 2019.1 の新機能です",
                  "markdown": "単一の `String.repeat()` メソッドに置換できるループを報告します (Java 11 以降で使用できます)。\n\n**例:**\n\n\n      void append(StringBuilder sb, int count, Object obj) {\n        for (int i = 0; i < count; i++) {\n          sb.append(obj);\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      void append(StringBuilder sb, int count, Object obj) {\n        sb.append(String.valueOf(obj).repeat(Math.max(0, count)));\n      }\n\n\nこのインスペクションは `count` が負の値でないことを静的に証明できない場合、デフォルトでは `count` を `Math.max(0, count)` でラップする場合があります。 この処理はセマンティクスの変更を防ぐために行われます。`String.repeat()` は負の数値を拒否するためです。\n必要に応じてこの動作を無効にするには、「**セマンティクスの変更を回避するために Math.max(0, count) を追加する**」オプションを使用します。\n\n同様に、繰り返したい文字列を `String.valueOf` でラップし、`null` になる可能性があるかどうかが分からない場合に `NullPointerException` を防ぐことができます。\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 11 以上の場合にのみ報告します。\n\n2019.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringRepeatCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 11",
                      "index": 125,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnsatisfiedRange",
                "shortDescription": {
                  "text": "戻り値は宣言された範囲から外れています"
                },
                "fullDescription": {
                  "text": "メソッドから返されている数値のうち、宣言されているメソッドの戻り値の範囲から外れているものを報告します。 さまざまなアノテーションを使用して、メソッドの戻り範囲を宣言できます。 JetBrains アノテーションパッケージの 'org.jetbrains.annotations.Range' ('from' と 'to' を指定) Checker Framework アノテーションパッケージの 'org.checkerframework.common.value.qual.IntRange' ('from' と 'to' を指定) Checker Framework アノテーションパッケージの 'org.checkerframework.checker.index.qual.GTENegativeOne' (範囲は '>= -1') Checker Framework アノテーションパッケージの 'org.checkerframework.checker.index.qual.NonNegative' (範囲は '>= 0') Checker Framework アノテーションパッケージの 'org.checkerframework.checker.index.qual.Positive' (範囲は '> 0') JSR 305 アノテーションパッケージの 'javax.annotation.Nonnegative' (範囲は '>= 0') 'javax.validation.constraints.Min' (最小値を指定) 'javax.validation.constraints.Max' (最大値を指定) 例: '@Range(from = 0, to = Integer.MAX_VALUE) int getValue() {\n    // 警告: -1 は宣言された範囲から外れています\n    return -1;\n  }' 2021.2 の新機能です",
                  "markdown": "メソッドから返されている数値のうち、宣言されているメソッドの戻り値の範囲から外れているものを報告します。 さまざまなアノテーションを使用して、メソッドの戻り範囲を宣言できます。\n\n* JetBrains アノテーションパッケージの `org.jetbrains.annotations.Range` ('from' と 'to' を指定)\n* Checker Framework アノテーションパッケージの `org.checkerframework.common.value.qual.IntRange` ('from' と 'to' を指定)\n* Checker Framework アノテーションパッケージの `org.checkerframework.checker.index.qual.GTENegativeOne` (範囲は '\\>= -1')\n* Checker Framework アノテーションパッケージの `org.checkerframework.checker.index.qual.NonNegative` (範囲は '\\>= 0')\n* Checker Framework アノテーションパッケージの `org.checkerframework.checker.index.qual.Positive` (範囲は '\\> 0')\n* JSR 305 アノテーションパッケージの `javax.annotation.Nonnegative` (範囲は '\\>= 0')\n* `javax.validation.constraints.Min` (最小値を指定)\n* `javax.validation.constraints.Max` (最大値を指定)\n\n例:\n\n\n      @Range(from = 0, to = Integer.MAX_VALUE) int getValue() {\n        // 警告: -1 は宣言された範囲から外れています\n        return -1;\n      }\n\n2021.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnsatisfiedRange",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemSetSecurityManager",
                "shortDescription": {
                  "text": "'System.setSecurityManager()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'System.setSecurityManager()' の呼び出しを報告します。 多くの場合は無害ですが、'System.setSecurityManager()' の呼び出しはセキュリティ監査で詳細に調査すべきです。",
                  "markdown": "`System.setSecurityManager()` の呼び出しを報告します。\n\n多くの場合は無害ですが、`System.setSecurityManager()` の呼び出しはセキュリティ監査で詳細に調査すべきです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemSetSecurityManager",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithoutNoArgConstructor",
                "shortDescription": {
                  "text": "引数なしのコンストラクターを持たないクラス"
                },
                "fullDescription": {
                  "text": "引数を取らない (パラメーターがない) コンストラクターがないクラスを報告します。 引数なしのコンストラクターは、状況によっては必要です。 たとえば、リフレクションを使用してクラスを作成する必要がある場合です。 例: 'public class Bean {\n    private String name;\n\n    public Bean(String name) {\n      this.name = name;\n    }\n  }' 明示的なコンストラクターのないクラスを無視するには、以下のチェックボックスを使用します。 コンパイラーは、このようなクラスにデフォルトの引数なしコンストラクターを提供します。",
                  "markdown": "引数を取らない (パラメーターがない) コンストラクターがないクラスを報告します。 引数なしのコンストラクターは、状況によっては必要です。 たとえば、リフレクションを使用してクラスを作成する必要がある場合です。\n\n**例:**\n\n\n      public class Bean {\n        private String name;\n\n        public Bean(String name) {\n          this.name = name;\n        }\n      }\n\n\n明示的なコンストラクターのないクラスを無視するには、以下のチェックボックスを使用します。\nコンパイラーは、このようなクラスにデフォルトの引数なしコンストラクターを提供します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithoutNoArgConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 関連の問題",
                      "index": 34,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithTooManyDependencies",
                "shortDescription": {
                  "text": "他への依存関係が多すぎるクラス"
                },
                "fullDescription": {
                  "text": "プロジェクト内にある他のクラスへの直接依存が多すぎるクラスを報告します。 このようなクラスの依存関係に修正を加えるとクラスを変更する必要性が生じるため、不安定になる可能性があります。 トップレベルのクラスのみが報告されます。 クラスで許容される依存関係数の最大値を指定するには、「最大依存関係数」フィールドを使用します。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "プロジェクト内にある他のクラスへの直接依存が多すぎるクラスを報告します。\n\nこのようなクラスの依存関係に修正を加えるとクラスを変更する必要性が生じるため、不安定になる可能性があります。\n\nトップレベルのクラスのみが報告されます。\n\nクラスで許容される依存関係数の最大値を指定するには、「**最大依存関係数**」フィールドを使用します。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyDependencies",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依存関係の問題",
                      "index": 86,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastConflictsWithInstanceof",
                "shortDescription": {
                  "text": "'instanceof' と競合するキャスト"
                },
                "fullDescription": {
                  "text": "別の型に対する 'instanceof' チェックが先行している型キャスト式を報告します。 このような構文は意図的な場合もありますが、誤りである可能性が高く、実行時に 'java.lang.ClassCastException' が発生します。 例: 'class Main {\n    int whenCharSequenceCastToNumber(Object o){\n      if (o instanceof CharSequence) {\n        return ((Number) o).intValue();\n      }\n      return 0;\n    }\n\n    int earlyReturnWhenNotCharSequence(Object o){\n      if (!(o instanceof CharSequence)) return 0;\n      return ((Number)o).intValue();\n    }\n  }'",
                  "markdown": "別の型に対する `instanceof` チェックが先行している型キャスト式を報告します。\n\n\nこのような構文は意図的な場合もありますが、誤りである可能性が高く、実行時に `java.lang.ClassCastException` が発生します。\n\n**例:**\n\n\n      class Main {\n        int whenCharSequenceCastToNumber(Object o){\n          if (o instanceof CharSequence) {\n            return ((Number) o).intValue();\n          }\n          return 0;\n        }\n\n        int earlyReturnWhenNotCharSequence(Object o){\n          if (!(o instanceof CharSequence)) return 0;\n          return ((Number)o).intValue();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CastConflictsWithInstanceof",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MathRoundingWithIntArgument",
                "shortDescription": {
                  "text": "'int' 引数で丸める math を呼び出す"
                },
                "fullDescription": {
                  "text": "'int' を引数として持つ 'Math' および 'StrictMath' の 'round()'、'ceil()'、'floor()'、'rint()' メソッドへの呼び出しを報告します。 これらのメソッドは引数が 'long' または 'double' を必要とする場合に呼び出すことができ、予期しない結果となる場合があります。 このインスペクションは、'double' にキャストするためにこのような式 ('round' を除く) を単純化する修正を提供します。 例: 'int i = 2;\n  double d1 = Math.floor(i);' クイックフィックス適用後: 'int i = 2;\n  double d1 = i;' 2023.1 の新機能です",
                  "markdown": "`int` を引数として持つ `Math` および `StrictMath` の `round()`、`ceil()`、`floor()`、`rint()` メソッドへの呼び出しを報告します。\n\nこれらのメソッドは引数が `long` または `double` を必要とする場合に呼び出すことができ、予期しない結果となる場合があります。\n\nこのインスペクションは、`double` にキャストするためにこのような式 (`round` を除く) を単純化する修正を提供します。\n\n**例:**\n\n\n      int i = 2;\n      double d1 = Math.floor(i);\n\nクイックフィックス適用後:\n\n\n      int i = 2;\n      double d1 = i;\n\n2023.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MathRoundingWithIntArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewExceptionWithoutArguments",
                "shortDescription": {
                  "text": "引数なしで呼び出される例外コンストラクター"
                },
                "fullDescription": {
                  "text": "引数を指定せずに例外インスタンスが作成されていることを報告します。 引数なしで作成された例外には発生した問題に関する情報が一切含まれていないため、デバッグが不必要に困難になります。 例: 'throw new IOException(); // 警告: 引数なしの例外'",
                  "markdown": "引数を指定せずに例外インスタンスが作成されていることを報告します。\n\n引数なしで作成された例外には発生した問題に関する情報が一切含まれていないため、デバッグが不必要に困難になります。\n\n**例:**\n\n\n      throw new IOException(); // 警告: 引数なしの例外\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewExceptionWithoutArguments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/エラー処理",
                      "index": 14,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Contract",
                "shortDescription": {
                  "text": "契約関連の問題"
                },
                "fullDescription": {
                  "text": "メソッドの '@Contract' アノテーションの問題を報告します。 以下の種類の問題が報告されます。 契約構文のエラー メソッドシグネチャーに準拠していない契約 (パラメーターの数が違う) 契約と矛盾しているメソッドの実装 (契約に 'false' と記述されているにも関わらず 'true' を返しているなど) 例: '// メソッドにパラメーターがないのに、契約が 1 つを要求している\n  @Contract(\"_ -> fail\")\n  void x() {\n    throw new AssertionError();\n  }'",
                  "markdown": "メソッドの `@Contract` アノテーションの問題を報告します。 以下の種類の問題が報告されます。\n\n* 契約構文のエラー\n* メソッドシグネチャーに準拠していない契約 (パラメーターの数が違う)\n* 契約と矛盾しているメソッドの実装 (契約に `false` と記述されているにも関わらず `true` を返しているなど)\n\n例:\n\n\n      // メソッドにパラメーターがないのに、契約が 1 つを要求している\n      @Contract(\"_ -> fail\")\n      void x() {\n        throw new AssertionError();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Contract",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnhancedSwitchBackwardMigration",
                "shortDescription": {
                  "text": "拡張 'switch'"
                },
                "fullDescription": {
                  "text": "拡張 'switch' ステートメントと式を報告します。 報告対象を通常の 'switch' に置換することを提案します。 例: 'boolean even = switch (condition) {\n    case 1, 3, 5, 7, 9 -> false;\n    default -> true;\n  };' クイックフィックス適用後: 'boolean even;\n  switch (condition) {\n    case 1:\n    case 3:\n    case 5:\n    case 7:\n    case 9:\n      even = false;\n      break;\n    default:\n      even = true;\n      break;\n}' 拡張 'switch' は Java 14 で登場しました。 このインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。 2019.1 の新機能です",
                  "markdown": "拡張 `switch` ステートメントと式を報告します。 報告対象を通常の `switch` に置換することを提案します。\n\n**例:**\n\n\n      boolean even = switch (condition) {\n        case 1, 3, 5, 7, 9 -> false;\n        default -> true;\n      };\n\nクイックフィックス適用後:\n\n\n      boolean even;\n      switch (condition) {\n        case 1:\n        case 3:\n        case 5:\n        case 7:\n        case 9:\n          even = false;\n          break;\n        default:\n          even = true;\n          break;\n    }\n\n\n*拡張* `switch` は Java 14 で登場しました。\nこのインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。\n\n2019.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EnhancedSwitchBackwardMigration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 14",
                      "index": 101,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageWithTooManyClasses",
                "shortDescription": {
                  "text": "クラスが多すぎるパッケージ"
                },
                "fullDescription": {
                  "text": "含んでいるクラスが多すぎるパッケージを報告します。 パッケージが大きすぎる場合、デザインの明瞭性が欠けている可能性があります。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。 パッケージで許容されるクラス数の最大値を指定するには、「最大クラス数」フィールドを使用します。",
                  "markdown": "含んでいるクラスが多すぎるパッケージを報告します。\n\nパッケージが大きすぎる場合、デザインの明瞭性が欠けている可能性があります。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。\n\nパッケージで許容されるクラス数の最大値を指定するには、「**最大クラス数**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageWithTooManyClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パッケージ関連の問題",
                      "index": 37,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggingGuardedByCondition",
                "shortDescription": {
                  "text": "ログ条件でガードされているロギング呼び出し"
                },
                "fullDescription": {
                  "text": "ガード条件で囲まれているロギング呼び出しを報告します。 このインスペクションは、カスタムコードスタイルを使用して調整するために使用できます。 例: 'public class TestObject {\n    void test(Object object) {\n      if(LOG.isDebugEnabled()){\n        LOG.debug(\"some logging \" + expensiveCalculation(1));\n      }\n    }\n  }' クイックフィックス適用後: 'public class TestObject {\n    void test(Object object) {\n      LOG.debug(\"some logging \" + expensiveCalculation(1));\n    }\n  }' このインスペクションは Log4j2 および SLF4J ロギングフレームワークをサポートします (ビルダーを除く)。 2024.2 の新機能です",
                  "markdown": "ガード条件で囲まれているロギング呼び出しを報告します。 このインスペクションは、カスタムコードスタイルを使用して調整するために使用できます。\n\n**例:**\n\n\n      public class TestObject {\n        void test(Object object) {\n          if(LOG.isDebugEnabled()){\n            LOG.debug(\"some logging \" + expensiveCalculation(1));\n          }\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public class TestObject {\n        void test(Object object) {\n          LOG.debug(\"some logging \" + expensiveCalculation(1));\n        }\n      }\n\nこのインスペクションは *Log4j2* および *SLF4J* ロギングフレームワークをサポートします (ビルダーを除く)。\n\n2024.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LoggingGuardedByCondition",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語/ログ関連",
                      "index": 45,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TryFinallyCanBeTryWithResources",
                "shortDescription": {
                  "text": "'try' with resources に置換可能な 'try finally'"
                },
                "fullDescription": {
                  "text": "エラーが発生しにくい Java 7 の Automatic Resource Management (自動リソース管理) を使用できる 'try'-'finally' ステートメントを報告します。 'try'-'finally' ステートメントを 'try'-with-resources ステートメントに変換するクイックフィックスを使用できます。 例: 'PrintStream printStream = new PrintStream(fileName);\n  try {\n    printStream.print(true);\n  } finally {\n    printStream.close();\n  }' コンストラクターにイベントを渡すためのクイックフィックスが提供されています。 'try (PrintStream printStream = new PrintStream(fileName)) {\n    printStream.print(true);\n  }' このインスペクションは Java 7 以降で使用できる Java の機能 'try-with-resources' に依存しています。",
                  "markdown": "エラーが発生しにくい Java 7 の Automatic Resource Management (自動リソース管理) を使用できる `try`-`finally` ステートメントを報告します。\n\n`try`-`finally` ステートメントを `try`-with-resources ステートメントに変換するクイックフィックスを使用できます。\n\n**例:**\n\n\n      PrintStream printStream = new PrintStream(fileName);\n      try {\n        printStream.print(true);\n      } finally {\n        printStream.close();\n      }\n\nコンストラクターにイベントを渡すためのクイックフィックスが提供されています。\n\n\n      try (PrintStream printStream = new PrintStream(fileName)) {\n        printStream.print(true);\n      }\n\nこのインスペクションは Java 7 以降で使用できる Java の機能 'try-with-resources' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TryFinallyCanBeTryWithResources",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 7",
                      "index": 114,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizationOnStaticField",
                "shortDescription": {
                  "text": "'static' フィールドの同期"
                },
                "fullDescription": {
                  "text": "'static' 式フィールドの同期を報告します。 'static' フィールドでの同期は厳密には誤りとは言えませんが、競合が原因でパフォーマンスに悪影響が出る可能性があります。",
                  "markdown": "`static` 式フィールドの同期を報告します。 `static` フィールドでの同期は厳密には誤りとは言えませんが、競合が原因でパフォーマンスに悪影響が出る可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizationOnStaticField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementWithConfusingDeclaration",
                "shortDescription": {
                  "text": "別々の 'switch' ブランチで使用および宣言されているローカル変数"
                },
                "fullDescription": {
                  "text": "'switch' ステートメントのある分岐で宣言され、別の分岐で使用されているローカル変数を報告します。 このような宣言は大きな混乱を招く可能性があります。 例: 'switch(i) {\n      case 2:\n          int x = 0;\n          break;\n      case 3:\n          x = 3;\n          System.out.println(x);\n          break;\n    }'",
                  "markdown": "`switch` ステートメントのある分岐で宣言され、別の分岐で使用されているローカル変数を報告します。 このような宣言は大きな混乱を招く可能性があります。\n\n例:\n\n\n        switch(i) {\n          case 2:\n              int x = 0;\n              break;\n          case 3:\n              x = 3;\n              System.out.println(x);\n              break;\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LocalVariableUsedAndDeclaredInDifferentSwitchBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SamePackageImport",
                "shortDescription": {
                  "text": "同じパッケージからの不要なインポート"
                },
                "fullDescription": {
                  "text": "包含ファイルと同じパッケージを参照している 'import' ステートメントを報告します。 同じパッケージのファイルは常に暗黙的にインポートされるため、このような 'import' ステートメントは冗長で混乱を招きます。 IntelliJ IDEA は「インポートの最適化」コマンドでこのようなステートメントを自動的に検出して修正できるため、このインスペクションは変更を意図していないコードベースについて主にオフラインで報告させる目的で主に役立ちます。",
                  "markdown": "包含ファイルと同じパッケージを参照している `import` ステートメントを報告します。\n\n\n同じパッケージのファイルは常に暗黙的にインポートされるため、このような `import` ステートメントは冗長で混乱を招きます。\n\n\nIntelliJ IDEA は「**インポートの最適化**」コマンドでこのようなステートメントを自動的に検出して修正できるため、このインスペクションは変更を意図していないコードベースについて主にオフラインで報告させる目的で主に役立ちます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SamePackageImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/インポート",
                      "index": 23,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadLocalSetWithNull",
                "shortDescription": {
                  "text": "引数が null の 'ThreadLocal.set()'"
                },
                "fullDescription": {
                  "text": "引数が null の 'java.lang.ThreadLocal.set()' を報告します。 この呼び出しではリソースが解放されず、メモリリークが発生する可能性があります。 以下の理由で発生する可能性があります。 まず、'ThreadLocal.set(null)' が現在のスレッドに関連付けられたマップを見つけます。 そのようなマップがない場合、必要なマップが作成されます 'map.set(this, value)' でキーと値が設定されます。ここで、'this' は 'ThreadLocal' のインスタンスを参照しています リソースを解放するには、'java.lang.ThreadLocal.remove()' を使用する必要があります。 例: 'ThreadLocal<Integer> threadLocal = new ThreadLocal<>();\n  threadLocal.set(null);' クイックフィックス適用後: 'threadLocal.remove();' 2023.2 の新機能です",
                  "markdown": "引数が null の `java.lang.ThreadLocal.set()` を報告します。\n\nこの呼び出しではリソースが解放されず、メモリリークが発生する可能性があります。\n以下の理由で発生する可能性があります。\n\n* まず、`ThreadLocal.set(null)` が現在のスレッドに関連付けられたマップを見つけます。 そのようなマップがない場合、必要なマップが作成されます\n* `map.set(this, value)` でキーと値が設定されます。ここで、`this` は `ThreadLocal` のインスタンスを参照しています\n\nリソースを解放するには、`java.lang.ThreadLocal.remove()` を使用する必要があります。\n\n例:\n\n\n      ThreadLocal<Integer> threadLocal = new ThreadLocal<>();\n      threadLocal.set(null);\n\nクイックフィックス適用後:\n\n\n      threadLocal.remove();\n\n2023.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ThreadLocalSetWithNull",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldMayBeFinal",
                "shortDescription": {
                  "text": "フィールドは 'final' 指定可能です"
                },
                "fullDescription": {
                  "text": "安全に 'final' にできるフィールドを報告します。 すべての 'final' フィールドは変化しない値を持つため、コードを推論しやすくなります。 解析に多大なコストがかからないようにするため、このインスペクションはフィールドに 'private' 修飾子があるか、フィールドがローカルクラスまたは匿名クラスで定義されているときのみ報告します。 次の条件を満たす場合にフィールドを 'final' にできます。 'static' であり、その宣言内か 1 つの 'static' イニシャライザーで 1 回だけ初期化されている。 非 'static' であり、その宣言内、1 つのインスタンスイニシャライザー、あるいはすべてのコンストラクター内で 1 回だけ初期化されている。 また、このフィールドは他の場所では変更されません。 例: 'public class Person {\n    private String name; // final を指定できます\n\n    Person(String name) {\n      this.name = name;\n    }\n\n    public String getName() {\n      return name;\n    }\n  }' クイックフィックス適用後: 'public class Person {\n    private final String name;\n\n    Person(String name) {\n      this.name = name;\n    }\n\n    public String getName() {\n      return name;\n    }\n  }' 暗黙的なフィールドの書き込みを想定するアノテーションのリストを変更するには、「アノテーション」ボタンを使用します。",
                  "markdown": "安全に `final` にできるフィールドを報告します。 すべての `final` フィールドは変化しない値を持つため、コードを推論しやすくなります。\n\n解析に多大なコストがかからないようにするため、このインスペクションはフィールドに `private` 修飾子があるか、フィールドがローカルクラスまたは匿名クラスで定義されているときのみ報告します。\n次の条件を満たす場合にフィールドを `final` にできます。\n\n* `static` であり、その宣言内か 1 つの `static` イニシャライザーで 1 回だけ初期化されている。\n* 非 `static` であり、その宣言内、1 つのインスタンスイニシャライザー、あるいはすべてのコンストラクター内で 1 回だけ初期化されている。\n\nまた、このフィールドは他の場所では変更されません。\n\n**例:**\n\n\n      public class Person {\n        private String name; // final を指定できます\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\n\n暗黙的なフィールドの書き込みを想定するアノテーションのリストを変更するには、「アノテーション」ボタンを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldMayBeFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingJavadoc",
                "shortDescription": {
                  "text": "欠落している Javadoc"
                },
                "fullDescription": {
                  "text": "欠落している Javadoc のコメントとタグを報告します。 例: '/**\n   * 欠落している \"@param\" が報告されます (構成されている場合)。\n   */\n  public void sample(int param){\n  }' クイックフィックスを使用していると、欠落しているタグか欠落している Javadoc コメントが追加されます。 '/**\n   * 欠落している \"@param\" が報告されます (構成されている場合)。\n   * @param param\n   */\n  public void sample(int param){\n  }' このインスペクションは、非推奨の要素や、'getField()' または 'setField()' のような単純なアクセサーメソッドを無視するように構成できます。 以下のオプションを使用して、メソッド、フィールド、クラス、パッケージ、モジュールなどの特定のコード要素に必要なタグと最小限の必要な可視性を構成することもできます。",
                  "markdown": "欠落している Javadoc のコメントとタグを報告します。\n\n例:\n\n\n      /**\n       * 欠落している \"@param\" が報告されます (構成されている場合)。\n       */\n      public void sample(int param){\n      }\n\nクイックフィックスを使用していると、欠落しているタグか欠落している Javadoc コメントが追加されます。\n\n\n      /**\n       * 欠落している \"@param\" が報告されます (構成されている場合)。\n       * @param param\n       */\n      public void sample(int param){\n      }\n\n\nこのインスペクションは、非推奨の要素や、`getField()` または `setField()` のような単純なアクセサーメソッドを無視するように構成できます。\n以下のオプションを使用して、メソッド、フィールド、クラス、パッケージ、モジュールなどの特定のコード要素に必要なタグと最小限の必要な可視性を構成することもできます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MissingJavadoc",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 46,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousArrayMethodCall",
                "shortDescription": {
                  "text": "疑わしい 'Arrays' メソッドの呼び出し"
                },
                "fullDescription": {
                  "text": "引数の型が一致していない 'Arrays.fill()' などの一般的でない配列操作メソッドの呼び出しを報告します。 このような呼び出しは無益であり、間違いである可能性があります。 例: 'int foo(String[] strings) {\n    return Arrays.binarySearch(strings, 1);\n  }' 2017.2 の新機能です",
                  "markdown": "引数の型が一致していない `Arrays.fill()` などの一般的でない配列操作メソッドの呼び出しを報告します。 このような呼び出しは無益であり、間違いである可能性があります。\n\n**例:**\n\n\n      int foo(String[] strings) {\n        return Arrays.binarySearch(strings, 1);\n      }\n\n2017.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousArrayMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassHasNoToStringMethod",
                "shortDescription": {
                  "text": "'toString()' メソッドをオーバーライドしていないクラス"
                },
                "fullDescription": {
                  "text": "'toString()' メソッドのないクラスを報告します。",
                  "markdown": "`toString()` メソッドのないクラスを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassHasNoToStringMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/toString() の問題",
                      "index": 123,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AwaitWithoutCorrespondingSignal",
                "shortDescription": {
                  "text": "対応する 'signal()' のない 'await()'"
                },
                "fullDescription": {
                  "text": "'Condition.await()' への呼び出しのうち、対応する 'Condition.signal()' または 'Condition.signalAll()' の呼び出しが見つからないものを報告します。 対応する 'Condition.signal()' のないスレッドで 'Condition.await()' を呼び出すと、スレッドが中断されるか「スプリアスウェイクアップ」(偽の起床) が発生するまで、スレッドが無効になる場合があります。 このインスペクションは、現在のクラスのフィールドを対象とする呼び出しのみを報告します。 例: 'class Queue {\n    private final Condition isEmpty = ...;\n\n    void add(Object elem) {\n      // ...\n      // isEmpty.signal();\n      // ...\n    }\n\n    void remove(Object elem) throws InterruptedException {\n      // ...\n      isEmpty.await(); //'await()' には対応する 'signal()'/'signalAll()' 呼び出しが含まれていません\n      // ...\n    }\n  }'",
                  "markdown": "`Condition.await()` への呼び出しのうち、対応する `Condition.signal()` または `Condition.signalAll()` の呼び出しが見つからないものを報告します。\n\n\n対応する `Condition.signal()` のないスレッドで `Condition.await()` を呼び出すと、スレッドが中断されるか「スプリアスウェイクアップ」(偽の起床) が発生するまで、スレッドが無効になる場合があります。\n\nこのインスペクションは、現在のクラスのフィールドを対象とする呼び出しのみを報告します。\n\n**例:**\n\n\n      class Queue {\n        private final Condition isEmpty = ...;\n\n        void add(Object elem) {\n          // ...\n          // isEmpty.signal();\n          // ...\n        }\n\n        void remove(Object elem) throws InterruptedException {\n          // ...\n          isEmpty.await(); //'await()' には対応する 'signal()'/'signalAll()' 呼び出しが含まれていません\n          // ...\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AwaitWithoutCorrespondingSignal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryLocalVariable",
                "shortDescription": {
                  "text": "冗長なローカル変数"
                },
                "fullDescription": {
                  "text": "以下のように、メソッドの分かりやすさに何ら寄与しない不必要なローカル変数を報告します。 直ちに返されるローカル変数。 別の変数にすぐに代入された後、使用されていないローカル変数。 別のローカル変数またはパラメーターと常に同じ値を持つローカル変数。 例: 'boolean yes() {\n    boolean b = true;\n    return b;\n  }' クイックフィックス適用後: 'boolean yes() {\n    return true;\n  }' インスペクションの構成: 直ちに返される変数またはスローされる変数を無視するには、「直ちに返される変数またはスローされる変数を無視する」オプションを使用します。 一部のコードスタイルは、コードを明確にしてデバッグを容易にする目的でこのような変数を使用することを推奨しています。 アノテーションを持つ変数を無視するには、「アノテーションを持つ変数を無視する」オプションを使用します。",
                  "markdown": "以下のように、メソッドの分かりやすさに何ら寄与しない不必要なローカル変数を報告します。\n\n* 直ちに返されるローカル変数。\n* 別の変数にすぐに代入された後、使用されていないローカル変数。\n* 別のローカル変数またはパラメーターと常に同じ値を持つローカル変数。\n\n**例:**\n\n\n      boolean yes() {\n        boolean b = true;\n        return b;\n      }\n\nクイックフィックス適用後:\n\n\n      boolean yes() {\n        return true;\n      }\n      \nインスペクションの構成:\n\n* 直ちに返される変数またはスローされる変数を無視するには、「**直ちに返される変数またはスローされる変数を無視する**」オプションを使用します。 一部のコードスタイルは、コードを明確にしてデバッグを容易にする目的でこのような変数を使用することを推奨しています。\n* アノテーションを持つ変数を無視するには、「**アノテーションを持つ変数を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryLocalVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/データフロー",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9RedundantRequiresStatement",
                "shortDescription": {
                  "text": "module-info の冗長な 'requires' ディレクティブ"
                },
                "fullDescription": {
                  "text": "Java プラットフォームモジュールシステムの 'module-info.java' ファイルにある冗長な 'requires' ディレクティブを報告します。 モジュール 'A' がモジュール 'B' を必要としているものの、モジュール 'A' のコードが 'B' のパッケージまたはクラスをインポートしていない場合、'requires' ディレクティブは冗長になります。 さらに、すべてのモジュールには 'java.base' モジュールに暗黙的に宣言された依存関係があるため、'requires java.base;' ディレクティブは常に冗長になります。 クイックフィックスを使用すると、冗長な 'requires' ディレクティブが削除されます。 削除した依存関係によって実際に使用されているモジュールが再度エクスポートされた場合は、クイックフィックスによって該当モジュール用の 'requires' ディレクティブが追加されます。 このインスペクションは、プロジェクトまたはモジュールの言語レベルが 9 以上の場合にのみ報告します。 2017.1 の新機能です",
                  "markdown": "Java プラットフォームモジュールシステムの `module-info.java` ファイルにある冗長な `requires` ディレクティブを報告します。 モジュール `A` がモジュール `B` を必要としているものの、モジュール `A` のコードが `B` のパッケージまたはクラスをインポートしていない場合、`requires` ディレクティブは冗長になります。 さらに、すべてのモジュールには `java.base` モジュールに暗黙的に宣言された依存関係があるため、`requires java.base;` ディレクティブは常に冗長になります。\n\n\nクイックフィックスを使用すると、冗長な `requires` ディレクティブが削除されます。\n削除した依存関係によって実際に使用されているモジュールが再度エクスポートされた場合は、クイックフィックスによって該当モジュール用の `requires` ディレクティブが追加されます。\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 9 以上の場合にのみ報告します。\n\n2017.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java9RedundantRequiresStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldAccessNotGuarded",
                "shortDescription": {
                  "text": "ガードされていないフィールドアクセスまたはメソッド呼び出し"
                },
                "fullDescription": {
                  "text": "'@GuardedBy' で宣言されているものの、適切な同期構造によりガードされていないフィールドへのアクセスを報告します。 例: '@GuardedBy(\"this\")\n    void x() {\n        notify();\n    }\n    void y() {\n        x(); // ガードされていないメソッド呼び出し\n    }' サポート対象の '@GuardedBy' アノテーションは以下の通りです。 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "`@GuardedBy` で宣言されているものの、適切な同期構造によりガードされていないフィールドへのアクセスを報告します。\n\n例:\n\n\n        @GuardedBy(\"this\")\n        void x() {\n            notify();\n        }\n        void y() {\n            x(); // ガードされていないメソッド呼び出し\n        }\n\nサポート対象の `@GuardedBy` アノテーションは以下の通りです。\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldAccessNotGuarded",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/並行処理に関するアノテーションの問題",
                      "index": 58,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BusyWait",
                "shortDescription": {
                  "text": "ビジーウェイト"
                },
                "fullDescription": {
                  "text": "ループ内にある 'java.lang.Thread.sleep()' メソッドの呼び出しを報告します。 このような呼び出しは、「ビジーウェイト」の発生を意味します。 ビジーウェイトは往々にして非効率であり、予期しないデッドロックの原因になる場合があります。ビジーウェイトしているスレッドがロックしたリソースを解放しないためです。 例: 'class X {\n     volatile int x;\n     public void waitX() throws Exception {\n      while (x > 0) {\n        Thread.sleep(10);// 警告: 'Thread.sleep()' がループ中で呼び出されており、おそらくビジーウェイトしています\n      }\n    }\n  }'",
                  "markdown": "ループ内にある `java.lang.Thread.sleep()` メソッドの呼び出しを報告します。\n\nこのような呼び出しは、「ビジーウェイト」の発生を意味します。 ビジーウェイトは往々にして非効率であり、予期しないデッドロックの原因になる場合があります。ビジーウェイトしているスレッドがロックしたリソースを解放しないためです。\n\n**例:**\n\n\n      class X {\n         volatile int x;\n         public void waitX() throws Exception {\n          while (x > 0) {\n            Thread.sleep(10);// 警告: 'Thread.sleep()' がループ中で呼び出されており、おそらくビジーウェイトしています\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BusyWait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForLoopWithMissingComponent",
                "shortDescription": {
                  "text": "欠落したコンポーネントがある 'for' ループ"
                },
                "fullDescription": {
                  "text": "初期化、条件、または更新句がない 'for' ループを報告します。 一部のコードスタイルでは、このようなループが禁止されています。 例: 'for (int i = 0;;i++) {\n    // body\n  }' イテレーターを使用するループを無視するには、「コレクションの繰り返しを無視する」オプションを使用します。 これは、'for' ループに更新句がないコレクションの標準的な反復処理方法です。",
                  "markdown": "初期化、条件、または更新句がない `for` ループを報告します。 一部のコードスタイルでは、このようなループが禁止されています。\n\n例:\n\n\n      for (int i = 0;;i++) {\n        // body\n      }\n\n\nイテレーターを使用するループを無視するには、「**コレクションの繰り返しを無視する** 」オプションを使用します。\nこれは、`for` ループに更新句がないコレクションの標準的な反復処理方法です。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForLoopWithMissingComponent",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicStaticArrayField",
                "shortDescription": {
                  "text": "'public static' 配列フィールド"
                },
                "fullDescription": {
                  "text": "'public' 'static' 配列フィールドを報告します。 このようなフィールドは、定数値の配列を保管するためによく使用されます。 ただし、このようなフィールドは 'final' 宣言されている場合でも中身が変更される可能性があるため、セキュリティ上の危険があります。 例: 'public static String[] allowedPasswords = {\"foo\", \"bar\"};'",
                  "markdown": "`public` `static` 配列フィールドを報告します。\n\n\nこのようなフィールドは、定数値の配列を保管するためによく使用されます。 ただし、このようなフィールドは `final` 宣言されている場合でも中身が変更される可能性があるため、セキュリティ上の危険があります。\n\n**例:**\n\n\n      public static String[] allowedPasswords = {\"foo\", \"bar\"};\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicStaticArrayField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MagicNumber",
                "shortDescription": {
                  "text": "マジックナンバー"
                },
                "fullDescription": {
                  "text": "\"マジックナンバー\"、すなわち定数宣言で命名されていない数値リテラルを報告します。 マジックナンバーを使用するとコードが不明確になるだけでなく、マジックナンバーがある場所だけで変更され、他の場所で変更されていない場合にエラーが発生する可能性があります。 数値 0、1、2、3、4、5、6、7、8、9、10、100、1000、0L、1L、2L、0.0、1.0、0.0F、1.0F は、このインスペクションでは報告されません。 例: 'void checkFileSize(long bytes) {\n    if (bytes > 1_048_576) {\n      throw new IllegalArgumentException(\"too big\");\n    }\n  }' クイックフィックスによって新しい定数が導入されます。 'static final int MAX_SUPPORTED_FILE_SIZE = 1_048_576;\n\n  void checkFileSize(long bytes) {\n    if (bytes > MAX_SUPPORTED_FILE_SIZE) {\n      throw new IllegalArgumentException(\"too big\");\n    }\n  }' インスペクションの構成: 'hashCode()' メソッド内でこのインスペクションを無効にするには、「'hashCode()' メソッドで定数を無視する」オプションを使用します。 アノテーション内のマジックナンバーを無視するには、「アノテーション内で無視する」オプションを使用します。 'Collection'、'Map'、'StringBuilder' または 'StringBuffer' オブジェクトを構築する際に初期容量として使用されるマジックナンバーを無視するには、「StringBuilder および Collection の初期容量を無視する」オプションを使用します。",
                  "markdown": "\"マジックナンバー\"、すなわち定数宣言で命名されていない数値リテラルを報告します。\n\nマジックナンバーを使用するとコードが不明確になるだけでなく、マジックナンバーがある場所だけで変更され、他の場所で変更されていない場合にエラーが発生する可能性があります。 数値 0、1、2、3、4、5、6、7、8、9、10、100、1000、0L、1L、2L、0.0、1.0、0.0F、1.0F は、このインスペクションでは報告されません。\n\n例:\n\n\n      void checkFileSize(long bytes) {\n        if (bytes > 1_048_576) {\n          throw new IllegalArgumentException(\"too big\");\n        }\n      }\n\nクイックフィックスによって新しい定数が導入されます。\n\n\n      static final int MAX_SUPPORTED_FILE_SIZE = 1_048_576;\n\n      void checkFileSize(long bytes) {\n        if (bytes > MAX_SUPPORTED_FILE_SIZE) {\n          throw new IllegalArgumentException(\"too big\");\n        }\n      }\n\nインスペクションの構成:\n\n* `hashCode()` メソッド内でこのインスペクションを無効にするには、「**'hashCode()' メソッドで定数を無視する**」オプションを使用します。\n* アノテーション内のマジックナンバーを無視するには、「**アノテーション内で無視する**」オプションを使用します。\n* `Collection`、`Map`、`StringBuilder` または `StringBuffer` オブジェクトを構築する際に初期容量として使用されるマジックナンバーを無視するには、「**StringBuilder および Collection の初期容量を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MagicNumber",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象化関連の問題",
                      "index": 74,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverwrittenKey",
                "shortDescription": {
                  "text": "上書きされている Map、Set、または配列要素"
                },
                "fullDescription": {
                  "text": "連続する 'add'/'put' 呼び出しにある、または 'Set.of' などの Java 9 ファクトリメソッドを使用している 'Map' キー、'Set' 要素、または配列要素を上書きしている (ランタイム例外を引き起こす) コードを報告します。 これは通常、コピーと貼り付けの問題が原因で発生します。 例: 'map.put(\"A\", 1);\n  map.put(\"B\", 2);\n  map.put(\"C\", 3);\n  map.put(\"D\", 4);\n  map.put(\"A\", 5); // \"A\" キーが重複しているため、以前に書き込まれたエントリが上書きされます' 2017.3 の新機能です",
                  "markdown": "連続する `add`/`put` 呼び出しにある、または `Set.of` などの Java 9 ファクトリメソッドを使用している `Map` キー、`Set` 要素、または配列要素を上書きしている (ランタイム例外を引き起こす) コードを報告します。\n\nこれは通常、コピーと貼り付けの問題が原因で発生します。\n\n**例:**\n\n\n      map.put(\"A\", 1);\n      map.put(\"B\", 2);\n      map.put(\"C\", 3);\n      map.put(\"D\", 4);\n      map.put(\"A\", 5); // \"A\" キーが重複しているため、以前に書き込まれたエントリが上書きされます\n\n2017.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverwrittenKey",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousClassMethodCount",
                "shortDescription": {
                  "text": "メソッドが多すぎる匿名クラス"
                },
                "fullDescription": {
                  "text": "メソッド数が指定された最大値を超えている匿名の内部クラスを報告します。 多数のメソッドを含む匿名クラスは理解しにくい可能性があるため、名前付きの内部クラスになるように昇格する必要があります。 匿名の内部クラスで許容されるメソッド数の最大値を指定するには、「メソッド数の制限」フィールドを使用します。",
                  "markdown": "メソッド数が指定された最大値を超えている匿名の内部クラスを報告します。\n\n多数のメソッドを含む匿名クラスは理解しにくい可能性があるため、名前付きの内部クラスになるように昇格する必要があります。\n\n匿名の内部クラスで許容されるメソッド数の最大値を指定するには、「**メソッド数の制限**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnonymousInnerClassWithTooManyMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラスメトリクス",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumSwitchStatementWhichMissesCases",
                "shortDescription": {
                  "text": "大文字と小文字を区別しない列挙型の 'switch' ステートメント"
                },
                "fullDescription": {
                  "text": "完全ではない列挙型に対して実行されている 'switch' ステートメントを報告します。 例: 'enum AlphaBetaGamma {\n    A, B, C;\n\n    void x(AlphaBetaGamma e) {\n      switch (e) {\n\n      }\n    }\n  }' クイックフィックス適用後: 'enum AlphaBetaGamma {\n    A, B, C;\n\n    void x(AlphaBetaGamma e) {\n      switch (e) {\n        case A -> {}\n        case B -> {}\n        case C -> {}\n      }\n    }\n  }' 'default' 分岐を持つ 'switch' ステートメントを無視するには、「default 分岐のある switch 文を無視する」オプションを使用します。 このインスペクションは Java 5 以降で使用できる Java の機能 '列挙型' に依存しています。",
                  "markdown": "完全ではない列挙型に対して実行されている `switch` ステートメントを報告します。\n\n**例:**\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n\n          }\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n            case A -> {}\n            case B -> {}\n            case C -> {}\n          }\n        }\n      }\n\n\n`default` 分岐を持つ `switch` ステートメントを無視するには、「**default 分岐のある switch 文を無視する**」オプションを使用します。\n\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 '列挙型' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EnumSwitchStatementWhichMissesCases",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegativelyNamedBooleanVariable",
                "shortDescription": {
                  "text": "否定的な名前のブール変数"
                },
                "fullDescription": {
                  "text": "'disabled'、'hidden'、'isNotChanged' などの否定的な名前の変数を報告します。 多くの場合、'boolean' 値を反転して名前を肯定的に変えるとコードが理解しやすくなります。 例: 'boolean disabled = false;'",
                  "markdown": "`disabled`、`hidden`、`isNotChanged` などの否定的な名前の変数を報告します。\n\n多くの場合、`boolean` 値を反転して名前を肯定的に変えるとコードが理解しやすくなります。\n\n例:\n\n\n        boolean disabled = false;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NegativelyNamedBooleanVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/データフロー",
                      "index": 24,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodWithMultipleLoops",
                "shortDescription": {
                  "text": "複数のループを持つメソッド"
                },
                "fullDescription": {
                  "text": "1 つ以上のループステートメントを含むメソッドを報告します。 例: 以下のメソッドは 2 つのループを含んでいるため、報告の対象になります。 'void methodWithTwoLoops(int n1, int n2) {\n    for (int i = 0; i < n1; i++) {\n      System.out.println(i);\n    }\n\n    int j = 0;\n    while (j < n2) {\n      System.out.println(j);\n      j++;\n    }\n  }' 以下のメソッドもネストしたループを含んでいるため、報告の対象になります。 'void methodWithNestedLoop(int n1, int n2) {\n    for (int i = 0; i < n1; i++) {\n      for (int j = 0; j < n2; j++) {\n        System.out.println(i + j);\n      }\n    }\n  }'",
                  "markdown": "1 つ以上のループステートメントを含むメソッドを報告します。\n\n**例:**\n\n以下のメソッドは 2 つのループを含んでいるため、報告の対象になります。\n\n\n      void methodWithTwoLoops(int n1, int n2) {\n        for (int i = 0; i < n1; i++) {\n          System.out.println(i);\n        }\n\n        int j = 0;\n        while (j < n2) {\n          System.out.println(j);\n          j++;\n        }\n      }\n\n以下のメソッドもネストしたループを含んでいるため、報告の対象になります。\n\n\n      void methodWithNestedLoop(int n1, int n2) {\n        for (int i = 0; i < n1; i++) {\n          for (int j = 0; j < n2; j++) {\n            System.out.println(i + j);\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithMultipleLoops",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メソッドメトリクス",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousIntegerDivAssignment",
                "shortDescription": {
                  "text": "疑わしい整数の分割代入"
                },
                "fullDescription": {
                  "text": "代入式のうち、その右側が整数に切り捨ててはならない除算になっているものを報告します。 このようなコンストラクトは意図的な場合もありますが、多くの場合はバグです。 例: 'int x = 18;\n  x *= 3/2; // 整数除算の結果のため、x は変更されません' このコードは次に置換すべきです。 'int x = 18;\n  x *= 3.0/2;' インスペクションのオプションでは、疑わしいものの正しいと思われる除算の警告を無効にすることができます (被除数を静的に計算できない場合などに使用します)。 'void calc(int d) {\n     int x = 18;\n     x *= d/2;\n  }' 2019.2 の新機能です",
                  "markdown": "代入式のうち、その右側が整数に切り捨ててはならない除算になっているものを報告します。\n\nこのようなコンストラクトは意図的な場合もありますが、多くの場合はバグです。\n\n**例:**\n\n\n      int x = 18;\n      x *= 3/2; // 整数除算の結果のため、x は変更されません\n\n\nこのコードは次に置換すべきです。\n\n\n      int x = 18;\n      x *= 3.0/2;\n\n\nインスペクションのオプションでは、疑わしいものの正しいと思われる除算の警告を無効にすることができます (被除数を静的に計算できない場合などに使用します)。\n\n\n      void calc(int d) {\n         int x = 18;\n         x *= d/2;\n      }\n\n\n2019.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousIntegerDivAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SleepWhileHoldingLock",
                "shortDescription": {
                  "text": "同期中の 'Thread.sleep()' の呼び出し"
                },
                "fullDescription": {
                  "text": "'synchronized' ブロックまたはメソッド内にある 'java.lang.Thread.sleep()' メソッドの呼び出しを報告します。 'synchronized' ブロック内に 'sleep()' があると、パフォーマンスの低下と拡張性の低下に加えて、場合によってはデッドロックが発生する可能性があります。 代わりに 'wait()' を使用して保持されているロックを解放することを検討してください。 例: 'synchronized (lock) {\n    Thread.sleep(100);\n  }'",
                  "markdown": "`synchronized` ブロックまたはメソッド内にある `java.lang.Thread.sleep()` メソッドの呼び出しを報告します。\n\n\n`synchronized` ブロック内に `sleep()` があると、パフォーマンスの低下と拡張性の低下に加えて、場合によってはデッドロックが発生する可能性があります。 代わりに `wait()` を使用して保持されているロックを解放することを検討してください。\n\n**例:**\n\n\n      synchronized (lock) {\n        Thread.sleep(100);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SleepWhileHoldingLock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/スレッド関連の問題",
                      "index": 8,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedClassUsageInspection",
                "shortDescription": {
                  "text": "XML 内での非推奨 API の使用箇所"
                },
                "fullDescription": {
                  "text": "XML ファイルで非推奨のクラスとメソッドが使用されていることを報告します。",
                  "markdown": "XML ファイルで非推奨のクラスとメソッドが使用されていることを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeprecatedClassUsageInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalOfNullableMisuse",
                "shortDescription": {
                  "text": "null または非 null 引数を持つ Optional.ofNullable の使用"
                },
                "fullDescription": {
                  "text": "常に null または常に null 以外の引数が渡されている 'Optional.ofNullable()' の使用を報告します。 この場合は 'Optional.ofNullable()' の使用は意味がありません。'Optional.empty()' または 'Optional.of()' のいずれかを使用し、常に空であるか、または常に空でない Optional を作成する意図をそれぞれ明確に示す必要があります。 'Optional.ofNullable()' の引数にミスがある可能性もあるため、調べる必要があります。 例: 'Optional<String> empty = Optional.ofNullable(null); // Optional.empty(); にする必要があります\nOptional<String> present = Optional.ofNullable(\"value\"); // Optional.of(\"value\"); にする必要があります' このインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。",
                  "markdown": "常に null または常に null 以外の引数が渡されている `Optional.ofNullable()` の使用を報告します。 この場合は `Optional.ofNullable()` の使用は意味がありません。`Optional.empty()` または `Optional.of()` のいずれかを使用し、常に空であるか、または常に空でない Optional を作成する意図をそれぞれ明確に示す必要があります。 `Optional.ofNullable()` の引数にミスがある可能性もあるため、調べる必要があります。\n\n\n例:\n\n\n    Optional<String> empty = Optional.ofNullable(null); // Optional.empty(); にする必要があります\n    Optional<String> present = Optional.ofNullable(\"value\"); // Optional.of(\"value\"); にする必要があります \n\nこのインスペクションは Java 8 以降で使用できる Java の機能 'Stream と Optional API' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalOfNullableMisuse",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastToIncompatibleInterface",
                "shortDescription": {
                  "text": "互換性のない型へのキャスト"
                },
                "fullDescription": {
                  "text": "キャストクラス/インターフェース型を extends/implements せず、それを行うサブクラスもないクラス/インターフェース型がキャスト対象の式にある型キャスト式を報告します。 このようなコンストラクトは間違いである可能性が高く、実行時に 'java.lang.ClassCastException' をスローします。 例: 'interface A {}\n  interface Z {}\n  static class C {}\n\n  void x(C c) {\n    if (c instanceof Z) {\n      A a = ((A)c); // 互換性のないインターフェース 'A' にキャスト\n    }\n  }'",
                  "markdown": "キャストクラス/インターフェース型を extends/implements せず、それを行うサブクラスもないクラス/インターフェース型がキャスト対象の式にある型キャスト式を報告します。\n\n\nこのようなコンストラクトは間違いである可能性が高く、実行時に `java.lang.ClassCastException` をスローします。\n\n**例:**\n\n\n      interface A {}\n      interface Z {}\n      static class C {}\n\n      void x(C c) {\n        if (c instanceof Z) {\n          A a = ((A)c); // 互換性のないインターフェース 'A' にキャスト\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CastToIncompatibleInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodReturnAlwaysConstant",
                "shortDescription": {
                  "text": "定数のみを返すメソッド"
                },
                "fullDescription": {
                  "text": "継承先によって異なる定数のみを返すメソッドを報告します。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。",
                  "markdown": "継承先によって異なる定数のみを返すメソッドを報告します。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodReturnAlwaysConstant",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateBranchesInSwitch",
                "shortDescription": {
                  "text": "'switch' 内の重複した分岐"
                },
                "fullDescription": {
                  "text": "異なる分岐に同じコードがある 'switch' ステートメントまたは式を報告し、重複している分岐のマージを提案します。 例: 'switch (n) {\n    case 1:\n      System.out.println(n);\n      break;\n    case 2:\n      System.out.println(n);\n      break;\n    default:\n      System.out.println(\"default\");\n  }' クイックフィックス適用後: 'switch (n) {\n    case 1:\n    case 2:\n      System.out.println(n);\n      break;\n    default:\n      System.out.println(\"default\");\n  }' 2019.1 の新機能です",
                  "markdown": "異なる分岐に同じコードがある `switch` ステートメントまたは式を報告し、重複している分岐のマージを提案します。\n\n例:\n\n\n      switch (n) {\n        case 1:\n          System.out.println(n);\n          break;\n        case 2:\n          System.out.println(n);\n          break;\n        default:\n          System.out.println(\"default\");\n      }\n\nクイックフィックス適用後:\n\n\n      switch (n) {\n        case 1:\n        case 2:\n          System.out.println(n);\n          break;\n        default:\n          System.out.println(\"default\");\n      }\n\n2019.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DuplicateBranchesInSwitch",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SingleElementAnnotation",
                "shortDescription": {
                  "text": "正規化されていないアノテーション"
                },
                "fullDescription": {
                  "text": "短縮形のアノテーションを報告し、属性名を含む通常のアノテーション形式に書き換えることを提案します。 例: '@SuppressWarnings(\"foo\")' クイックフィックス適用後: '@SuppressWarnings(value = \"foo\")'",
                  "markdown": "短縮形のアノテーションを報告し、属性名を含む通常のアノテーション形式に書き換えることを提案します。\n\n例:\n\n\n      @SuppressWarnings(\"foo\")\n\nクイックフィックス適用後:\n\n\n      @SuppressWarnings(value = \"foo\")\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SingleElementAnnotation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ManualMinMaxCalculation",
                "shortDescription": {
                  "text": "min/max の手動計算"
                },
                "fullDescription": {
                  "text": "手動で計算する代わりに、'Math.max()' または 'Math.min()' 呼び出しを使用して 2 つの数値の最小値または最大値を計算できる場合に報告します。 例: 'public int min(int a, int b) {\n    return b < a ? b : a;\n  }' クイックフィックス適用後: 'public int min(int a, int b) {\n    return Math.min(a, b);\n  }' このインスペクションを 'double' および 'float' 型に対して無効にするには、「float と double に対して無効化」オプションを使用します。 このオプションは、このクイックフィックスが 'NaN' を処理する際に 'float'/ 'double' 型のセマンティクスをわずかに変わる可能性がある場合に役立ちます。 しかし、このクイックフィックスは多くの場合、'NaN' が考慮されていない場合に発生する微妙なバグを実際に修正します。 2019.2 の新機能です",
                  "markdown": "手動で計算する代わりに、`Math.max()` または `Math.min()` 呼び出しを使用して 2 つの数値の最小値または最大値を計算できる場合に報告します。\n\n**例:**\n\n\n      public int min(int a, int b) {\n        return b < a ? b : a;\n      }\n\nクイックフィックス適用後:\n\n\n      public int min(int a, int b) {\n        return Math.min(a, b);\n      }\n\n\nこのインスペクションを `double` および `float` 型に対して無効にするには、「**float と double に対して無効化** 」オプションを使用します。\nこのオプションは、このクイックフィックスが `NaN` を処理する際に `float`/ `double` 型のセマンティクスをわずかに変わる可能性がある場合に役立ちます。 しかし、このクイックフィックスは多くの場合、`NaN` が考慮されていない場合に発生する微妙なバグを実際に修正します。\n\n2019.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ManualMinMaxCalculation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableConditionalExpression",
                "shortDescription": {
                  "text": "単純化できる条件式"
                },
                "fullDescription": {
                  "text": "条件式を報告し、単純化することを提案します。 例: 'condition ? true : foo → condition || foo' 'condition ? false : foo → !condition && foo' 'condition ? foo : !foo → condition == foo' 'condition ? true : false → condition' 'a == b ? b : a → a' 'result != null ? result : null → result'",
                  "markdown": "条件式を報告し、単純化することを提案します。\n\n例:\n\n    condition ? true : foo → condition || foo\n\n    condition ? false : foo → !condition && foo\n\n    condition ? foo : !foo → condition == foo\n\n    condition ? true : false → condition\n\n    a == b ? b : a → a\n\n    result != null ? result : null → result\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableConditionalExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SillyAssignment",
                "shortDescription": {
                  "text": "自身に代入されている変数"
                },
                "fullDescription": {
                  "text": "変数の自己代入を報告します。 例: 'a = a;' クイックフィックスを使用すると、このような代入が除去されます。",
                  "markdown": "変数の自己代入を報告します。\n\n**例:**\n\n\n      a = a;\n\nクイックフィックスを使用すると、このような代入が除去されます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SillyAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BoundedWildcard",
                "shortDescription": {
                  "text": "境界ワイルドカードを使用可能"
                },
                "fullDescription": {
                  "text": "境界ワイルドカードを使用可能な一般的なメソッドパラメーターを報告します。 例: 'void process(Consumer<Number> consumer);' 上のコードは下のコードに置換すべきです。 'void process(Consumer<? super Number> consumer);' このメソッドシグネチャーは 'Consumer<Number>' と 'Consumer<Object>' の両方の型を受け付けるため、より柔軟性が高くなっています。 同様に、型パラメーターが共変の位置にある場合を考えます。 'T produce(Producer<T> p);' 上のコードは下のコードに置換すべきです。 'T produce(Producer<? extends T> p);' Effective Java 第 3 版から Joshua Bloch 氏の言葉を引用します。 項目 31: API の柔軟性向上のために境界ワイルドカードを使う トリッキーではありますが、API で境界ワイルドカードを使うと、API の柔軟性が飛躍的に高まります。 広範に使用されるライブラリを書く場合、ワイルドカード型の適切な使用を考慮することは避けて通れません。 プロデューサー-extends、コンシューマー-super (PECS) の基本ルールを覚えておいてください。 また、すべての Comparable と Comparator がコンシューマーであることも覚えておいてください。 報告対象を切り替えるには、インスペクションのオプションを使用します。 非変クラス。 たとえば、非変クラスには 'java.util.List<T>' があります。このクラスは値を受け付ける ('List.add(T)' メソッド経由) だけでなく、値を生成 ('T List.get()' メソッド経由) するためです。 いっぽう、'反変'クラスは値を受け付けるだけです。たとえば、'accept(T)' メソッドのみを持つ 'java.util.function.Consumer<T>' があります。 同様に、'共変'クラスは値の生成のみを行います。たとえば、'T get()' メソッドのみを持つ 'java.util.function.Supplier<T>' があります。 境界ワイルドカードは共変/反変クラスでよく使用されていますが、'void process(List<? extends T> l)' のような非変クラスではワイルドカードの使用は避けられています。 このような非変クラスを無視し、'void process(List<T> l)' のように厳密な型付けを維持するには、このオプションを無効にしてください。 公開 API の一部とは見なされない、'private' メソッド。 インスタンスメソッド",
                  "markdown": "[境界ワイルドカード](https://en.wikipedia.org/wiki/Wildcard_(Java))を使用可能な一般的なメソッドパラメーターを報告します。\n\n**例:**\n\n\n      void process(Consumer<Number> consumer);\n\n上のコードは下のコードに置換すべきです。\n\n\n      void process(Consumer<? super Number> consumer);\n\n\nこのメソッドシグネチャーは `Consumer<Number>` と `Consumer<Object>` の両方の型を受け付けるため、より柔軟性が高くなっています。\n\n同様に、型パラメーターが共変の位置にある場合を考えます。\n\n\n      T produce(Producer<T> p);\n\n上のコードは下のコードに置換すべきです。\n\n\n      T produce(Producer<? extends T> p);\n\n\n*Effective Java* 第 3 版から [Joshua Bloch](https://en.wikipedia.org/wiki/Joshua_Bloch#Effective_Java) 氏の言葉を引用します。\n>\n> #### 項目 31: API の柔軟性向上のために境界ワイルドカードを使う\n>\n> トリッキーではありますが、API で境界ワイルドカードを使うと、API の柔軟性が飛躍的に高まります。 広範に使用されるライブラリを書く場合、ワイルドカード型の適切な使用を考慮することは避けて通れません。 プロデューサー-extends、コンシューマー-super (PECS) の基本ルールを覚えておいてください。 また、すべての Comparable と Comparator がコンシューマーであることも覚えておいてください。\n\n\n報告対象を切り替えるには、インスペクションのオプションを使用します。\n\n*\n  非変クラス。 たとえば、非変クラスには `java.util.List<T>` があります。このクラスは値を受け付ける (`List.add(T)` メソッド経由) だけでなく、値を生成 (`T List.get()` メソッド経由) するためです。\n\n\n  いっぽう、`反変`クラスは値を受け付けるだけです。たとえば、`accept(T)` メソッドのみを持つ `java.util.function.Consumer<T>` があります。 同様に、`共変`クラスは値の生成のみを行います。たとえば、`T get()` メソッドのみを持つ `java.util.function.Supplier<T>` があります。\n\n\n  境界ワイルドカードは共変/反変クラスでよく使用されていますが、`void process(List<? extends T> l)` のような非変クラスではワイルドカードの使用は避けられています。\n  このような非変クラスを無視し、`void process(List<T> l)` のように厳密な型付けを維持するには、このオプションを無効にしてください。\n*\n  公開 API の一部とは見なされない、`private` メソッド。\n\n*\n  インスタンスメソッド"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BoundedWildcard",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnqualifiedMethodAccess",
                "shortDescription": {
                  "text": "'this' で修飾されていないインスタンスメソッド呼び出し"
                },
                "fullDescription": {
                  "text": "'this' で修飾されていない同じインスタンス上にある非 'static' メソッドの呼び出しを報告します。 例: 'class Foo {\n    void bar() {}\n\n    void foo() {\n      bar();\n    }\n  }' クイックフィックス適用後: 'class Foo {\n    void bar() {}\n\n    void foo() {\n      this.bar();\n    }\n  }'",
                  "markdown": "`this` で修飾されていない同じインスタンス上にある非 `static` メソッドの呼び出しを報告します。\n\n**例:**\n\n\n      class Foo {\n        void bar() {}\n\n        void foo() {\n          bar();\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        void bar() {}\n\n        void foo() {\n          this.bar();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnqualifiedMethodAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceofIncompatibleInterface",
                "shortDescription": {
                  "text": "互換性のない型との 'instanceof'"
                },
                "fullDescription": {
                  "text": "'instanceof' 式の右辺でクラス/インターフェース型を extends/implements せず、それを行うサブクラスもないクラス/インターフェース型がチェック対象の式にある 'instanceof' 式を報告します。 このような式はライブラリコードをなどを意図している可能性があるものの、このようなコンストラクトは間違いである可能性があります。なぜなら、プロジェクトで宣言されているクラスのインスタンスはこの 'instanceof' テストをパスできない可能性があるためです。 例: 'class Foo { }\n\n  interface Bar { }\n  \n  class Main {\n      void test(Foo f, Bar b) {\n          if (f instanceof Bar) { // 問題\n              System.out.println(\"fail\");\n          }\n          if (b instanceof Foo) { // 問題\n              System.out.println(\"fail\");\n          }\n      }\n  }'",
                  "markdown": "`instanceof` 式の右辺でクラス/インターフェース型を extends/implements せず、それを行うサブクラスもないクラス/インターフェース型がチェック対象の式にある `instanceof` 式を報告します。\n\n\nこのような式はライブラリコードをなどを意図している可能性があるものの、このようなコンストラクトは間違いである可能性があります。なぜなら、プロジェクトで宣言されているクラスのインスタンスはこの `instanceof` テストをパスできない可能性があるためです。\n\n**例:**\n\n\n      class Foo { }\n\n      interface Bar { }\n      \n      class Main {\n          void test(Foo f, Bar b) {\n              if (f instanceof Bar) { // 問題\n                  System.out.println(\"fail\");\n              }\n              if (b instanceof Foo) { // 問題\n                  System.out.println(\"fail\");\n              }\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceofIncompatibleInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FunctionalExpressionCanBeFolded",
                "shortDescription": {
                  "text": "折りたたみ可能な関数式"
                },
                "fullDescription": {
                  "text": "メソッド参照またはラムダ式で、同じ関数型インターフェースの型のメソッドを参照しているため、それぞれの修飾子に置換して不要なオブジェクト割り当てを除去できるものを報告します。 例: 'SwingUtilities.invokeLater(r::run);\n  SwingUtilities.invokeAndWait(() -> r.run());' クイックフィックス適用後: 'SwingUtilities.invokeLater(r);\n  SwingUtilities.invokeAndWait(r);' このインスペクションは、プロジェクトまたはモジュールの言語レベルが 8 以上の場合にのみ報告します。",
                  "markdown": "メソッド参照またはラムダ式で、同じ関数型インターフェースの型のメソッドを参照しているため、それぞれの修飾子に置換して不要なオブジェクト割り当てを除去できるものを報告します。\n\n例:\n\n\n      SwingUtilities.invokeLater(r::run);\n      SwingUtilities.invokeAndWait(() -> r.run());\n\nクイックフィックス適用後:\n\n\n      SwingUtilities.invokeLater(r);\n      SwingUtilities.invokeAndWait(r);\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 8 以上の場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FunctionalExpressionCanBeFolded",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/宣言の冗長性",
                      "index": 15,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceVariableInitialization",
                "shortDescription": {
                  "text": "未初期化の可能性があるインスタンスフィールド"
                },
                "fullDescription": {
                  "text": "オブジェクト初期化時に初期化されていない可能性のあるインスタンス変数を報告します。 例: 'class Foo {\n    public int bar;\n\n    static { }\n  }' このインスペクションは非常に保守的なデータフローアルゴリズムを使用しており、インスタンス変数が初期化されていないものとして誤って報告される場合があります。 初期化されているものとして報告される変数は、常に初期化されます。 初期化されていないプリミティブフィールドを無視するには、「プリミティブフィールドを無視」オプションを使用します。",
                  "markdown": "オブジェクト初期化時に初期化されていない可能性のあるインスタンス変数を報告します。\n\n**例:**\n\n\n      class Foo {\n        public int bar;\n\n        static { }\n      }\n\nこのインスペクションは非常に保守的なデータフローアルゴリズムを使用しており、インスタンス変数が初期化されていないものとして誤って報告される場合があります。 初期化されているものとして報告される変数は、常に初期化されます。\n\n初期化されていないプリミティブフィールドを無視するには、「**プリミティブフィールドを無視**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceVariableMayNotBeInitialized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初期化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CustomClassloader",
                "shortDescription": {
                  "text": "カスタム 'ClassLoader' の宣言"
                },
                "fullDescription": {
                  "text": "ユーザーが定義している 'java.lang.ClassLoader' のサブクラスを報告します。 このようなクラスは必ずしもセキュリティホールになるわけではありませんが、セキュリティの問題が発生する可能性があるため、念入りに検査する必要があります。",
                  "markdown": "ユーザーが定義している `java.lang.ClassLoader` のサブクラスを報告します。\n\n\nこのようなクラスは必ずしもセキュリティホールになるわけではありませんが、セキュリティの問題が発生する可能性があるため、念入りに検査する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CustomClassloader",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/セキュリティ",
                      "index": 31,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfStatementWithTooManyBranches",
                "shortDescription": {
                  "text": "分岐が多すぎる 'if' ステートメント"
                },
                "fullDescription": {
                  "text": "分岐が多すぎる 'if' ステートメントを報告します。 このようなステートメントは混乱を招く可能性があり、多くの場合は設計の抽象化レベルが不十分であることを示しています。 'if' ステートメントで使用できる最大分岐数を指定するには、「最大分岐数」フィールドを使用します。",
                  "markdown": "分岐が多すぎる `if` ステートメントを報告します。\n\nこのようなステートメントは混乱を招く可能性があり、多くの場合は設計の抽象化レベルが不十分であることを示しています。\n\n\n`if` ステートメントで使用できる最大分岐数を指定するには、「**最大分岐数**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IfStatementWithTooManyBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThisEscapedInConstructor",
                "shortDescription": {
                  "text": "オブジェクト構築中の 'this' 参照のエスケープ"
                },
                "fullDescription": {
                  "text": "オブジェクトの初期化中に 'this' がエスケープする可能性があることを報告します。 エスケープは、コンストラクターまたはイニシャライザーで 'this' がメソッド引数またはオブジェクト代入として使用される場合に発生します。 このようなエスケープはバグの検出を困難にします。オブジェクトを初期化されるとは限らないコンテキストで使用できるようになったためです。 例: 'class Foo {\n    {\n      System.out.println(this);\n    }\n  }'",
                  "markdown": "オブジェクトの初期化中に `this` がエスケープする可能性があることを報告します。 エスケープは、コンストラクターまたはイニシャライザーで `this` がメソッド引数またはオブジェクト代入として使用される場合に発生します。 このようなエスケープはバグの検出を困難にします。オブジェクトを初期化されるとは限らないコンテキストで使用できるようになったためです。\n\n**例:**\n\n\n      class Foo {\n        {\n          System.out.println(this);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThisEscapedInObjectConstruction",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初期化",
                      "index": 29,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarySuperConstructor",
                "shortDescription": {
                  "text": "'super()' への不要な呼び出し"
                },
                "fullDescription": {
                  "text": "引数のないスーパークラスコンストラクターが、オブジェクト構築中に呼び出されていることを報告します。 このような呼び出しは不要なため、除去できます。 例: 'class Foo {\n    Foo() {\n      super();\n    }\n  }' クイックフィックス適用後: 'class Foo {\n    Foo() {\n    }\n  }'",
                  "markdown": "引数のないスーパークラスコンストラクターが、オブジェクト構築中に呼び出されていることを報告します。\n\nこのような呼び出しは不要なため、除去できます。\n\n**例:**\n\n\n      class Foo {\n        Foo() {\n          super();\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo {\n        Foo() {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryCallToSuper",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableObjectPassedToObjectStream",
                "shortDescription": {
                  "text": "非 Serializable オブジェクトが 'ObjectOutputStream' に渡されています"
                },
                "fullDescription": {
                  "text": "'java.io.ObjectOutputStream.write()' の引数として使用されている非 'Serializable' オブジェクトを報告します。 このような呼び出しは、ランタイム例外を引き起こします。 このインスペクションは型 'java.util.Collection' および 'java.util.Map' のオブジェクトについて、その宣言を含む型が非 'Serializable' でない限りは 'Serializable' であると仮定します。 例: 'public class IWantToSerializeThis {\n    public static void main(String[] args) throws IOException {\n      try(var stream = new ObjectOutputStream(Files.newOutputStream(Paths.get(\"output\")))) {\n        // 警告 - NotSerializableException で失敗します\n        stream.writeObject(new IWantToSerializeThis());\n      }\n    }\n  }'",
                  "markdown": "`java.io.ObjectOutputStream.write()` の引数として使用されている非 `Serializable` オブジェクトを報告します。 このような呼び出しは、ランタイム例外を引き起こします。\n\n\nこのインスペクションは型 `java.util.Collection` および `java.util.Map` のオブジェクトについて、その宣言を含む型が非 `Serializable` でない限りは `Serializable` であると仮定します。\n\n**例:**\n\n\n      public class IWantToSerializeThis {\n        public static void main(String[] args) throws IOException {\n          try(var stream = new ObjectOutputStream(Files.newOutputStream(Paths.get(\"output\")))) {\n            // 警告 - NotSerializableException で失敗します\n            stream.writeObject(new IWantToSerializeThis());\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableObjectPassedToObjectStream",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/シリアライズ関連の問題",
                      "index": 19,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonPublicClone",
                "shortDescription": {
                  "text": "'public' ではない 'clone()' メソッド"
                },
                "fullDescription": {
                  "text": "'public' ではなく 'protected' になっている 'clone()' メソッドを報告します。 'java.lang.Object' の 'clone()' メソッドをオーバーライドする場合は、メソッドを 'public' にしてパッケージ外の非サブクラスからアクセスできるようにする必要があります。",
                  "markdown": "`public` ではなく `protected` になっている `clone()` メソッドを報告します。\n\n`java.lang.Object` の `clone()` メソッドをオーバーライドする場合は、メソッドを `public` にしてパッケージ外の非サブクラスからアクセスできるようにする必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonPublicClone",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クローン関連の問題",
                      "index": 79,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfCanBeSwitch",
                "shortDescription": {
                  "text": "'if' は 'switch' に置換できます"
                },
                "fullDescription": {
                  "text": "'switch' ステートメントに置換できる 'if' ステートメントを報告します。 この置換により、通常はコードがより簡潔かつ明瞭になります。 例: 'void test(String str) {\n    if (str.equals(\"1\")) {\n      System.out.println(1);\n    } else if (str.equals(\"2\")) {\n      System.out.println(2);\n    } else if (str.equals(\"3\")) {\n      System.out.println(3);\n    } else {\n      System.out.println(4);\n    }\n  }' クイックフィックス適用後: 'void test(String str) {\n    switch (str) {\n      case \"1\" -> System.out.println(1);\n      case \"2\" -> System.out.println(2);\n      case \"3\" -> System.out.println(3);\n      default -> System.out.println(4);\n    }\n  }' このインスペクションは、プロジェクトまたはモジュールの言語レベルが 7 以上の場合にのみ報告します。 報告対象とする 'if' ステートメントの 'if' 条件の最小分岐数を指定するには、「'if' 条件分岐の最小数」フィールドを使用します。 ターミナルの 'else' 分岐 ('if' なし) はカウントされません。 プリミティブ型とボクシングした数値と文字の 'switch' ステートメントを提案させるには、「数値の switch を提案する」オプションを使用します。 'enum' 定数の 'switch' ステートメントを提案させるには、「列挙型の switch を提案する」オプションを使用します。 'NullPointerException' のみを導入できない 'switch' ステートメントを提案するには、「null セーフな式でのみ提案する」オプションを使用します。",
                  "markdown": "`switch` ステートメントに置換できる `if` ステートメントを報告します。\n\nこの置換により、通常はコードがより簡潔かつ明瞭になります。\n\n**例:**\n\n\n      void test(String str) {\n        if (str.equals(\"1\")) {\n          System.out.println(1);\n        } else if (str.equals(\"2\")) {\n          System.out.println(2);\n        } else if (str.equals(\"3\")) {\n          System.out.println(3);\n        } else {\n          System.out.println(4);\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      void test(String str) {\n        switch (str) {\n          case \"1\" -> System.out.println(1);\n          case \"2\" -> System.out.println(2);\n          case \"3\" -> System.out.println(3);\n          default -> System.out.println(4);\n        }\n      }\n      \nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 7 以上の場合にのみ報告します。\n\n報告対象とする `if` ステートメントの `if` 条件の最小分岐数を指定するには、「**'if' 条件分岐の最小数** 」フィールドを使用します。 ターミナルの `else` 分岐 (`if` なし) はカウントされません。\n\n\nプリミティブ型とボクシングした数値と文字の `switch` ステートメントを提案させるには、「**数値の switch を提案する**」オプションを使用します。\n\n\n`enum` 定数の `switch` ステートメントを提案させるには、「**列挙型の switch を提案する**」オプションを使用します。\n\n\n`NullPointerException` のみを導入できない `switch` ステートメントを提案するには、「**null セーフな式でのみ提案する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IfCanBeSwitch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援",
                      "index": 52,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfObsoleteDateTimeApi",
                "shortDescription": {
                  "text": "廃止された日時 API の使用"
                },
                "fullDescription": {
                  "text": "'java.util.Date'、'java.util.Calendar'、'java.util.GregorianCalendar'、'java.util.TimeZone'、'java.util.SimpleTimeZone' の使用箇所を報告します。 これらのクラスは引き続きサポートされていますが、JDK8 で日時 API が導入されて以降は廃止されているため、新しい開発では使用すべきでないと思われます。",
                  "markdown": "`java.util.Date`、`java.util.Calendar`、`java.util.GregorianCalendar`、`java.util.TimeZone`、`java.util.SimpleTimeZone` の使用箇所を報告します。\n\nこれらのクラスは引き続きサポートされていますが、JDK8 で日時 API が導入されて以降は廃止されているため、新しい開発では使用すべきでないと思われます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfObsoleteDateTimeApi",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コード成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InfiniteRecursion",
                "shortDescription": {
                  "text": "無限再帰"
                },
                "fullDescription": {
                  "text": "例外がスローされない限り、自分自身を無限に呼び出すメソッドを報告します。 このインスペクションで報告されるメソッドは、正常に結果を返すことができません。 このような挙動は意図的な場合もありますが、多くの場合は単なる見落としです。 例: 'int baz() {\n      return baz();\n  }'",
                  "markdown": "例外がスローされない限り、自分自身を無限に呼び出すメソッドを報告します。\n\n\nこのインスペクションで報告されるメソッドは、正常に結果を返すことができません。\nこのような挙動は意図的な場合もありますが、多くの場合は単なる見落としです。\n\n**例:**\n\n      int baz() {\n          return baz();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InfiniteRecursion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ModuleWithTooFewClasses",
                "shortDescription": {
                  "text": "クラスが少なすぎるモジュール"
                },
                "fullDescription": {
                  "text": "含んでいるクラスが少なすぎるモジュールを報告します。 モジュールが小さすぎる場合、設計が細分化されすぎている可能性があります。 Java、Kotlin、および Groovy クラスがカウントされます。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。 モジュールに含めることができるクラスの最小数を指定するには、「最小クラス数」フィールドを使用します。",
                  "markdown": "含んでいるクラスが少なすぎるモジュールを報告します。 モジュールが小さすぎる場合、設計が細分化されすぎている可能性があります。 Java、Kotlin、および Groovy クラスがカウントされます。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。\n\nモジュールに含めることができるクラスの最小数を指定するには、「**最小クラス数**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ModuleWithTooFewClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/モジュール化関連の問題",
                      "index": 65,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NullArgumentToVariableArgMethod",
                "shortDescription": {
                  "text": "紛らわしい可変引数メソッドの引数"
                },
                "fullDescription": {
                  "text": "可変長引数メソッドの呼び出しで、可変長引数パラメーターの位置に単一の引数 ('null' または可変長引数パラメーターのサブタイプの配列のいずれか) があるものを報告します。 このような引数は混乱を招く可能性があります。可変引数または非可変引数の呼び出しが望ましいのかどうかが明確でないためです。 例: 'String[] ss = new String[]{\"foo\", \"bar\"};\n  System.out.printf(\"%s\", ss);' この例では配列全体ではなく、配列の最初の要素のみが出力されます。 このインスペクションは Java 5 以降で使用できる Java の機能 '可変引数メソッド' に依存しています。",
                  "markdown": "可変長引数メソッドの呼び出しで、可変長引数パラメーターの位置に単一の引数 (`null` または可変長引数パラメーターのサブタイプの配列のいずれか) があるものを報告します。 このような引数は混乱を招く可能性があります。可変引数または非可変引数の呼び出しが望ましいのかどうかが明確でないためです。\n\n**例:**\n\n\n      String[] ss = new String[]{\"foo\", \"bar\"};\n      System.out.printf(\"%s\", ss);\n\nこの例では配列全体ではなく、配列の最初の要素のみが出力されます。\n\nこのインスペクションは Java 5 以降で使用できる Java の機能 '可変引数メソッド' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfusingArgumentToVarargsMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverloadedVarargsMethod",
                "shortDescription": {
                  "text": "オーバーロードされた可変引数メソッド"
                },
                "fullDescription": {
                  "text": "クラス内またはスーパークラス内の他のメソッドと同じ名前の可変長引数メソッドを報告します。 可変長引数を取るオーバーライドされたメソッドは、大きな混乱を招く可能性があります。これは多くの場合、どのオーバーロードが呼び出されるのかが不明確であるためです。 例: 'public void execute(Runnable... r) {} // 警告\n    public void execute(Runnable r1, Runnable r2) {}' 明らかに互換性のないパラメーターの型を持つオーバーロードされたメソッドを無視するには、オプションを使用します。",
                  "markdown": "クラス内またはスーパークラス内の他のメソッドと同じ名前の可変長引数メソッドを報告します。 可変長引数を取るオーバーライドされたメソッドは、大きな混乱を招く可能性があります。これは多くの場合、どのオーバーロードが呼び出されるのかが不明確であるためです。\n\n**例:**\n\n\n        public void execute(Runnable... r) {} // 警告\n        public void execute(Runnable r1, Runnable r2) {}\n\n\n明らかに互換性のないパラメーターの型を持つオーバーロードされたメソッドを無視するには、オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverloadedVarargsMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名規則/メソッド",
                      "index": 84,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousInnerClassMayBeStatic",
                "shortDescription": {
                  "text": "名前付きの 'static' 内部クラスできる匿名クラス"
                },
                "fullDescription": {
                  "text": "'static' 内部クラスに安全に置換できる匿名クラスを報告します。 匿名クラスは外側のインスタンスか、それを囲むメソッドのローカル変数を明示的に参照していない場合に 'static' 内部クラスにできます。 'static' の内部クラスは、外部インスタンスへの暗黙的な参照を維持しません。 これにより、一般的なメモリリークの原因を防ぎ、クラスインスタンスごとのメモリ消費量を削減しています。 Java 18 以降はこの参照が使用されていない場合、シリアル化可能な匿名クラスのみが外部インスタンスへの暗黙的な参照を保持します。 そのため、モジュールの言語レベルが Java 18 以降の場合、 このインスペクションはシリアル化可能なクラスのみを報告します。 クイックフィックスを使用すると、匿名クラスが名前付き 'static' 内部クラスに抽出されます。 例: 'void sample() {\n    Thread thread = new Thread(new Runnable() {\n      @Override\n      public void run() {\n      }\n    });\n  }' クイックフィックス適用後: 'void sample() {\n    Thread thread = new Thread(new Task());\n  }\n\n  private static class Task implements Runnable {\n    @Override\n    public void run() {\n    }\n  }'",
                  "markdown": "`static` 内部クラスに安全に置換できる匿名クラスを報告します。 匿名クラスは外側のインスタンスか、それを囲むメソッドのローカル変数を明示的に参照していない場合に `static` 内部クラスにできます。\n\n\n`static` の内部クラスは、外部インスタンスへの暗黙的な参照を維持しません。\nこれにより、一般的なメモリリークの原因を防ぎ、クラスインスタンスごとのメモリ消費量を削減しています。\n\n\nJava 18 以降はこの参照が使用されていない場合、シリアル化可能な匿名クラスのみが外部インスタンスへの暗黙的な参照を保持します。 そのため、モジュールの言語レベルが Java 18 以降の場合、\nこのインスペクションはシリアル化可能なクラスのみを報告します。\n\nクイックフィックスを使用すると、匿名クラスが名前付き `static` 内部クラスに抽出されます。\n\n**例:**\n\n\n      void sample() {\n        Thread thread = new Thread(new Runnable() {\n          @Override\n          public void run() {\n          }\n        });\n      }\n\nクイックフィックス適用後:\n\n\n      void sample() {\n        Thread thread = new Thread(new Task());\n      }\n\n      private static class Task implements Runnable {\n        @Override\n        public void run() {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnonymousInnerClassMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メモリ",
                      "index": 70,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedIsStillUsed",
                "shortDescription": {
                  "text": "非推奨メンバーの使用"
                },
                "fullDescription": {
                  "text": "非推奨にもかかわらず、コードに使用されているクラス、メソッド、フィールドを報告します。 例: 'class MyCode {\n    @Deprecated\n    void oldMethod() {}// 警告: \"非推奨メンバーの使用\"\n\n    void newMethod() {\n      oldMethod(); // 忘れられている使用箇所\n    }\n  }' 非推奨要素内の使用箇所は無視されます。 注意: パフォーマンス上の理由により、非 private メンバーは、その名前がプロジェクトでほぼ使用されていない場合に限ってチェックされます。",
                  "markdown": "非推奨にもかかわらず、コードに使用されているクラス、メソッド、フィールドを報告します。\n\n例:\n\n\n      class MyCode {\n        @Deprecated\n        void oldMethod() {}// 警告: \"非推奨メンバーの使用\"\n\n        void newMethod() {\n          oldMethod(); // 忘れられている使用箇所\n        }\n      }\n\n非推奨要素内の使用箇所は無視されます。\n\n**注意:** パフォーマンス上の理由により、非 private メンバーは、その名前がプロジェクトでほぼ使用されていない場合に限ってチェックされます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeprecatedIsStillUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コード成熟度",
                      "index": 50,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicConstructor",
                "shortDescription": {
                  "text": "'public' コンストラクターはファクトリメソッドに置換できます"
                },
                "fullDescription": {
                  "text": "'public' コンストラクターを報告します。 一部のコーディング標準は 'public' コンストラクターの使用を推奨しておらず、代わりに 'static' ファクトリメソッドを推奨しています。 static ファクトリメソッドを使用すると、呼び出しサイトに影響を与えずに実装を入れ替えることができます。 例: 'class Test {\n    private String name;\n\n    public Test(String name) {\n        this.name = name;\n    }\n\n    public void test() {\n        System.out.println(name);\n    }\n\n    public static void main(String[] args) {\n        new Test(\"str\").test();\n    }\n  }' クイックフィックス適用後: 'class Test {\n    private String name;\n\n    private Test(String name) {\n        this.name = name;\n    }\n\n    public static Test getInstance(String name) {\n        return new Test(name);\n    }\n\n    public void test() {\n        System.out.println(name);\n    }\n\n    public static void main(String[] args) {\n        getInstance(\"str\").test();\n    }\n  }'",
                  "markdown": "`public` コンストラクターを報告します。\n\n一部のコーディング標準は `public` コンストラクターの使用を推奨しておらず、代わりに `static` ファクトリメソッドを推奨しています。\nstatic ファクトリメソッドを使用すると、呼び出しサイトに影響を与えずに実装を入れ替えることができます。\n\n**例:**\n\n\n      class Test {\n        private String name;\n\n        public Test(String name) {\n            this.name = name;\n        }\n\n        public void test() {\n            System.out.println(name);\n        }\n\n        public static void main(String[] args) {\n            new Test(\"str\").test();\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      class Test {\n        private String name;\n\n        private Test(String name) {\n            this.name = name;\n        }\n\n        public static Test getInstance(String name) {\n            return new Test(name);\n        }\n\n        public void test() {\n            System.out.println(name);\n        }\n\n        public static void main(String[] args) {\n            getInstance(\"str\").test();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantEmbeddedExpression",
                "shortDescription": {
                  "text": "文字列テンプレート内の冗長な埋め込み式"
                },
                "fullDescription": {
                  "text": "'STR' テンプレートにある冗長な埋め込み式 (自明なリテラルや空の式など) を報告します。 例: 'System.out.println(STR.\"Hello \\{\"world\"}\");' クイックフィックス適用後: 'System.out.println(STR.\"Hello world\");' 2023.3 の新機能です このインスペクションは Java 21-preview 以降で使用できる Java の機能 '文字列テンプレート' に依存しています。",
                  "markdown": "`STR` テンプレートにある冗長な埋め込み式 (自明なリテラルや空の式など) を報告します。\n\n例:\n\n\n      System.out.println(STR.\"Hello \\{\"world\"}\");\n\nクイックフィックス適用後:\n\n\n      System.out.println(STR.\"Hello world\");\n\n2023.3 の新機能です\n\nこのインスペクションは Java 21-preview 以降で使用できる Java の機能 '文字列テンプレート' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantEmbeddedExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantComparatorComparing",
                "shortDescription": {
                  "text": "コンパレーターメソッドは単純化できます"
                },
                "fullDescription": {
                  "text": "'Comparator' を組み合わせたコンストラクトで、単純化できるものを報告します。 例: 'c.thenComparing(Comparator.comparing(function));\n\n  Comparator.comparing(Map.Entry::getKey);\n\n  Collections.max(list, Comparator.reverseOrder());' クイックフィックス適用後: 'c.thenComparing(function)\n\n  Map.Entry.comparingByKey()\n\n  Collections.min(list, Comparator.naturalOrder());' 2018.1 の新機能です",
                  "markdown": "`Comparator` を組み合わせたコンストラクトで、単純化できるものを報告します。\n\n例:\n\n\n      c.thenComparing(Comparator.comparing(function));\n\n      Comparator.comparing(Map.Entry::getKey);\n\n      Collections.max(list, Comparator.reverseOrder());\n\nクイックフィックス適用後:\n\n\n      c.thenComparing(function)\n\n      Map.Entry.comparingByKey()\n\n      Collections.min(list, Comparator.naturalOrder());\n\n2018.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantComparatorComparing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementWithTooFewBranches",
                "shortDescription": {
                  "text": "最小の 'switch' 分岐"
                },
                "fullDescription": {
                  "text": "'case' ラベルの数が少なすぎる 'switch' ステートメントと式を報告し、それらを 'if' および 'else if' ステートメントに書き換えることを提案します。 例 (最小分岐数 == 3): 'switch (expression) {\n    case \"foo\" -> foo();\n    case \"bar\" -> bar();\n  }' クイックフィックス適用後: 'if (\"foo\".equals(expression)) {\n    foo();\n  } else if (\"bar\".equals(expression)) {\n    bar();\n  }' 'default' 分岐のない完全な switch 式 (Java 14 以降) またはパターン switch ステートメント (Java 17 プレビュー) は報告されません。 これは、'switch' が 'if' に変換される場合にコンパイル時の完全性確認が失われ、それが望ましくない場合があるためです。 インスペクションの構成: 最小限必要な 'case' ラベルの数を指定するには、「最小分岐数」フィールドを使用します。 パターン分岐がある switch ステートメントと式を報告をしないようにするには、「パターンの switch ステートメントを報告しない」オプションを使用します。 例: 'String result = switch(obj) {\n    case String str -> str.trim();\n    default -> \"none\";\n  };' 'instanceof' ステートメントを使用するよりも、単一のパターン分岐を持つ switch を保持するほうが望ましい場合があります。",
                  "markdown": "`case` ラベルの数が少なすぎる `switch` ステートメントと式を報告し、それらを `if` および `else if` ステートメントに書き換えることを提案します。\n\n例 (最小分岐数 == 3):\n\n\n      switch (expression) {\n        case \"foo\" -> foo();\n        case \"bar\" -> bar();\n      }\n\nクイックフィックス適用後:\n\n\n      if (\"foo\".equals(expression)) {\n        foo();\n      } else if (\"bar\".equals(expression)) {\n        bar();\n      }\n\n'default' 分岐のない完全な switch 式 (Java 14 以降) またはパターン switch ステートメント (Java 17 プレビュー) は報告されません。\nこれは、`switch` が `if` に変換される場合にコンパイル時の完全性確認が失われ、それが望ましくない場合があるためです。\n\nインスペクションの構成:\n\n最小限必要な `case` ラベルの数を指定するには、「**最小分岐数**」フィールドを使用します。\n\nパターン分岐がある switch ステートメントと式を報告をしないようにするには、「**パターンの switch ステートメントを報告しない**」オプションを使用します。 例:\n\n\n      String result = switch(obj) {\n        case String str -> str.trim();\n        default -> \"none\";\n      };\n\n`instanceof` ステートメントを使用するよりも、単一のパターン分岐を持つ switch を保持するほうが望ましい場合があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SwitchStatementWithTooFewBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VariableNotUsedInsideIf",
                "shortDescription": {
                  "text": "'if' の中で使用されていない 'null' チェック済みの参照"
                },
                "fullDescription": {
                  "text": "'if' ステートメントまたは条件式の条件で null 許容性がチェックされているものの、その 'if' ステートメント内では使用されていない変数への参照を報告します。 これは多くの場合、チェックが不要であるか、ミスによって変数が 'if' ステートメント内で参照されていないことを意味します。 例: 'void test(Integer i) {\n    if (i != null) { // この 'i' は 'if' ステートメント内では使用されていません\n      System.out.println();\n    }\n  }'",
                  "markdown": "`if` ステートメントまたは条件式の条件で null 許容性がチェックされているものの、その `if` ステートメント内では使用されていない変数への参照を報告します。\n\n\nこれは多くの場合、チェックが不要であるか、ミスによって変数が `if` ステートメント内で参照されていないことを意味します。\n\n**例:**\n\n\n      void test(Integer i) {\n        if (i != null) { // この 'i' は 'if' ステートメント内では使用されていません\n          System.out.println();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VariableNotUsedInsideIf",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UsagesOfObsoleteApi",
                "shortDescription": {
                  "text": "ApiStatus.@Obsolete の使用箇所"
                },
                "fullDescription": {
                  "text": "'@ApiStatus.Obsolete' アノテーションが付いた宣言 (クラス、メソッド、フィールド) を報告します。 現在の API が正しく機能しない可能性がある、より新しい、より優れている、またはより一般的な API があるのに、削除できない場合があります。 これは '@Deprecated' アノテーションのより弱いバリアントです。 アノテーション付きの API を新しいコードで使用することは想定されていませんが、既存コードの移行を延期することは許められているため、その使用箇所は警告とは見なされません。",
                  "markdown": "`@ApiStatus.Obsolete` アノテーションが付いた宣言 (クラス、メソッド、フィールド) を報告します。\n\n\n現在の API が正しく機能しない可能性がある、より新しい、より優れている、またはより一般的な API があるのに、削除できない場合があります。\nこれは `@Deprecated` アノテーションのより弱いバリアントです。\nアノテーション付きの API を新しいコードで使用することは想定されていませんが、既存コードの移行を延期することは許められているため、その使用箇所は警告とは見なされません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UsagesOfObsoleteApi",
                    "ideaSeverity": "TEXT ATTRIBUTES",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 言語",
                      "index": 4,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CollectionAddAllCanBeReplacedWithConstructor",
                "shortDescription": {
                  "text": "冗長な 'Collection.addAll()' の呼び出し"
                },
                "fullDescription": {
                  "text": "引数のないコンストラクターを使用しているコレクションをインスタンス化した直後に呼び出されている 'Collection.addAll()' と 'Map.putAll()' を報告します。 このようなコンストラクトは、単一のパラメーター化したコンストラクターの呼び出しに置換できます。その結果、コードが単純化されます。 また、コレクションによっては、置換したほうがパフォーマンスが良くなる場合があります。 例: 'Set<String> set = new HashSet<>();\n  set.addAll(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));' クイックフィックス適用後: 'Set<String> set = new HashSet<>(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));' JDK のコレクションクラスはデフォルトでサポートされています。 さらに、「チェックするクラス」パネルを使用してその他のクラスを指定できます。",
                  "markdown": "引数のないコンストラクターを使用しているコレクションをインスタンス化した直後に呼び出されている `Collection.addAll()` と `Map.putAll()` を報告します。\n\nこのようなコンストラクトは、単一のパラメーター化したコンストラクターの呼び出しに置換できます。その結果、コードが単純化されます。 また、コレクションによっては、置換したほうがパフォーマンスが良くなる場合があります。\n\n**例:**\n\n\n      Set<String> set = new HashSet<>();\n      set.addAll(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));\n\nクイックフィックス適用後:\n\n\n      Set<String> set = new HashSet<>(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));\n\n\nJDK のコレクションクラスはデフォルトでサポートされています。\nさらに、「**チェックするクラス**」パネルを使用してその他のクラスを指定できます。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionAddAllCanBeReplacedWithConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/パフォーマンス",
                      "index": 10,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultipleReturnPointsPerMethod",
                "shortDescription": {
                  "text": "複数の return を持つメソッド"
                },
                "fullDescription": {
                  "text": "'return' ポイントの数が指定された最大値を超えているメソッドを報告します。 'return' ポイントが多すぎるメソッドは混乱を招き、リファクタリングしにくい可能性があります。 'return' ポイントとは、'return' ステートメントか、'void' メソッドまたはコンストラクターの最下部に到達することを指します。 例: 2 つの 'return' ステートメントのみが許可されている場合、以下のメソッドは報告の対象になります。 'void doSmth(User[] users) {\n    for (User user : users) {\n      if (cond1(user)) {\n        user.setId(getId());\n        return;\n      } else if (cond2(user)) {\n        if (cond3(user)) {\n          user.setId(getId());\n          return;\n        }\n      }\n    }\n  }' このメソッドを書き直し、より分かりやすくすることを検討してください。 'void doSmth(User[] users) {\n    for (User user : users) {\n      if (cond1(user) || cond2(user) && cond3(user)) {\n        user.setId(getId());\n        return;\n      }\n    }\n  }' インスペクションの構成: メソッドで許容される 'return' ポイント数の最大値を指定するには、「return ポイントの制限」フィールドを使用します。 ガード節を無視するには、「ガード節を無視する」オプションを使用します。 ガード節は、'return' ステートメントのみを含む 'if' ステートメントのことです。 'equals()' メソッド内の 'return' ポイントを無視するには、「'equals()' メソッドを無視」オプションを使用します。",
                  "markdown": "`return` ポイントの数が指定された最大値を超えているメソッドを報告します。 `return` ポイントが多すぎるメソッドは混乱を招き、リファクタリングしにくい可能性があります。\n\n`return` ポイントとは、`return` ステートメントか、`void` メソッドまたはコンストラクターの最下部に到達することを指します。\n\n**例:**\n\n2 つの `return` ステートメントのみが許可されている場合、以下のメソッドは報告の対象になります。\n\n\n      void doSmth(User[] users) {\n        for (User user : users) {\n          if (cond1(user)) {\n            user.setId(getId());\n            return;\n          } else if (cond2(user)) {\n            if (cond3(user)) {\n              user.setId(getId());\n              return;\n            }\n          }\n        }\n      }\n\nこのメソッドを書き直し、より分かりやすくすることを検討してください。\n\n\n      void doSmth(User[] users) {\n        for (User user : users) {\n          if (cond1(user) || cond2(user) && cond3(user)) {\n            user.setId(getId());\n            return;\n          }\n        }\n      }\n\nインスペクションの構成:\n\n* メソッドで許容される `return` ポイント数の最大値を指定するには、「**return ポイントの制限**」フィールドを使用します。\n* ガード節を無視するには、「**ガード節を無視する** 」オプションを使用します。 ガード節は、`return` ステートメントのみを含む `if` ステートメントのことです。\n* `equals()` メソッド内の `return` ポイントを無視するには、「**'equals()' メソッドを無視**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithMultipleReturnPoints",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/メソッドメトリクス",
                      "index": 94,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousMethodCalls",
                "shortDescription": {
                  "text": "疑わしいコレクションメソッドの呼び出し"
                },
                "fullDescription": {
                  "text": "パラメーター化されたコレクションのメソッド呼び出しで、実際の引数の型がコレクション要素の型に対応していないものを報告します。 例: 'List<Integer> list = getListOfElements();\n  list.remove(\"\"); // remove はハイライトされます' インスペクションの設定では、次のように正しい可能性のあるコードに関する警告を無効にできます。 'public boolean accept(Map<Integer, String> map, Object key) {\n    return map.containsKey(key);\n  }'",
                  "markdown": "パラメーター化されたコレクションのメソッド呼び出しで、実際の引数の型がコレクション要素の型に対応していないものを報告します。\n\n**例:**\n\n\n      List<Integer> list = getListOfElements();\n      list.remove(\"\"); // remove はハイライトされます\n\n\nインスペクションの設定では、次のように正しい可能性のあるコードに関する警告を無効にできます。\n\n\n      public boolean accept(Map<Integer, String> map, Object key) {\n        return map.containsKey(key);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousMethodCalls",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/潜在的なバグ",
                      "index": 13,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantDeclaredInInterface",
                "shortDescription": {
                  "text": "インターフェースで宣言された定数"
                },
                "fullDescription": {
                  "text": "インターフェースで宣言されている定数 ('public static final' フィールド) を報告します。 一部のコーディング標準は、代わりに抽象クラスで定数を宣言することを要求しています。",
                  "markdown": "インターフェースで宣言されている定数 (`public static final` フィールド) を報告します。\n\n一部のコーディング標準は、代わりに抽象クラスで定数を宣言することを要求しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantDeclaredInInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラス構造",
                      "index": 12,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForwardCompatibility",
                "shortDescription": {
                  "text": "前方互換性"
                },
                "fullDescription": {
                  "text": "今後の Java バージョンでコンパイルに失敗する可能性がある Java コードコンストラクトを報告します。 次の問題が報告されます。 'assert'、'enum'、または '_' を識別子として使用している 'var'、'yield'、'record' 制限付き識別子を型名として使用している 'yield' という名前のメソッドを修飾子なしで呼び出している 'module-info.java' 内の 'requires java.base' ステートメントに修飾子がある import ステートメント間に冗長なセミコロンがある 例: '// このクラスは以前は有効でしたが、'yield' が制限付き識別子になったため、\n// Java 14 との互換性がありません。\n  public class yield {}' 上記の問題を適時に修正することで、今後の Java バージョンへの移行が単純化される可能性があります。",
                  "markdown": "今後の Java バージョンでコンパイルに失敗する可能性がある Java コードコンストラクトを報告します。\n\n次の問題が報告されます。\n\n* `assert`、`enum`、または `_` を識別子として使用している\n* `var`、`yield`、`record` 制限付き識別子を型名として使用している\n* `yield` という名前のメソッドを修飾子なしで呼び出している\n* `module-info.java` 内の `requires java.base` ステートメントに修飾子がある\n* import ステートメント間に冗長なセミコロンがある\n\n**例:**\n\n\n      // このクラスは以前は有効でしたが、'yield' が制限付き識別子になったため、\n    // Java 14 との互換性がありません。\n      public class yield {} \n\n上記の問題を適時に修正することで、今後の Java バージョンへの移行が単純化される可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForwardCompatibility",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java の言語レベル関連の問題",
                      "index": 61,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DiamondCanBeReplacedWithExplicitTypeArguments",
                "shortDescription": {
                  "text": "ダイヤモンド演算子は明示的な型引数で置換可能です"
                },
                "fullDescription": {
                  "text": "ジェネリッククラスのインスタンス化で、型パラメーターではなく <> 記号 (ダイヤモンド) が使用されていることを報告します。 クイックフィックスを使用すると、<> (ダイヤモンド) が明示的な型パラメーターに置換されます。 例: 'List <String> list = new ArrayList<>()' クイックフィックス適用後: 'List <String> list = new ArrayList<String>()' ダイヤモンド演算子は Java 7 で登場しました。 このインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。",
                  "markdown": "ジェネリッククラスのインスタンス化で、型パラメーターではなく **\\<\\>** 記号 (ダイヤモンド) が使用されていることを報告します。\n\nクイックフィックスを使用すると、**\\<\\>** (ダイヤモンド) が明示的な型パラメーターに置換されます。\n\n例:\n\n    List <String> list = new ArrayList<>()\n\nクイックフィックス適用後:\n\n    List <String> list = new ArrayList<String>()\n\n\n*ダイヤモンド演算子*は Java 7 で登場しました。\nこのインスペクションは、旧バージョンの Java との下位互換性を確保するためにダウングレードするのに役立ちます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DiamondCanBeReplacedWithExplicitTypeArguments",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/コードスタイル問題",
                      "index": 11,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfProcessBuilder",
                "shortDescription": {
                  "text": "'java.lang.ProcessBuilder' クラスの使用"
                },
                "fullDescription": {
                  "text": "オペレーティングシステム間で移植不可能だと思われる 'java.lang.ProcessBuilder' が使用されていることを報告します。なぜなら、実行可能ファイルのパス、環境変数、コマンドライン引数とそのエスケープ処理は OS によって異なる場合があるからです。",
                  "markdown": "オペレーティングシステム間で移植不可能だと思われる `java.lang.ProcessBuilder` が使用されていることを報告します。なぜなら、実行可能ファイルのパス、環境変数、コマンドライン引数とそのエスケープ処理は OS によって異なる場合があるからです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfProcessBuilder",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ポータビリティ",
                      "index": 7,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaRequiresAutoModule",
                "shortDescription": {
                  "text": "自動モジュールへの依存"
                },
                "fullDescription": {
                  "text": "'requires' ディレクティブで自動モジュールが使用されていることを報告します。 自動モジュールはクラスパスの型に依存する可能性があるため信頼性が低く、明示的なモジュールに変換された場合にその名前とエクスポートされたパッケージが変わる可能性があります。 Javac の '-Xlint:requires-automatic' および '-Xlint:requires-transitive-automatic' オプションに対応しています。 最初のオプションは自動モジュールが使用されていることを注意喚起するものです。 2 つ目のオプションは自動モジュールに対する暗黙の可読性を確立することで、モジュールの作成者に該当モジュールのユーザーを危険にさらしていることを警告するものです。 例: '//module-info.java\n  module org.printer {\n    requires transitive drivers.corp.org; // 'drivers.corp.org' が自動モジュールの場合に報告されます\n  }' 推移的な依存関係についてのみ警告するには、「推移的な依存関係のみをハイライトする」オプションを使用します。 このインスペクションは Java 9 以降で使用できる Java の機能 'モジュール' に依存しています。",
                  "markdown": "`requires` ディレクティブで自動モジュールが使用されていることを報告します。\n\n自動モジュールはクラスパスの型に依存する可能性があるため信頼性が低く、明示的なモジュールに変換された場合にその名前とエクスポートされたパッケージが変わる可能性があります。\n\nJavac の `-Xlint:requires-automatic` および `-Xlint:requires-transitive-automatic` オプションに対応しています。\n最初のオプションは自動モジュールが使用されていることを注意喚起するものです。\n2 つ目のオプションは自動モジュールに対する暗黙の可読性を確立することで、モジュールの作成者に該当モジュールのユーザーを危険にさらしていることを警告するものです。\n\n**例:**\n\n\n      //module-info.java\n      module org.printer {\n        requires transitive drivers.corp.org; // 'drivers.corp.org' が自動モジュールの場合に報告されます\n      }\n\n\n推移的な依存関係についてのみ警告するには、「**推移的な依存関係のみをハイライトする**」オプションを使用します。\n\nこのインスペクションは Java 9 以降で使用できる Java の機能 'モジュール' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "requires-transitive-automatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 9",
                      "index": 76,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExcessiveRangeCheck",
                "shortDescription": {
                  "text": "過剰な範囲チェック"
                },
                "fullDescription": {
                  "text": "値の範囲がチェックされており、かつ単一のチェックに単純化できる連鎖した条件を報告します。 クイックフィックスを使用すると、連鎖した条件が単純な式に置換されます。 例: 'x > 2 && x < 4' クイックフィックス適用後: 'x == 3' 例: 'arr.length == 0 || arr.length > 1' クイックフィックス適用後: 'arr.length != 1' 2019.1 の新機能です",
                  "markdown": "値の範囲がチェックされており、かつ単一のチェックに単純化できる連鎖した条件を報告します。\n\nクイックフィックスを使用すると、連鎖した条件が単純な式に置換されます。\n\n例:\n\n\n      x > 2 && x < 4\n\nクイックフィックス適用後:\n\n\n      x == 3\n\n例:\n\n\n      arr.length == 0 || arr.length > 1\n\nクイックフィックス適用後:\n\n\n      arr.length != 1\n\n2019.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExcessiveRangeCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticImport",
                "shortDescription": {
                  "text": "static インポート"
                },
                "fullDescription": {
                  "text": "'import static' ステートメントを報告します。 このような 'import' ステートメントは、Java 1.4 以前の JVM ではサポートされていません。 インスペクションの構成: 'import static' ステートメントで使用される時にインスペクションによって無視されるクラスを指定するには、以下のテーブルを使用します。 単一フィールドの 'import static' ステートメントを無視するには、「単一フィールドの static インポートを無視する」チェックボックスを使用します。 単一メソッドの 'import static' ステートメントを無視するには、「単一メソッドの static インポートを無視する」チェックボックスを使用します。",
                  "markdown": "`import static` ステートメントを報告します。\n\nこのような `import` ステートメントは、Java 1.4 以前の JVM ではサポートされていません。\n\nインスペクションの構成:\n\n* `import static` ステートメントで使用される時にインスペクションによって無視されるクラスを指定するには、以下のテーブルを使用します。\n* 単一フィールドの `import static` ステートメントを無視するには、「**単一フィールドの static インポートを無視する**」チェックボックスを使用します。\n* 単一メソッドの `import static` ステートメントを無視するには、「**単一メソッドの static インポートを無視する**」チェックボックスを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/インポート",
                      "index": 23,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceNullCheck",
                "shortDescription": {
                  "text": "メソッド呼び出しに置換可能な null チェック"
                },
                "fullDescription": {
                  "text": "'Objects' または 'Stream' からの static メソッド呼び出しに置換できる 'null' チェックを報告します。 例: 'if (message == null) {\n    application.messageStorage().save(new EmptyMessage());\n  } else {\n    application.messageStorage().save(message);\n  }' クイックフィックス適用後: 'application.messageStorage()\n    .save(Objects.requireNonNullElseGet(message, () -> new EmptyMessage()));' 置換後のコードが元のコードよりも長い場合を無視するには、「置換後のコードが元のコードよりも長い場合に警告しない」オプションを使用します。 2017.3 の新機能です",
                  "markdown": "`Objects` または `Stream` からの static メソッド呼び出しに置換できる `null` チェックを報告します。\n\n**例:**\n\n\n      if (message == null) {\n        application.messageStorage().save(new EmptyMessage());\n      } else {\n        application.messageStorage().save(message);\n      }\n\nクイックフィックス適用後:\n\n\n      application.messageStorage()\n        .save(Objects.requireNonNullElseGet(message, () -> new EmptyMessage()));\n\n\n置換後のコードが元のコードよりも長い場合を無視するには、「**置換後のコードが元のコードよりも長い場合に警告しない**」オプションを使用します。\n\n2017.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceNullCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 9",
                      "index": 76,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NoExplicitFinalizeCalls",
                "shortDescription": {
                  "text": "明示的に呼び出されている 'finalize()'"
                },
                "fullDescription": {
                  "text": "'Object.finalize()' の呼び出しを報告します。 'Object.finalize()' を明示的に呼び出すと、オブジェクトが不整合な状態になる可能性があります。 ガベージコレクターはあるオブジェクトへの参照が存在しないと判断すると、そのオブジェクトに対してこのメソッドを自動的に呼び出します。 'finalize()' の実装内からの 'super.finalize()' の呼び出しは無害であるため、このインスペクションでは報告されません。 例: 'MyObject m = new MyObject();\n  m.finalize();\n  System.gc()'",
                  "markdown": "`Object.finalize()` の呼び出しを報告します。\n\n`Object.finalize()` を明示的に呼び出すと、オブジェクトが不整合な状態になる可能性があります。\nガベージコレクターはあるオブジェクトへの参照が存在しないと判断すると、そのオブジェクトに対してこのメソッドを自動的に呼び出します。\n\n`finalize()` の実装内からの `super.finalize()` の呼び出しは無害であるため、このインスペクションでは報告されません。\n\n**例:**\n\n\n      MyObject m = new MyObject();\n      m.finalize();\n      System.gc()\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalizeCalledExplicitly",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/ファイナライズ",
                      "index": 63,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegatedIfElse",
                "shortDescription": {
                  "text": "否定条件を含む 'if' ステートメント"
                },
                "fullDescription": {
                  "text": "'else' 分岐を含み、条件が否定されている 'if' ステートメントを報告します。 通常、このようなステートメントは 'if' および 'else' 分岐の順序を反転させると明確さが増します。 現在の 'if' ステートメントを反転するクイックフィックスがあります。 例: 'void m(Object o1, Object o2) {\n        if (o1 != o2) {\n            System.out.println(1);\n        }\n        else {\n            System.out.println(2);\n        }\n    }' クイックフィックス適用後: 'void m(Object o1, Object o2) {\n        if (o1 == o2) {\n            System.out.println(2);\n        } else {\n            System.out.println(1);\n        }\n    }' '!= null' 形式の比較を無視するには、「'!= null' 比較を無視する」オプションを使用します。 '!= 0' 形式の比較を無視するには、「'!= 0' 比較を無視する」オプションを使用します。",
                  "markdown": "`else` 分岐を含み、条件が否定されている `if` ステートメントを報告します。\n\n通常、このようなステートメントは `if` および `else` 分岐の順序を反転させると明確さが増します。\n\n現在の `if` ステートメントを反転するクイックフィックスがあります。\n\n例:\n\n\n        void m(Object o1, Object o2) {\n            if (o1 != o2) {\n                System.out.println(1);\n            }\n            else {\n                System.out.println(2);\n            }\n        }\n\nクイックフィックス適用後:\n\n\n        void m(Object o1, Object o2) {\n            if (o1 == o2) {\n                System.out.println(2);\n            } else {\n                System.out.println(1);\n            }\n        }\n\n`!= null` 形式の比較を無視するには、「**'!= null' 比較を無視する**」オプションを使用します。\n\n`!= 0` 形式の比較を無視するには、「**'!= 0' 比較を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IfStatementWithNegatedCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/制御フロー問題",
                      "index": 28,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantJavaTimeOperations",
                "shortDescription": {
                  "text": "'java.time' オブジェクトの冗長な操作"
                },
                "fullDescription": {
                  "text": "冗長な 'java.time' オブジェクトに対する冗長な操作を報告します。 よりシンプルなメソッド呼び出しを使用できる、または作成を回避できる場合の、JDK 'java.time' パッケージからの日付/時刻オブジェクトの作成。　 より具体的なメソッドの呼び出しに置換できる場合の、'java.time.temporal.ChronoField' と 'java.time.temporal.ChronoUnit' を引数として持つ 'java.time' メソッドの呼び出し。 'isAfter()'、'isBefore()'、または 'isEqual()' の呼び出しに置換できる 'compareTo()' の呼び出しを使用した 'java.time' 比較。 例: - 前: 'LocalDateTime now = LocalDateTime.now();\nreturn LocalDateTime.from(now);' クイックフィックス適用後: 'LocalDateTime now = LocalDateTime.now();\nreturn now;' - 前: 'LocalTime localTime = LocalTime.now();\nint minute = localTime.get(ChronoField.MINUTE_OF_HOUR);' クイックフィックス適用後: 'LocalTime localTime = LocalTime.now();\nint minute = localTime.getMinute();' - 前: 'LocalDate date1 = LocalDate.now();\n  LocalDate date2 = LocalDate.now();\n  boolean t = date1.compareTo(date2) > 0;' クイックフィックス適用後: 'LocalDate date1 = LocalDate.now();\n  LocalDate date2 = LocalDate.now();\n  boolean t = date1.isAfter(date2);' 2024.3 の新機能です",
                  "markdown": "冗長な 'java.time' オブジェクトに対する冗長な操作を報告します。\n\n* よりシンプルなメソッド呼び出しを使用できる、または作成を回避できる場合の、JDK `java.time` パッケージからの日付/時刻オブジェクトの作成。　\n* より具体的なメソッドの呼び出しに置換できる場合の、`java.time.temporal.ChronoField` と `java.time.temporal.ChronoUnit` を引数として持つ `java.time` メソッドの呼び出し。\n* `isAfter()`、`isBefore()`、または `isEqual()` の呼び出しに置換できる `compareTo()` の呼び出しを使用した `java.time` 比較。\n\n例:\n- 前:\n\n\n    LocalDateTime now = LocalDateTime.now();\n    return LocalDateTime.from(now);\n\nクイックフィックス適用後:\n\n\n    LocalDateTime now = LocalDateTime.now();\n    return now;\n\n- 前:\n\n\n    LocalTime localTime = LocalTime.now();\n    int minute = localTime.get(ChronoField.MINUTE_OF_HOUR);\n\nクイックフィックス適用後:\n\n\n    LocalTime localTime = LocalTime.now();\n    int minute = localTime.getMinute();\n\n- 前:\n\n\n      LocalDate date1 = LocalDate.now();\n      LocalDate date2 = LocalDate.now();\n      boolean t = date1.compareTo(date2) > 0;\n\nクイックフィックス適用後:\n\n\n      LocalDate date1 = LocalDate.now();\n      LocalDate date2 = LocalDate.now();\n      boolean t = date1.isAfter(date2);\n\n2024.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantJavaTimeOperations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/冗長または不要なコード構成",
                      "index": 38,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldCount",
                "shortDescription": {
                  "text": "フィールドが多すぎるクラス"
                },
                "fullDescription": {
                  "text": "フィールド数が指定された最大値を超えているクラスを報告します。 大量のフィールドを含むクラスは多くの場合、実行しようとしている処理の数が多すぎます。 このようなクラスは、より小さな複数のクラスに分割することを検討してください。 インスペクションの構成: クラスで許容されるフィールド数の最大値を指定するには、「フィールド数の制限」フィールドを使用します。 定数フィールドをカウントするかどうかを指定するには、「定数フィールドをカウントに含める」オプションを使用します。 デフォルトでは、イミュータブルな 'static final' オブジェクトのみが定数としてカウントされます。 任意の 'static final' フィールドを定数としてカウントするには、「'static final' フィールドを定数としてカウントする」オプションを使用します。 'enum' クラス内の 'enum' 定数をカウントするかどうかを指定するには、「列挙型定数をカウントに含める」オプションを使用します。",
                  "markdown": "フィールド数が指定された最大値を超えているクラスを報告します。\n\n大量のフィールドを含むクラスは多くの場合、実行しようとしている処理の数が多すぎます。 このようなクラスは、より小さな複数のクラスに分割することを検討してください。\n\nインスペクションの構成:\n\n* クラスで許容されるフィールド数の最大値を指定するには、「**フィールド数の制限**」フィールドを使用します。\n* 定数フィールドをカウントするかどうかを指定するには、「**定数フィールドをカウントに含める**」オプションを使用します。\n* デフォルトでは、イミュータブルな `static final` オブジェクトのみが定数としてカウントされます。 任意の `static final` フィールドを定数としてカウントするには、「**'static final' フィールドを定数としてカウントする**」オプションを使用します。\n* `enum` クラス内の `enum` 定数をカウントするかどうかを指定するには、「**列挙型定数をカウントに含める**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyFields",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/クラスメトリクス",
                      "index": 83,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenation",
                "shortDescription": {
                  "text": "文字列連結"
                },
                "fullDescription": {
                  "text": "'String' の連結を報告します。 連結は国際化環境では正しくない可能性があり、'java.text.MessageFormat' または同様のクラスを使用するように置換できます。 例: 'String getMessage(String string, int number) {\n    return string + number;\n  }'",
                  "markdown": "`String` の連結を報告します。 連結は国際化環境では正しくない可能性があり、`java.text.MessageFormat` または同様のクラスを使用するように置換できます。\n\n**例:**\n\n\n      String getMessage(String string, int number) {\n        return string + number;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassCanBeRecord",
                "shortDescription": {
                  "text": "クラスはレコードクラスにできます"
                },
                "fullDescription": {
                  "text": "レコードクラスに変換できるクラスを報告します。 レコードクラスは拡張可能な動作ではなく、不変データのモデル化に焦点を当てています。 'equals()' やアクセサーなどのデータ駆動型メソッドを自動的かつ暗黙的に実装すれば、ボイラープレートコードを減らすことができます。 ただし、すべてのクラスをレコードクラスに置換できるわけではないことには注意してください。 以下に制限事項の一部を掲載しています。 クラスにサブクラスを含むことはできない。 クラス内の非 static フィールドはすべて final でなければならない。 イニシャライザー、ジェネリックコンストラクター、ネイティブメソッドがあってはならない。 レコードクラスの詳細な説明については、「Java 言語仕様」を参照してください。 例: 'class Point {\n    private final double x;\n    private final double y;\n\n    Point(double x, double y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    double getX() {\n      return x;\n    }\n\n    double getY() {\n      return y;\n    }\n  }' クイックフィックス適用後: 'record Point(int x, int y) {\n  }' 「アクセサーメソッドの名前変更を提案する」オプションを有効にすると、 'getX()' / 'isX()' アクセサーの名前が自動的に 'x()' へ変更されます。 「メンバーのアクセス性が向上する場合」オプションを使用すると、変換によってメンバーのアクセス性が向上する場合の動作を指定できます。 メンバーのアクセス性が向上する場合に変換しないようにするには、「変換を提案しない」オプションを選択します。 影響を受けたメンバーを表示して続行するかどうかを確認するには、「競合ビューを表示する」オプションを選択します。 バッチモードでは変換は提案されません。 必要に応じて確認なしでアクセス性を向上させるには、「確認なしで変換する」オプションを選択します。 指定のパターンに一致するアノテーションがある場合にクラスを変換対象外にするには、「クラスに次のアノテーションがある場合は変換を抑止する」リストを使用してください。 2020.3 の新機能です このインスペクションは Java 16 以降で使用できる Java の機能 'レコード' に依存しています。",
                  "markdown": "レコードクラスに変換できるクラスを報告します。\n\nレコードクラスは拡張可能な動作ではなく、不変データのモデル化に焦点を当てています。\n`equals()` やアクセサーなどのデータ駆動型メソッドを自動的かつ暗黙的に実装すれば、ボイラープレートコードを減らすことができます。\n\n\nただし、すべてのクラスをレコードクラスに置換できるわけではないことには注意してください。 以下に制限事項の一部を掲載しています。\n\n* クラスにサブクラスを含むことはできない。\n* クラス内の非 static フィールドはすべて final でなければならない。\n* イニシャライザー、ジェネリックコンストラクター、ネイティブメソッドがあってはならない。\n\nレコードクラスの詳細な説明については、「[Java 言語仕様](https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.10)」を参照してください。\n\n例:\n\n\n      class Point {\n        private final double x;\n        private final double y;\n\n        Point(double x, double y) {\n          this.x = x;\n          this.y = y;\n        }\n\n        double getX() {\n          return x;\n        }\n\n        double getY() {\n          return y;\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      record Point(int x, int y) {\n      }\n\n「**アクセサーメソッドの名前変更を提案する** 」オプションを有効にすると、 `getX()` / `isX()` アクセサーの名前が自動的に `x()` へ変更されます。\n\n\n「**メンバーのアクセス性が向上する場合**」オプションを使用すると、変換によってメンバーのアクセス性が向上する場合の動作を指定できます。\n\n* メンバーのアクセス性が向上する場合に変換しないようにするには、「**変換を提案しない**」オプションを選択します。\n* 影響を受けたメンバーを表示して続行するかどうかを確認するには、「**競合ビューを表示する**」オプションを選択します。 バッチモードでは変換は提案されません。\n* 必要に応じて確認なしでアクセス性を向上させるには、「**確認なしで変換する**」オプションを選択します。\n\n指定のパターンに一致するアノテーションがある場合にクラスを変換対象外にするには、「**クラスに次のアノテーションがある場合は変換を抑止する**」リストを使用してください。\n\n2020.3 の新機能です\n\nこのインスペクションは Java 16 以降で使用できる Java の機能 'レコード' に依存しています。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ClassCanBeRecord",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 言語レベルの移行支援/Java 16",
                      "index": 113,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantAssertArgument",
                "shortDescription": {
                  "text": "定数のアサート引数"
                },
                "fullDescription": {
                  "text": "'assertTrue()'、'assertFalse()'、'assertNull()'、'assertNotNull()' の呼び出しで使用されている定数の引数を報告します。 このような定数の引数を使用したメソッドの呼び出しは、常に成功するか失敗するかのどちらかです。 このようなステートメントはリファクタリング後に残りやすく、意図されたものではないと思われます。 例: 'assertNotNull(\"foo\");'",
                  "markdown": "`assertTrue()`、`assertFalse()`、`assertNull()`、`assertNotNull()` の呼び出しで使用されている定数の引数を報告します。\n\n\nこのような定数の引数を使用したメソッドの呼び出しは、常に成功するか失敗するかのどちらかです。\nこのようなステートメントはリファクタリング後に残りやすく、意図されたものではないと思われます。\n\n**例:**\n\n\n      assertNotNull(\"foo\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantAssertArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/テストフレームワーク",
                      "index": 96,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.jetbrains.sh",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "ShellCheck",
                "shortDescription": {
                  "text": "ShellCheck"
                },
                "fullDescription": {
                  "text": "組み込みの ShellCheck 静的解析ツールが検出したシェルスクリプトのバグを報告します。",
                  "markdown": "組み込みの [ShellCheck](https://github.com/koalaman/shellcheck) 静的解析ツールが検出したシェルスクリプトのバグを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ShellCheck",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Security"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "シェルスクリプト",
                      "index": 17,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.intellij.groovy",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "GroovyListSetCanBeKeyedAccess",
                "shortDescription": {
                  "text": "キーアクセスが可能な List.set 呼び出し"
                },
                "fullDescription": {
                  "text": "'java.util.List.set()' メソッドの呼び出しを報告します。 そのような呼び出しは、より短く明確なキーでアクセスされる形式に置換できます。 例: 'def list = [\"foo\"]\nlist.set(0, \"bar\") // list.set(0, \"bar\") は list[0] = \"bar\" に置換できます'\n クイックフィックス適用後: 'def list = [\"foo\"]\nlist[0] = \"bar\"'",
                  "markdown": "`java.util.List.set()` メソッドの呼び出しを報告します。 そのような呼び出しは、より短く明確なキーでアクセスされる形式に置換できます。\n\n**例:**\n\n\n    def list = [\"foo\"]\n    list.set(0, \"bar\") // list.set(0, \"bar\") は list[0] = \"bar\" に置換できます\n\nクイックフィックス適用後:\n\n\n    def list = [\"foo\"]\n    list[0] = \"bar\"\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyListSetCanBeKeyedAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/GPath",
                      "index": 22,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConstantNamingConvention",
                "shortDescription": {
                  "text": "定数の命名規則"
                },
                "fullDescription": {
                  "text": "指定した規則と一致しない名前を持つ定数を報告します。 定数は、'static' および 'final' 修飾子付きで宣言されたイミュータブルな型のフィールドです。 名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていない定数を報告します。 インスペクションの構成: 定数名と一致させたい 'java.util.regex.Pattern' を特定するには、「パターン」フィールドを使用します。 定数名の最小の長さを指定するには、「最小長」フィールドを使用します。 定数名の最大の長さを指定するには、「最大長」フィールドを使用します。",
                  "markdown": "指定した規則と一致しない名前を持つ定数を報告します。\n\n定数は、`static` および `final` 修飾子付きで宣言されたイミュータブルな型のフィールドです。\n名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていない定数を報告します。\n\nインスペクションの構成:\n\n* 定数名と一致させたい `java.util.regex.Pattern` を特定するには、「**パターン**」フィールドを使用します。\n* 定数名の最小の長さを指定するには、「**最小長**」フィールドを使用します。\n* 定数名の最大の長さを指定するには、「**最大長**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyConstantNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名規則",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyThreadStopSuspendResume",
                "shortDescription": {
                  "text": "Thread.stop()、Thread.suspend()、または Thread.resume() の呼び出し"
                },
                "fullDescription": {
                  "text": "'Thread.stop()'、'Thread.suspend()'、または 'Thread.resume()' の呼び出しを報告します。 これらの呼び出しは本質的にデータの破損やデッドロックを誘発しやすいため、使用しないことを強くお勧めします。",
                  "markdown": "`Thread.stop()`、`Thread.suspend()`、または `Thread.resume()` の呼び出しを報告します。\n\n\nこれらの呼び出しは本質的にデータの破損やデッドロックを誘発しやすいため、使用しないことを強くお勧めします。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyThreadStopSuspendResume",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Security"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyContinueOrBreakFromFinallyBlock",
                "shortDescription": {
                  "text": "'finally' ブロック内の 'continue' または 'break'"
                },
                "fullDescription": {
                  "text": "'finally' ブロック内の 'break' と 'continue' ステートメントを報告します。 このようなステートメントは意図的な場合もありますが、大きな混乱を招く可能性があり、例外のスローをマスクしてデバッグを途方もなく困難にする可能性があります。",
                  "markdown": "`finally` ブロック内の `break` と `continue` ステートメントを報告します。\n\nこのようなステートメントは意図的な場合もありますが、大きな混乱を招く可能性があり、例外のスローをマスクしてデバッグを途方もなく困難にする可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyContinueOrBreakFromFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/エラー処理",
                      "index": 42,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyInArgumentCheck",
                "shortDescription": {
                  "text": "互換性のない 'in' 引数の型"
                },
                "fullDescription": {
                  "text": "互換性のない型の項目とコンテナーを使用しているメンバーシップ演算子 'in' の使用箇所を報告します。 例: 'def list = [1, 2]\nif (\"foo\" in list) {} // 整数のリストに文字列を含めることはできません'",
                  "markdown": "互換性のない型の項目とコンテナーを使用しているメンバーシップ演算子 `in` の使用箇所を報告します。\n\n**例:**\n\n\n    def list = [1, 2]\n    if (\"foo\" in list) {} // 整数のリストに文字列を含めることはできません\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyInArgumentCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyMapPutCanBeKeyedAccess",
                "shortDescription": {
                  "text": "キーアクセスが可能な Map.put 呼び出し"
                },
                "fullDescription": {
                  "text": "'java.util.Map.put()' メソッドの呼び出しを報告します。 そのような呼び出しは、より短く明確なキーでアクセスされる形式に置換できます。 例: 'def map = [\"foo\": \"bar\"]\nmap.put(\"foo\", \"baz\") // map.put(\"foo\", \"baz\") は map[\"foo\"] = \"baz\" に置換できます'\n クイックフィックス適用後: 'def map = [\"foo\": \"bar\"]\nmap[\"foo\"] = \"baz\"'",
                  "markdown": "`java.util.Map.put()` メソッドの呼び出しを報告します。 そのような呼び出しは、より短く明確なキーでアクセスされる形式に置換できます。\n\n**例:**\n\n\n    def map = [\"foo\": \"bar\"]\n    map.put(\"foo\", \"baz\") // map.put(\"foo\", \"baz\") は map[\"foo\"] = \"baz\" に置換できます\n\nクイックフィックス適用後:\n\n\n    def map = [\"foo\": \"bar\"]\n    map[\"foo\"] = \"baz\"\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyMapPutCanBeKeyedAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/GPath",
                      "index": 22,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyAssignmentToMethodParameter",
                "shortDescription": {
                  "text": "メソッドパラメーターへの代入"
                },
                "fullDescription": {
                  "text": "メソッドパラメーターへの代入を報告します。 このようなコンストラクトは意図的に宣言されていることもありますが、非常に混乱を招きやすく、多くの場合はタイプミスによるものです。 例: 'def m(a, b, c) {\n      a = [] // 警告\n  }'",
                  "markdown": "メソッドパラメーターへの代入を報告します。\n\nこのようなコンストラクトは意図的に宣言されていることもありますが、非常に混乱を招きやすく、多くの場合はタイプミスによるものです。\n\n**例:**\n\n\n      def m(a, b, c) {\n          a = [] // 警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyAssignmentToMethodParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/代入関連の問題",
                      "index": 64,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyStaticMethodNamingConvention",
                "shortDescription": {
                  "text": "static メソッドの命名規則"
                },
                "fullDescription": {
                  "text": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていない static メソッドを報告します。 static メソッドの名前に期待される最小の長さ、最大の長さ、および正規表現を指定するには、以下に記載されているフィールドを使用します。 正規表現は標準的な 'java.util.regex' 形式で指定する必要があります。",
                  "markdown": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていない static メソッドを報告します。\n\n\nstatic メソッドの名前に期待される最小の長さ、最大の長さ、および正規表現を指定するには、以下に記載されているフィールドを使用します。\n\n正規表現は標準的な `java.util.regex` 形式で指定する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyStaticMethodNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名規則",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyTrivialIf",
                "shortDescription": {
                  "text": "冗長な 'if' ステートメント"
                },
                "fullDescription": {
                  "text": "単一の代入または 'return' ステートメントに単純化できる 'if' ステートメントを報告します。 例: 'if (foo())\n    return true;\n  else\n    return false;' クイックフィックス適用後: 'return foo();'",
                  "markdown": "単一の代入または `return` ステートメントに単純化できる `if` ステートメントを報告します。\n\n**例:**\n\n\n      if (foo())\n        return true;\n      else\n        return false;\n\nクイックフィックス適用後:\n\n\n      return foo();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyTrivialIf",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyPointlessArithmetic",
                "shortDescription": {
                  "text": "無意味な算術式"
                },
                "fullDescription": {
                  "text": "無意味な算術式を報告します。 このような式には、0 の加算または減算、0 または 1 の乗算、1 による除算、および 0 によるシフトが含まれます。 このような式は自動リファクタリングを完遂しなかったために発生している可能性があり、いかなる場合も開発者が意図していたものではないと思われます。 例: 'a + 0' クイックフィックス適用後: 'a'",
                  "markdown": "無意味な算術式を報告します。\n\n\nこのような式には、0 の加算または減算、0 または 1 の乗算、1 による除算、および 0 によるシフトが含まれます。 このような式は自動リファクタリングを完遂しなかったために発生している可能性があり、いかなる場合も開発者が意図していたものではないと思われます。\n\n**例:**\n\n\n      a + 0\n\nクイックフィックス適用後:\n\n\n      a\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyPointlessArithmetic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyAccessibility",
                "shortDescription": {
                  "text": "アクセスできない要素"
                },
                "fullDescription": {
                  "text": "アクセス権を超えている参照を報告します。 private メンバーにアクセスすると、カプセル化が解除されます。",
                  "markdown": "アクセス権を超えている参照を報告します。\n\nprivate メンバーにアクセスすると、カプセル化が解除されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyAccessibility",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Security"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyDoubleCheckedLocking",
                "shortDescription": {
                  "text": "ダブルチェックロック"
                },
                "fullDescription": {
                  "text": "ダブルチェックロックを報告します。 ダブルチェックロックは同期コストを避けながら、オンデマンドかつスレッドセーフな方法でフィールドを初期化しようとします。 残念ながら、'volatile' で宣言されていないフィールドで使用される場合はスレッドセーフではありません。 Java 1.4 以前を使用している場合、'volatile' フィールドを使用していてもダブルチェックロックは機能しません。 この問題の詳細な説明については、上記のリンク先の記事をご覧ください。 例: 'class Foo {\n      private Helper helper = null\n\n      Helper getHelper() {\n          if (helper == null)\n              synchronized(this) {\n                  if (helper == null) {\n                      helper = new Helper()\n                  }\n              }\n          }\n          return helper;\n      }\n  }'",
                  "markdown": "[ダブルチェックロック](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html)を報告します。\n\n\nダブルチェックロックは同期コストを避けながら、オンデマンドかつスレッドセーフな方法でフィールドを初期化しようとします。\n残念ながら、`volatile` で宣言されていないフィールドで使用される場合はスレッドセーフではありません。\nJava 1.4 以前を使用している場合、`volatile` フィールドを使用していてもダブルチェックロックは機能しません。\nこの問題の詳細な説明については、上記のリンク先の記事をご覧ください。\n\n**例:**\n\n\n      class Foo {\n          private Helper helper = null\n\n          Helper getHelper() {\n              if (helper == null)\n                  synchronized(this) {\n                      if (helper == null) {\n                          helper = new Helper()\n                      }\n                  }\n              }\n              return helper;\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyDoubleCheckedLocking",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyFallthrough",
                "shortDescription": {
                  "text": "フォールスルーする 'switch' ステートメント"
                },
                "fullDescription": {
                  "text": "switch ステートメントのフォールスルーを報告します。 フォールスルーは便利な場合もありますが、多くの場合は意図されたものではなく、予期しないバグを引き起こす可能性があります。 例: 'switch(n) {\n  case 1:\n    print 1\n  case 2: // \"case 1\" は \"case 2\" にフォールスルーします。 \"case 2\" のステートメントは \"case 1\" の直後に実行されます。\n    print 2\n    break\n  default:\n    print \"Default\"\n}'",
                  "markdown": "switch ステートメントの*フォールスルー* を報告します。 フォールスルーは便利な場合もありますが、多くの場合は意図されたものではなく、予期しないバグを引き起こす可能性があります。\n\n**例:**\n\n\n    switch(n) {\n      case 1:\n        print 1\n      case 2: // \"case 1\" は \"case 2\" にフォールスルーします。 \"case 2\" のステートメントは \"case 1\" の直後に実行されます。\n        print 2\n        break\n      default:\n        print \"Default\"\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyFallthrough",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyLocalVariableNamingConvention",
                "shortDescription": {
                  "text": "ローカル変数の命名規則"
                },
                "fullDescription": {
                  "text": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないローカル変数を報告します。 ローカル変数の名前に期待される最小の長さ、最大の長さ、および正規表現を指定するには、以下に記載されているフィールドを使用します。 正規表現は標準的な 'java.util.regex' 形式で指定する必要があります。",
                  "markdown": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないローカル変数を報告します。\n\n\nローカル変数の名前に期待される最小の長さ、最大の長さ、および正規表現を指定するには、以下に記載されているフィールドを使用します。\n\n正規表現は標準的な `java.util.regex` 形式で指定する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyLocalVariableNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名規則",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyIfStatementWithIdenticalBranches",
                "shortDescription": {
                  "text": "同一の分岐を持つ if ステートメント"
                },
                "fullDescription": {
                  "text": "内容がまったく同じ \"then\" および 'else' 分岐を持つ 'if' ステートメントを報告します。 このようなステートメントはほぼ確実にプログラマーのミスです。 例: 'if (condition) {\n  print \"foo\"\n} else {\n  print \"foo\"\n}'\n クイックフィックス適用後: 'print \"foo\"'",
                  "markdown": "内容がまったく同じ \"then\" および `else` 分岐を持つ `if` ステートメントを報告します。 このようなステートメントはほぼ確実にプログラマーのミスです。\n\n**例:**\n\n\n    if (condition) {\n      print \"foo\"\n    } else {\n      print \"foo\"\n    }\n\nクイックフィックス適用後:\n\n\n    print \"foo\"\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyIfStatementWithIdenticalBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUncheckedAssignmentOfMemberOfRawType",
                "shortDescription": {
                  "text": "未チェックの raw 型のメンバーからの代入"
                },
                "fullDescription": {
                  "text": "未チェックの raw 型のメンバーからの代入を報告します。 例: 'List list = new ArrayList()\n  List&ltString> a = list.get(0)'",
                  "markdown": "未チェックの raw 型のメンバーからの代入を報告します。\n\n**例:**\n\n\n      List list = new ArrayList()\n      List&ltString> a = list.get(0)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUncheckedAssignmentOfMemberOfRawType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/代入関連の問題",
                      "index": 64,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNonShortCircuitBoolean",
                "shortDescription": {
                  "text": "非短絡ブール値"
                },
                "fullDescription": {
                  "text": "非短絡形式のブール演算子 'and' および 'or' ('&' および '|') を報告します。 非短絡形式は便利な場合もありますが、多くの場合は短絡形式 ('&&' および '||') のタイポが原因で存在しています。また、バグの検出を困難にする可能性があります。 例: 'if (a & b) {}' クイックフィックス適用後: 'if (a && b) {}'",
                  "markdown": "非短絡形式のブール演算子 'and' および 'or' (`&` および `|`) を報告します。\n\n\n非短絡形式は便利な場合もありますが、多くの場合は短絡形式 (`&&` および `||`) のタイポが原因で存在しています。また、バグの検出を困難にする可能性があります。\n\n**例:**\n\n\n    if (a & b) {}\n\nクイックフィックス適用後:\n\n\n    if (a && b) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNonShortCircuitBoolean",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrMethodMayBeStatic",
                "shortDescription": {
                  "text": "'static' にできるメソッド"
                },
                "fullDescription": {
                  "text": "安全に 'static' にできるメソッドを報告します。 'synchronized' でない、所属クラスのインスタンスメソッドとインスタンスフィールドのいずれも参照していない、またはサブクラスでオーバライドされていないメソッドは 'static' にすることができます。",
                  "markdown": "安全に `static` にできるメソッドを報告します。\n\n\n`synchronized` でない、所属クラスのインスタンスメソッドとインスタンスフィールドのいずれも参照していない、またはサブクラスでオーバライドされていないメソッドは `static` にすることができます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrMethodMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/その他",
                      "index": 78,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyDivideByZero",
                "shortDescription": {
                  "text": "ゼロ除算"
                },
                "fullDescription": {
                  "text": "0 による除算または剰余計算を報告します。 例: 'def a = 42\n  a / 0 // 警告\n  a % 0.0 // 警告'",
                  "markdown": "0 による除算または剰余計算を報告します。\n\n**例:**\n\n\n      def a = 42\n      a / 0 // 警告\n      a % 0.0 // 警告\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyDivideByZero",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaStylePropertiesInvocation",
                "shortDescription": {
                  "text": "Java 形式のプロパティアクセス"
                },
                "fullDescription": {
                  "text": "メソッド呼び出し経由でアクセスされているプロパティを報告します。 例: 'class Foo {\n      int foo\n  }\n\n  def bar = new Foo()\n  print(bar.getFoo())' クイックフィックス適用後: 'class Foo {\n      int foo\n  }\n\n  def bar = new Foo()\n  print(bar.foo)'",
                  "markdown": "メソッド呼び出し経由でアクセスされているプロパティを報告します。\n\n**例:**\n\n\n      class Foo {\n          int foo\n      }\n\n      def bar = new Foo()\n      print(bar.getFoo())\n\nクイックフィックス適用後:\n\n\n      class Foo {\n          int foo\n      }\n\n      def bar = new Foo()\n      print(bar.foo)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JavaStylePropertiesInvocation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スタイル",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyTrivialConditional",
                "shortDescription": {
                  "text": "冗長な条件式"
                },
                "fullDescription": {
                  "text": "'x ? true : false' または同様の形式の三項条件演算子で、明らかに単純化できるものを報告します。 例: 'foo() ? true : false' クイックフィックス適用後: 'foo()'",
                  "markdown": "`x ? true : false` または同様の形式の三項条件演算子で、明らかに単純化できるものを報告します。\n\n**例:**\n\n\n      foo() ? true : false\n\nクイックフィックス適用後:\n\n\n    foo()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyTrivialConditional",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnnecessarySemicolon",
                "shortDescription": {
                  "text": "不要なセミコロン"
                },
                "fullDescription": {
                  "text": "不要なセミコロンを報告します。 例: 'print 2; print 3 // セミコロンは必要\n  print 2; // セミコロンは不要'",
                  "markdown": "不要なセミコロンを報告します。\n\n**例:**\n\n\n      print 2; print 3 // セミコロンは必要\n      print 2; // セミコロンは不要\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrUnnecessarySemicolon",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スタイル",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrFinalVariableAccess",
                "shortDescription": {
                  "text": "final 変数アクセス"
                },
                "fullDescription": {
                  "text": "初期化されていない final フィールド、final 変数、パラメーター、およびフィールドへの無効な代入を報告します。",
                  "markdown": "初期化されていない final フィールド、final 変数、パラメーター、およびフィールドへの無効な代入を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrFinalVariableAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryQualifiedReference",
                "shortDescription": {
                  "text": "不要な修飾参照"
                },
                "fullDescription": {
                  "text": "インポートに置換できる完全修飾参照を報告します。 例: 'def swingBuilder = new groovy.swing.SwingBuilder()' クイックフィックス適用後: 'import groovy.swing.SwingBuilder\n \n  def swingBuilder = new SwingBuilder()'",
                  "markdown": "インポートに置換できる完全修飾参照を報告します。\n\n**例:**\n\n\n      def swingBuilder = new groovy.swing.SwingBuilder()\n\nクイックフィックス適用後:\n\n\n      import groovy.swing.SwingBuilder\n     \n      def swingBuilder = new SwingBuilder()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryQualifiedReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChangeToMethod",
                "shortDescription": {
                  "text": "演算子の呼び出しはメソッドの呼び出しに置換できます"
                },
                "fullDescription": {
                  "text": "メソッドの呼び出しに置換できる演算子の呼び出しを報告します。 例: 'a + b' クイックフィックス適用後: 'a.plus(b)'",
                  "markdown": "メソッドの呼び出しに置換できる演算子の呼び出しを報告します。\n\n**例:**\n\n\n      a + b\n\nクイックフィックス適用後:\n\n\n      a.plus(b)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ChangeToMethod",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スタイル",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyBreak",
                "shortDescription": {
                  "text": "'break' ステートメント"
                },
                "fullDescription": {
                  "text": "'switch' ステートメントの外側の 'break' ステートメントを報告します。",
                  "markdown": "`switch` ステートメントの外側の `break` ステートメントを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyBreak",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DelegatesTo",
                "shortDescription": {
                  "text": "@DelegatesTo"
                },
                "fullDescription": {
                  "text": "未使用の '@DelegatesTo.Target' アノテーションと未解決の '@DelegatedTo.target' アノテーションの属性値を報告します。 例: '// 未使用のターゲット 't1' と未解決のターゲット 't2'\n  def m(\n      @DelegatesTo.Target('t1') target,\n      @DelegatesTo(target = 't2') Closure c\n  ) {}'",
                  "markdown": "未使用の `@DelegatesTo.Target` アノテーションと未解決の `@DelegatedTo.target` アノテーションの属性値を報告します。\n\n**例:**\n\n\n      // 未使用のターゲット 't1' と未解決のターゲット 't2'\n      def m(\n          @DelegatesTo.Target('t1') target,\n          @DelegatesTo(target = 't2') Closure c\n      ) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DelegatesTo",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/注釈",
                      "index": 88,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConstantConditional",
                "shortDescription": {
                  "text": "定数条件式"
                },
                "fullDescription": {
                  "text": "ブール定数を条件として使用している条件式を報告します。 例: 'true ? result1 : result2\n  false ? result1 : result2'",
                  "markdown": "ブール定数を条件として使用している条件式を報告します。\n\n**例:**\n\n\n      true ? result1 : result2\n      false ? result1 : result2\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyConstantConditional",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyOverlyComplexArithmeticExpression",
                "shortDescription": {
                  "text": "過度に複雑な算術式"
                },
                "fullDescription": {
                  "text": "項が多すぎる算術式を報告します。 このような式は混乱を招く可能性があり、バグを誘発しやすくします。 算術式に使用できる最大項数を指定するには、「最大項数」フィールドを使用します。",
                  "markdown": "項が多すぎる算術式を報告します。\n\n\nこのような式は混乱を招く可能性があり、バグを誘発しやすくします。\n\n\n算術式に使用できる最大項数を指定するには、「**最大項数**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyOverlyComplexArithmeticExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrSwitchExhaustivenessCheck",
                "shortDescription": {
                  "text": "switch 式の完全性確認"
                },
                "fullDescription": {
                  "text": "パターンマッチングの予想されるすべての結果を網羅していない switch 式を報告します。 Groovy は switch 式が完全であることを要求しません。 暗黙的な 'default -> null' 分岐が挿入されているかのように動作します。 開発者が必要な 'case' 分岐を挿入し忘れている場合は、予期しない null が発生する場合があります。 例: 'enum A { X, Y }\n\n  def foo(A a) {\n    def x = switch (a) { // switch は報告されます\n      case A.X -> ...\n    }\n  }'",
                  "markdown": "パターンマッチングの予想されるすべての結果を網羅していない switch 式を報告します。\n\nGroovy は switch 式が完全であることを要求しません。 暗黙的な `default -> null` 分岐が挿入されているかのように動作します。\n開発者が必要な `case` 分岐を挿入し忘れている場合は、予期しない null が発生する場合があります。\n\n**例:**\n\n\n      enum A { X, Y }\n\n      def foo(A a) {\n        def x = switch (a) { // switch は報告されます\n          case A.X -> ...\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GrSwitchExhaustivenessCheck",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyThrowFromFinallyBlock",
                "shortDescription": {
                  "text": "'finally' ブロック内の 'throw'"
                },
                "fullDescription": {
                  "text": "'finally' ブロック内の 'throw' ステートメントを報告します。 このような 'throw' ステートメントは意図的な場合もありますが、例外のスローをマスクし、デバッグを途方もなく困難にする可能性があります。",
                  "markdown": "`finally` ブロック内の `throw` ステートメントを報告します。\n\n\nこのような `throw` ステートメントは意図的な場合もありますが、例外のスローをマスクし、デバッグを途方もなく困難にする可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyThrowFromFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/エラー処理",
                      "index": 42,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyAssignabilityCheck",
                "shortDescription": {
                  "text": "互換性のない型の代入"
                },
                "fullDescription": {
                  "text": "互換性のない型による代入を報告します。 このような代入は、さまざまなランタイム例外を引き起こす可能性があります。 例: 'class A {}\n  class B {}\n\n  // 互換性のない代入\n  A a = new B()'",
                  "markdown": "互換性のない型による代入を報告します。\n\nこのような代入は、さまざまなランタイム例外を引き起こす可能性があります。\n\n**例:**\n\n\n      class A {}\n      class B {}\n\n      // 互換性のない代入\n      A a = new B()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyAssignabilityCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/代入関連の問題",
                      "index": 64,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChangeToOperator",
                "shortDescription": {
                  "text": "メソッドの呼び出しは演算子の呼び出しに置換できます"
                },
                "fullDescription": {
                  "text": "演算子の呼び出しに置換できるメソッドの呼び出しを報告します。 例: 'a.plus(b)' クイックフィックス適用後: 'a + b'",
                  "markdown": "演算子の呼び出しに置換できるメソッドの呼び出しを報告します。\n\n**例:**\n\n\n      a.plus(b)\n\nクイックフィックス適用後:\n\n\n      a + b\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ChangeToOperator",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スタイル",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyMapGetCanBeKeyedAccess",
                "shortDescription": {
                  "text": "キーアクセスが可能な Map.get 呼び出し"
                },
                "fullDescription": {
                  "text": "'java.util.Map.get()' メソッドの呼び出しを報告します。 そのような呼び出しは、より短く明確なキーでアクセスされる形式に置換できます。 例: 'def map = [\"foo\": \"bar\"]\ndef str = map.get(\"foo\") // map.get(\"foo\") は map[\"foo\"] に置換できます'\n クイックフィックス適用後: 'def map = [\"foo\": \"bar\"]\ndef str = map[\"foo\"]'",
                  "markdown": "`java.util.Map.get()` メソッドの呼び出しを報告します。 そのような呼び出しは、より短く明確なキーでアクセスされる形式に置換できます。\n\n**例:**\n\n\n    def map = [\"foo\": \"bar\"]\n    def str = map.get(\"foo\") // map.get(\"foo\") は map[\"foo\"] に置換できます\n\nクイックフィックス適用後:\n\n\n    def map = [\"foo\": \"bar\"]\n    def str = map[\"foo\"]\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyMapGetCanBeKeyedAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/GPath",
                      "index": 22,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyResultOfAssignmentUsed",
                "shortDescription": {
                  "text": "代入の結果を使用"
                },
                "fullDescription": {
                  "text": "代入値を即座に使用する目的で他の式の中にネストしている代入式を報告します。 このような式は混乱を招きやすく、特定のコンストラクトが 1 つのみのタスクを実行するという一般的な設計原理に違反しています。",
                  "markdown": "代入値を即座に使用する目的で他の式の中にネストしている代入式を報告します。\n\n\nこのような式は混乱を招きやすく、特定のコンストラクトが 1 つのみのタスクを実行するという一般的な設計原理に違反しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyResultOfAssignmentUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/代入関連の問題",
                      "index": 64,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUntypedAccess",
                "shortDescription": {
                  "text": "型指定のない参照式"
                },
                "fullDescription": {
                  "text": "型を判別できない参照式を報告します。",
                  "markdown": "型を判別できない参照式を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUntypedAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyResultOfObjectAllocationIgnored",
                "shortDescription": {
                  "text": "オブジェクトの割り当て結果を無視"
                },
                "fullDescription": {
                  "text": "オブジェクト割り当てで、その演算結果が無視されているものを報告します。 このような割り当て式は Groovy では有効ですが、通常は意図しない、もしくは複雑なオブジェクト初期化戦略が取られていることを表しています。",
                  "markdown": "オブジェクト割り当てで、その演算結果が無視されているものを報告します。\n\n\nこのような割り当て式は Groovy では有効ですが、通常は意図しない、もしくは複雑なオブジェクト初期化戦略が取られていることを表しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyResultOfObjectAllocationIgnored",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNestedAssignment",
                "shortDescription": {
                  "text": "ネストした代入"
                },
                "fullDescription": {
                  "text": "他の式の中にネストしている代入式を報告します。 このような式は実に簡潔ですが、混乱を招きやすく、特定のコンストラクトが 1 つのみのタスクを実行するという一般的な設計原理に違反しています。 例: 'a = b = 1'",
                  "markdown": "他の式の中にネストしている代入式を報告します。 このような式は実に簡潔ですが、混乱を招きやすく、特定のコンストラクトが 1 つのみのタスクを実行するという一般的な設計原理に違反しています。\n\n**例:**\n\n\n    a = b = 1\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNestedAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/代入関連の問題",
                      "index": 64,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyDocCheck",
                "shortDescription": {
                  "text": "未解決の GroovyDoc 参照"
                },
                "fullDescription": {
                  "text": "GroovyDoc コメント内に未解決の参照があることを報告します。",
                  "markdown": "GroovyDoc コメント内に未解決の参照があることを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "GroovyDocCheck",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnusedCatchParameter",
                "shortDescription": {
                  "text": "未使用の 'catch' パラメーター"
                },
                "fullDescription": {
                  "text": "catch パラメーターで、対応するブロックで使用されていないものを報告します。 このインスペクションは、\"ignore\" または \"ignored\" という名前の catch パラメーターは報告しません。 例: 'try {\n      def arr = new int[3]\n      arr[5] = 5\n  } catch(Exception ex) {\n      println('Catching the exception')\n  }' この例にあるパラメーター ex は、catch ブロックで使用されることはありません。 クイックフィックス適用後: 'try {\n      def arr = new int[3]\n      arr[5] = 5\n  } catch(Exception ignored) {\n      println('Catching the exception')\n  }'",
                  "markdown": "**catch** パラメーターで、対応するブロックで使用されていないものを報告します。 このインスペクションは、\"ignore\" または \"ignored\" という名前の **catch** パラメーターは報告しません。\n\n**例:**\n\n\n      try {\n          def arr = new int[3]\n          arr[5] = 5\n      } catch(Exception ex) {\n          println('Catching the exception')\n      }\n\nこの例にあるパラメーター **ex** は、**catch** ブロックで使用されることはありません。\n\nクイックフィックス適用後:\n\n\n      try {\n          def arr = new int[3]\n          arr[5] = 5\n      } catch(Exception ignored) {\n          println('Catching the exception')\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnusedCatchParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/エラー処理",
                      "index": 42,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyInstanceMethodNamingConvention",
                "shortDescription": {
                  "text": "インスタンスメソッドの命名規則"
                },
                "fullDescription": {
                  "text": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないインスタンスメソッドを報告します。 ライブラリメソッドをオーバーライドしているインスタンスメソッドは、このインスペクションにより無視されます。 インスタンスメソッドの名前に期待される最小の長さ、最大の長さ、および正規表現を指定するには、以下に記載されているフィールドを使用します。 正規表現は標準的な 'java.util.regex' 形式で指定する必要があります。",
                  "markdown": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないインスタンスメソッドを報告します。 ライブラリメソッドをオーバーライドしているインスタンスメソッドは、このインスペクションにより無視されます。\n\n\nインスタンスメソッドの名前に期待される最小の長さ、最大の長さ、および正規表現を指定するには、以下に記載されているフィールドを使用します。\n\n正規表現は標準的な `java.util.regex` 形式で指定する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyInstanceMethodNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名規則",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovySynchronizedMethod",
                "shortDescription": {
                  "text": "synchronized メソッド"
                },
                "fullDescription": {
                  "text": "メソッドの 'synchronized' 修飾子を報告します。 一部のコーディング標準は 'synchronized' ステートメントを推奨し、'synchronized' 修飾子の使用を禁止しています。",
                  "markdown": "メソッドの `synchronized` 修飾子を報告します。\n\n\n一部のコーディング標準は `synchronized` ステートメントを推奨し、`synchronized` 修飾子の使用を禁止しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovySynchronizedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnconditionalWait",
                "shortDescription": {
                  "text": "無条件の 'wait' 呼び出し"
                },
                "fullDescription": {
                  "text": "同期コンテキスト内で、無条件に呼び出されている wait() を報告します。 wait() は通常、ある条件が true になるまでスレッドをブロックするために使用されます。 wait() が無条件に呼び出されている場合、多くの場合はロックの取得前に条件がチェックされています。 このような場合、条件をチェックしてロックを取得するまでの間に条件が true になるとデータ競合が発生する可能性があります。 このインスペクションによって検出されるコンストラクトが必ずしも間違っているわけではありませんが、検査する価値はあります。",
                  "markdown": "同期コンテキスト内で、無条件に呼び出されている **wait()** を報告します。\n**wait()** は通常、ある条件が true になるまでスレッドをブロックするために使用されます。 **wait()** が無条件に呼び出されている場合、多くの場合はロックの取得前に条件がチェックされています。 このような場合、条件をチェックしてロックを取得するまでの間に条件が true になるとデータ競合が発生する可能性があります。 このインスペクションによって検出されるコンストラクトが必ずしも間違っているわけではありませんが、検査する価値はあります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnconditionalWait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyContinue",
                "shortDescription": {
                  "text": "'continue' ステートメント"
                },
                "fullDescription": {
                  "text": "'continue' ステートメントを報告します。",
                  "markdown": "`continue` ステートメントを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyContinue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnsynchronizedMethodOverridesSynchronizedMethod",
                "shortDescription": {
                  "text": "synchronized メソッドを非同期メソッドでオーバーライド"
                },
                "fullDescription": {
                  "text": "synchronized メソッドをオーバーライドしている非 synchronized メソッドを報告します。 例: 'abstract class Base {\n      synchronized void foo() {\n          // ...\n      }\n  }\n  class Derived extends Base {\n      @Override\n      void foo() {\n          super.foo()\n            // ...\n        }\n    }' この例では、'Derived' クラスの非 synchronized メソッドである 'foo()' が synchronized メソッドをオーバーライドしています。",
                  "markdown": "**synchronized** メソッドをオーバーライドしている非 **synchronized** メソッドを報告します。\n\n**例:**\n\n\n      abstract class Base {\n          synchronized void foo() {\n              // ...\n          }\n      }\n      class Derived extends Base {\n          @Override\n          void foo() {\n              super.foo()\n                // ...\n            }\n        }\n\nこの例では、`Derived` クラスの非 synchronized メソッドである `foo()` が synchronized メソッドをオーバーライドしています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnsynchronizedMethodOverridesSynchronizedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Security"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNegatedIf",
                "shortDescription": {
                  "text": "否定された if 条件式"
                },
                "fullDescription": {
                  "text": "'else' 分岐を含み、条件が否定されている 'if' ステートメントを報告します。 通常、このようなステートメントは 'if' および 'else' 分岐の順序を反転させると明確さが増します。 例: 'if (!condition) {\n  return \"1\"\n} else {\n  return \"2\"\n}'",
                  "markdown": "`else` 分岐を含み、条件が否定されている `if` ステートメントを報告します。 通常、このようなステートメントは `if` および `else` 分岐の順序を反転させると明確さが増します。\n\n**例:**\n\n\n    if (!condition) {\n      return \"1\"\n    } else {\n      return \"2\"\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNegatedIf",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewGroovyClassNamingConvention",
                "shortDescription": {
                  "text": "クラスの命名規則"
                },
                "fullDescription": {
                  "text": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないクラスを報告します。 提供された入力フィールドを使用して、クラスの型ごとにクラス名に期待される最小長、最大長、および正規表現を指定します。 正規表現は標準的な 'java.util.regex' 形式で指定する必要があります。",
                  "markdown": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないクラスを報告します。\n\n提供された入力フィールドを使用して、クラスの型ごとにクラス名に期待される最小長、最大長、および正規表現を指定します。\n\n正規表現は標準的な `java.util.regex` 形式で指定する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewGroovyClassNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名規則",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClashingGetters",
                "shortDescription": {
                  "text": "getter の競合"
                },
                "fullDescription": {
                  "text": "同じプロパティ名でアクセスできるブールメソッドを報告します。 このようなプロパティにアクセスすると、予期しない結果になることがあります。 例: 'class X {\n      boolean isFoo() { true }\n      boolean getFoo() { false }\n  }\n\n  // getFoo() が呼び出されます\n  new X().foo'",
                  "markdown": "同じプロパティ名でアクセスできるブールメソッドを報告します。\n\nこのようなプロパティにアクセスすると、予期しない結果になることがあります。\n\n**例:**\n\n\n      class X {\n          boolean isFoo() { true }\n          boolean getFoo() { false }\n      }\n\n      // getFoo() が呼び出されます\n      new X().foo\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClashingGetters",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyDuplicateSwitchBranch",
                "shortDescription": {
                  "text": "switch case の重複"
                },
                "fullDescription": {
                  "text": "'switch' の 'case' ラベルで重複している式を報告します。 例: 'switch (n) {\n  case 1: //重複\n    break\n  case 1: //重複\n    System.out.println(\"2\")\n    break\n  default:\n    System.out.println(\"default\");\n}'",
                  "markdown": "`switch` の `case` ラベルで重複している式を報告します。\n\n**例:**\n\n\n    switch (n) {\n      case 1: //重複\n        break\n      case 1: //重複\n        System.out.println(\"2\")\n        break\n      default:\n        System.out.println(\"default\");\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyDuplicateSwitchBranch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/妥当性の問題",
                      "index": 102,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovySwitchStatementWithNoDefault",
                "shortDescription": {
                  "text": "default case がない switch ステートメント"
                },
                "fullDescription": {
                  "text": "'default' ラベルが含まれていない 'switch' ステートメントを報告します。 一部のコーディングプラクティスは、このラベルをすべての 'switch' ステートメントに追加することを求めています。",
                  "markdown": "`default` ラベルが含まれていない `switch` ステートメントを報告します。\n\n\n一部のコーディングプラクティスは、このラベルをすべての `switch` ステートメントに追加することを求めています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovySwitchStatementWithNoDefault",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyListGetCanBeKeyedAccess",
                "shortDescription": {
                  "text": "キーアクセスが可能な List.get 呼び出し"
                },
                "fullDescription": {
                  "text": "'java.util.List.get()' メソッドの呼び出しを報告します。 そのような呼び出しは、より短く明確なキーでアクセスされる形式に置換できます。 例: 'def list = [\"foo\"]\ndef str = list.get(0) // list.get(0) は list[0] に置換できます'\n クイックフィックス適用後: 'def list = [\"foo\"]\ndef str = list[0]'",
                  "markdown": "`java.util.List.get()` メソッドの呼び出しを報告します。 そのような呼び出しは、より短く明確なキーでアクセスされる形式に置換できます。\n\n**例:**\n\n\n    def list = [\"foo\"]\n    def str = list.get(0) // list.get(0) は list[0] に置換できます\n\nクイックフィックス適用後:\n\n\n    def list = [\"foo\"]\n    def str = list[0]\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyListGetCanBeKeyedAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/GPath",
                      "index": 22,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovySynchronizationOnThis",
                "shortDescription": {
                  "text": "'this' の同期"
                },
                "fullDescription": {
                  "text": "'this' をロック式として使用している同期を報告します。 報告対象のコンストラクトには、'this' をロックする 'synchronized' ブロック、'wait()' の呼び出し、'wait()' をターゲットにする 'notify()' または 'notifyAll()' が含まれます。 synchronized メソッドのようなコンストラクトがあるとオブジェクトのロック元を追跡するのが困難になるばかりでなく、オブジェクトの「サービス拒否」攻撃が発生する可能性があります。 代わりに、private インスタンス変数をロックすることを検討してください。この変数へのアクセスは完全に制御できます。",
                  "markdown": "`this` をロック式として使用している同期を報告します。\n\n\n報告対象のコンストラクトには、`this` をロックする `synchronized` ブロック、`wait()` の呼び出し、`wait()` をターゲットにする `notify()` または `notifyAll()` が含まれます。\nsynchronized メソッドのようなコンストラクトがあるとオブジェクトのロック元を追跡するのが困難になるばかりでなく、オブジェクトの「サービス拒否」攻撃が発生する可能性があります。 代わりに、private インスタンス変数をロックすることを検討してください。この変数へのアクセスは完全に制御できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovySynchronizationOnThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Security"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNestedSynchronizedStatement",
                "shortDescription": {
                  "text": "ネストした 'synchronized' ステートメント"
                },
                "fullDescription": {
                  "text": "ネストした 'synchronized' ステートメントを報告します。 ネストした 'synchronized' ステートメントは冗長であるか (ロックオブジェクトがまったく同一である場合)、デッドロックが発生しやすくなる原因になります。",
                  "markdown": "ネストした `synchronized` ステートメントを報告します。\n\n\nネストした `synchronized` ステートメントは冗長であるか (ロックオブジェクトがまったく同一である場合)、デッドロックが発生しやすくなる原因になります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNestedSynchronizedStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyGStringKey",
                "shortDescription": {
                  "text": "GString マップキー"
                },
                "fullDescription": {
                  "text": "'groovy.lang.GString' オブジェクトをマップのキーとして使用しているステートメントを報告します。 一般的に 'GString' オブジェクトはミュータブルであるため、ほぼ確実にキーとして使用すべきではありません。 'GString' エントリは、同じ値を持つ 'java.lang.String' オブジェクトでアクセスすることもできません。 例: 'def map = [:]\ndef key = 'foo'\nmap << [\"${key}\": 'bar']\nassert map[key] == null // 混乱を招く比較による 'true' の結果'\n 2017.1 の新機能です",
                  "markdown": "`groovy.lang.GString` オブジェクトをマップのキーとして使用しているステートメントを報告します。 一般的に `GString` オブジェクトはミュータブルであるため、ほぼ確実にキーとして使用すべきではありません。 `GString` エントリは、同じ値を持つ `java.lang.String` オブジェクトでアクセスすることもできません。\n\n**例:**\n\n\n    def map = [:]\n    def key = 'foo'\n    map << [\"${key}\": 'bar']\n    assert map[key] == null // 混乱を招く比較による 'true' の結果\n\n2017.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyGStringKey",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewInstanceOfSingleton",
                "shortDescription": {
                  "text": "@ groovy.lang.Singleton 注釈が付いたクラスの新しいインスタンス"
                },
                "fullDescription": {
                  "text": "クラスの新規インスタンスの作成で、'@groovy.lang.Singleton' アノテーションが付いているものを報告します。 このような構文は、「Can't instantiate singleton」ランタイム例外を引き起こす可能性があります。 例: '@Singleton\n  class Foo{\n  }\n  \n  Foo foo = new Foo()' クイックフィックス適用後: '@Singleton\n  class Foo{\n  }\n  \n  Foo foo = Foo.instance'",
                  "markdown": "クラスの新規インスタンスの作成で、`@groovy.lang.Singleton` アノテーションが付いているものを報告します。\nこのような構文は、「**Can't instantiate singleton**」ランタイム例外を引き起こす可能性があります。\n\n**例:**\n\n\n      @Singleton\n      class Foo{\n      }\n      \n      Foo foo = new Foo()\n\nクイックフィックス適用後:\n\n\n      @Singleton\n      class Foo{\n      }\n      \n      Foo foo = Foo.instance\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewInstanceOfSingleton",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyVariableCanBeFinal",
                "shortDescription": {
                  "text": "final にできる変数"
                },
                "fullDescription": {
                  "text": "final 修飾子を追加できるパラメーターまたはローカル変数を報告します。 例: 'def list = [1,2,3]\n  return list' クイックフィックス適用後: 'final def list = [1,2,3]\n  return list' 詳しくは、Java の同じインスペクションを参照してください。",
                  "markdown": "final 修飾子を追加できるパラメーターまたはローカル変数を報告します。\n\n**例:**\n\n\n      def list = [1,2,3]\n      return list\n\nクイックフィックス適用後:\n\n\n      final def list = [1,2,3]\n      return list\n\n詳しくは、Java の同じインスペクションを参照してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyVariableCanBeFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/データフロー",
                      "index": 107,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyWaitCallNotInLoop",
                "shortDescription": {
                  "text": "ループ内にない 'wait()'"
                },
                "fullDescription": {
                  "text": "ループ内で行われていない 'wait()' の呼び出しを報告します。 'wait()' は一般的にある条件が true になるまでスレッドを中断するために使用されるため、'wait()' の結果が返ってきた後はその条件をチェックする必要があります。 これを実現するには、ループを使用するのが最も簡単です。",
                  "markdown": "ループ内で行われていない `wait()` の呼び出しを報告します。\n\n`wait()` は一般的にある条件が true になるまでスレッドを中断するために使用されるため、`wait()` の結果が返ってきた後はその条件をチェックする必要があります。 これを実現するには、ループを使用するのが最も簡単です。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyWaitCallNotInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnnecessaryReturn",
                "shortDescription": {
                  "text": "不要な 'return' ステートメント"
                },
                "fullDescription": {
                  "text": "'void' を返しているコンストラクターとメソッドの最後にある 'return' ステートメントを報告します。 これらは不要なため、安全に除去できます。 例: 'void foo (String s){\n      print(s)\n      return\n  }' クイックフィックス適用後: 'void foo (String s){\n      print(s)\n  }' 詳しくは、Java の同じインスペクションを参照してください。",
                  "markdown": "`void` を返しているコンストラクターとメソッドの最後にある `return` ステートメントを報告します。 これらは不要なため、安全に除去できます。\n\n**例:**\n\n\n      void foo (String s){\n          print(s)\n          return\n      }\n\nクイックフィックス適用後:\n\n\n      void foo (String s){\n          print(s)\n      }\n\n詳しくは、Java の同じインスペクションを参照してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnnecessaryReturn",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrReassignedInClosureLocalVar",
                "shortDescription": {
                  "text": "クロージャまたは無名クラスで再割り当てられているローカル変数"
                },
                "fullDescription": {
                  "text": "クロージャまたは匿名クラス内で型が異なる式に代入されているローカル変数を報告します。 例: 'int sum = 0\n  [1, 2, 3].each { sum += 'as' }\n  println(sum)' この例では結果的に 'integer' 変数の sum が 'String' 式に再代入されています。",
                  "markdown": "クロージャまたは匿名クラス内で型が異なる式に代入されているローカル変数を報告します。\n\n**例:**\n\n\n      int sum = 0\n      [1, 2, 3].each { sum += 'as' }\n      println(sum)\n\nこの例では結果的に `integer` 変数の **sum** が `String` 式に再代入されています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrReassignedInClosureLocalVar",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyMethodParameterCount",
                "shortDescription": {
                  "text": "パラメーターが多すぎるメソッド"
                },
                "fullDescription": {
                  "text": "パラメーターが多すぎるメソッドを報告します。 パラメーターが多すぎるメソッドは、リファクタリングが必要かもしれません。 ライブラリクラスから継承されたシグネチャーを持つメソッドは、このインスペクションにより無視されます。 メソッドで許容されるパラメーターの最大数を指定するには、「最大パラメーター数:」フィールドを使用します。",
                  "markdown": "パラメーターが多すぎるメソッドを報告します。 パラメーターが多すぎるメソッドは、リファクタリングが必要かもしれません。 ライブラリクラスから継承されたシグネチャーを持つメソッドは、このインスペクションにより無視されます。\n\n\nメソッドで許容されるパラメーターの最大数を指定するには、「**最大パラメーター数:**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyMethodParameterCount",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/メソッドメトリクス",
                      "index": 108,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConditional",
                "shortDescription": {
                  "text": "三項式"
                },
                "fullDescription": {
                  "text": "三項式を報告します。 一部のコーディング標準は 'if' ステートメントを推奨し、条件演算子の使用を禁止しています。",
                  "markdown": "三項式を報告します。\n\n一部のコーディング標準は `if` ステートメントを推奨し、条件演算子の使用を禁止しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyConditional",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スタイル",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyAccessToStaticFieldLockedOnInstance",
                "shortDescription": {
                  "text": "インスタンスデータにロックされた static フィールドへのアクセス"
                },
                "fullDescription": {
                  "text": "'this' または 'this' のインスタンスフィールドのいずれかでロックされている非定数の static フィールドへのアクセスを報告します。 インスタンスデータの static フィールドをロックしても、そのフィールドが他のインスタンスによって変更されるのを防ぐことはできないため、予期しない競合状態が発生する可能性があります。 例: 'static String s;\n  def foo() {\n      synchronized (this) {\n          System.out.println(s); // 警告\n      }\n  }'",
                  "markdown": "`this` または `this` のインスタンスフィールドのいずれかでロックされている非定数の static フィールドへのアクセスを報告します。\n\n\nインスタンスデータの static フィールドをロックしても、そのフィールドが他のインスタンスによって変更されるのを防ぐことはできないため、予期しない競合状態が発生する可能性があります。\n\n**例:**\n\n\n      static String s;\n      def foo() {\n          synchronized (this) {\n              System.out.println(s); // 警告\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyAccessToStaticFieldLockedOnInstance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNestedConditional",
                "shortDescription": {
                  "text": "ネストした条件式"
                },
                "fullDescription": {
                  "text": "他の条件式の中にネストしている三項条件式を報告します。 このようなネストした条件式は大きな混乱を招く可能性があります。 このインスペクションでは、「エルビス」式は条件式と見なされます。 例: 'return (condition ? \"result\" : null) ?: \"fail\"'",
                  "markdown": "他の条件式の中にネストしている三項条件式を報告します。 このようなネストした条件式は大きな混乱を招く可能性があります。 このインスペクションでは、「エルビス」式は条件式と見なされます。\n\n**例:**\n\n\n    return (condition ? \"result\" : null) ?: \"fail\"\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNestedConditional",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyLabeledStatement",
                "shortDescription": {
                  "text": "ラベル付きステートメントのインスペクション"
                },
                "fullDescription": {
                  "text": "親ワークフローですでに使用されているラベルを報告します。 例: 'def list = [\"foo\"]\ncycle:\nfor (element in list) {\n  cycle: // 紛らわしいラベルの繰り返し\n  element.chars().forEach {\n  }\n}'",
                  "markdown": "親ワークフローですでに使用されているラベルを報告します。\n\n**例:**\n\n\n    def list = [\"foo\"]\n    cycle:\n    for (element in list) {\n      cycle: // 紛らわしいラベルの繰り返し\n      element.chars().forEach {\n      }\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyLabeledStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyEmptyStatementBody",
                "shortDescription": {
                  "text": "本体が空のステートメント"
                },
                "fullDescription": {
                  "text": "本体が空の 'if'、'while'、'do'、または 'for' ステートメントを報告します。 このような構文は意図的な場合もありますが、混乱を招き、多くの場合はタイプミスによるものです。 例: 'if (condition) {}\nwhile(true){}'",
                  "markdown": "本体が空の `if`、`while`、`do`、または `for` ステートメントを報告します。 このような構文は意図的な場合もありますが、混乱を招き、多くの場合はタイプミスによるものです。\n\n**例:**\n\n\n    if (condition) {}\n    while(true){}\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyEmptyStatementBody",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyAssignmentToForLoopParameter",
                "shortDescription": {
                  "text": "'for' ループパラメーターへの代入"
                },
                "fullDescription": {
                  "text": "for ループ本体内の for ループパラメーターへの代入を報告します。 このようなコンストラクトは意図的に宣言されていることもありますが、非常に混乱を招きやすく、多くの場合はタイプミスによるものです。 例: 'for (value in [1, 2, 3]) {\n      value = 4 // 警告\n  }'",
                  "markdown": "**for** ループ本体内の **for** ループパラメーターへの代入を報告します。\n\nこのようなコンストラクトは意図的に宣言されていることもありますが、非常に混乱を招きやすく、多くの場合はタイプミスによるものです。\n\n**例:**\n\n\n      for (value in [1, 2, 3]) {\n          value = 4 // 警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyAssignmentToForLoopParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/代入関連の問題",
                      "index": 64,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnnecessaryAlias",
                "shortDescription": {
                  "text": "不要なインポートエイリアス"
                },
                "fullDescription": {
                  "text": "不要なインポートエイリアスを報告します。 例: 'import com.foo.Bar as Bar' クイックフィックス適用後: 'import com.foo.Bar'",
                  "markdown": "不要なインポートエイリアスを報告します。\n\n**例:**\n\n\n      import com.foo.Bar as Bar\n\nクイックフィックス適用後:\n\n\n      import com.foo.Bar\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GrUnnecessaryAlias",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スタイル",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyAssignmentCanBeOperatorAssignment",
                "shortDescription": {
                  "text": "演算子代入に置換可能な代入"
                },
                "fullDescription": {
                  "text": "演算子代入に置換できる代入を報告します。 例: 'a = a + b' クイックフィックス適用後: 'a += b' インスペクションの構成: '&&' および '||' 演算子を無視するには、「条件演算子を無視する」オプションを使用します。 '^' および '%' 演算子を無視するには、「あいまいな演算子を無視する」オプションを使用します。",
                  "markdown": "演算子代入に置換できる代入を報告します。\n\n**例:**\n\n\n      a = a + b\n\nクイックフィックス適用後:\n\n\n      a += b\n\nインスペクションの構成:\n\n* `&&` および `||` 演算子を無視するには、「**条件演算子を無視する**」オプションを使用します。\n* `^` および `%` 演算子を無視するには、「**あいまいな演算子を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GroovyAssignmentCanBeOperatorAssignment",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/代入関連の問題",
                      "index": 64,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyImplicitNullArgumentCall",
                "shortDescription": {
                  "text": "暗黙の null 引数"
                },
                "fullDescription": {
                  "text": "パラメーターが 1 つだけのメソッドを引数なしで呼び出していることを報告します。 これは 'null' を使用して呼び出すのと同じです。多くの場合、その動作は誤解を招き、意図されたものではありません。 例: 'def foo(String s){}\nfoo() // この呼び出しは実際には 'foo(null)' を呼び出します。'",
                  "markdown": "パラメーターが 1 つだけのメソッドを引数なしで呼び出していることを報告します。 これは `null` を使用して呼び出すのと同じです。多くの場合、その動作は誤解を招き、意図されたものではありません。\n\n**例:**\n\n\n    def foo(String s){}\n    foo() // この呼び出しは実際には 'foo(null)' を呼び出します。\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GroovyImplicitNullArgumentCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyReturnFromFinallyBlock",
                "shortDescription": {
                  "text": "'finally' ブロック内の 'return'"
                },
                "fullDescription": {
                  "text": "'finally' ブロック内の 'return' ステートメントを報告します。 このような 'return' ステートメントは意図的な場合もありますが、例外のスローをマスクし、デバッグを困難にする可能性があります。",
                  "markdown": "`finally` ブロック内の `return` ステートメントを報告します。\n\n\nこのような `return` ステートメントは意図的な場合もありますが、例外のスローをマスクし、デバッグを困難にする可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyReturnFromFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/エラー処理",
                      "index": 42,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConstructorNamedArguments",
                "shortDescription": {
                  "text": "コンストラクター呼び出しの名前付き引数"
                },
                "fullDescription": {
                  "text": "デフォルトのクラスコンストラクターの呼び出しの名前付き引数で、そのクラスのプロパティに対応していないものを報告します。 例: 'class Person {\n      def name\n      def age\n  }\n\n  // 'firstName' プロパティは存在しません\n  new Person(firstName: \"John\")'",
                  "markdown": "デフォルトのクラスコンストラクターの呼び出しの名前付き引数で、そのクラスのプロパティに対応していないものを報告します。\n\n**例:**\n\n\n      class Person {\n          def name\n          def age\n      }\n\n      // 'firstName' プロパティは存在しません\n      new Person(firstName: \"John\")\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyConstructorNamedArguments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConditionalWithIdenticalBranches",
                "shortDescription": {
                  "text": "同一の分岐を持つ三項式"
                },
                "fullDescription": {
                  "text": "内容がまったく同じ \"then\" および \"else\" 分岐を含む三項式を報告します。 このような式はほぼ確実にプログラマーのミスです。 クイックフィックスを使用すると、\"then\" 分岐を含む式が置換されます。 例: 'condition ? a.foo() : a.foo()' クイックフィックス適用後: 'a.foo()'",
                  "markdown": "内容がまったく同じ \"then\" および \"else\" 分岐を含む三項式を報告します。 このような式はほぼ確実にプログラマーのミスです。\n\nクイックフィックスを使用すると、\"then\" 分岐を含む式が置換されます。\n\n**例:**\n\n\n      condition ? a.foo() : a.foo()\n\nクイックフィックス適用後:\n\n\n      a.foo()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyConditionalWithIdenticalBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnnecessaryNonSealedModifier",
                "shortDescription": {
                  "text": "不要な 'non-sealed' 修飾子"
                },
                "fullDescription": {
                  "text": "メソッド、フィールド、または変数で使用されている不要な 'non-sealed' 修飾子を報告します。 この修飾子は、クラス、インターフェース、トレイトに対してのみ有効です。 例: 'non-sealed boolean foo() {} // 修飾子は不要\n  non-sealed Object bar // 修飾子は不要\n\n  // 修飾子は必要なため、ハイライトされていません\n  non-sealed class A {}'",
                  "markdown": "メソッド、フィールド、または変数で使用されている不要な `non-sealed` 修飾子を報告します。\n\nこの修飾子は、クラス、インターフェース、トレイトに対してのみ有効です。\n\n**例:**\n\n\n      non-sealed boolean foo() {} // 修飾子は不要\n      non-sealed Object bar // 修飾子は不要\n\n      // 修飾子は必要なため、ハイライトされていません\n      non-sealed class A {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrUnnecessaryNonSealedModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スタイル",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrAnnotationReferencingUnknownIdentifiers",
                "shortDescription": {
                  "text": "@TupleConstructor と @MapConstructor"
                },
                "fullDescription": {
                  "text": "'@TupleConstructor' と '@MapConstructor' の 'includes' および 'excludes' アノテーションの属性値にある未解決の識別子を報告します。 例: '// 未解決の 'c'\n  @TupleConstructor(includes = ['a', 'b', 'c'])\n  class X {\n      def a\n      def b\n  }'",
                  "markdown": "`@TupleConstructor` と `@MapConstructor` の `includes` および `excludes` アノテーションの属性値にある未解決の識別子を報告します。\n\n**例:**\n\n\n      // 未解決の 'c'\n      @TupleConstructor(includes = ['a', 'b', 'c'])\n      class X {\n          def a\n          def b\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrAnnotationReferencingUnknownIdentifiers",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/注釈",
                      "index": 88,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnnecessaryDefModifier",
                "shortDescription": {
                  "text": "不要な 'def'"
                },
                "fullDescription": {
                  "text": "明示的な型宣言を使用する際には不要な 'def' 修飾子を報告します。 例: 'def boolean foo() {} // 修飾子は不要\n  def Object bar // 修飾子は不要\n\n  // 修飾子は必要なため、ハイライトされません\n  def (int a, String b) = []'",
                  "markdown": "明示的な型宣言を使用する際には不要な `def` 修飾子を報告します。\n\n**例:**\n\n\n      def boolean foo() {} // 修飾子は不要\n      def Object bar // 修飾子は不要\n\n      // 修飾子は必要なため、ハイライトされません\n      def (int a, String b) = []\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrUnnecessaryDefModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スタイル",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnresolvedAccess",
                "shortDescription": {
                  "text": "未解決の参照式"
                },
                "fullDescription": {
                  "text": "解決できない参照式を報告します。",
                  "markdown": "解決できない参照式を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GrUnresolvedAccess",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrPOJO",
                "shortDescription": {
                  "text": "@CompileStatic なしの @POJO"
                },
                "fullDescription": {
                  "text": "'@groovy.transform.CompileStatic' なしで適用されているアノテーション '@groovy.transform.stc.POJO' を報告します。 アノテーション '@POJO' は Groovy クラスのコンパイル処理をバイトコードに変更します。 明示的に有効化された静的コンパイル ('@CompileStatic' アノテーションを介して行われるもの) がない場合は効果はありません。 例: '@POJO // @POJO が報告されます\n  class A {}'",
                  "markdown": "`@groovy.transform.CompileStatic` なしで適用されているアノテーション `@groovy.transform.stc.POJO` を報告します。\n\nアノテーション `@POJO` は Groovy クラスのコンパイル処理をバイトコードに変更します。 明示的に有効化された静的コンパイル (`@CompileStatic` アノテーションを介して行われるもの) がない場合は効果はありません。\n\n**例:**\n\n\n      @POJO // @POJO が報告されます\n      class A {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrPOJO",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/注釈",
                      "index": 88,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyWaitWhileNotSynchronized",
                "shortDescription": {
                  "text": "同期されていない 'wait()'"
                },
                "fullDescription": {
                  "text": "'wait()' の呼び出しのうち、対応する synchronized ステートメントまたは synchronized メソッド内にないものを報告します。 あるオブジェクトに対してロックを保持せずにそのオブジェクトに対して 'wait()' を呼び出すと、'IllegalMonitorStateException' がスローされます。 このようなコンストラクトは必ずしも間違いではありませんが、一度確認することをおすすめします。含んでいるメソッドが呼び出される前に必要なロックが取得される可能性があるためです。",
                  "markdown": "`wait()` の呼び出しのうち、対応する synchronized ステートメントまたは synchronized メソッド内にないものを報告します。\n\nあるオブジェクトに対してロックを保持せずにそのオブジェクトに対して `wait()` を呼び出すと、`IllegalMonitorStateException` がスローされます。\nこのようなコンストラクトは必ずしも間違いではありませんが、一度確認することをおすすめします。含んでいるメソッドが呼び出される前に必要なロックが取得される可能性があるためです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyWaitWhileNotSynchronized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyMultipleReturnPointsPerMethod",
                "shortDescription": {
                  "text": "複数の return を持つメソッド"
                },
                "fullDescription": {
                  "text": "return ポイントが多すぎるメソッドを報告します。 return ポイントが多すぎるメソッドは混乱を招き、リファクタリングしにくい可能性があります。 例: 'int foo(int a) {\n    if (a > 0) {\n      return a\n    }\n    if (a < 0) return -a\n    return 0\n  }'\n メソッドで許容される return ポイントの最大数を指定するには、以下に記載されているフィールドを使用します。",
                  "markdown": "return ポイントが多すぎるメソッドを報告します。 return ポイントが多すぎるメソッドは混乱を招き、リファクタリングしにくい可能性があります。\n\n**例:**\n\n\n      int foo(int a) {\n        if (a > 0) {\n          return a\n        }\n        if (a < 0) return -a\n        return 0\n      }\n\n\nメソッドで許容される return ポイントの最大数を指定するには、以下に記載されているフィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyMultipleReturnPointsPerMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/メソッドメトリクス",
                      "index": 108,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConditionalCanBeElvis",
                "shortDescription": {
                  "text": "三項式はエルビス式に置換できます"
                },
                "fullDescription": {
                  "text": "エルビス式に置換できる三項式を報告します。 例: 'def notNull(o, defaultValue) {\n      o != null ? o : defaultValue\n  }' クイックフィックス適用後: 'def notNull(o, defaultValue) {\n      o ?: defaultValue\n  }'",
                  "markdown": "エルビス式に置換できる三項式を報告します。\n\n**例:**\n\n\n      def notNull(o, defaultValue) {\n          o != null ? o : defaultValue\n      }\n\nクイックフィックス適用後:\n\n\n      def notNull(o, defaultValue) {\n          o ?: defaultValue\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GroovyConditionalCanBeElvis",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnnecessaryFinalModifier",
                "shortDescription": {
                  "text": "不要な 'final'"
                },
                "fullDescription": {
                  "text": "レコードの定義で使用されている不要な 'final' 修飾子を報告します。 例: 'final record R(int a) {} // 修飾子は不要です'",
                  "markdown": "レコードの定義で使用されている不要な `final` 修飾子を報告します。\n\n**例:**\n\n\n      final record R(int a) {} // 修飾子は不要です\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrUnnecessaryFinalModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スタイル",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyOverlyLongMethod",
                "shortDescription": {
                  "text": "長すぎるメソッド"
                },
                "fullDescription": {
                  "text": "長すぎるメソッドを報告します。 長すぎるメソッドは混乱を招く可能性があるため、ファクタリングが必要かもしれません。 メソッドで許容される非コメントソースステートメントの最大数を指定するには、「メソッドごとの最大ステートメント数」フィールドを使用します。",
                  "markdown": "長すぎるメソッドを報告します。\n\n\n長すぎるメソッドは混乱を招く可能性があるため、ファクタリングが必要かもしれません。\n\n\nメソッドで許容される非コメントソースステートメントの最大数を指定するには、「**メソッドごとの最大ステートメント数**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyOverlyLongMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/メソッドメトリクス",
                      "index": 108,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SecondUnsafeCall",
                "shortDescription": {
                  "text": "安全でない 2 回目の呼び出し"
                },
                "fullDescription": {
                  "text": "チェーンメソッドまたはプロパティの呼び出し中に発生する可能性がある NullPointerException を報告します。 例: 'domain?.getZone().getName()' クイックフィックス適用後: 'domain?.getZone()?.getName()'",
                  "markdown": "チェーンメソッドまたはプロパティの呼び出し中に発生する可能性がある **NullPointerException** を報告します。\n\n**例:**\n\n\n      domain?.getZone().getName()\n\nクイックフィックス適用後:\n\n\n      domain?.getZone()?.getName()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SecondUnsafeCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrPackage",
                "shortDescription": {
                  "text": "パッケージの不一致"
                },
                "fullDescription": {
                  "text": "予期されるパッケージに一致しない宣言されたパッケージがあるファイルを報告します。 また、'package' ステートメントのないファイルのうち、ソースルートディレクトリに直接配置されていないものも報告します。",
                  "markdown": "予期されるパッケージに一致しない宣言されたパッケージがあるファイルを報告します。 また、`package` ステートメントのないファイルのうち、ソースルートディレクトリに直接配置されていないものも報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrPackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyOverlyComplexBooleanExpression",
                "shortDescription": {
                  "text": "過度に複雑なブール式"
                },
                "fullDescription": {
                  "text": "項が多すぎるブール式を報告します。 このような式は混乱を招く可能性があり、バグを誘発しやすくします。 ブール式に使用できる最大項数を指定するには、「最大項数」フィールドを使用します。",
                  "markdown": "項が多すぎるブール式を報告します。\n\n\nこのような式は混乱を招く可能性があり、バグを誘発しやすくします。\n\n\nブール式に使用できる最大項数を指定するには、「**最大項数**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyOverlyComplexBooleanExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnreachableStatement",
                "shortDescription": {
                  "text": "到達不能なステートメント"
                },
                "fullDescription": {
                  "text": "到達不可能なステートメントを報告します。 このような状況は、ステートメントが無限ループ、'return'、'break'、'continue' ステートメントのいずれかの後にある場合に発生します。 例: 'void foo (int n) {\n      if (n < 1) {\n          return\n          print('This statement is unreachable')\n      }\n      while (true){\n          print ('Hello, world!')\n      }\n      print('This statement is unreachable too')\n  }'",
                  "markdown": "到達不可能なステートメントを報告します。 このような状況は、ステートメントが無限ループ、`return`、`break`、`continue` ステートメントのいずれかの後にある場合に発生します。\n\n**例:**\n\n\n      void foo (int n) {\n          if (n < 1) {\n              return\n              print('This statement is unreachable')\n          }\n          while (true){\n              print ('Hello, world!')\n          }\n          print('This statement is unreachable too')\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnreachableStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/妥当性の問題",
                      "index": 102,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovySystemRunFinalizersOnExit",
                "shortDescription": {
                  "text": "System.runFinalizersOnExit() の呼び出し"
                },
                "fullDescription": {
                  "text": "'System.runFinalizersOnExit()' の呼び出しを報告します。 これは、Java 言語で最も危険な呼び出しの 1 つです。 この呼び出しは本質的にスレッドセーフではなく、データの破損やデッドロックを誘発するだけでなく、呼び出し箇所から遠く離れたプログラムの部分に影響を与える可能性があります。 この呼び出しは非推奨であるため、使用しないことを強くお勧めします。",
                  "markdown": "`System.runFinalizersOnExit()` の呼び出しを報告します。\n\n\nこれは、Java 言語で最も危険な呼び出しの 1 つです。 この呼び出しは本質的にスレッドセーフではなく、データの破損やデッドロックを誘発するだけでなく、呼び出し箇所から遠く離れたプログラムの部分に影響を与える可能性があります。\nこの呼び出しは非推奨であるため、使用しないことを強くお勧めします。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovySystemRunFinalizersOnExit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Security"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyInstanceVariableNamingConvention",
                "shortDescription": {
                  "text": "インスタンス変数の命名規則"
                },
                "fullDescription": {
                  "text": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないインスタンス変数を報告します。 インスタンス変数の名前に期待される最小の長さ、最大の長さ、および正規表現を指定するには、以下に記載されているフィールドを使用します。 正規表現は標準的な 'java.util.regex' 形式で指定する必要があります。",
                  "markdown": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないインスタンス変数を報告します。\n\n\nインスタンス変数の名前に期待される最小の長さ、最大の長さ、および正規表現を指定するには、以下に記載されているフィールドを使用します。\n\n正規表現は標準的な `java.util.regex` 形式で指定する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyInstanceVariableNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名規則",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConstantIfStatement",
                "shortDescription": {
                  "text": "定数 if 文"
                },
                "fullDescription": {
                  "text": "ブール定数を条件として使用している 'if' ステートメントを報告します。 例: 'if (true) {\n      // ...\n  }\n  if (false) {\n      // ...\n  }'",
                  "markdown": "ブール定数を条件として使用している `if` ステートメントを報告します。\n\n**例:**\n\n\n      if (true) {\n          // ...\n      }\n      if (false) {\n          // ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyConstantIfStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyParameterNamingConvention",
                "shortDescription": {
                  "text": "メソッドパラメーターの命名規則"
                },
                "fullDescription": {
                  "text": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないメソッドパラメーターを報告します。 メソッドパラメーターの名前に期待される最小の長さ、最大の長さ、および正規表現を指定するには、以下に記載されているフィールドを使用します。 正規表現は標準的な 'java.util.regex' 形式で指定する必要があります。",
                  "markdown": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていないメソッドパラメーターを報告します。\n\n\nメソッドパラメーターの名前に期待される最小の長さ、最大の長さ、および正規表現を指定するには、以下に記載されているフィールドを使用します。\n\n正規表現は標準的な `java.util.regex` 形式で指定する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyParameterNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名規則",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnnecessaryPublicModifier",
                "shortDescription": {
                  "text": "不要な 'public'"
                },
                "fullDescription": {
                  "text": "Groovy のクラスとメソッドはデフォルトで 'public' であるため、不要な 'public' 修飾子を報告します。 例: 'public class Foo{\n      public void bar(){\n      }\n  }' クイックフィックス適用後: 'class Foo{\n      void bar(){\n      }\n  }'",
                  "markdown": "Groovy のクラスとメソッドはデフォルトで `public` であるため、不要な `public` 修飾子を報告します。\n\n**例:**\n\n\n      public class Foo{\n          public void bar(){\n          }\n      }\n\nクイックフィックス適用後:\n\n\n      class Foo{\n          void bar(){\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrUnnecessaryPublicModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スタイル",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrStringStyleViolation",
                "shortDescription": {
                  "text": "文字列の規約違反"
                },
                "fullDescription": {
                  "text": "コードスタイルに一致しない引用符を使用している文字列を報告します。 例: 'def hw = \"Hello, world!\"' クイックフィックス適用後: 'def hw = 'Hello, world!'' 異なる種類の文字列のコードスタイルを指定するには、以下に記載されているフィールドを使用します。",
                  "markdown": "コードスタイルに一致しない引用符を使用している文字列を報告します。\n\n**例:**\n\n\n      def hw = \"Hello, world!\"\n\nクイックフィックス適用後:\n\n\n      def hw = 'Hello, world!'\n\n異なる種類の文字列のコードスタイルを指定するには、以下に記載されているフィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GrStringStyleViolation",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スタイル",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyPointlessBoolean",
                "shortDescription": {
                  "text": "無意味なブール式"
                },
                "fullDescription": {
                  "text": "意味のない、または無駄に複雑なブール式を報告します。 このような式には、true を含む論理積、false を含む論理和、ブールリテラルを含む等価比較、ブールリテラルの否定などがあります。 このような式は自動リファクタリングを完遂しなかったために発生している可能性があり、いかなる場合も開発者が意図していたものではないと思われます。 例: 'if (someBool && true) {}' クイックフィックス適用後: 'if (someBool) {}'",
                  "markdown": "意味のない、または無駄に複雑なブール式を報告します。\n\n\nこのような式には、true を含む論理積、false を含む論理和、ブールリテラルを含む等価比較、ブールリテラルの否定などがあります。 このような式は自動リファクタリングを完遂しなかったために発生している可能性があり、いかなる場合も開発者が意図していたものではないと思われます。\n\n**例:**\n\n\n      if (someBool && true) {}\n\nクイックフィックス適用後:\n\n\n      if (someBool) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyPointlessBoolean",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SingletonConstructor",
                "shortDescription": {
                  "text": "@Singleton コンストラクター"
                },
                "fullDescription": {
                  "text": "strict で宣言されておらず、'@Singleton' アノテーションが付いたクラスのコンストラクターを報告します。 例: '@Singleton\n  class Foo{\n      Foo(){\n      }\n  }' コンストラクターを除去する、'@Singleton' を非 strict で宣言する、の 2 つのクイックフィックスを使用できます。 クイックフィックス適用後: '@Singleton\n  class Foo{\n  }' または '@Singleton(strict = false)\n  class Foo{\n      Foo(){\n      }\n  }'",
                  "markdown": "strict で宣言されておらず、`@Singleton` アノテーションが付いたクラスのコンストラクターを報告します。\n\n**例:**\n\n\n      @Singleton\n      class Foo{\n          Foo(){\n          }\n      }\n\nコンストラクターを除去する、`@Singleton` を非 strict で宣言する、の 2 つのクイックフィックスを使用できます。\n\nクイックフィックス適用後:\n\n\n      @Singleton\n      class Foo{\n      }\n\nまたは\n\n\n      @Singleton(strict = false)\n      class Foo{\n          Foo(){\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "SingletonConstructor",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/注釈",
                      "index": 88,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyStaticVariableNamingConvention",
                "shortDescription": {
                  "text": "static 変数の命名規則"
                },
                "fullDescription": {
                  "text": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていない 'static' 変数を報告します。 定数 ('static final' で宣言されたイミュータブルな型の変数) は、このインスペクションによりチェックされません。 static 変数の名前に期待される最小の長さ、最大の長さ、および正規表現を指定するには、以下に記載されているフィールドを使用します。 正規表現は標準的な 'java.util.regex' 形式で指定する必要があります。",
                  "markdown": "名前が短すぎる、長すぎる、または指定された正規表現パターンに従っていない `static` 変数を報告します。\n\n\n定数 (`static final` で宣言されたイミュータブルな型の変数) は、このインスペクションによりチェックされません。\n\n\nstatic 変数の名前に期待される最小の長さ、最大の長さ、および正規表現を指定するには、以下に記載されているフィールドを使用します。\n\n正規表現は標準的な `java.util.regex` 形式で指定する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyStaticVariableNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/命名規則",
                      "index": 36,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyInfiniteLoopStatement",
                "shortDescription": {
                  "text": "無限ループステートメント"
                },
                "fullDescription": {
                  "text": "例外のスローによってのみ終了できる 'for'、'while'、または 'do' ステートメントを報告します。 このようなステートメントは正しい場合もありますが、多くの場合は間違いによるものです。 例: 'while(true) {\n  Thread.sleep(1000)\n}'",
                  "markdown": "例外のスローによってのみ終了できる `for`、`while`、または `do` ステートメントを報告します。 このようなステートメントは正しい場合もありますが、多くの場合は間違いによるものです。\n\n**例:**\n\n\n    while(true) {\n      Thread.sleep(1000)\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyInfiniteLoopStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyEmptyTryBlock",
                "shortDescription": {
                  "text": "空の 'try' ブロック"
                },
                "fullDescription": {
                  "text": "空の 'try' ブロックを報告します。 空の 'try' ブロックは多くの場合、コーディングの誤りです。 例: 'try {\n}\nfinally {\n  close()\n}'",
                  "markdown": "空の `try` ブロックを報告します。 空の `try` ブロックは多くの場合、コーディングの誤りです。\n\n**例:**\n\n\n    try {\n    }\n    finally {\n      close()\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyEmptyTryBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/エラー処理",
                      "index": 42,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrPermitsClause",
                "shortDescription": {
                  "text": "拡張が許可されていないサブクラス"
                },
                "fullDescription": {
                  "text": "permits に指定されているクラスで、sealed 基底クラスを拡張していないものを報告します。 Groovy では permits に指定されているすべてのクラスがコンパイル時に使用可能であり、基底クラスと一緒にコンパイルされる必要はありません。 コンパイラーは permits に指定されており、拡張を行わないサブクラスを処理する際に警告を表示しませんが、それは sealed クラスの性質に矛盾しています。 例: 'class A permits B {} // B が報告されます\n  class B {}'",
                  "markdown": "permits に指定されているクラスで、sealed 基底クラスを拡張していないものを報告します。\n\nGroovy では permits に指定されているすべてのクラスがコンパイル時に使用可能であり、基底クラスと一緒にコンパイルされる必要はありません。 コンパイラーは permits に指定されており、拡張を行わないサブクラスを処理する際に警告を表示しませんが、それは sealed クラスの性質に矛盾しています。\n\n**例:**\n\n\n      class A permits B {} // B が報告されます\n      class B {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "GrPermitsClause",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnusedIncOrDec",
                "shortDescription": {
                  "text": "未使用のインクリメントまたはデクリメント"
                },
                "fullDescription": {
                  "text": "未使用のインクリメント式とデクリメント式を報告します。",
                  "markdown": "未使用のインクリメント式とデクリメント式を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnusedIncOrDec",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/データフロー",
                      "index": 107,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyEmptyCatchBlock",
                "shortDescription": {
                  "text": "空の 'catch' ブロック"
                },
                "fullDescription": {
                  "text": "空の 'catch' ブロックを報告します。 このような空の 'catch' ブロックは意図的な場合もありますが、デバッグを極めて困難にする可能性があります。 例: 'try {\n  throw new Exception()\n}\ncatch (Exception e) {\n}'\n クイックフィックス適用後: 'try {\n  throw new Exception()\n}\ncatch (Exception ignored) {\n}'",
                  "markdown": "空の `catch` ブロックを報告します。 このような空の `catch` ブロックは意図的な場合もありますが、デバッグを極めて困難にする可能性があります。\n\n**例:**\n\n\n    try {\n      throw new Exception()\n    }\n    catch (Exception e) {\n    }\n\nクイックフィックス適用後:\n\n\n    try {\n      throw new Exception()\n    }\n    catch (Exception ignored) {\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyEmptyCatchBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/エラー処理",
                      "index": 42,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClashingTraitMethods",
                "shortDescription": {
                  "text": "トレイトメソッドの競合"
                },
                "fullDescription": {
                  "text": "2 つ以上のトレイトを実装するクラスで、シグネチャーが同じメソッドを含んでいるものを報告します。 このようなメソッドを呼び出すと、予期しない結果になることがあります。 クイックフィックスを使用すると、明示的なオーバーライドするメソッドが追加されます。 例: 'trait T1 {\n      def foo() {}\n  }\n\n  trait T2 {\n      def foo() {}\n  }\n\n  class X implements T1, T2 {}\n\n  // T2.foo() が呼び出されます\n  new X().foo()' クイックフィックス適用後: 'class X implements T1, T2 {\n      @Override\n      Object foo() {\n          return T2.super.foo()\n      }\n  }'",
                  "markdown": "2 つ以上のトレイトを実装するクラスで、シグネチャーが同じメソッドを含んでいるものを報告します。\n\nこのようなメソッドを呼び出すと、予期しない結果になることがあります。\n\nクイックフィックスを使用すると、明示的なオーバーライドするメソッドが追加されます。\n\n**例:**\n\n\n      trait T1 {\n          def foo() {}\n      }\n\n      trait T2 {\n          def foo() {}\n      }\n\n      class X implements T1, T2 {}\n\n      // T2.foo() が呼び出されます\n      new X().foo()\n\nクイックフィックス適用後:\n\n\n      class X implements T1, T2 {\n          @Override\n          Object foo() {\n              return T2.super.foo()\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClashingTraitMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyOverlyComplexMethod",
                "shortDescription": {
                  "text": "過度に複雑なメソッド"
                },
                "fullDescription": {
                  "text": "サイクロマティック複雑度が高すぎるメソッドを報告します。 サイクロマティック複雑度とは、基本的にはメソッドの分岐点数を表す尺度です。 サイクロマティック複雑度が高すぎるメソッドは混乱を招き、テストしにくい可能性があります。 メソッドで許容されるサイクロマティック複雑度の最大値を指定するには、「メソッド複雑度の制限」フィールドを使用します。",
                  "markdown": "サイクロマティック複雑度が高すぎるメソッドを報告します。\n\n\nサイクロマティック複雑度とは、基本的にはメソッドの分岐点数を表す尺度です。 サイクロマティック複雑度が高すぎるメソッドは混乱を招き、テストしにくい可能性があります。\n\n\nメソッドで許容されるサイクロマティック複雑度の最大値を指定するには、「**メソッド複雑度の制限**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyOverlyComplexMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/メソッドメトリクス",
                      "index": 108,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeCustomizer",
                "shortDescription": {
                  "text": "型カスタマイザーインスペクション"
                },
                "fullDescription": {
                  "text": "カスタムの型チェッカーにでき、コンパイラーリソースにまだ追加されていないファイルを報告します。",
                  "markdown": "カスタムの型チェッカーにでき、コンパイラーリソースにまだ追加されていないファイルを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeCustomizer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/その他",
                      "index": 78,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyOverlyNestedMethod",
                "shortDescription": {
                  "text": "過度にネストしたメソッド"
                },
                "fullDescription": {
                  "text": "本文が深くネストしているメソッドを報告します。 ステートメントのネストが深すぎるメソッドは混乱を招く可能性があるため、リファクタリングが必要かもしれません。 メソッドで許容されるネストの最大深さを指定するには、「ネストの最大深さ 」フィールドを使用します。",
                  "markdown": "本文が深くネストしているメソッドを報告します。\n\n\nステートメントのネストが深すぎるメソッドは混乱を招く可能性があるため、リファクタリングが必要かもしれません。\n\n\nメソッドで許容されるネストの最大深さを指定するには、「**ネストの最大深さ** 」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyOverlyNestedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/メソッドメトリクス",
                      "index": 108,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyVariableNotAssigned",
                "shortDescription": {
                  "text": "代入されていない変数"
                },
                "fullDescription": {
                  "text": "初期化されていない可能性がある変数を報告します。",
                  "markdown": "初期化されていない可能性がある変数を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyVariableNotAssigned",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/データフロー",
                      "index": 107,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyMethodWithMoreThanThreeNegations",
                "shortDescription": {
                  "text": "4 つ以上の否定を含むメソッド"
                },
                "fullDescription": {
                  "text": "3 つ以上の否定演算 ('!' または '!=') を含むメソッドを報告します。 このようなメソッドは不要な混乱を招く可能性があります。",
                  "markdown": "3 つ以上の否定演算 (`!` または `!=`) を含むメソッドを報告します。 このようなメソッドは不要な混乱を招く可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyMethodWithMoreThanThreeNegations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/メソッドメトリクス",
                      "index": 108,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyDoubleNegation",
                "shortDescription": {
                  "text": "二重否定"
                },
                "fullDescription": {
                  "text": "単純化できる二重否定を報告します。 例: 'if (!!functionCall()) {} // 二重否定\nif (!(a != b)) {} // 二重否定'\n クイックフィックス適用後: 'if (functionCall()) {}\nif (a == b) {}'",
                  "markdown": "単純化できる二重否定を報告します。\n\n**例:**\n\n\n    if (!!functionCall()) {} // 二重否定\n    if (!(a != b)) {} // 二重否定\n\nクイックフィックス適用後:\n\n\n    if (functionCall()) {}\n    if (a == b) {}\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyDoubleNegation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrNamedVariantLabels",
                "shortDescription": {
                  "text": "@NamedVariant/@NamedParam/@NamedDelegate 未解決ラベル"
                },
                "fullDescription": {
                  "text": "'@NamedVariant'/'@NamedParam'/'@NamedDelegate' アノテーションが付いたメソッドの呼び出しで、未解決になっている引数ラベルを報告します。 例: '@groovy.transform.NamedVariant\n  def foo(a, b) {}\n\n  // 未解決のラベル 'c'\n  foo(a: 1, b: 2, c: 3)'",
                  "markdown": "`@NamedVariant`/`@NamedParam`/`@NamedDelegate` アノテーションが付いたメソッドの呼び出しで、未解決になっている引数ラベルを報告します。\n\n**例:**\n\n\n      @groovy.transform.NamedVariant\n      def foo(a, b) {}\n\n      // 未解決のラベル 'c'\n      foo(a: 1, b: 2, c: 3)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrNamedVariantLabels",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/注釈",
                      "index": 88,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyIfStatementWithTooManyBranches",
                "shortDescription": {
                  "text": "分岐が多すぎる if ステートメント"
                },
                "fullDescription": {
                  "text": "分岐が多すぎる 'if' ステートメントを報告します。 このようなステートメントは混乱を招く可能性があり、多くの場合は設計の抽象化レベルが不十分であることを示しています。 例: 'if (a) {\n  print \"foo\"\n} else if (b) {\n  print \"bar\"\n} else if (c) {\n  print \"baz\"\n} else if (d) {\n  print \"Too many branches\"\n}'\n 期待される分岐の最大数を指定するには、「最大分岐数」フィールドを使用します。",
                  "markdown": "分岐が多すぎる `if` ステートメントを報告します。 このようなステートメントは混乱を招く可能性があり、多くの場合は設計の抽象化レベルが不十分であることを示しています。\n\n**例:**\n\n\n    if (a) {\n      print \"foo\"\n    } else if (b) {\n      print \"bar\"\n    } else if (c) {\n      print \"baz\"\n    } else if (d) {\n      print \"Too many branches\"\n    }\n\n\n期待される分岐の最大数を指定するには、「**最大分岐数**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyIfStatementWithTooManyBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNegatedConditional",
                "shortDescription": {
                  "text": "否定された条件式"
                },
                "fullDescription": {
                  "text": "条件が否定されている条件式を報告します。 通常、このようなステートメントは条件式の分岐の順序を入れ替えると明確さが増します。 例: '~condition ? \"1\" : \"2\"'",
                  "markdown": "条件が否定されている条件式を報告します。 通常、このようなステートメントは条件式の分岐の順序を入れ替えると明確さが増します。\n\n**例:**\n\n\n    ~condition ? \"1\" : \"2\"\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNegatedConditional",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyWhileLoopSpinsOnField",
                "shortDescription": {
                  "text": "フィールドでの while ループ処理"
                },
                "fullDescription": {
                  "text": "非 'volatile' フィールドの値で周回しており、別スレッドによる変更を待機している 'while' ループを報告します。 このようなループはループ内でほとんど作業が行われない場合に CPU 消費が非常に激しくなる可能性があるうえ、意図したものとは異なるセマンティクスを持っている可能性があります。 Java メモリモデルでは、別スレッドによってフィールドの値が変更された場合でも、このようなループが完了することはありません。 例: 'class SpinsOnField {\n      boolean ready = false;\n\n      void run() {\n          // このループは  markAsReady が他のスレッドから\n          // 呼び出されても完了しない可能性があります\n          while (!ready) {\n          }\n          // 何らかの処理を実行\n      }\n\n      void markAsReady() {\n          ready = true;\n      }\n  }' また、Java 9 以降は 'volatile' フィールドの周回ループ内で 'Thread.onSpinWait()' を呼び出すことをお勧めします。これにより、一部のハードウェアのパフォーマンスが大幅に向上する可能性があります。 このインスペクションに空の 'while' ループのみを報告させるには、下のチェックボックスを使用します。",
                  "markdown": "非 `volatile` フィールドの値で周回しており、別スレッドによる変更を待機している `while` ループを報告します。\n\n\nこのようなループはループ内でほとんど作業が行われない場合に CPU 消費が非常に激しくなる可能性があるうえ、意図したものとは異なるセマンティクスを持っている可能性があります。 Java メモリモデルでは、別スレッドによってフィールドの値が変更された場合でも、このようなループが完了することはありません。\n\n**例:**\n\n\n      class SpinsOnField {\n          boolean ready = false;\n\n          void run() {\n              // このループは  markAsReady が他のスレッドから\n              // 呼び出されても完了しない可能性があります\n              while (!ready) {\n              }\n              // 何らかの処理を実行\n          }\n\n          void markAsReady() {\n              ready = true;\n          }\n      }\n\n\nまた、Java 9 以降は `volatile` フィールドの周回ループ内で `Thread.onSpinWait()` を呼び出すことをお勧めします。これにより、一部のハードウェアのパフォーマンスが大幅に向上する可能性があります。\n\n\nこのインスペクションに空の `while` ループのみを報告させるには、下のチェックボックスを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyWhileLoopSpinsOnField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrEqualsBetweenInconvertibleTypes",
                "shortDescription": {
                  "text": "互換性のない型のオブジェクト間の 'equals()'"
                },
                "fullDescription": {
                  "text": "ターゲットと引数が互換性のない型である 'equals()' の呼び出しを報告します。 このような呼び出しは理屈の上では役に立つ場合もありますが、バグの可能性が高いです。 例: 'new HashSet<String>() == new TreeSet<Integer>())'",
                  "markdown": "ターゲットと引数が互換性のない型である `equals()` の呼び出しを報告します。\n\nこのような呼び出しは理屈の上では役に立つ場合もありますが、バグの可能性が高いです。\n\n**例:**\n\n\n        new HashSet<String>() == new TreeSet<Integer>())\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrEqualsBetweenInconvertibleTypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyEmptySyncBlock",
                "shortDescription": {
                  "text": "空の 'synchronized' ブロック"
                },
                "fullDescription": {
                  "text": "本体が空の 'synchronized' ステートメントを報告します。 このようなコンストラクトは理論的に意図されたセマンティクスである場合もありますが、混乱を招き、多くの場合はタイプミスによるものです。 例: 'synchronized(lock) {\n}'",
                  "markdown": "本体が空の `synchronized` ステートメントを報告します。 このようなコンストラクトは理論的に意図されたセマンティクスである場合もありますが、混乱を招き、多くの場合はタイプミスによるものです。\n\n**例:**\n\n\n    synchronized(lock) {\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyEmptySyncBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovySillyAssignment",
                "shortDescription": {
                  "text": "不適切な代入"
                },
                "fullDescription": {
                  "text": "変数の自己代入を報告します。",
                  "markdown": "変数の自己代入を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovySillyAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/代入関連の問題",
                      "index": 64,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyConditionalCanBeConditionalCall",
                "shortDescription": {
                  "text": "三項式は安全な呼び出しに置換できます"
                },
                "fullDescription": {
                  "text": "安全な呼び出しに置換できる三項式を報告します。 例: 'def charArray(String s) {\n      s == null ? null : s.toCharArray()\n  }' クイックフィックス適用後: 'def charArray(String s) {\n      s?.toCharArray()\n  }'",
                  "markdown": "安全な呼び出しに置換できる三項式を報告します。\n\n**例:**\n\n\n      def charArray(String s) {\n          s == null ? null : s.toCharArray()\n      }\n\nクイックフィックス適用後:\n\n\n      def charArray(String s) {\n          s?.toCharArray()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GroovyConditionalCanBeConditionalCall",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyInfiniteRecursion",
                "shortDescription": {
                  "text": "無限再帰"
                },
                "fullDescription": {
                  "text": "無限に繰り返されるか、例外をスローする必要のあるメソッドを報告します。 このインスペクションで報告されるメソッドは、正しく終了することができません。 例: '// この関数を実行するとループの階層がどんどん深くなります\ndef fibonacci(int n) {\n  return fibonacci(n-1) + fibonacci(n-2)\n}'",
                  "markdown": "無限に繰り返されるか、例外をスローする必要のあるメソッドを報告します。 このインスペクションで報告されるメソッドは、正しく終了することができません。\n\n**例:**\n\n\n    // この関数を実行するとループの階層がどんどん深くなります\n    def fibonacci(int n) {\n      return fibonacci(n-1) + fibonacci(n-2)\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyInfiniteRecursion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNestedSwitch",
                "shortDescription": {
                  "text": "ネストした switch ステートメント"
                },
                "fullDescription": {
                  "text": "他の 'switch' ステートメントの中にネストしている 'switch' ステートメントを報告します。 このようなネストした switch ステートメントは混乱を招き、予期しない動作を引き起こす可能性があります。 例: 'switch (outer) {\n  case 1:\n    switch (inner) {\n      case 1:\n        print \"inner 1\"\n        break\n      default:\n        print \"inner default\"\n    }\n    break\n  default:\n    print \"default\"\n}'",
                  "markdown": "他の `switch` ステートメントの中にネストしている `switch` ステートメントを報告します。 このようなネストした switch ステートメントは混乱を招き、予期しない動作を引き起こす可能性があります。\n\n**例:**\n\n\n    switch (outer) {\n      case 1:\n        switch (inner) {\n          case 1:\n            print \"inner 1\"\n            break\n          default:\n            print \"inner default\"\n        }\n        break\n      default:\n        print \"default\"\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNestedSwitch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyRangeTypeCheck",
                "shortDescription": {
                  "text": "不正な範囲引数"
                },
                "fullDescription": {
                  "text": "'next()' または 'previous()' メソッドを持たない、または 'java.lang.Comparable' インターフェースを実装していない範囲で使用されている型を報告します。",
                  "markdown": "`next()` または `previous()` メソッドを持たない、または `java.lang.Comparable` インターフェースを実装していない範囲で使用されている型を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyRangeTypeCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/潜在的なバグ",
                      "index": 55,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrUnnecessarySealedModifier",
                "shortDescription": {
                  "text": "不要な 'sealed' 修飾子"
                },
                "fullDescription": {
                  "text": "メソッド、フィールド、または変数で使用されている不要な 'sealed' 修飾子を報告します。 この修飾子は、クラス、インターフェース、トレイトに対してのみ有効です。 例: 'sealed boolean foo() {} // 修飾子は不要\n  sealed Object bar // 修飾子は不要\n\n  // 修飾子は必要なため、ハイライトされていません\n  sealed class A {}'",
                  "markdown": "メソッド、フィールド、または変数で使用されている不要な `sealed` 修飾子を報告します。\n\nこの修飾子は、クラス、インターフェース、トレイトに対してのみ有効です。\n\n**例:**\n\n\n      sealed boolean foo() {} // 修飾子は不要\n      sealed Object bar // 修飾子は不要\n\n      // 修飾子は必要なため、ハイライトされていません\n      sealed class A {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrUnnecessarySealedModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スタイル",
                      "index": 81,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrDeprecatedAPIUsage",
                "shortDescription": {
                  "text": "非推奨 API の使用"
                },
                "fullDescription": {
                  "text": "非推奨のクラス、フィールド、メソッドへの参照を報告します。",
                  "markdown": "非推奨のクラス、フィールド、メソッドへの参照を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GrDeprecatedAPIUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyMissingReturnStatement",
                "shortDescription": {
                  "text": "return ステートメントがありません"
                },
                "fullDescription": {
                  "text": "戻り値の型が非 void であるメソッドの最後に 'return' ステートメントがない場合に報告します。 メソッドの最後は、メソッドの実行フローにより到達可能でなければなりません。 例: 'String foo(int a) {\n  if (a > 0) {\n    return \"more than zero\"\n  }\n} // foo(-1) は 'null' を返します\n\nint bar(int a) {\n  if (a > 0) {\n    return a\n  }\n} // bar(-1) はランタイム例外で失敗します'",
                  "markdown": "戻り値の型が非 **void** であるメソッドの最後に `return` ステートメントがない場合に報告します。 メソッドの最後は、メソッドの実行フローにより到達可能でなければなりません。\n\n**例:**\n\n\n    String foo(int a) {\n      if (a > 0) {\n        return \"more than zero\"\n      }\n    } // foo(-1) は 'null' を返します\n\n    int bar(int a) {\n      if (a > 0) {\n        return a\n      }\n    } // bar(-1) はランタイム例外で失敗します\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyMissingReturnStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/データフロー",
                      "index": 107,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyPublicFieldAccessedInSynchronizedContext",
                "shortDescription": {
                  "text": "同期コンテキストでアクセスされる非 private フィールド"
                },
                "fullDescription": {
                  "text": "同期コンテンツでアクセスされている、非 'final'、非 'private' フィールドを報告します。 非 private フィールドは必ず同期的にアクセスされるとは保証されていないため、このような「部分的な同期」アクセスは一貫性のないデータ構造を予期せず生み出す可能性があります。 コンストラクターとイニシャライザーでのアクセスは、このインスペクションでは無視されます。",
                  "markdown": "同期コンテンツでアクセスされている、非 `final`、非 `private` フィールドを報告します。\n\n\n非 private フィールドは必ず同期的にアクセスされるとは保証されていないため、このような「部分的な同期」アクセスは一貫性のないデータ構造を予期せず生み出す可能性があります。 コンストラクターとイニシャライザーでのアクセスは、このインスペクションでは無視されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyPublicFieldAccessedInSynchronizedContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnnecessaryContinue",
                "shortDescription": {
                  "text": "不要な 'continue' ステートメント"
                },
                "fullDescription": {
                  "text": "ループ内で最後に到達可能なステートメントになっている 'continue' ステートメントを報告します。 このような 'continue' ステートメントは不要であり、安全に除去できます。 例: 'for(int i in array) {\n      println(i)\n      continue\n  }' クイックフィックス適用後: 'for(int i in array) {\n      println(i)\n  }' 詳しくは、Java の同じインスペクションを参照してください。",
                  "markdown": "ループ内で最後に到達可能なステートメントになっている `continue` ステートメントを報告します。\nこのような `continue` ステートメントは不要であり、安全に除去できます。\n\n**例:**\n\n\n      for(int i in array) {\n          println(i)\n          continue\n      }\n\nクイックフィックス適用後:\n\n\n      for(int i in array) {\n          println(i)\n      }\n\n詳しくは、Java の同じインスペクションを参照してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnnecessaryContinue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnusedAssignment",
                "shortDescription": {
                  "text": "使用されない代入"
                },
                "fullDescription": {
                  "text": "ある変数の値が代入後にまったく使用されていないため、変数が冗長になっている場合に報告します。 変数が使用されていない場合は、その変数を除去してコードを短縮し、冗長な代入を回避することをお勧めします。 次のケースが報告されます。 代入後、変数がまったく読み取られていない。 変数が次に読み取られる前に、変数の値が常に別の代入によって上書きされている。 (上記の 2 つの理由のうち 1 つが原因で) 変数のイニシャライザーが冗長になっている。 詳しくは、Java の同じインスペクションを参照してください。",
                  "markdown": "ある変数の値が代入後にまったく使用されていないため、変数が冗長になっている場合に報告します。\n\n変数が使用されていない場合は、その変数を除去してコードを短縮し、冗長な代入を回避することをお勧めします。\n\n次のケースが報告されます。\n\n* 代入後、変数がまったく読み取られていない。\n* 変数が次に読み取られる前に、変数の値が常に別の代入によって上書きされている。\n* (上記の 2 つの理由のうち 1 つが原因で) 変数のイニシャライザーが冗長になっている。\n\n詳しくは、Java の同じインスペクションを参照してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnusedAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/データフロー",
                      "index": 107,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyNotifyWhileNotSynchronized",
                "shortDescription": {
                  "text": "同期されていない 'notify()' または 'notifyAll()'"
                },
                "fullDescription": {
                  "text": "'notify()' と 'notifyAll()' の呼び出しのうち、対応する synchronized ステートメントまたは synchronized メソッド内にないものを報告します。 あるオブジェクトに対してロックを保持せずにそのオブジェクトに対してこれらのメソッドを呼び出すと、'IllegalMonitorStateException' がスローされます。 このようなコンストラクトは必ずしも間違いではありませんが、一度確認することをおすすめします。含んでいるメソッドが呼び出される前に必要なロックが取得される可能性があるためです。",
                  "markdown": "`notify()` と `notifyAll()` の呼び出しのうち、対応する synchronized ステートメントまたは synchronized メソッド内にないものを報告します。\n\n\nあるオブジェクトに対してロックを保持せずにそのオブジェクトに対してこれらのメソッドを呼び出すと、`IllegalMonitorStateException` がスローされます。\nこのようなコンストラクトは必ずしも間違いではありませんが、一度確認することをおすすめします。含んでいるメソッドが呼び出される前に必要なロックが取得される可能性があるためです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyNotifyWhileNotSynchronized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyBusyWait",
                "shortDescription": {
                  "text": "ビジーウェイト"
                },
                "fullDescription": {
                  "text": "ループ内にある 'java.lang.Thread.sleep()' メソッドの呼び出しを報告します。 このような呼び出しは、「ビジーウェイト」を引き起こす可能性があります。 ビジーウェイトは往々にして非効率であり、予期しないデッドロックの原因になる場合があります。ビジーウェイトしているスレッドがロックしたリソースを解放しないためです。",
                  "markdown": "ループ内にある `java.lang.Thread.sleep()` メソッドの呼び出しを報告します。\n\n\nこのような呼び出しは、「ビジーウェイト」を引き起こす可能性があります。 ビジーウェイトは往々にして非効率であり、予期しないデッドロックの原因になる場合があります。ビジーウェイトしているスレッドがロックしたリソースを解放しないためです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyBusyWait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyOctalInteger",
                "shortDescription": {
                  "text": "8 進整数"
                },
                "fullDescription": {
                  "text": "8 進数の整数リテラルを報告します。 コーディング標準には、10 進リテラルと混乱しやすい 8 進リテラルの使用を禁止しているものもあります。",
                  "markdown": "8 進数の整数リテラルを報告します。\n\n\nコーディング標準には、10 進リテラルと混乱しやすい 8 進リテラルの使用を禁止しているものもあります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyOctalInteger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyEmptyFinallyBlock",
                "shortDescription": {
                  "text": "空の 'finally' ブロック"
                },
                "fullDescription": {
                  "text": "空の 'finally' ブロックを報告します。 空の 'finally' ブロックは多くの場合、コーディングの誤りです。 例: 'try {\n  throw new Exception()\n}\nfinally {\n}'",
                  "markdown": "空の `finally` ブロックを報告します。 空の `finally` ブロックは多くの場合、コーディングの誤りです。\n\n**例:**\n\n\n    try {\n      throw new Exception()\n    }\n    finally {\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyEmptyFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/エラー処理",
                      "index": 42,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovySynchronizationOnVariableInitializedWithLiteral",
                "shortDescription": {
                  "text": "リテラルで初期化された変数の同期"
                },
                "fullDescription": {
                  "text": "リテラルで初期化されるオブジェクトをロックしている synchronized ブロックを報告します。 文字列リテラルはインターン処理され、'Number' リテラルはキャッシュから割り当てることができます。 このため、同じリテラルで初期化されるオブジェクトを使用しているシステムの他の部分に、まったく同じオブジェクトへの参照を実際に保持しているものがある可能性があります。 その結果、文字列が private であると見なされた場合に予期しないデッドロック状態が発生する可能性があります。",
                  "markdown": "リテラルで初期化されるオブジェクトをロックしている synchronized ブロックを報告します。\n\n\n文字列リテラルはインターン処理され、`Number` リテラルはキャッシュから割り当てることができます。 このため、同じリテラルで初期化されるオブジェクトを使用しているシステムの他の部分に、まったく同じオブジェクトへの参照を実際に保持しているものがある可能性があります。 その結果、文字列が private であると見なされた場合に予期しないデッドロック状態が発生する可能性があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovySynchronizationOnVariableInitializedWithLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Security"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyUnusedDeclaration",
                "shortDescription": {
                  "text": "未使用の宣言"
                },
                "fullDescription": {
                  "text": "未使用のクラス、メソッド、フィールドを報告します。 例: 'public class Department {\n      private Organization myOrganization;\n  }' この例では、'Department' は 'Organization' を明示的に参照していますが、'Department' クラス自体が未使用の場合は両方のクラスがインスペクションによって報告されます。 このインスペクションは、所属するメソッドとすべてのメソッド実装/オーバーライド先で使用されていないパラメーターに加えて、宣言されているものの使用されていないローカル変数も報告します。 詳しくは、Java の同じインスペクションを参照してください。",
                  "markdown": "未使用のクラス、メソッド、フィールドを報告します。\n\n**例:**\n\n\n      public class Department {\n          private Organization myOrganization;\n      }\n\nこの例では、`Department` は `Organization` を明示的に参照していますが、`Department` クラス自体が未使用の場合は両方のクラスがインスペクションによって報告されます。\n\n\nこのインスペクションは、所属するメソッドとすべてのメソッド実装/オーバーライド先で使用されていないパラメーターに加えて、宣言されているものの使用されていないローカル変数も報告します。\n\n詳しくは、Java の同じインスペクションを参照してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyUnusedDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/宣言の冗長性",
                      "index": 133,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyLoopStatementThatDoesntLoop",
                "shortDescription": {
                  "text": "ループしないループステートメント"
                },
                "fullDescription": {
                  "text": "本体が 1 回までしか実行されないことが確実な 'for' または 'while' ステートメントを報告します。 このようなステートメントは意図的に書かれている場合もありますが、通常は誤りです。 例: 'for (int i in 0..<10) {\n    return\n  }'",
                  "markdown": "本体が 1 回までしか実行されないことが確実な `for` または `while` ステートメントを報告します。 このようなステートメントは意図的に書かれている場合もありますが、通常は誤りです。\n\n**例:**\n\n\n      for (int i in 0..<10) {\n        return\n      }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyLoopStatementThatDoesntLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyResultOfIncrementOrDecrementUsed",
                "shortDescription": {
                  "text": "インクリメントまたはデクリメントの結果を使用"
                },
                "fullDescription": {
                  "text": "他の式の中にネストしているインクリメント式またはデクリメント式を報告します。 このような式は混乱を招きやすく、特定のコンストラクトが 1 つのみのタスクを実行するという一般的な設計原理に違反しています。",
                  "markdown": "他の式の中にネストしているインクリメント式またはデクリメント式を報告します。\n\n\nこのような式は混乱を招きやすく、特定のコンストラクトが 1 つのみのタスクを実行するという一般的な設計原理に違反しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyResultOfIncrementOrDecrementUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/混乱を招く可能性があるコード箇所",
                      "index": 71,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovyReturnFromClosureCanBeImplicit",
                "shortDescription": {
                  "text": "暗黙的にできる 'return' ステートメント"
                },
                "fullDescription": {
                  "text": "クロージャの最後にある return ステートメントで、暗黙的にできるものを報告します。 Groovy クロージャは、その中に含まれる最後のステートメントの値を暗黙的に返します。 例: 'def foo = {\n    return 1\n  }' クイックフィックス適用後: 'def foo = {\n    1\n  }'",
                  "markdown": "クロージャの最後にある return ステートメントで、暗黙的にできるものを報告します。\n\n\nGroovy クロージャは、その中に含まれる最後のステートメントの値を暗黙的に返します。\n\n**例:**\n\n\n      def foo = {\n        return 1\n      }\n\nクイックフィックス適用後:\n\n\n      def foo = {\n        1\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovyReturnFromClosureCanBeImplicit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/制御フロー問題",
                      "index": 69,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GroovySynchronizationOnNonFinalField",
                "shortDescription": {
                  "text": "非 final フィールドの同期"
                },
                "fullDescription": {
                  "text": "ロック式が非 'final' フィールドである 'synchronized' ステートメントを報告します。 このようなステートメントが有効なセマンティクスを持つ可能性は低いです。同じオブジェクトに対する操作を行っている場合も、異なるスレッドが別のオブジェクトをロックしている場合があるためです。",
                  "markdown": "ロック式が非 `final` フィールドである `synchronized` ステートメントを報告します。\n\n\nこのようなステートメントが有効なセマンティクスを持つ可能性は低いです。同じオブジェクトに対する操作を行っている場合も、異なるスレッドが別のオブジェクトをロックしている場合があるためです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "GroovySynchronizationOnNonFinalField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Groovy/スレッド関連の問題",
                      "index": 39,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "HtmlUnknownBooleanAttribute",
                "shortDescription": {
                  "text": "不正なブール属性"
                },
                "fullDescription": {
                  "text": "値のない HTML の非ブール属性を報告します。 報告すべきでない属性を構成するよう提案します。",
                  "markdown": "値のない HTML の非ブール属性を報告します。 報告すべきでない属性を構成するよう提案します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownBooleanAttribute",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InconsistentLineSeparators",
                "shortDescription": {
                  "text": "矛盾する改行コード"
                },
                "fullDescription": {
                  "text": "プロジェクトの設定で指定されているものとは異なる改行コードがあるファイルを報告します。 たとえば、このインスペクションは「設定 | エディター | コードスタイル | 改行コード」で改行コードを '\\n' に設定しており、編集しているファイルの改行コードが '\\r\\n' の場合にトリガーされます。 このインスペクションは、ファイル内に混在している改行コードについても警告します。",
                  "markdown": "プロジェクトの設定で指定されているものとは異なる改行コードがあるファイルを報告します。\n\nたとえば、このインスペクションは「[設定 \\| エディター \\| コードスタイル \\| 改行コード](settings://preferences.sourceCode?Line%20separator)」で改行コードを `\\n` に設定しており、編集しているファイルの改行コードが `\n\\r\\n` の場合にトリガーされます。\n\nこのインスペクションは、ファイル内に混在している改行コードについても警告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InconsistentLineSeparators",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "一般",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantSuppression",
                "shortDescription": {
                  "text": "冗長な抑止"
                },
                "fullDescription": {
                  "text": "次の要素の使用箇所のうち、関係するインスペクションが対象のコンテキストに適用されなくなったため、安全に除去できるものを報告します。 '@SuppressWarning' アノテーション '// noinspection' 行コメント '/** noinspection */' JavaDoc コメント 例: 'public class C {\n // シンボルは private になっていますが、\n // アノテーションがまだ付いています\n  @SuppressWarnings({\"WeakerAccess\"})\n private boolean CONST = true;\n void f() {\n    CONST = false;\n  }\n}'",
                  "markdown": "次の要素の使用箇所のうち、関係するインスペクションが対象のコンテキストに適用されなくなったため、安全に除去できるものを報告します。\n\n* `@SuppressWarning` アノテーション\n* `// noinspection` 行コメント\n* `/** noinspection */` JavaDoc コメント\n\n例:\n\n\n    public class C {\n     // シンボルは private になっていますが、\n     // アノテーションがまだ付いています\n      @SuppressWarnings({\"WeakerAccess\"})\n     private boolean CONST = true;\n     void f() {\n        CONST = false;\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantSuppression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "一般",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProblematicWhitespace",
                "shortDescription": {
                  "text": "問題のある空白"
                },
                "fullDescription": {
                  "text": "以下の問題を報告します。 コードスタイルがスペースのみを使用するように構成されている場合に、タブがインデントに使用されている。 コードスタイルがタブのみを使用するように構成されている場合に、スペースがインデントに使用されている。 コードスタイルがスマートタブを使用するように構成されている場合に、スペースがインデントに、タブが位置合わせに使用されている。",
                  "markdown": "以下の問題を報告します。\n\n* コードスタイルがスペースのみを使用するように構成されている場合に、タブがインデントに使用されている。\n* コードスタイルがタブのみを使用するように構成されている場合に、スペースがインデントに使用されている。\n* コードスタイルがスマートタブを使用するように構成されている場合に、スペースがインデントに、タブが位置合わせに使用されている。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProblematicWhitespace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "一般",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlUnknownTarget",
                "shortDescription": {
                  "text": "リンク内の未解決ファイル"
                },
                "fullDescription": {
                  "text": "リンク内の未解決ファイルを報告します。",
                  "markdown": "リンク内の未解決ファイルを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownTarget",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LongLine",
                "shortDescription": {
                  "text": "コードスタイルで許可されている長さよりも長い行"
                },
                "fullDescription": {
                  "text": "「設定 | エディター | コードスタイル | 一般」で指定されている「ハードラップ」パラメーターよりも長い行を報告します。",
                  "markdown": "「[設定 \\| エディター \\| コードスタイル \\| 一般](settings://preferences.sourceCode?Hard%20wrap%20at)」で指定されている「**ハードラップ**」パラメーターよりも長い行を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LongLine",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "一般",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlWrongRootElement",
                "shortDescription": {
                  "text": "不正なルート要素"
                },
                "fullDescription": {
                  "text": "'<doctype>' タグで指定されている名前とは異なるルートタグ名を報告します。",
                  "markdown": "`<doctype>` タグで指定されている名前とは異なるルートタグ名を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlWrongRootElement",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlUnknownAttribute",
                "shortDescription": {
                  "text": "不明な属性"
                },
                "fullDescription": {
                  "text": "不明な HTML 属性を報告します。 報告すべきでない属性を構成するよう提案します。",
                  "markdown": "不明な HTML 属性を報告します。 報告すべきでない属性を構成するよう提案します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownAttribute",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpRedundantEscape",
                "shortDescription": {
                  "text": "冗長な文字エスケープ"
                },
                "fullDescription": {
                  "text": "意味を保持したままエスケープされていない文字に置換できる冗長な文字エスケープシーケンスを報告します。 文字クラスの外側で必要な多くのエスケープシーケンスは、文字クラスの角括弧 '[]' 内では冗長です。 一部のダイアレクト (JavaScript、Python など) では文字クラスの外側でエスケープされていない左波括弧 '{' を使用できますが、波括弧を文字としてエスケープすることを要求するダイアレクトが存在するため、このような表記は混乱を招き、パターンの移植性を低下させる可能性があります。 このため、このインスペクションはエススケープされた左波括弧を報告しません。 例: '\\-\\;[\\.]' クイックフィックス適用後: '-;[.]' 文字クラスの外側にある '\\}' および '\\]' がエスケープされていないことが正規表現ダイアレクトで許されている場合に報告するかどうかを指定するには、「エスケープされた右括弧 '}' と ']' を無視する」オプションを使用します。 2017.3 の新機能です",
                  "markdown": "意味を保持したままエスケープされていない文字に置換できる冗長な文字エスケープシーケンスを報告します。 文字クラスの外側で必要な多くのエスケープシーケンスは、文字クラスの角括弧 `[]` 内では冗長です。\n\n\n一部のダイアレクト (JavaScript、Python など) では文字クラスの外側でエスケープされていない左波括弧 `{` を使用できますが、波括弧を文字としてエスケープすることを要求するダイアレクトが存在するため、このような表記は混乱を招き、パターンの移植性を低下させる可能性があります。\nこのため、このインスペクションはエススケープされた左波括弧を報告しません。\n\n**例:**\n\n\n      \\-\\;[\\.]\n\nクイックフィックス適用後:\n\n\n      -;[.]\n\n\n文字クラスの外側にある `\\}` および `\\]` がエスケープされていないことが正規表現ダイアレクトで許されている場合に報告するかどうかを指定するには、「**エスケープされた右括弧 '}' と '\\]' を無視する**」オプションを使用します。\n\n2017.3 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpRedundantEscape",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CustomRegExpInspection",
                "shortDescription": {
                  "text": "カスタム正規表現インスペクション"
                },
                "fullDescription": {
                  "text": "カスタムの正規表現インスペクション",
                  "markdown": "カスタムの正規表現インスペクション"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CustomRegExpInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncorrectFormatting",
                "shortDescription": {
                  "text": "不適切なフォーマット"
                },
                "fullDescription": {
                  "text": "コードがプロジェクトのコードスタイル設定に従っていない場合に発生する書式の問題を報告します。 このインスペクションは Go や CLangFormat が有効になっている C など、コード整形用のサードパーティフォーマッターを必要とする言語とは互換性がありません。",
                  "markdown": "コードがプロジェクトのコードスタイル設定に従っていない場合に発生する書式の問題を報告します。\n\n\nこのインスペクションは Go や CLangFormat が有効になっている C など、コード整形用のサードパーティフォーマッターを必要とする言語とは互換性がありません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IncorrectFormatting",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "一般",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlExtraClosingTag",
                "shortDescription": {
                  "text": "冗長な終了タグ"
                },
                "fullDescription": {
                  "text": "'img' や 'br' など、空の要素で使用されている冗長な終了タグを報告します。 例: '<html>\n    <body>\n      <br></br>\n    </body>\n  </html>' クイックフィックス適用後: '<html>\n    <body>\n      <br>\n    </body>\n  </html>'",
                  "markdown": "`img` や `br` など、空の要素で使用されている冗長な終了タグを報告します。\n\n**例:**\n\n\n      <html>\n        <body>\n          <br></br>\n        </body>\n      </html>\n\nクイックフィックス適用後:\n\n\n      <html>\n        <body>\n          <br>\n        </body>\n      </html>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlExtraClosingTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpUnexpectedAnchor",
                "shortDescription": {
                  "text": "予期しない位置のアンカー開始または終了"
                },
                "fullDescription": {
                  "text": "パターンの先頭にない '^' または '\\A' アンカーと、パターンの末尾にない '$'、'\\Z'、または '\\z' アンカーを報告します。 これらの正規表現アンカーが誤った位置にある場合、パターンマッチングに支障が出ます。 '^' および '$' アンカーの場合はリテラル文字が意図されていた可能性が高く、エスケープが忘れられていると思われます。 例: '(Price $10)' 2018.1 の新機能です",
                  "markdown": "パターンの先頭にない `^` または `\\A` アンカーと、パターンの末尾にない `$`、`\\Z`、または `\\z` アンカーを報告します。 これらの正規表現アンカーが誤った位置にある場合、パターンマッチングに支障が出ます。 `^` および `$` アンカーの場合はリテラル文字が意図されていた可能性が高く、エスケープが忘れられていると思われます。\n\n**例:**\n\n\n      (Price $10)\n\n\n2018.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpUnexpectedAnchor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SpellCheckingInspection",
                "shortDescription": {
                  "text": "タイポ"
                },
                "fullDescription": {
                  "text": "コード、コメント、リテラル内のタイポとスペルミスを報告し、ワンクリックで修正します。",
                  "markdown": "コード、コメント、リテラル内のタイポとスペルミスを報告し、ワンクリックで修正します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SpellCheckingInspection",
                    "ideaSeverity": "TYPO",
                    "qodanaSeverity": "Low",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "校正",
                      "index": 89,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckXmlFileWithXercesValidator",
                "shortDescription": {
                  "text": "外部検証に失敗しました"
                },
                "fullDescription": {
                  "text": "XML ファイルにおける、指定した DTD または Xerces バリデーターが検出したスキーマとの矛盾を報告します。",
                  "markdown": "XML ファイルにおける、指定した DTD または Xerces バリデーターが検出したスキーマとの矛盾を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CheckXmlFileWithXercesValidator",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlUnknownTag",
                "shortDescription": {
                  "text": "不明なタグ"
                },
                "fullDescription": {
                  "text": "不明な HTML タグを報告します。 報告する必要のないタグを構成するよう提案します。",
                  "markdown": "不明な HTML タグを報告します。 報告する必要のないタグを構成するよう提案します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpEscapedMetaCharacter",
                "shortDescription": {
                  "text": "エスケープされたメタ文字"
                },
                "fullDescription": {
                  "text": "エスケープされたメタ文字を報告します。 一部の正規表現コーディングスタイルは、正規表現を理解しやすくするためにメタ文字を文字クラス内に配置するように規定しています。 このインスペクションはメタ文字 '['、']'、'^' については警告しません。これらは文字クラス内で追加のエスケープが必要になるためです。 例: '\\d+\\.\\d+' クイックフィックス適用後: '\\d+[.]\\d+' 2017.1 の新機能です",
                  "markdown": "エスケープされたメタ文字を報告します。 一部の正規表現コーディングスタイルは、正規表現を理解しやすくするためにメタ文字を文字クラス内に配置するように規定しています。 このインスペクションはメタ文字 `[`、`]`、`^` については警告しません。これらは文字クラス内で追加のエスケープが必要になるためです。\n\n**例:**\n\n\n      \\d+\\.\\d+\n\nクイックフィックス適用後:\n\n\n      \\d+[.]\\d+\n\n2017.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RegExpEscapedMetaCharacter",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlHighlighting",
                "shortDescription": {
                  "text": "XML ハイライト表示"
                },
                "fullDescription": {
                  "text": "バッチコードインスペクションの結果で見つかった XML 検証の問題を報告します。",
                  "markdown": "バッチコードインスペクションの結果で見つかった XML 検証の問題を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlHighlighting",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlDuplicatedId",
                "shortDescription": {
                  "text": "重複している 'id' 属性"
                },
                "fullDescription": {
                  "text": "XML にある冗長な 'id' 属性を報告します。",
                  "markdown": "XML にある冗長な `id` 属性を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlDuplicatedId",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpDuplicateCharacterInClass",
                "shortDescription": {
                  "text": "重複した文字がある文字クラス"
                },
                "fullDescription": {
                  "text": "正規表現の文字クラス内で重複している文字を報告します。 重複文字は不要であり、正規表現のセマンティクスを変更せずに除去できます。 例: '[aabc]' クイックフィックス適用後: '[abc]'",
                  "markdown": "正規表現の文字クラス内で重複している文字を報告します。 重複文字は不要であり、正規表現のセマンティクスを変更せずに除去できます。\n\n**例:**\n\n\n      [aabc]\n\nクイックフィックス適用後:\n\n\n      [abc]\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpDuplicateCharacterInClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlUnboundNsPrefix",
                "shortDescription": {
                  "text": "バインドされていない名前空間接頭辞"
                },
                "fullDescription": {
                  "text": "XML にあるバインドされていない名前空間接頭辞を報告します。",
                  "markdown": "XML にあるバインドされていない名前空間接頭辞を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "XmlUnboundNsPrefix",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RequiredAttributes",
                "shortDescription": {
                  "text": "必須属性の欠落"
                },
                "fullDescription": {
                  "text": "XML/HTML タグに欠落している必須属性を報告します。 報告すべきでない属性を構成するよう提案します。",
                  "markdown": "XML/HTML タグに欠落している必須属性を報告します。 報告すべきでない属性を構成するよう提案します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RequiredAttributes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlUnusedNamespaceDeclaration",
                "shortDescription": {
                  "text": "未使用のスキーマ宣言"
                },
                "fullDescription": {
                  "text": "XML にある未使用の名前空間宣言またはロケーションのヒントを報告します。",
                  "markdown": "XML にある未使用の名前空間宣言またはロケーションのヒントを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "XmlUnusedNamespaceDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpRedundantClassElement",
                "shortDescription": {
                  "text": "冗長な '\\d'、'[:digit:]'、または '\\D' クラス要素"
                },
                "fullDescription": {
                  "text": "'\\w' または '[:word:]' ('\\W' と '\\D') と共に 1 つのクラスで使用されており、除去できる冗長な '\\d' または '[:digit:]' を報告します。 例: '[\\w\\d]' クイックフィックス適用後: '[\\w]' 2022.2 の新機能です",
                  "markdown": "`\\w` または `[:word:]` (`\\W` と `\\D`) と共に 1 つのクラスで使用されており、除去できる冗長な `\\d` または `[:digit:]` を報告します。\n\n**例:**\n\n\n      [\\w\\d]\n\nクイックフィックス適用後:\n\n\n      [\\w]\n\n2022.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RegExpRedundantClassElement",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpSimplifiable",
                "shortDescription": {
                  "text": "正規表現は単純化できます"
                },
                "fullDescription": {
                  "text": "単純化できる正規表現を報告します。 例: '[a] xx* [ah-hz]' クイックフィックス適用後: 'a x+ [ahz]' 2022.1 の新機能です",
                  "markdown": "単純化できる正規表現を報告します。\n\n**例:**\n\n\n      [a] xx* [ah-hz]\n\nクイックフィックス適用後:\n\n\n      a x+ [ahz]\n\n2022.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RegExpSimplifiable",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpEmptyAlternationBranch",
                "shortDescription": {
                  "text": "論理和内の空の分岐"
                },
                "fullDescription": {
                  "text": "正規表現の論理和内にある空の分岐を報告します。 空の分岐は空の文字列にのみマッチし、ほとんどの場合は意図されているものではありません。 このインスペクションは、論理和の開始または終了にある単一の空の分岐を報告しません。 例: '(alpha||bravo)' クイックフィックス適用後: '(alpha|bravo)' 2017.2 の新機能です",
                  "markdown": "正規表現の論理和内にある空の分岐を報告します。 空の分岐は空の文字列にのみマッチし、ほとんどの場合は意図されているものではありません。 このインスペクションは、論理和の開始または終了にある単一の空の分岐を報告しません。\n\n**例:**\n\n\n      (alpha||bravo)\n\nクイックフィックス適用後:\n\n\n      (alpha|bravo)\n\n2017.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpEmptyAlternationBranch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlPathReference",
                "shortDescription": {
                  "text": "未解決のファイル参照"
                },
                "fullDescription": {
                  "text": "XML にある未解決のファイル参照を報告します。",
                  "markdown": "XML にある未解決のファイル参照を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlPathReference",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpUnnecessaryNonCapturingGroup",
                "shortDescription": {
                  "text": "不要な非キャプチャリンググループ"
                },
                "fullDescription": {
                  "text": "マッチングの結果に影響を与えない不要な非キャプチャグループを報告します。 例: 'Everybody be cool, (?:this) is a robbery!' クイックフィックス適用後: 'Everybody be cool, this is a robbery!' 2021.1 の新機能です",
                  "markdown": "マッチングの結果に影響を与えない不要な非キャプチャグループを報告します。\n\n**例:**\n\n\n      Everybody be cool, (?:this) is a robbery!\n\nクイックフィックス適用後:\n\n\n      Everybody be cool, this is a robbery!\n\n2021.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpUnnecessaryNonCapturingGroup",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TodoComment",
                "shortDescription": {
                  "text": "TODO コメント"
                },
                "fullDescription": {
                  "text": "コード内にある TODO コメントを報告します。 「設定 | エディター | TODO」で TODO コメントのフォーマットを構成できます。 実施すべきタスクの説明が入力されていない空の TODO コメントについてのみ警告するには、「詳細のない TODO コメントについてのみ警告」オプションを有効にします。 無効にすると、すべての TODO コメントが報告されます。",
                  "markdown": "コード内にある **TODO** コメントを報告します。\n\n「[設定 \\| エディター \\| TODO](settings://preferences.toDoOptions)」で **TODO** コメントのフォーマットを構成できます。\n\n実施すべきタスクの説明が入力されていない空の TODO コメントについてのみ警告するには、「**詳細のない TODO コメントについてのみ警告**」オプションを有効にします。 無効にすると、すべての TODO コメントが報告されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TodoComment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "一般",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlWrongAttributeValue",
                "shortDescription": {
                  "text": "属性値が正しくありません"
                },
                "fullDescription": {
                  "text": "不正な HTML 属性値を報告します。",
                  "markdown": "不正な HTML 属性値を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlWrongAttributeValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlDefaultAttributeValue",
                "shortDescription": {
                  "text": "デフォルト値を持つ冗長な属性"
                },
                "fullDescription": {
                  "text": "XML 属性のデフォルト値の冗長な代入を報告します。",
                  "markdown": "XML 属性のデフォルト値の冗長な代入を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "XmlDefaultAttributeValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyDirectory",
                "shortDescription": {
                  "text": "空のディレクトリ"
                },
                "fullDescription": {
                  "text": "空のディレクトリを報告します。 「コード | コードのインスペクション」または「コード | コードの解析 | インスペクション名を指定して実行」からのみ使用でき、エディター内では報告されません。 ソースルートの下にあるディレクトリのみを報告対象にするには、「ソースフォルダーの下にある空のディレクトリのみを報告する」オプションを使用します。",
                  "markdown": "空のディレクトリを報告します。\n\n「**コード \\| コードのインスペクション** 」または「**コード \\| コードの解析 \\| インスペクション名を指定して実行**」からのみ使用でき、エディター内では報告されません。\n\nソースルートの下にあるディレクトリのみを報告対象にするには、「**ソースフォルダーの下にある空のディレクトリのみを報告する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyDirectory",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "一般",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckDtdRefs",
                "shortDescription": {
                  "text": "未解決の DTD 参照"
                },
                "fullDescription": {
                  "text": "XML エンティティや DTD 要素宣言への参照など、DTD 固有の参照における矛盾を報告します。 DTD と XML ファイルで機能します。",
                  "markdown": "XML エンティティや DTD 要素宣言への参照など、DTD 固有の参照における矛盾を報告します。 DTD と XML ファイルで機能します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CheckDtdRefs",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonAsciiCharacters",
                "shortDescription": {
                  "text": "非 ASCII 文字"
                },
                "fullDescription": {
                  "text": "特殊なコンテキストで非 ASCII 文字を使用しているコード要素を報告します。 例: 識別子、文字列、またはコメントで使用されている非 ASCII 文字。 'myCollection' ('C' の文字がキリル文字で書かれている) のように異なる言語で書かれている識別子。 長破線や矢印などの Unicode 文字を含むコメントや文字列。",
                  "markdown": "特殊なコンテキストで非 ASCII 文字を使用しているコード要素を報告します。\n\n例:\n\n* 識別子、文字列、またはコメントで使用されている非 ASCII 文字。\n* `my`**C**`ollection` (**C** の文字がキリル文字で書かれている) のように異なる言語で書かれている識別子。\n* 長破線や矢印などの Unicode 文字を含むコメントや文字列。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonAsciiCharacters",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "国際化",
                      "index": 111,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LossyEncoding",
                "shortDescription": {
                  "text": "ロッシーエンコーディング"
                },
                "fullDescription": {
                  "text": "現在のドキュメントのエンコーディングが原因で表示できない文字を報告します。 例: US-ASCII 文字セットを使用するドキュメントに国際文字を入力すると、保存時に一部の文字が失われます。 ISO-8859-1 の 1バイト文字セットを使用して UTF-8 でエンコードされたファイルを読み込むと、一部の文字が正しく表示されません。 このような問題はファイルのエンコーティングを変更することで解決できます。たとえば、XML ファイルの XML prolog の 'encoding=' 属性を編集してファイル内で直接エンコーディングを指定するか、「設定 | エディター | ファイルエンコーディング」で対応するオプションを変更することができます。",
                  "markdown": "現在のドキュメントのエンコーディングが原因で表示できない文字を報告します。\n\n例:\n\n* **US-ASCII** 文字セットを使用するドキュメントに国際文字を入力すると、保存時に一部の文字が失われます。\n* **ISO-8859-1** の 1バイト文字セットを使用して **UTF-8** でエンコードされたファイルを読み込むと、一部の文字が正しく表示されません。\n\nこのような問題はファイルのエンコーティングを変更することで解決できます。たとえば、XML ファイルの XML prolog の `encoding=` 属性を編集してファイル内で直接エンコーディングを指定するか、「**設定 \\| エディター \\| ファイルエンコーディング**」で対応するオプションを変更することができます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LossyEncoding",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "国際化",
                      "index": 111,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IgnoreFileDuplicateEntry",
                "shortDescription": {
                  "text": "ファイルの重複を無視"
                },
                "fullDescription": {
                  "text": "無視対象ファイル (例: .gitignore、.hgignore) の重複するエントリ (パターン) を報告します。 該当するファイルの重複するエントリは冗長であるため、除去できます。 例: '# 出力ディレクトリ\n    /out/\n    /target/\n    /out/'",
                  "markdown": "無視対象ファイル (例: .gitignore、.hgignore) の重複するエントリ (パターン) を報告します。 該当するファイルの重複するエントリは冗長であるため、除去できます。\n\n例:\n\n\n        # 出力ディレクトリ\n        /out/\n        /target/\n        /out/\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IgnoreFileDuplicateEntry",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "バージョン管理",
                      "index": 116,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SSBasedInspection",
                "shortDescription": {
                  "text": "構造検索インスペクション"
                },
                "fullDescription": {
                  "text": "編集中のファイルに適用できる Structural Search/Structural Replace テンプレートの構成を許可します。 すべての一致がハイライトされ、構成したテンプレートの名前が付けられます。 Structural Replace パターンも構成する場合は、対応する置換オプションがクイックフィックスとして使用できるようになります。",
                  "markdown": "編集中のファイルに適用できる **Structural Search/Structural Replace** テンプレートの構成を許可します。\n\nすべての一致がハイライトされ、構成したテンプレートの名前が付けられます。\n**Structural Replace** パターンも構成する場合は、対応する置換オプションがクイックフィックスとして使用できるようになります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SSBasedInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "構造検索",
                      "index": 121,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckValidXmlInScriptTagBody",
                "shortDescription": {
                  "text": "不正な内容の 'script' タグ"
                },
                "fullDescription": {
                  "text": "'script' タグの内容が無効な XML になっているものを報告します。 例: '<script type=\"text/javascript\">\n    console.log('<');\n  </script>' クイックフィックス適用後: '<script type=\"text/javascript\">\n    console.log('&lt;');\n  </script>'",
                  "markdown": "`script` タグの内容が無効な XML になっているものを報告します。  \n\n**例:**\n\n\n      <script type=\"text/javascript\">\n        console.log('<');\n      </script>\n\nクイックフィックス適用後:\n\n\n      <script type=\"text/javascript\">\n        console.log('&lt;');\n      </script>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CheckValidXmlInScriptTagBody",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpSuspiciousBackref",
                "shortDescription": {
                  "text": "疑わしい後方参照"
                },
                "fullDescription": {
                  "text": "実行時に解決できない後方参照を報告します。 このような後方参照に一致するものはありません。 後方参照の後にグループが定義されている場合、またはグループが論理和の異なる分岐で定義されている場合、後方参照は解決されません。 後方参照の後に定義されているグループの例 '\\1(abc)' 異なる分岐にあるグループと後方参照の例 'a(b)c|(xy)\\1z' 2022.1 の新機能です",
                  "markdown": "実行時に解決できない後方参照を報告します。 このような後方参照に一致するものはありません。 後方参照の後にグループが定義されている場合、またはグループが論理和の異なる分岐で定義されている場合、後方参照は解決されません。\n\n**後方参照の後に定義されているグループの例**\n\n\n      \\1(abc)\n\n**異なる分岐にあるグループと後方参照の例**\n\n\n      a(b)c|(xy)\\1z\n\n2022.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpSuspiciousBackref",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpSingleCharAlternation",
                "shortDescription": {
                  "text": "単一文字の論理和"
                },
                "fullDescription": {
                  "text": "正規表現内にある単一文字の論理和を報告します。 代わりに文字クラスを使用するほうが簡潔です。 これにより、マッチングのパフォーマンスが向上する可能性もあります。 例: 'a|b|c|d' クイックフィックス適用後: '[abcd]' 2017.1 の新機能です",
                  "markdown": "正規表現内にある単一文字の論理和を報告します。 代わりに文字クラスを使用するほうが簡潔です。 これにより、マッチングのパフォーマンスが向上する可能性もあります。\n\n**例:**\n\n\n      a|b|c|d\n\nクイックフィックス適用後:\n\n\n      [abcd]\n\n\n2017.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpSingleCharAlternation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckTagEmptyBody",
                "shortDescription": {
                  "text": "空要素の内容"
                },
                "fullDescription": {
                  "text": "内容のない XML 要素を報告します。 例: '<user>\n    <name></name>\n  </user>' クイックフィックス適用後: '<user>\n    <name/>\n  </user>'",
                  "markdown": "内容のない XML 要素を報告します。\n\n**例:**\n\n\n      <user>\n        <name></name>\n      </user>\n\nクイックフィックス適用後:\n\n\n      <user>\n        <name/>\n      </user>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CheckTagEmptyBody",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnresolvedReference",
                "shortDescription": {
                  "text": "未解決の参照"
                },
                "fullDescription": {
                  "text": "XML 構文を使用する RELAX-NG ファイルにある名前付きパターンへの未解決の参照 ('define') を報告します。 参照先の 'define' 要素を作成するよう提案します。",
                  "markdown": "XML 構文を使用する RELAX-NG ファイルにある名前付きパターンへの未解決の参照 (`define`) を報告します。 参照先の `define` 要素を作成するよう提案します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "UnresolvedReference",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "RELAX NG",
                      "index": 124,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlMissingClosingTag",
                "shortDescription": {
                  "text": "終了タグの欠落"
                },
                "fullDescription": {
                  "text": "終了タグがない HTML 要素を報告します。 コーディングスタイルの中には、省略可能であっても HTML 要素の終了タグを要求するものがあります。 例: '<html>\n    <body>\n      <p>Behold!\n    </body>\n  </html>' クイックフィックス適用後: '<html>\n    <body>\n      <p>Behold!</p>\n    </body>\n  </html>'",
                  "markdown": "終了タグがない HTML 要素を報告します。 コーディングスタイルの中には、省略可能であっても HTML 要素の終了タグを要求するものがあります。\n\n**例:**\n\n\n      <html>\n        <body>\n          <p>Behold!\n        </body>\n      </html>\n\nクイックフィックス適用後:\n\n\n      <html>\n        <body>\n          <p>Behold!</p>\n        </body>\n      </html>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "HtmlMissingClosingTag",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlUnknownAnchorTarget",
                "shortDescription": {
                  "text": "リンク内の未解決フラグメント"
                },
                "fullDescription": {
                  "text": "URL の '#' 記号の後にある未解決の最後の部分を報告します。",
                  "markdown": "URL の `#` 記号の後にある未解決の最後の部分を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownAnchorTarget",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlInvalidId",
                "shortDescription": {
                  "text": "未解決の 'id' 参照"
                },
                "fullDescription": {
                  "text": "XML にある未解決の 'id' 参照を報告します。",
                  "markdown": "XML にある未解決の `id` 参照を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlInvalidId",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReassignedToPlainText",
                "shortDescription": {
                  "text": "プレーンテキストに再割り当て済み"
                },
                "fullDescription": {
                  "text": "プレーンテキストのファイルタイプに明示的に再割り当てされたファイルを報告します。 プラットフォームは内容に従って自動的にテキストファイルを検出するため、この関連付けは不要です。 「設定 | エディター | ファイルタイプ | テキスト」でファイルタイプの関連付けを除去すると、この警告を閉じることができます。",
                  "markdown": "プレーンテキストのファイルタイプに明示的に再割り当てされたファイルを報告します。 プラットフォームは内容に従って自動的にテキストファイルを検出するため、この関連付けは不要です。\n\n「**設定 \\| エディター \\| ファイルタイプ \\| テキスト**」でファイルタイプの関連付けを除去すると、この警告を閉じることができます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReassignedToPlainText",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "一般",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Annotator",
                "shortDescription": {
                  "text": "アノテーター"
                },
                "fullDescription": {
                  "text": "バッチコードインスペクションを実行した結果、このファイルで見つかった非常に重要な問題を報告します。 通常、このような問題はエディターで常にハイライトされ、インスペクションのように構成することはできません。 以下のオプションを使用すると、このインスペクションが実行するチェックの範囲を制御できます。 オプション「構文エラーを報告する」: パーサー関連の問題を報告します。 オプション「言語固有のアノテーターの問題を報告する」: 関連言語向けに構成されたアノテーターにより見つかった問題を報告します。 詳細は、カスタム言語サポート: アノテーターを参照してください。 オプション「その他のハイライトされている問題を報告する」: 現在のファイルの言語固有の問題 (たとえば、型の不一致、報告されない例外) を報告します。 詳細は、カスタム言語サポート: ハイライトを参照してください。",
                  "markdown": "バッチコードインスペクションを実行した結果、このファイルで見つかった非常に重要な問題を報告します。 通常、このような問題はエディターで常にハイライトされ、インスペクションのように構成することはできません。 以下のオプションを使用すると、このインスペクションが実行するチェックの範囲を制御できます。\n\n* オプション「**構文エラーを報告する**」: パーサー関連の問題を報告します。\n* オプション「**言語固有のアノテーターの問題を報告する** 」: 関連言語向けに構成されたアノテーターにより見つかった問題を報告します。 詳細は、[カスタム言語サポート: アノテーター](https://plugins.jetbrains.com/docs/intellij/annotator.html)を参照してください。\n* オプション「**その他のハイライトされている問題を報告する** 」: 現在のファイルの言語固有の問題 (たとえば、型の不一致、報告されない例外) を報告します。 詳細は、[カスタム言語サポート: ハイライト](https://plugins.jetbrains.com/docs/intellij/syntax-highlighting-and-error-highlighting.html#semantic-highlighting)を参照してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "Annotator",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "一般",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlDeprecatedElement",
                "shortDescription": {
                  "text": "非推奨のシンボル"
                },
                "fullDescription": {
                  "text": "非推奨の XML 要素または属性を報告します。 シンボルは 'deprecated' というテキストを含む XML コメントまたはドキュメントタグでマークできます。",
                  "markdown": "非推奨の XML 要素または属性を報告します。\n\nシンボルは 'deprecated' というテキストを含む XML コメントまたはドキュメントタグでマークできます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "XmlDeprecatedElement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpRedundantNestedCharacterClass",
                "shortDescription": {
                  "text": "冗長なネストした文字クラス"
                },
                "fullDescription": {
                  "text": "不要なネストした文字クラスを報告します。 例: '[a-c[x-z]]' クイックフィックス適用後: '[a-cx-z]' 2020.2 の新機能です",
                  "markdown": "不要なネストした文字クラスを報告します。\n\n**例:**\n\n\n      [a-c[x-z]]\n\nクイックフィックス適用後:\n\n\n      [a-cx-z]\n\n2020.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpRedundantNestedCharacterClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpOctalEscape",
                "shortDescription": {
                  "text": "8 進数のエスケープ"
                },
                "fullDescription": {
                  "text": "後方参照と混同されやすい 8 進数のエスケープを報告します。 混同を避けるため、16 進数のエスケープを使用してください。 例: '\\07' クイックフィックス適用後: '\\x07' 2017.1 の新機能です",
                  "markdown": "後方参照と混同されやすい 8 進数のエスケープを報告します。 混同を避けるため、16 進数のエスケープを使用してください。\n\n**例:**\n\n\n      \\07\n\nクイックフィックス適用後:\n\n\n      \\x07\n\n2017.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RegExpOctalEscape",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedDefine",
                "shortDescription": {
                  "text": "未使用の定義"
                },
                "fullDescription": {
                  "text": "RELAX-NG ファイル (XML または Compact 構文) にある未使用の名前付きパターン ('define') を報告します。 別のファイルで include によって使用されている 'define' 要素は無視されます。",
                  "markdown": "RELAX-NG ファイル (XML または Compact 構文) にある未使用の名前付きパターン (`define`) を報告します。 別のファイルで include によって使用されている `define` 要素は無視されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedDefine",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "RELAX NG",
                      "index": 124,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpAnonymousGroup",
                "shortDescription": {
                  "text": "匿名キャプチャーグループまたは数値バックリファレンス"
                },
                "fullDescription": {
                  "text": "正規表現内にある匿名キャプチャグループと数値の後方参照を報告します。 これらは、正規表現ダイアレクトが名前付きグループと名前付きグループ参照をサポートしている場合にのみ報告されます。 名前付きグループと名前付き後方参照はコードの可読性を向上させるため、これらを代わりに使用することをお勧めします。 キャプチャーが不要な場合は、非キャプチャグループを使用することで (例: '(?:xxx)' の代わりに '(xxx)' を使用する)、マッチングのパフォーマンスを向上させ、メモリ使用量を減らすことができます。 例: '(\\d\\d\\d\\d)\\1' より良い正規表現パターンは次のようになります。 '(?<quad>\\d\\d\\d\\d)\\k<quad>' 2017.2 の新機能です",
                  "markdown": "正規表現内にある匿名キャプチャグループと数値の後方参照を報告します。 これらは、正規表現ダイアレクトが名前付きグループと名前付きグループ参照をサポートしている場合にのみ報告されます。 名前付きグループと名前付き後方参照はコードの可読性を向上させるため、これらを代わりに使用することをお勧めします。 キャプチャーが不要な場合は、非キャプチャグループを使用することで (例: `(?:xxx)` の代わりに `(xxx)` を使用する)、マッチングのパフォーマンスを向上させ、メモリ使用量を減らすことができます。\n\n**例:**\n\n\n      (\\d\\d\\d\\d)\\1\n\nより良い正規表現パターンは次のようになります。\n\n\n      (?<quad>\\d\\d\\d\\d)\\k<quad>\n\n2017.2 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpAnonymousGroup",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlUnresolvedReference",
                "shortDescription": {
                  "text": "未解決の参照"
                },
                "fullDescription": {
                  "text": "XML にある未解決の参照を報告します。",
                  "markdown": "XML にある未解決の参照を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlUnresolvedReference",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 62,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpRepeatedSpace",
                "shortDescription": {
                  "text": "連続するスペース"
                },
                "fullDescription": {
                  "text": "正規表現内に複数のスペースが連続している場合に報告します。 デフォルトではスペースが表示されないため、必要なスペース数の確認が難しい可能性があります。 連続するスペースを単一のスペースと量指定子に置換することで、正規表現をより明確にすることができます。 例: '(     )' クイックフィックス適用後: '( {5})' 2017.1 の新機能です",
                  "markdown": "正規表現内に複数のスペースが連続している場合に報告します。 デフォルトではスペースが表示されないため、必要なスペース数の確認が難しい可能性があります。 連続するスペースを単一のスペースと量指定子に置換することで、正規表現をより明確にすることができます。\n\n**例:**\n\n\n      (     )\n\nクイックフィックス適用後:\n\n\n      ( {5})\n\n\n2017.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpRepeatedSpace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpDuplicateAlternationBranch",
                "shortDescription": {
                  "text": "論理和内の重複する分岐"
                },
                "fullDescription": {
                  "text": "正規表現の論理和内で重複している分岐を報告します。 分岐が重複しているとマッチング速度が低下し、式の意図が不明瞭になってしまいます。 例: '(alpha|bravo|charlie|alpha)' クイックフィックス適用後: '(alpha|bravo|charlie)' 2017.1 の新機能です",
                  "markdown": "正規表現の論理和内で重複している分岐を報告します。 分岐が重複しているとマッチング速度が低下し、式の意図が不明瞭になってしまいます。\n\n**例:**\n\n\n      (alpha|bravo|charlie|alpha)\n\nクイックフィックス適用後:\n\n\n      (alpha|bravo|charlie)\n\n2017.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpDuplicateAlternationBranch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正規表現",
                      "index": 80,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckEmptyScriptTag",
                "shortDescription": {
                  "text": "空のタグ"
                },
                "fullDescription": {
                  "text": "一部のブラウザーで機能しない空のタグを報告します。 例: '<html>\n    <script/>\n  </html>' クイックフィックス適用後: '<html>\n    <script></script>\n  </html>'",
                  "markdown": "一部のブラウザーで機能しない空のタグを報告します。\n\n**例:**\n\n\n      <html>\n        <script/>\n      </html>\n\nクイックフィックス適用後:\n\n\n      <html>\n        <script></script>\n      </html>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CheckEmptyScriptTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.java-i18n",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "UnusedMessageFormatParameter",
                "shortDescription": {
                  "text": "欠落したメッセージフォーマットパラメーター"
                },
                "fullDescription": {
                  "text": "'java.text.MessageFormat' フォーマット文字列のように見えるものの、'{xx}' の類のパラメーターを使用していないプロパティ値を報告します。 例: '# パラメーター {0} が使用されていない\nerror.message=Something happened in line {1}'",
                  "markdown": "`java.text.MessageFormat` フォーマット文字列のように見えるものの、`{xx}` の類のパラメーターを使用していないプロパティ値を報告します。\n\n例:\n\n\n    # パラメーター {0} が使用されていない\n    error.message=Something happened in line {1}\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedMessageFormatParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "プロパティファイル",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertToBasicLatin",
                "shortDescription": {
                  "text": "基本的でないラテン文字"
                },
                "fullDescription": {
                  "text": "基本的な英文字でないリテラルを報告し、Unicode エンティティへの置換を提案します。 例: '// © 2021\n  char c = '©';\n  String s = \"Áî\";'\n クイックフィックス適用後: '// &copy; 2021\n  char c = '\\u00a9';\n  String s = \"\\u00c1\\u00ee\";'",
                  "markdown": "基本的な英文字でないリテラルを報告し、Unicode エンティティへの置換を提案します。\n\n例:\n\n\n      // © 2021\n      char c = '©';\n      String s = \"Áî\";\n\nクイックフィックス適用後:\n\n\n      // &copy; 2021\n      char c = '\\u00a9';\n      String s = \"\\u00c1\\u00ee\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConvertToBasicLatin",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InconsistentResourceBundle",
                "shortDescription": {
                  "text": "整合性のないリソースバンドル"
                },
                "fullDescription": {
                  "text": "リソースバンドルに含まれているプロパティファイル内の問題を報告します。 欠落した翻訳を報告する 親プロパティファイルに含まれており、継承先にないプロパティ (言語のダイアレクトであるものを除く) を報告するには、このオプションを使用します。 例: '# messages.properties\n    abc=xxx\n\n    # messages_fr.properties\n    # 空のファイル' プロパティ 'abc' が未翻訳として報告されます。 矛盾するプロパティを報告する 継承先のプロパティファイルに含まれており、親 (親がない場合は兄弟) プロパティにないプロパティを報告するには、このオプションを使用します。 例: '# messages.properties\n    # 空のファイル\n\n    # messages_fr.properties\n    abc=xxx' この場合、プロパティ 'abc' の翻訳はフランス語以外の言語では存在しないため、(デフォルト) プロパティファイル 'messages.properties' に存在しないものとして報告されます。 同じ値でオーバーライドされているプロパティを報告する 複数のプロパティファイルに一字一句違わずコピーして貼り付けられているプロパティを報告するには、このオプションを使用します。 例: '# messages.properties\n    abc=xxx\n\n    # messages_fr.properties\n    abc=xxx' プロパティ 'abc' は 'messages_fr.properties' ファイルに不必要に継承されているため、報告されます。 矛盾するプレースホルダーを持つプロパティを報告する オーバーライドされたプロパティでのプレースホルダーの一貫性をチェックするには、このオプションを使用します。 例: '# messages.properties\n    qwe={0}xxx{1}\n    abc={0}yyy{1}\n\n    # messages_fr.properties\n    qwe={0}xxx{0}xxx{1}\n    abc={0}yyy' プロパティ 'abc' は 'messages.properties' に対応しないメッセージフォーマットプレースホルダーを含むプロパティとして報告されます。 末尾が矛盾するプロパティを報告する オーバーライドされたプロパティでの末尾の一貫性をチェックするには、このオプションを使用します。 例: '# messages.properties\n    abc=xxxzzz\n\n    # messages_fr.properties\n    abc=xxx;' プロパティ 'abc' は末尾が特殊記号 ('!' / '?' / '.' / ':' / ';') になっているのに対して、'messages.properties' にある親の値はそうではないと報告されます。",
                  "markdown": "リソースバンドルに含まれているプロパティファイル内の問題を報告します。\n\n* **欠落した翻訳を報告する**   \n\n  親プロパティファイルに含まれており、継承先にないプロパティ (言語のダイアレクトであるものを除く) を報告するには、このオプションを使用します。   \n\n  例:\n\n\n          # messages.properties\n          abc=xxx\n\n          # messages_fr.properties\n          # 空のファイル\n        \n  プロパティ `abc` が未翻訳として報告されます。   \n\n* **矛盾するプロパティを報告する**   \n\n  継承先のプロパティファイルに含まれており、親 (親がない場合は兄弟) プロパティにないプロパティを報告するには、このオプションを使用します。   \n\n  例:\n\n\n          # messages.properties\n          # 空のファイル\n\n          # messages_fr.properties\n          abc=xxx\n        \n  この場合、プロパティ `abc` の翻訳はフランス語以外の言語では存在しないため、(デフォルト) プロパティファイル `messages.properties` に存在しないものとして報告されます。   \n\n* **同じ値でオーバーライドされているプロパティを報告する**   \n\n  複数のプロパティファイルに一字一句違わずコピーして貼り付けられているプロパティを報告するには、このオプションを使用します。   \n\n  例:\n\n\n          # messages.properties\n          abc=xxx\n\n          # messages_fr.properties\n          abc=xxx\n        \n  プロパティ `abc` は `messages_fr.properties` ファイルに不必要に継承されているため、報告されます。   \n\n* **矛盾するプレースホルダーを持つプロパティを報告する**   \n\n  オーバーライドされたプロパティでのプレースホルダーの一貫性をチェックするには、このオプションを使用します。   \n\n  例:\n\n\n          # messages.properties\n          qwe={0}xxx{1}\n          abc={0}yyy{1}\n\n          # messages_fr.properties\n          qwe={0}xxx{0}xxx{1}\n          abc={0}yyy\n        \n  プロパティ `abc` は `messages.properties` に対応しないメッセージフォーマットプレースホルダーを含むプロパティとして報告されます。   \n\n* **末尾が矛盾するプロパティを報告する**   \n\n  オーバーライドされたプロパティでの末尾の一貫性をチェックするには、このオプションを使用します。   \n\n  例:\n\n\n          # messages.properties\n          abc=xxxzzz\n\n          # messages_fr.properties\n          abc=xxx;\n        \n  プロパティ `abc` は末尾が特殊記号 (`!` / `?` / `.` / `:` / `;`) になっているのに対して、`messages.properties` にある親の値はそうではないと報告されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "InconsistentResourceBundle",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "プロパティファイル",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HardCodedStringLiteral",
                "shortDescription": {
                  "text": "ハードコードされた文字列"
                },
                "fullDescription": {
                  "text": "ハードコードされている 'String' リテラルのインスタンスを報告します。 ハードコードされている 'String' リテラルは、国際化環境では誤りである可能性があります。 このインスペクションは、空の文字列と空白のみで構成された文字列は報告しません。 文字列リテラルを 'java.util.ResourceBundle.getString()' メソッドの呼び出しに変換するクイックフィックスを使用できます。",
                  "markdown": "ハードコードされている `String` リテラルのインスタンスを報告します。\n\nハードコードされている `String` リテラルは、国際化環境では誤りである可能性があります。 このインスペクションは、空の文字列と空白のみで構成された文字列は報告しません。 文字列リテラルを `java.util.ResourceBundle.getString()` メソッドの呼び出しに変換するクイックフィックスを使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HardCodedStringLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnsupportedCharacter",
                "shortDescription": {
                  "text": "サポート対象外の文字"
                },
                "fullDescription": {
                  "text": "Java 1.8 以前が使用されている場合、ISO-8859-1 文字セットによりサポートされていないプロパティファイル内の文字を報告します。 インスペクションはプロパティファイルに ISO-8859-1 にマップできない文字が含まれているかどうかをチェックし、互換性のある Unicode エスケープシーケンスに変換するよう提案します。 インスペクションの構成: ISO-8859-1 エンコーディングとの互換性を確保するには、「エスケープシーケンスに変換」クイックフィックスを使用します。 例: 'key=Java + ☕ = 🍀' クイックフィックス適用後: 'key=Java + \\u2615 = \\uD83C\\uDF40'",
                  "markdown": "Java 1.8 以前が使用されている場合、ISO-8859-1 文字セットによりサポートされていないプロパティファイル内の文字を報告します。 インスペクションはプロパティファイルに ISO-8859-1 にマップできない文字が含まれているかどうかをチェックし、互換性のある Unicode エスケープシーケンスに変換するよう提案します。\n\nインスペクションの構成:\n\n\nISO-8859-1 エンコーディングとの互換性を確保するには、「**エスケープシーケンスに変換**」クイックフィックスを使用します。\n\n**例:**\n\n\n      key=Java + ☕ = 🍀\n\nクイックフィックス適用後:\n\n\n      key=Java + \\u2615 = \\uD83C\\uDF40\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnsupportedCharacter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/プロパティファイル",
                      "index": 118,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DialogTitleCapitalization",
                "shortDescription": {
                  "text": "文字列の不正な大文字化"
                },
                "fullDescription": {
                  "text": "'@Nls' アノテーションが付いたメソッドパラメーターと戻り値の文字列を報告し、たいていのプラットフォームの UI ガイドラインに存在する大文字化ルールに準拠するようにパラメーターを大文字化します。 例: 'void setTitle(@NlsContexts.DialogTitle String title) {}\n  setTitle(\"This is sentence capitalization but should be title\");' クイックフィックス適用後: 'setTitle(\"This Is Sentence Capitalization but Should Be Title\");'",
                  "markdown": "`@Nls` アノテーションが付いたメソッドパラメーターと戻り値の文字列を報告し、たいていのプラットフォームの UI ガイドラインに存在する大文字化ルールに準拠するようにパラメーターを大文字化します。\n\n**例:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nクイックフィックス適用後:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DialogTitleCapitalization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnresolvedPropertyKey",
                "shortDescription": {
                  "text": "無効なプロパティキー"
                },
                "fullDescription": {
                  "text": "'@PropertyKey' アノテーションが付いたパラメーターを持つメソッドに渡されている無効な引数を報告します。 このような引数は、対応するプロパティファイルの有効なプロパティキーである必要があります。 また、このインスペクションは '@PropertyKey' アノテーションの 'resourceBundle' 引数が既存のリソースバンドルであることを検証します。 クイックフィックスを使用すると、新しいプロパティを作成するか、既存のプロパティを選択できます。 例: '@PropertyKey(resourceBundle = \"myBundle\") String value = \"invalid.key\";'",
                  "markdown": "`@PropertyKey` アノテーションが付いたパラメーターを持つメソッドに渡されている無効な引数を報告します。\n\nこのような引数は、対応するプロパティファイルの有効なプロパティキーである必要があります。\nまた、このインスペクションは `@PropertyKey` アノテーションの `resourceBundle` 引数が既存のリソースバンドルであることを検証します。\n\n\nクイックフィックスを使用すると、新しいプロパティを作成するか、既存のプロパティを選択できます。\n\n例:\n\n\n      @PropertyKey(resourceBundle = \"myBundle\") String value = \"invalid.key\";\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "UnresolvedPropertyKey",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/プロパティファイル",
                      "index": 118,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousLocalesLanguages",
                "shortDescription": {
                  "text": "疑わしいリソースバンドルのロケール言語"
                },
                "fullDescription": {
                  "text": "Java がサポートしていない言語コードを持つロケールを報告します。",
                  "markdown": "Java がサポートしていない言語コードを持つロケールを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousLocalesLanguages",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "プロパティファイル",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateStringLiteralInspection",
                "shortDescription": {
                  "text": "重複する文字列リテラル"
                },
                "fullDescription": {
                  "text": "重複する文字列リテラルで、プロジェクト全体を通して変更されないものを報告します。 2 つのクイックフィックスが提供されます。 1 つは重複する文字列に対応する定数を導入してそれをプロジェクト全体で使用するもので、もう 1 つは特定の文字列リテラルのすべての重複箇所を表示するものです。 例: 'class C1 { String CONST1 = \"duplicate string\"; }\n  class C2 { String CONST2 = \"duplicate string\"; }' インスペクションの構成: 重複を検出するのに必要な最小文字列長さを設定するには、「最小文字列長」を使用します。 'org.jetbrains.annotations.PropertyKey' のアノテーションが付いたメソッドに引数として渡されている文字列を無視するには、「@PropertyKey 式を無視する」オプションを使用します。",
                  "markdown": "重複する文字列リテラルで、プロジェクト全体を通して変更されないものを報告します。 2 つのクイックフィックスが提供されます。 1 つは重複する文字列に対応する定数を導入してそれをプロジェクト全体で使用するもので、もう 1 つは特定の文字列リテラルのすべての重複箇所を表示するものです。\n\n例:\n\n\n      class C1 { String CONST1 = \"duplicate string\"; }\n      class C2 { String CONST2 = \"duplicate string\"; }\n\nインスペクションの構成:\n\n* 重複を検出するのに必要な最小文字列長さを設定するには、「**最小文字列長**」を使用します。\n* `org.jetbrains.annotations.PropertyKey` のアノテーションが付いたメソッドに引数として渡されている文字列を無視するには、「**@PropertyKey 式を無視する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DuplicateStringLiteralInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国際化",
                      "index": 9,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.editorconfig.editorconfigjetbrains",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "EditorConfigRootDeclarationUniqueness",
                "shortDescription": {
                  "text": "不要なトップレベルの宣言"
                },
                "fullDescription": {
                  "text": "複数のトップレベル宣言が使用されていることを報告します。 EditorConfig ファイルでオプションに使用できる “root=true” トップレベル宣言は 1 つだけです。 複数のトップレベル宣言を使用することはできません。",
                  "markdown": "複数のトップレベル宣言が使用されていることを報告します。 EditorConfig ファイルでオプションに使用できる \"root=true\" トップレベル宣言は 1 つだけです。 複数のトップレベル宣言を使用することはできません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigRootDeclarationUniqueness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigNumerousWildcards",
                "shortDescription": {
                  "text": "多すぎるワイルドカード"
                },
                "fullDescription": {
                  "text": "ワイルドカードの数が多すぎるセクションを報告します。 ワイルドカードを多用すると、パフォーマンスに問題が出る場合があります。",
                  "markdown": "ワイルドカードの数が多すぎるセクションを報告します。 ワイルドカードを多用すると、パフォーマンスに問題が出る場合があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EditorConfigNumerousWildcards",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigKeyCorrectness",
                "shortDescription": {
                  "text": "不明なプロパティ"
                },
                "fullDescription": {
                  "text": "IDE がサポートしていないプロパティを報告します。 注意: 一部の “ij”ドメインのプロパティには、特定の言語プラグインが必要になる場合があります。",
                  "markdown": "IDE がサポートしていないプロパティを報告します。 注意: 一部の \"ij\"ドメインのプロパティには、特定の言語プラグインが必要になる場合があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigKeyCorrectness",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigEncoding",
                "shortDescription": {
                  "text": "ファイルエンコーディングが EditorConfig 文字セットに一致しません"
                },
                "fullDescription": {
                  "text": "現在のファイルエンコーディングが .editorconfig ファイルの \"charset\" プロパティで定義されているエンコーディングと一致することを確認します。",
                  "markdown": "現在のファイルエンコーディングが .editorconfig ファイルの \"charset\" プロパティで定義されているエンコーディングと一致することを確認します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigEncoding",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigRootDeclarationCorrectness",
                "shortDescription": {
                  "text": "予期しないトップレベルの宣言"
                },
                "fullDescription": {
                  "text": "予期しないトップレベル宣言を報告します。 EditorConfig ファイルでは “root=true” 以外のトップレベル宣言を使用できません。",
                  "markdown": "予期しないトップレベル宣言を報告します。 EditorConfig ファイルでは \"root=true\" 以外のトップレベル宣言を使用できません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigRootDeclarationCorrectness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigPatternRedundancy",
                "shortDescription": {
                  "text": "重複もしくは冗長なパターン"
                },
                "fullDescription": {
                  "text": "スコープが同じ、もしくはより広範なファイルを定義している別のパターンがすでに存在するために冗長になっているファイルパターンを報告します。 たとえば '[{*.java,*}]' の場合、最初の '*.java' パターンは '*' よりも狭いスコープを定義しています。 このため、最初のパターンは冗長であり、除去できます。",
                  "markdown": "スコープが同じ、もしくはより広範なファイルを定義している別のパターンがすでに存在するために冗長になっているファイルパターンを報告します。 たとえば `[{*.java,*}]` の場合、最初の `*.java` パターンは `*` よりも狭いスコープを定義しています。 このため、最初のパターンは冗長であり、除去できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigPatternRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigDeprecatedDescriptor",
                "shortDescription": {
                  "text": "非推奨のプロパティ"
                },
                "fullDescription": {
                  "text": "サポートが終了している EditorConfig プロパティを報告します。",
                  "markdown": "サポートが終了している EditorConfig プロパティを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigDeprecatedDescriptor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigShadowedOption",
                "shortDescription": {
                  "text": "オーバーライドされたプロパティ"
                },
                "fullDescription": {
                  "text": "すでに別のセクションで宣言されているプロパティを報告します。 例: '[*.java]\nindent_size=4\n[{*.java,*.js}]\nindent_size=2' 2 つ目のセクションにも 1 つ目のセクションと同様にすべての '*.java' ファイルが含まれていますが、同時に indent_size を再定義しています。 この結果、値「2」が '*.java' にマッチするファイルに使用されます。",
                  "markdown": "すでに別のセクションで宣言されているプロパティを報告します。\n\n例:\n\n\n    [*.java]\n    indent_size=4\n    [{*.java,*.js}]\n    indent_size=2\n\n2 つ目のセクションにも 1 つ目のセクションと同様にすべての `*.java` ファイルが含まれていますが、同時に indent_size を再定義しています。 この結果、値「2」が `*.java` にマッチするファイルに使用されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigShadowedOption",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigEmptyHeader",
                "shortDescription": {
                  "text": "空のヘッダー"
                },
                "fullDescription": {
                  "text": "ヘッダーが空のセクションを報告します。 セクションのヘッダーには、'gitignore' がサポートしているものと同様の書式で記述されたファイルパスの glob を含める必要があります。",
                  "markdown": "ヘッダーが空のセクションを報告します。 セクションのヘッダーには、`gitignore` がサポートしているものと同様の書式で記述されたファイルパスの glob を含める必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigEmptyHeader",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigValueUniqueness",
                "shortDescription": {
                  "text": "リストの値が一意ではありません"
                },
                "fullDescription": {
                  "text": "値のリストにある重複を報告します。",
                  "markdown": "値のリストにある重複を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigValueUniqueness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigMissingRequiredDeclaration",
                "shortDescription": {
                  "text": "必要な宣言がありません"
                },
                "fullDescription": {
                  "text": "必要な宣言がないプロパティを報告します。 詳しくは、ドキュメントを参照してください。",
                  "markdown": "必要な宣言がないプロパティを報告します。 詳しくは、ドキュメントを参照してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigMissingRequiredDeclaration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigSpaceInHeader",
                "shortDescription": {
                  "text": "ファイルパターン内のスペース"
                },
                "fullDescription": {
                  "text": "ワイルドカードパターンに含まれているスペース文字で、パターンマッチングに影響するものを報告します。 このような文字は、意図的に使用されていない場合は除去する必要があります。",
                  "markdown": "ワイルドカードパターンに含まれているスペース文字で、パターンマッチングに影響するものを報告します。 このような文字は、意図的に使用されていない場合は除去する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EditorConfigSpaceInHeader",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigOptionRedundancy",
                "shortDescription": {
                  "text": "冗長なプロパティ"
                },
                "fullDescription": {
                  "text": "別の適用可能なセクションに同じプロパティと値がすでに含まれているため、冗長になっているプロパティを報告します。 例: '[*]\nindent_size=4\n[*.java]\nindent_size=4' 上記は共に '*.java' ファイルに適用可能であり、同じ 'indent_size' の値を定義しています。",
                  "markdown": "別の適用可能なセクションに同じプロパティと値がすでに含まれているため、冗長になっているプロパティを報告します。\n\n\n例:\n\n\n    [*]\n    indent_size=4\n    [*.java]\n    indent_size=4\n\n上記は共に `*.java` ファイルに適用可能であり、同じ `indent_size` の値を定義しています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigOptionRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigUnexpectedComma",
                "shortDescription": {
                  "text": "予期しないコンマ"
                },
                "fullDescription": {
                  "text": "現在のコンテキストで使用できないコンマを報告します。 コンマは、リスト内の値を区切るための文字としてのみ使用できます。",
                  "markdown": "現在のコンテキストで使用できないコンマを報告します。 コンマは、リスト内の値を区切るための文字としてのみ使用できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigUnexpectedComma",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigCharClassRedundancy",
                "shortDescription": {
                  "text": "不要な文字クラス"
                },
                "fullDescription": {
                  "text": "1 文字からなる文字クラスを報告します。 このようなクラスは 1 つの文字に単純化できます (例: '[a]'→'a')。",
                  "markdown": "1 文字からなる文字クラスを報告します。 このようなクラスは 1 つの文字に単純化できます (例: `[a]`→`a`)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigCharClassRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigPartialOverride",
                "shortDescription": {
                  "text": "セクションのオーバーラップ"
                },
                "fullDescription": {
                  "text": "現在のセクションに指定されているファイルのサブセットで、別セクションの別サブセットと重複しているものを報告します。 たとえば、'[{foo,bar}]' と '[{foo,bas}]' はどちらも “foo” を含んでいます。",
                  "markdown": "現在のセクションに指定されているファイルのサブセットで、別セクションの別サブセットと重複しているものを報告します。 たとえば、`[{foo,bar}]` と `[{foo,bas}]` はどちらも \"foo\" を含んでいます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EditorConfigPartialOverride",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigEmptySection",
                "shortDescription": {
                  "text": "空のセクション"
                },
                "fullDescription": {
                  "text": "EditorConfig プロパティをまったく含んでいないセクションを報告します。",
                  "markdown": "EditorConfig プロパティをまったく含んでいないセクションを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigEmptySection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigShadowingOption",
                "shortDescription": {
                  "text": "オーバーライドするプロパティ"
                },
                "fullDescription": {
                  "text": "ファイル内で先に定義されている同じプロパティをオーバーライドしているプロパティを報告します。 例: '[*.java]\nindent_size=4\n[{*.java,*.js}]\nindent_size=2' 2 つ目のセクションは '[*.java]' と同じファイルを含んでいますが、同時に indent_size の値を「2」に設定しています。 そのため、最初の宣言 'indent_size=4' は無視されます。",
                  "markdown": "ファイル内で先に定義されている同じプロパティをオーバーライドしているプロパティを報告します。\n\n例:\n\n\n    [*.java]\n    indent_size=4\n    [{*.java,*.js}]\n    indent_size=2\n\n2 つ目のセクションは `[*.java]` と同じファイルを含んでいますが、同時に indent_size の値を「2」に設定しています。 そのため、最初の宣言 `indent_size=4` は無視されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigShadowingOption",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigListAcceptability",
                "shortDescription": {
                  "text": "予期しない値のリスト"
                },
                "fullDescription": {
                  "text": "リストがサポートされていないプロパティで使用されている値のリストを報告します。 このような場合、値は 1 つしか指定できません。",
                  "markdown": "リストがサポートされていないプロパティで使用されている値のリストを報告します。 このような場合、値は 1 つしか指定できません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigListAcceptability",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigPatternEnumerationRedundancy",
                "shortDescription": {
                  "text": "不要な波括弧"
                },
                "fullDescription": {
                  "text": "空の '{}' または '{foo}' のように 1 つのパターンのみを含むパターンリストを報告します。'{foo,bar}' のような複数のパターンを含むリストは対象外です。 この場合、波括弧は名前の一部として処理されます。 たとえば、パターン '*.{a}' はファイル 'my.{a}' と一致しますが、'my.a' とは一致しません。",
                  "markdown": "空の `{}` または `{foo}` のように 1 つのパターンのみを含むパターンリストを報告します。`{foo,bar}` のような複数のパターンを含むリストは対象外です。 この場合、波括弧は名前の一部として処理されます。 たとえば、パターン `*.{a}` はファイル `my.{a}` と一致しますが、`my.a` とは一致しません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigPatternEnumerationRedundancy",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigReferenceCorrectness",
                "shortDescription": {
                  "text": "無効な参照"
                },
                "fullDescription": {
                  "text": "不明、または型が不正な識別子を報告します。",
                  "markdown": "不明、または型が不正な識別子を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigReferenceCorrectness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigPairAcceptability",
                "shortDescription": {
                  "text": "予期しないキー/値ペア"
                },
                "fullDescription": {
                  "text": "現在のコンテキストでは使用できないキーと値のペアを報告します。",
                  "markdown": "現在のコンテキストでは使用できないキーと値のペアを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigPairAcceptability",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigNoMatchingFiles",
                "shortDescription": {
                  "text": "一致するファイルがない"
                },
                "fullDescription": {
                  "text": "'.editorconfig' ファイルがあるディレクトリ内にあるどのファイルとも一致しないワイルドカードパターンを使用しているセクションを報告します。",
                  "markdown": "`.editorconfig` ファイルがあるディレクトリ内にあるどのファイルとも一致しないワイルドカードパターンを使用しているセクションを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigNoMatchingFiles",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigWildcardRedundancy",
                "shortDescription": {
                  "text": "冗長なワイルドカード"
                },
                "fullDescription": {
                  "text": "同じセクションで “**” ワイルドカードが使用されると冗長になるワイルドカードを報告します。 “**” ワイルドカードは、他のあらゆるワイルドカードよりも幅広くファイルを定義します。 従って、同じセクションで使用されている他のワイルドカードは無効になるため、除去できます。",
                  "markdown": "同じセクションで \"\\*\\*\" ワイルドカードが使用されると冗長になるワイルドカードを報告します。\n\n\n\"\\*\\*\" ワイルドカードは、他のあらゆるワイルドカードよりも幅広くファイルを定義します。\n従って、同じセクションで使用されている他のワイルドカードは無効になるため、除去できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigWildcardRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigHeaderUniqueness",
                "shortDescription": {
                  "text": "EditorConfig セクションが一意ではありません"
                },
                "fullDescription": {
                  "text": "別セクションと同じファイルパターンを定義しているセクションを報告します。",
                  "markdown": "別セクションと同じファイルパターンを定義しているセクションを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigHeaderUniqueness",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigValueCorrectness",
                "shortDescription": {
                  "text": "無効なプロパティ値"
                },
                "fullDescription": {
                  "text": "値の制限を満たしていないプロパティ値を報告します。 たとえば、“true” か “false” にしかなり得ないプロパティもあれば、整数しか持たないプロパティもあります。 値の種類が限られている場合は、コード補完を使えばすべての種類を表示できます。",
                  "markdown": "値の制限を満たしていないプロパティ値を報告します。 たとえば、\"true\" か \"false\" にしかなり得ないプロパティもあれば、整数しか持たないプロパティもあります。 値の種類が限られている場合は、コード補完を使えばすべての種類を表示できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigValueCorrectness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigVerifyByCore",
                "shortDescription": {
                  "text": "無効な .editorconfig ファイル"
                },
                "fullDescription": {
                  "text": "バッキング EditorConfig コアライブラリを使用しているファイル全体を検証し、エラーを報告します。 このようなエラーがある場合、EditorConfig プロパティは正しく適用されません。",
                  "markdown": "バッキング EditorConfig コアライブラリを使用しているファイル全体を検証し、エラーを報告します。 このようなエラーがある場合、EditorConfig プロパティは正しく適用されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigVerifyByCore",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigCharClassLetterRedundancy",
                "shortDescription": {
                  "text": "文字クラスの重複文字"
                },
                "fullDescription": {
                  "text": "EditorConfig セクションのワイルドカードパターンで、文字クラス内に重複した文字を含むものを報告します (例: '[aa]')。",
                  "markdown": "EditorConfig セクションのワイルドカードパターンで、文字クラス内に重複した文字を含むものを報告します (例: `[aa]`)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigCharClassLetterRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigUnusedDeclaration",
                "shortDescription": {
                  "text": "未使用の宣言"
                },
                "fullDescription": {
                  "text": "未使用の宣言を報告します。 このような宣言は除去できます。",
                  "markdown": "未使用の宣言を報告します。 このような宣言は除去できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigUnusedDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 33,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.plugins.gradle",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "ForeignDelegate",
                "shortDescription": {
                  "text": "誤って配置された可能性がある Gradle メソッドへの呼び出し"
                },
                "fullDescription": {
                  "text": "誤って配置されている可能性がある Gradle メソッドの呼び出しを検出します。 Gradle ビルドスクリプトは多くのネストしたクロージャで構成されているため、コード構造がマークアップ言語に似ています。 DSL 言語の動作により、外部クロージャに書き込めるメソッドは内部クロージャでも使用できます。 そのようなメソッドは、スコープ外で書き込まれている場合には意味を持たない可能性があります。 この状況を検出することは困難な場合があります。 このインスペクションはそのようなメソッドを検出することを目的としています。 例: 'repositories {\n  // 'repositories' の委譲に 'exclusiveContent' メソッドがあり、ここに書き込むことができます\n  maven {\n    // 'maven'  の委譲に 'content' メソッドがあり、ここに書き込むことができますが、\n    // 'exclusiveContent' も使用できます\n    exclusiveContent {} // 'exclusiveContent' が報告されます\n  }\n}'",
                  "markdown": "誤って配置されている可能性がある Gradle メソッドの呼び出しを検出します。\nGradle ビルドスクリプトは多くのネストしたクロージャで構成されているため、コード構造がマークアップ言語に似ています。 DSL 言語の動作により、外部クロージャに書き込めるメソッドは内部クロージャでも使用できます。 そのようなメソッドは、スコープ外で書き込まれている場合には意味を持たない可能性があります。   \nこの状況を検出することは困難な場合があります。 このインスペクションはそのようなメソッドを検出することを目的としています。\n\n**例:**\n\n\n    repositories {\n      // 'repositories' の委譲に 'exclusiveContent' メソッドがあり、ここに書き込むことができます\n      maven {\n        // 'maven'  の委譲に 'content' メソッドがあり、ここに書き込むことができますが、\n        // 'exclusiveContent' も使用できます\n        exclusiveContent {} // 'exclusiveContent' が報告されます\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ForeignDelegate",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/潜在的なバグ",
                      "index": 41,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncorrectPluginDslStructure",
                "shortDescription": {
                  "text": "プラグイン DSL 構造"
                },
                "fullDescription": {
                  "text": "'plugins {}' ブロックの前の許可されていないステートメントを検出します。 Gradle プラグインの DSL には制限があるため、''plugins {}'' ブロックの前には限られた Groovy ステートメントのみを使用できます。 使用できるのは、''buildscript {}''、''pluginManagement {}''、およびその他の ''plugins {}'' です。 Gradle のドキュメントを参照する 例: 'import foo.bar.Baz\nplugins {} // 'plugins' が報告されます\nplugins {\n  foo() // 'foo' が報告されます\n  id 'java'\n}'",
                  "markdown": "'plugins {}' ブロックの前の許可されていないステートメントを検出します。\nGradle プラグインの DSL には制限があるため、'`plugins {}`' ブロックの前には限られた Groovy ステートメントのみを使用できます。 使用できるのは、'`buildscript {}`'、'`pluginManagement {}`'、およびその他の '`plugins {}`' です。   \n[Gradle のドキュメントを参照する](https://docs.gradle.org/current/userguide/plugins.html#plugins_dsl_limitations)\n\n**例:**\n\n\n    import foo.bar.Baz\n    plugins {} // 'plugins' が報告されます\n    plugins {\n      foo() // 'foo' が報告されます\n      id 'java'\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "IncorrectPluginDslStructure",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/妥当性の問題",
                      "index": 48,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BintrayPublishingPlugin",
                "shortDescription": {
                  "text": "Bintray 公開プラグインは 2021 年 5 月 1 日に機能しなくなる可能性があります"
                },
                "fullDescription": {
                  "text": "Gradle プラグイン 'com.jfrog.bintray' の使用を検出します。 このプラグインは、ビルド結果を Bintray に公開するために使用されます。 Bintray サービスへの公開は無効化されています。",
                  "markdown": "Gradle プラグイン `com.jfrog.bintray` の使用を検出します。\nこのプラグインは、ビルド結果を Bintray に公開するために使用されます。\n[Bintray](https://www.jfrog.com/confluence/display/BT/Welcome+to+JFrog+Bintray) サービスへの公開は無効化されています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BintrayPublishingPlugin",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/潜在的なバグ",
                      "index": 41,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DependencyNotationArgument",
                "shortDescription": {
                  "text": "認識できない依存関係表記"
                },
                "fullDescription": {
                  "text": "不正な依存関係表記を検出します。 次の型/書式が Gradle によってサポートされています。 'Dependency' のインスタンス 'String' または 'CharSequence' 値。例: ''org.gradle:gradle-core:1.0'' マップ。例: '[group: 'org.gradle', name: 'gradle-core', version: '1.0']' FileCollection。例: 'files('some.jar', 'someOther.jar')' プロジェクト。例: 'project(':some:project:path')' 'ClassPathNotation'。例: 'gradleApi()' 依存関係表記のリスト。例: '['org.gradle:gradle-core:1.0']' (Gradle 7.0+) バージョンカタログアクセサー。例: 'libs.groovy.core' Gradle のドキュメントを参照する 例: 'dependencies {\n  implementation(1) // reports '1'\n}'",
                  "markdown": "不正な依存関係表記を検出します。\n次の型/書式が Gradle によってサポートされています。\n\n* `Dependency` のインスタンス\n* `String` または `CharSequence` 値。例: `'org.gradle:gradle-core:1.0'`\n* マップ。例: `[group: 'org.gradle', name: 'gradle-core', version: '1.0']`\n* FileCollection。例: `files('some.jar', 'someOther.jar')`\n* プロジェクト。例: `project(':some:project:path')`\n* `ClassPathNotation`。例: `gradleApi()`\n* 依存関係表記のリスト。例: `['org.gradle:gradle-core:1.0']`\n* (Gradle 7.0+) [バージョンカタログアクセサー](https://docs.gradle.org/current/userguide/platforms.html)。例: `libs.groovy.core`\n\n[Gradle のドキュメントを参照する](https://docs.gradle.org/current/userguide/declaring_dependencies.html#sec:dependency-types)\n\n**例:**\n\n\n    dependencies {\n      implementation(1) // reports '1'\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DependencyNotationArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/潜在的なバグ",
                      "index": 41,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedConfigurations",
                "shortDescription": {
                  "text": "非推奨の構成"
                },
                "fullDescription": {
                  "text": "非推奨になった構成メソッドの使用箇所を検出します。 構成メソッドは、次の 2 つの理由で非推奨になる場合があります。 Gradle API が進化したため、従来のメソッドの選択を避ける必要がある。 非推奨になった構成メソッドの改良版を提供するプラグインがある。 多くの場合、非推奨になったメソッドの代替となるものが提供されます。 例: 'plugins {\n  id 'java'\n}\n\ndependencies {\n  archive 'org.gradle.api:gradle:1.0' // reports 'archive'\n}'",
                  "markdown": "非推奨になった構成メソッドの使用箇所を検出します。\n構成メソッドは、次の 2 つの理由で非推奨になる場合があります。\n\n* Gradle API が進化したため、従来のメソッドの選択を避ける必要がある。\n* 非推奨になった構成メソッドの改良版を提供するプラグインがある。\n\n多くの場合、非推奨になったメソッドの代替となるものが提供されます。\n\n**例:**\n\n\n    plugins {\n      id 'java'\n    }\n\n    dependencies {\n      archive 'org.gradle.api:gradle:1.0' // reports 'archive'\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeprecatedConfigurations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/妥当性の問題",
                      "index": 48,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedVersionCatalogEntry",
                "shortDescription": {
                  "text": "未使用のバージョンカタログのエントリ"
                },
                "fullDescription": {
                  "text": "バージョンカタログの TOML 記述子にある未使用のキーを検出します。 例: '// build.gradle\ndependencies {\n  implementation libs.foo.bar\n}' '# libs.versions.toml\n[libraries]\nfoo-bar = \"com.gradle:example:1.0.0\"\nbar-baz = \"com.gradle:example:2.0.0\" # bar-baz がハイライトされます'",
                  "markdown": "バージョンカタログの TOML 記述子にある未使用のキーを検出します。\n\n**例:**\n\n\n    // build.gradle\n    dependencies {\n      implementation libs.foo.bar\n    }\n\n\n    # libs.versions.toml\n    [libraries]\n    foo-bar = \"com.gradle:example:1.0.0\"\n    bar-baz = \"com.gradle:example:2.0.0\" # bar-baz がハイライトされます\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedVersionCatalogEntry",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/スタイル",
                      "index": 122,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultipleRepositoryUrls",
                "shortDescription": {
                  "text": "複数のリポジトリ URL"
                },
                "fullDescription": {
                  "text": "各リポジトリ (Maven または Ivy) ブロックに対して複数の URL が使用されていることを報告します。 リポジトリには 1 つの URL しか取得されないため、残りの URL は無視されます。",
                  "markdown": "各リポジトリ (Maven または Ivy) ブロックに対して複数の URL が使用されていることを報告します。 リポジトリには 1 つの URL しか取得されないため、残りの URL は無視されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MultipleRepositoryUrls",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/潜在的なバグ",
                      "index": 41,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JCenterRepository",
                "shortDescription": {
                  "text": "2022 年 2 月 1 日以降のビルドは JCenter のアーティファクトを解決できなくなります。"
                },
                "fullDescription": {
                  "text": "依存関係の解決を目的とした JCenter リポジトリの使用を検出します。 2022 年 2 月 1 日以降のビルドは JCenter のアーティファクトを解決できなくなります。",
                  "markdown": "依存関係の解決を目的とした JCenter リポジトリの使用を検出します。 2022 年 2 月 1 日以降のビルドは JCenter のアーティファクトを解決できなくなります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JCenterRepository",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/潜在的なバグ",
                      "index": 41,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfigurationAvoidance",
                "shortDescription": {
                  "text": "構成の回避"
                },
                "fullDescription": {
                  "text": "(Gradle 4.9 以降) タスクと一括で対話する API の使用箇所を検出します。 タスクの一括対話型処理は次のような不都合を引き起こします。 ユーザーがタスク間のすべての依存関係を手動で設定する必要あります。 構成フェーズでは、後で実行されないものも含め、一括 API 経由でアクセスされるすべてのタスクが構成されます。 その結果、パフォーマンスが低下します。 最終的には遅延 API が推奨され、一括 API は非推奨になります。 移行ガイドについては、Gradle のドキュメントを参照してください。 例: 'task foo { // 'task' を報告し、'task.register' への置換を提案します\n  // ...\n}'",
                  "markdown": "(Gradle 4.9 以降) タスクと一括で対話する API の使用箇所を検出します。\n\nタスクの一括対話型処理は次のような不都合を引き起こします。\n\n* ユーザーがタスク間のすべての依存関係を手動で設定する必要あります。\n* [構成フェーズ](https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:build_phases)では、後で実行されないものも含め、一括 API 経由でアクセスされるすべてのタスクが構成されます。 その結果、パフォーマンスが低下します。\n\n最終的には遅延 API が推奨され、一括 API は非推奨になります。\n\n移行ガイドについては、[Gradle のドキュメント](https://docs.gradle.org/current/userguide/task_configuration_avoidance.html)を参照してください。\n\n**例:**\n\n    task foo { // 'task' を報告し、'task.register' への置換を提案します\n      // ...\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfigurationAvoidance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Gradle/ベストプラクティス",
                      "index": 130,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "HtmlTools",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "HtmlRequiredAltAttribute",
                "shortDescription": {
                  "text": "必須 'alt' 属性の欠落"
                },
                "fullDescription": {
                  "text": "'img' または 'applet' タグ、または画像マップの 'area' 要素に欠落している 'alt' 属性を報告します。 必須属性とタグのコンテンツの代替テキストを追加するよう提案します。 WCAG 2.0: H24、H35、H36、H37 に基づいています。",
                  "markdown": "`img` または `applet` タグ、または画像マップの `area` 要素に欠落している `alt` 属性を報告します。 必須属性とタグのコンテンツの代替テキストを追加するよう提案します。 WCAG 2.0: [H24](https://www.w3.org/TR/WCAG20-TECHS/H24.html)、[H35](https://www.w3.org/TR/WCAG20-TECHS/H35.html)、[H36](https://www.w3.org/TR/WCAG20-TECHS/H36.html)、[H37](https://www.w3.org/TR/WCAG20-TECHS/H37.html) に基づいています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlRequiredAltAttribute",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML/アクセシビリティ",
                      "index": 43,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlDeprecatedTag",
                "shortDescription": {
                  "text": "廃止されたタグ"
                },
                "fullDescription": {
                  "text": "廃止された HTML 5 タグを報告します。 廃止されたタグを CSS または別のタグに置換するよう提案します。",
                  "markdown": "廃止された HTML 5 タグを報告します。 廃止されたタグを CSS または別のタグに置換するよう提案します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlDeprecatedTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckImageSize",
                "shortDescription": {
                  "text": "画像サイズの不一致"
                },
                "fullDescription": {
                  "text": "参照先画像の実際の幅と高さと異なっている 'img' タグの 'width' と 'height' の属性値を報告します。",
                  "markdown": "参照先画像の実際の幅と高さと異なっている `img` タグの `width` と `height` の属性値を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CheckImageSize",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Performance"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlRequiredSummaryAttribute",
                "shortDescription": {
                  "text": "必須 'summary' 属性の欠落"
                },
                "fullDescription": {
                  "text": "'table' タグに欠落している 'summary' 属性を報告します。 'summary' 属性を追加するよう提案します。 WCAG 2.0: H73 に基づいています。",
                  "markdown": "`table` タグに欠落している `summary` 属性を報告します。 `summary` 属性を追加するよう提案します。 WCAG 2.0: [H73](https://www.w3.org/TR/WCAG20-TECHS/H73.html) に基づいています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "HtmlRequiredSummaryAttribute",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML/アクセシビリティ",
                      "index": 43,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlNonExistentInternetResource",
                "shortDescription": {
                  "text": "未解決の Web リンク"
                },
                "fullDescription": {
                  "text": "未解決の Web リンクを報告します。 バックグラウンドでネットワークリクエストを発行して動作します。",
                  "markdown": "未解決の Web リンクを報告します。 バックグラウンドでネットワークリクエストを発行して動作します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlNonExistentInternetResource",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlFormInputWithoutLabel",
                "shortDescription": {
                  "text": "Form input without an associated label or title attribute"
                },
                "fullDescription": {
                  "text": "関連するラベルのない form 要素 ('input'、'textarea'、または 'select') を報告します。 新しいラベルを作成するよう提案します。 WCAG 2.0: H44 に基づいています。",
                  "markdown": "関連するラベルのない form 要素 (`input`、`textarea`、または `select`) を報告します。 新しいラベルを作成するよう提案します。 WCAG 2.0: [H44](https://www.w3.org/TR/WCAG20-TECHS/H44.html) に基づいています。  "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlFormInputWithoutLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML/アクセシビリティ",
                      "index": 43,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlRequiredTitleAttribute",
                "shortDescription": {
                  "text": "必須 'title' 属性の欠落"
                },
                "fullDescription": {
                  "text": "'frame'、'iframe'、'dl'、および 'a' タグに欠落している title 属性を報告します。 title 属性を追加するよう提案します。 WCAG 2.0: H33、H40、および H64 に基づいています。",
                  "markdown": "`frame`、`iframe`、`dl`、および `a` タグに欠落している title 属性を報告します。 title 属性を追加するよう提案します。 WCAG 2.0: [H33](https://www.w3.org/TR/WCAG20-TECHS/H33.html)、[H40](https://www.w3.org/TR/WCAG20-TECHS/H40.html)、および [H64](https://www.w3.org/TR/WCAG20-TECHS/H64.html) に基づいています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "HtmlRequiredTitleAttribute",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML/アクセシビリティ",
                      "index": 43,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlRequiredLangAttribute",
                "shortDescription": {
                  "text": "必須 'lang' 属性の欠落"
                },
                "fullDescription": {
                  "text": "'html' タグに欠落している 'lang' (または 'xml:lang') 属性を報告します。 ドキュメントのデフォルト言語を指定する必須属性を追加するよう提案します。 WCAG 2.0: H57 に基づいています。",
                  "markdown": "`html` タグに欠落している `lang` (または `xml:lang`) 属性を報告します。 ドキュメントのデフォルト言語を指定する必須属性を追加するよう提案します。 WCAG 2.0: [H57](https://www.w3.org/TR/WCAG20-TECHS/H57.html) に基づいています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlRequiredLangAttribute",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML/アクセシビリティ",
                      "index": 43,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlRequiredTitleElement",
                "shortDescription": {
                  "text": "必須 'title' 要素の欠落"
                },
                "fullDescription": {
                  "text": "'head' セクション内に欠落している 'title' 要素を報告します。 'title' 要素を追加するよう提案します。 title にはドキュメントを説明する内容を記述する必要があります。 WCAG 2.0: H25 に基づいています。",
                  "markdown": "`head` セクション内に欠落している `title` 要素を報告します。 `title` 要素を追加するよう提案します。 title にはドキュメントを説明する内容を記述する必要があります。 WCAG 2.0: [H25](https://www.w3.org/TR/WCAG20-TECHS/H25.html) に基づいています。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlRequiredTitleElement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML/アクセシビリティ",
                      "index": 43,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlDeprecatedAttribute",
                "shortDescription": {
                  "text": "廃止された属性"
                },
                "fullDescription": {
                  "text": "廃止された HTML 5 属性を報告します。",
                  "markdown": "廃止された HTML 5 属性を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlDeprecatedAttribute",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlPresentationalElement",
                "shortDescription": {
                  "text": "表現用タグ"
                },
                "fullDescription": {
                  "text": "表現用の HTML タグを報告します。 表現用タグを CSS または別のタグに置換するよう提案します。",
                  "markdown": "表現用の HTML タグを報告します。 表現用タグを CSS または別のタグに置換するよう提案します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "HtmlPresentationalElement",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 30,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.plugins.yaml",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "YAMLSchemaValidation",
                "shortDescription": {
                  "text": "JSON スキーマによる検証"
                },
                "fullDescription": {
                  "text": "YAML ファイルと JSON スキーマ間の矛盾を報告します (スキーマが指定されている場合)。 スキーマの例: '{\n    \"properties\": {\n      \"SomeNumberProperty\": {\n        \"type\": \"number\"\n      }\n    }\n  }' 以下は、対応する警告を示した例です。 'SomeNumberProperty: hello world'",
                  "markdown": "YAML ファイルと JSON スキーマ間の矛盾を報告します (スキーマが指定されている場合)。\n\n**スキーマの例:**\n\n\n      {\n        \"properties\": {\n          \"SomeNumberProperty\": {\n            \"type\": \"number\"\n          }\n        }\n      }\n\n**以下は、対応する警告を示した例です。**\n\n\n      SomeNumberProperty: hello world\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "YAMLSchemaValidation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 59,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLUnresolvedAlias",
                "shortDescription": {
                  "text": "未解決のエイリアス"
                },
                "fullDescription": {
                  "text": "YAML ファイルにある未解決のエイリアスを報告します。 例: 'some_key: *unknown_alias'",
                  "markdown": "YAML ファイルにある未解決のエイリアスを報告します。\n\n**例:**\n\n\n      some_key: *unknown_alias\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "YAMLUnresolvedAlias",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 59,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLSchemaDeprecation",
                "shortDescription": {
                  "text": "非推奨の YAML キー"
                },
                "fullDescription": {
                  "text": "YAML ファイルにある非推奨のキーを報告します。 非推奨であるかどうかは、対応する YAML ファイルに関連する JSON スキーマが存在する場合にのみチェックされます。 非推奨メカニズムはまだ JSON スキーマの仕様で定義されていないため、このインスペクションでは非標準的な拡張機能である 'deprecationMessage' が使用されます。 非推奨スキーマの例: '{\n    \"properties\": {\n      \"SomeDeprecatedProperty\": {\n        \"deprecationMessage\": \"Baz\",\n        \"description\": \"Foo bar\"\n      }\n    }\n  }' 以下は、対応する警告を示した例です。 'SomeDeprecatedProperty: some value'",
                  "markdown": "YAML ファイルにある非推奨のキーを報告します。\n\n非推奨であるかどうかは、対応する YAML ファイルに関連する JSON スキーマが存在する場合にのみチェックされます。\n\n非推奨メカニズムはまだ JSON スキーマの仕様で定義されていないため、このインスペクションでは非標準的な拡張機能である `deprecationMessage` が使用されます。\n\n**非推奨スキーマの例:**\n\n\n      {\n        \"properties\": {\n          \"SomeDeprecatedProperty\": {\n            \"deprecationMessage\": \"Baz\",\n            \"description\": \"Foo bar\"\n          }\n        }\n      }\n\n**以下は、対応する警告を示した例です。**\n\n\n      SomeDeprecatedProperty: some value\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "YAMLSchemaDeprecation",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 59,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLIncompatibleTypes",
                "shortDescription": {
                  "text": "疑わしい型の不一致"
                },
                "fullDescription": {
                  "text": "YAML ファイルにあるスカラー値の型と同様の位置にある値の型の不一致を報告します。 例: 'myElements:\n  - value1\n  - value2\n  - false # <- これはブール値ですが、その他の値は文字列であるため、報告されます'",
                  "markdown": "YAML ファイルにあるスカラー値の型と同様の位置にある値の型の不一致を報告します。\n\n**例:**\n\n\n    myElements:\n      - value1\n      - value2\n      - false # <- これはブール値ですが、その他の値は文字列であるため、報告されます\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "YAMLIncompatibleTypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 59,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLRecursiveAlias",
                "shortDescription": {
                  "text": "再帰エイリアス"
                },
                "fullDescription": {
                  "text": "YAML エイリアスの再帰を報告します。 エイリアスは再帰できません。また、対応するアンカーに参照されるデータ内で使用することもできません。 例: 'some_key: &some_anchor\n    sub_key1: value1\n    sub_key2: *some_anchor'",
                  "markdown": "YAML エイリアスの再帰を報告します。\n\nエイリアスは再帰できません。また、対応するアンカーに参照されるデータ内で使用することもできません。\n\n**例:**\n\n\n      some_key: &some_anchor\n        sub_key1: value1\n        sub_key2: *some_anchor\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "YAMLRecursiveAlias",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 59,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLDuplicatedKeys",
                "shortDescription": {
                  "text": "重複する YAML キー"
                },
                "fullDescription": {
                  "text": "YAML ファイルにある重複したキーを報告します。 例: 'same_key: some value\n  same_key: another value'",
                  "markdown": "YAML ファイルにある重複したキーを報告します。\n\n**例:**\n\n\n      same_key: some value\n      same_key: another value\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "YAMLDuplicatedKeys",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 59,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLUnusedAnchor",
                "shortDescription": {
                  "text": "未使用のアンカー"
                },
                "fullDescription": {
                  "text": "未使用のアンカーを報告します。 例: 'some_key: &some_anchor\n    key1: value1'",
                  "markdown": "未使用のアンカーを報告します。\n\n**例:**\n\n\n      some_key: &some_anchor\n        key1: value1\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "YAMLUnusedAnchor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 59,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "TestNG-J",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "groupsTestNG",
                "shortDescription": {
                  "text": "未定義のグループ名"
                },
                "fullDescription": {
                  "text": "'@Test' アノテーション内で 'dependsOnGroups' または 'groups' 属性に渡されている未定義のグループ名を報告します。 クイックフィックスを使用すると、未定義の名前が既知のグループのリストに追加されます。 既知のグループをコンマ区切りのリストで定義するには、「定義済みグループ」フィールドを使用します。",
                  "markdown": "`@Test` アノテーション内で `dependsOnGroups` または `groups` 属性に渡されている未定義のグループ名を報告します。\n\nクイックフィックスを使用すると、未定義の名前が既知のグループのリストに追加されます。\n\n既知のグループをコンマ区切りのリストで定義するには、「**定義済みグループ**」フィールドを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "groupsTestNG",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JUnitTestNG",
                "shortDescription": {
                  "text": "TestNG に変換可能な JUnit テスト"
                },
                "fullDescription": {
                  "text": "TestNG ベースのユニットテストに変換できる JUnit ベースのテストクラスを報告します。 例: 'import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ExampleTest {\n  @Test\n  public void testExample(){\n    assertEquals(2 + 2, 4);\n  }\n}' クイックフィックス適用後: 'import org.testng.Assert;\nimport org.testng.annotations.Test;\n\npublic class ExampleTest {\n  @Test\n  public void testExample(){\n    Assert.assertEquals(4, 2 + 2);\n  }\n}'",
                  "markdown": "TestNG ベースのユニットテストに変換できる JUnit ベースのテストクラスを報告します。\n\n例:\n\n\n    import org.junit.Test;\n    import static org.junit.Assert.*;\n\n    public class ExampleTest {\n      @Test\n      public void testExample(){\n        assertEquals(2 + 2, 4);\n      }\n    }\n\nクイックフィックス適用後:\n\n\n    import org.testng.Assert;\n    import org.testng.annotations.Test;\n\n    public class ExampleTest {\n      @Test\n      public void testExample(){\n        Assert.assertEquals(4, 2 + 2);\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnitTestNG",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertJavadoc",
                "shortDescription": {
                  "text": "アノテーションに変換可能な TestNG Javadoc"
                },
                "fullDescription": {
                  "text": "Javadoc アノテーションが付いた TestNG のテストをアサートし、JDK のアノテーションに変換します。 例: '/**\n    * @testng.before-test\n  */\n  public void sample() {}' クイックフィックス適用後: '@BeforeTest\n  public void sample() {}'",
                  "markdown": "Javadoc アノテーションが付いた TestNG のテストをアサートし、JDK のアノテーションに変換します。\n\n例:\n\n\n      /**\n        * @testng.before-test\n      */\n      public void sample() {}\n\nクイックフィックス適用後:\n\n\n      @BeforeTest\n      public void sample() {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConvertJavadoc",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DataProviderReturnType",
                "shortDescription": {
                  "text": "無効なデータプロバイダー戻り型"
                },
                "fullDescription": {
                  "text": "'@DataProvider' アノテーションが付いたメソッドで、'Object[][]' も 'Iterator<Object>' も返さないものを報告します。 別の型が返されると、TestNG は例外をスローします。 例: 'public class TestNgTest {\n  @DataProvider(name = \"Languages\")\n  List<String> getData() {\n    return List.of(\"Java\", \"Kotlin\");\n  }\n\n  @Test(dataProvider = \"Languages\")\n  public void testData(String language) {\n    System.out.println(language);\n  }\n}'",
                  "markdown": "`@DataProvider` アノテーションが付いたメソッドで、`Object[][]` も `Iterator<Object>` も返さないものを報告します。 別の型が返されると、TestNG は例外をスローします。\n\n例:\n\n\n    public class TestNgTest {\n      @DataProvider(name = \"Languages\")\n      List<String> getData() {\n        return List.of(\"Java\", \"Kotlin\");\n      }\n\n      @Test(dataProvider = \"Languages\")\n      public void testData(String language) {\n        System.out.println(language);\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "DataProviderReturnType",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExpectedExceptionNeverThrownTestNG",
                "shortDescription": {
                  "text": "期待した例外がテストメソッドの本体でスローされることはありません"
                },
                "fullDescription": {
                  "text": "TestNG のテストメソッドが期待するチェック例外で、メソッド本体の中でスローされないものを報告します。 例: '@Test(expectedExceptions = Exception.class) // 警告: 期待した 'Exception' がスローされることはありません\n  public void testEngineIsRunning() {\n    assertTrue(engine.isRunning());\n  }'",
                  "markdown": "TestNG のテストメソッドが期待するチェック例外で、メソッド本体の中でスローされないものを報告します。\n\n**例:**\n\n\n      @Test(expectedExceptions = Exception.class) // 警告: 期待した 'Exception' がスローされることはありません\n      public void testEngineIsRunning() {\n        assertTrue(engine.isRunning());\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExpectedExceptionNeverThrownTestNG",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UndeclaredTests",
                "shortDescription": {
                  "text": "未宣言のテスト"
                },
                "fullDescription": {
                  "text": "'testing.xml' に登録されていないテストクラスを報告します。 このようなテストは実行されないため、これはミスであることが多いです。",
                  "markdown": "`testing.xml` に登録されていないテストクラスを報告します。 このようなテストは実行されないため、これはミスであることが多いです。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UndeclaredTests",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConvertOldAnnotations",
                "shortDescription": {
                  "text": "古い TestNG アノテーション @Configuration の使用"
                },
                "fullDescription": {
                  "text": "TestNG の 'org.testng.annotations.Configuration' アノテーションを報告します。 最新の '@BeforeXXX'/'@AfterXXX' アノテーションを使ってテストスイートを構成することをお勧めします。 例: 'public class Test {\n    @Configuration(beforeSuite = true, afterTest = true)\n    public void afterBefore(){\n    }\n  }' クイックフィックス適用後: 'public class Test {\n    @AfterTest()\n    @BeforeSuite()\n    public void afterBefore(){\n    }\n  }'",
                  "markdown": "TestNG の `org.testng.annotations.Configuration` アノテーションを報告します。\n\n最新の `@BeforeXXX`/`@AfterXXX` アノテーションを使ってテストスイートを構成することをお勧めします。\n\n例:\n\n\n      public class Test {\n        @Configuration(beforeSuite = true, afterTest = true)\n        public void afterBefore(){\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public class Test {\n        @AfterTest()\n        @BeforeSuite()\n        public void afterBefore(){\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConvertOldAnnotations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicatedDataProviderNames",
                "shortDescription": {
                  "text": "データプロバイダー名の重複"
                },
                "fullDescription": {
                  "text": "'org.testng.TestNGException' が発生した場合に、同じ名前の 'TestNG' データプロバイダーを報告します。　 例: 'public class DuplicatedDataProviders {\n    @DataProvider\n    public Object[][] intTestData() { // 重複 1\n      return new Integer[][]{\n        new Integer[]{1, 1},\n      };\n    }\n\n    @DataProvider(name = \"intTestData\")\n    public Object[][] someTestData() { // 重複 2\n      return new Integer[][]{\n        new Integer[]{1, 1},\n      };\n    }\n\n    @Test(dataProvider = \"intTestData\")\n    public void testIsOK(Integer key, Integer value) {\n      assertEquals(key, value);\n    }\n  }'",
                  "markdown": "`org.testng.TestNGException` が発生した場合に、同じ名前の `TestNG` データプロバイダーを報告します。　\n\n例:\n\n\n      public class DuplicatedDataProviders {\n        @DataProvider\n        public Object[][] intTestData() { // 重複 1\n          return new Integer[][]{\n            new Integer[]{1, 1},\n          };\n        }\n\n        @DataProvider(name = \"intTestData\")\n        public Object[][] someTestData() { // 重複 2\n          return new Integer[][]{\n            new Integer[]{1, 1},\n          };\n        }\n\n        @Test(dataProvider = \"intTestData\")\n        public void testIsOK(Integer key, Integer value) {\n          assertEquals(key, value);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "DuplicatedDataProviderNames",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "dependsOnMethodTestNG",
                "shortDescription": {
                  "text": "'dependsOnMethods' に渡された不正なメソッド名"
                },
                "fullDescription": {
                  "text": "'@Test' アノテーション内で 'dependsOnMethods' 属性に渡されている不正なメソッドの名前を報告します。 メソッドの名前は、現在のクラスかその任意の親クラスで '@Test' アノテーションが付いた有効かつアクセス可能なメソッドに解決できない場合に不正と見なされます。 例: 'public class SampleTest {\n    @Test(dependsOnMethods = \"testSpellignError\")\n    public void testSample() {}\n    @Test\n    public void testSpellingError(){}\n  }'",
                  "markdown": "`@Test` アノテーション内で `dependsOnMethods` 属性に渡されている不正なメソッドの名前を報告します。\n\nメソッドの名前は、現在のクラスかその任意の親クラスで `@Test` アノテーションが付いた有効かつアクセス可能なメソッドに解決できない場合に不正と見なされます。\n\n例:\n\n\n      public class SampleTest {\n        @Test(dependsOnMethods = \"testSpellignError\")\n        public void testSample() {}\n        @Test\n        public void testSpellingError(){}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "dependsOnMethodTestNG",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MalformedDataProvider",
                "shortDescription": {
                  "text": "データプロバイダー問題"
                },
                "fullDescription": {
                  "text": "存在しない、またはアクセスできないデータプロバイダーメソッドへの参照を報告します。 例: 'public class InstanceDataProviderFromForeignClass {\n  // クラス A に data() メソッドは存在しません\n  @Test(dataProvider = \"data\", dataProviderClass = A.class)\n  public void test() {\n  }\n}\nclass A { }' クイックフィックス適用後: '// 必要な data() メソッドがクラス A に作成されます\nclass A {\n  @DataProvider\n  public Object[][] data() {\n    return new Object[][]{};\n  }\n}'",
                  "markdown": "存在しない、またはアクセスできないデータプロバイダーメソッドへの参照を報告します。\n\n例:\n\n\n    public class InstanceDataProviderFromForeignClass {\n      // クラス A に data() メソッドは存在しません\n      @Test(dataProvider = \"data\", dataProviderClass = A.class)\n      public void test() {\n      }\n    }\n    class A { }\n\nクイックフィックス適用後:\n\n\n    // 必要な data() メソッドがクラス A に作成されます\n    class A {\n      @DataProvider\n      public Object[][] data() {\n        return new Object[][]{};\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MalformedDataProvider",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/TestNG",
                      "index": 72,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "JUnit",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "MultipleExceptionsDeclaredOnTestMethod",
                "shortDescription": {
                  "text": "テストメソッドで宣言された複数の例外"
                },
                "fullDescription": {
                  "text": "'throws' 節に複数の例外が書かれている JUnit テストメソッドを報告します。 このような節は不必要に冗長です。 テストメソッドは他のプロジェクトのコードからは呼び出されないため、これらの例外を個別に処理する必要はありません。 例: '@Test\n  public void testReflection() throws NoSuchMethodException,\n      InvocationTargetException, IllegalAccessException {\n    String result = (String) String.class.getMethod(\"trim\")\n        .invoke(\" hello \");\n    assertEquals(\"hello\", result);\n  }' 複数の例外宣言を単一の例外に置換するクイックフィックスが提供されています。 '@Test\n  public void testReflection() throws Exception {\n    String result = (String) String.class.getMethod(\"trim\")\n        .invoke(\" hello \");\n    assertEquals(\"hello\", result);\n  }'",
                  "markdown": "`throws` 節に複数の例外が書かれている JUnit テストメソッドを報告します。 このような節は不必要に冗長です。 テストメソッドは他のプロジェクトのコードからは呼び出されないため、これらの例外を個別に処理する必要はありません。\n\n例:\n\n\n      @Test\n      public void testReflection() throws NoSuchMethodException,\n          InvocationTargetException, IllegalAccessException {\n        String result = (String) String.class.getMethod(\"trim\")\n            .invoke(\" hello \");\n        assertEquals(\"hello\", result);\n      }\n\n複数の例外宣言を単一の例外に置換するクイックフィックスが提供されています。\n\n\n      @Test\n      public void testReflection() throws Exception {\n        String result = (String) String.class.getMethod(\"trim\")\n            .invoke(\" hello \");\n        assertEquals(\"hello\", result);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MultipleExceptionsDeclaredOnTestMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExpectedExceptionNeverThrown",
                "shortDescription": {
                  "text": "期待した例外がテストメソッドの本体でスローされることはありません"
                },
                "fullDescription": {
                  "text": "JUnit 4 のテストメソッドに予期されているチェック例外で、メソッド本体の中でスローされないものを報告します。 このようなテストメソッドが成功することはありません。 例: '@Test(expected = CloneNotSupportedException.class)\n  public void testIt() { }'",
                  "markdown": "JUnit 4 のテストメソッドに予期されているチェック例外で、メソッド本体の中でスローされないものを報告します。 このようなテストメソッドが成功することはありません。\n\n**例:**\n\n\n      @Test(expected = CloneNotSupportedException.class)\n      public void testIt() { }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExpectedExceptionNeverThrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfObsoleteAssert",
                "shortDescription": {
                  "text": "廃止された 'junit.framework.Assert' メソッドの使用"
                },
                "fullDescription": {
                  "text": "'junit.framework.Assert' クラスにあるメソッドの呼び出しを報告します。 このクラスは廃止されており、このような呼び出しは 'org.junit.Assert' クラスにあるメソッドの呼び出しに置換できます。 例: 'import org.junit.*;\n  public class NecessaryTest {\n    @Test\n    public void testIt() {\n      junit.framework.Assert.assertEquals(\"expected\", \"actual\");\n    }\n  }' クイックフィックスを適用すると、結果は次のようになります： 'import org.junit;\n  public class NecessaryTest {\n\n    public void testIt() {\n      Assert.assertEquals(\"expected\", \"actual\");\n    }\n  }'",
                  "markdown": "`junit.framework.Assert` クラスにあるメソッドの呼び出しを報告します。 このクラスは廃止されており、このような呼び出しは `org.junit.Assert` クラスにあるメソッドの呼び出しに置換できます。\n\n例:\n\n\n      import org.junit.*;\n      public class NecessaryTest {\n        @Test\n        public void testIt() {\n          junit.framework.Assert.assertEquals(\"expected\", \"actual\");\n        }\n      }\n\nクイックフィックスを適用すると、結果は次のようになります：\n\n\n      import org.junit;\n      public class NecessaryTest {\n\n        public void testIt() {\n          Assert.assertEquals(\"expected\", \"actual\");\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfObsoleteAssert",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JUnitMixedFramework",
                "shortDescription": {
                  "text": "単一の TestCase に複数バージョンの JUnit API を使用"
                },
                "fullDescription": {
                  "text": "JUnit のアノテーション付きメソッドが別の JUnit バージョンのテストケースで使用されている場合報告します。 テストケースのフレームワークバージョンを特定するため、このインスペクションは可能な場合に super クラスのフレームワークバージョンを確認します。 super クラスがない場合は、テストケース内で最も使用されているフレームワークを使用します。 例 (JUnit 3 テストケース内の JUnit 4 アノテーション): 'public class MyTest extends TestCase {\n      @Test\n      public void foo() { }\n\n      @Test\n      @Ignore\n      public void testBar() { }\n  }' クイックフィックス適用後: 'public class MyTest extends TestCase {\n      public void testFoo() {}\n\n      public void _testBar() {}\n  }' 例 (JUnit 4 テストケース内の JUnit 5 アノテーション): 'public class MyTest {\n      @BeforeAll // JUnit 5 ライフサイクルメソッド\n      public void initialize() { }\n\n      @org.junit.Test  // JUnit 4 テストアノテーション\n      public void test() {}\n\n      @org.junit.Test  // JUnit 4 テストアノテーション\n      public void testWouldBeExecuted() {}\n  }' クイックフィックス適用後: 'public class MyTest {\n      @BeforeClass // JUnit 4 ライフサイクルメソッド\n      public void initialize() { }\n\n      @org.junit.Test  // JUnit 4 テストアノテーション\n      public void test() {}\n\n      @org.junit.Test  // JUnit 4 テストアノテーション\n      public void testWouldBeExecuted() {}\n  }'",
                  "markdown": "JUnit のアノテーション付きメソッドが別の JUnit バージョンのテストケースで使用されている場合報告します。 テストケースのフレームワークバージョンを特定するため、このインスペクションは可能な場合に super クラスのフレームワークバージョンを確認します。 super クラスがない場合は、テストケース内で最も使用されているフレームワークを使用します。\n\n例 (JUnit 3 テストケース内の JUnit 4 アノテーション):\n\n\n      public class MyTest extends TestCase {\n          @Test\n          public void foo() { }\n\n          @Test\n          @Ignore\n          public void testBar() { }\n      }\n\nクイックフィックス適用後:\n\n\n      public class MyTest extends TestCase {\n          public void testFoo() {}\n\n          public void _testBar() {}\n      }\n\n例 (JUnit 4 テストケース内の JUnit 5 アノテーション):\n\n\n      public class MyTest {\n          @BeforeAll // JUnit 5 ライフサイクルメソッド\n          public void initialize() { }\n\n          @org.junit.Test  // JUnit 4 テストアノテーション\n          public void test() {}\n\n          @org.junit.Test  // JUnit 4 テストアノテーション\n          public void testWouldBeExecuted() {}\n      }\n\nクイックフィックス適用後:\n\n\n      public class MyTest {\n          @BeforeClass // JUnit 4 ライフサイクルメソッド\n          public void initialize() { }\n\n          @org.junit.Test  // JUnit 4 テストアノテーション\n          public void test() {}\n\n          @org.junit.Test  // JUnit 4 テストアノテーション\n          public void testWouldBeExecuted() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnitMixedFramework",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JUnit3StyleTestMethodInJUnit4Class",
                "shortDescription": {
                  "text": "JUnit 4 クラスの古いスタイルの JUnit テストメソッド"
                },
                "fullDescription": {
                  "text": "JUnit 3 形式のテストメソッドで、JUnit 3 の 'TestCase' クラスを拡張せず、JUnit 4 と JUnit 5 の '@Test' アノテーション付きメソッドを含むクラス内にあるものを報告します。 このようなテストメソッドは実行できません。",
                  "markdown": "JUnit 3 形式のテストメソッドで、JUnit 3 の `TestCase` クラスを拡張せず、JUnit 4 と JUnit 5 の `@Test` アノテーション付きメソッドを含むクラス内にあるものを報告します。 このようなテストメソッドは実行できません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnit3StyleTestMethodInJUnit4Class",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertEqualsMayBeAssertSame",
                "shortDescription": {
                  "text": "'assertSame()' に置換できる 'assertEquals()'"
                },
                "fullDescription": {
                  "text": "JUnit の 'assertEquals()' 呼び出しで、同等の 'assertSame()' 呼び出しに置換できるものを報告します。 これは、'Object.equals()' メソッドをオーバーライドせず、オブジェクト識別子が比較されることを明示的にしている 'final' クラスのインスタンスが引数になっている場合に可能です。 'assertEquals()' を 'assertSame()' に置換することをお勧めします。 例: '@Test\n  public void testObjectType() {\n    Object o = getObject();\n    Assert.assertEquals(String.class, o.getClass());\n  }' クイックフィックス適用後: '@Test\n  public void testSort() {\n    Object o = getObject();\n    Assert.assertSame(String.class, o.getClass());\n  }'",
                  "markdown": "JUnit の `assertEquals()` 呼び出しで、同等の `assertSame()` 呼び出しに置換できるものを報告します。 これは、`Object.equals()` メソッドをオーバーライドせず、オブジェクト識別子が比較されることを明示的にしている `final` クラスのインスタンスが引数になっている場合に可能です。\n\n`assertEquals()` を `assertSame()` に置換することをお勧めします。\n\n**例:**\n\n\n      @Test\n      public void testObjectType() {\n        Object o = getObject();\n        Assert.assertEquals(String.class, o.getClass());\n      }\n\nクイックフィックス適用後:\n\n\n      @Test\n      public void testSort() {\n        Object o = getObject();\n        Assert.assertSame(String.class, o.getClass());\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertEqualsMayBeAssertSame",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuperTearDownInFinally",
                "shortDescription": {
                  "text": "'finally' ブロックから呼び出されていない JUnit 3 'super.tearDown()'"
                },
                "fullDescription": {
                  "text": "JUnit 3 の 'super.tearDown()' メソッドの呼び出しで、'finally' ブロック内で実行されていないものを報告します。 'super.tearDown()' が呼び出される前に例外がスローされた場合、矛盾やリークが発生する可能性があります。 例: 'public class AnotherTest extends CompanyTestCase {\n    private Path path;\n\n    @Override\n    protected void setUp() throws Exception {\n      super.setUp();\n      path = Files.createTempFile(\"File\", \".tmp\");\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n      Files.delete(path);\n      super.tearDown();\n    }\n  }' 改善後のコード: 'public class AnotherTest extends CompanyTestCase {\n    private Path path;\n\n    @Override\n    protected void setUp() throws Exception {\n      super.setUp();\n      path = Files.createTempFile(\"File\", \".tmp\");\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n      try {\n        Files.delete(path);\n      } finally {\n        super.tearDown();\n      }\n    }\n  }'",
                  "markdown": "JUnit 3 の `super.tearDown()` メソッドの呼び出しで、`finally` ブロック内で実行されていないものを報告します。 `super.tearDown()` が呼び出される前に例外がスローされた場合、矛盾やリークが発生する可能性があります。\n\n**例:**\n\n\n      public class AnotherTest extends CompanyTestCase {\n        private Path path;\n\n        @Override\n        protected void setUp() throws Exception {\n          super.setUp();\n          path = Files.createTempFile(\"File\", \".tmp\");\n        }\n\n        @Override\n        protected void tearDown() throws Exception {\n          Files.delete(path);\n          super.tearDown();\n        }\n      }\n\n改善後のコード:\n\n\n      public class AnotherTest extends CompanyTestCase {\n        private Path path;\n\n        @Override\n        protected void setUp() throws Exception {\n          super.setUp();\n          path = Files.createTempFile(\"File\", \".tmp\");\n        }\n\n        @Override\n        protected void tearDown() throws Exception {\n          try {\n            Files.delete(path);\n          } finally {\n            super.tearDown();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuperTearDownInFinally",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JUnitMalformedDeclaration",
                "shortDescription": {
                  "text": "JUnit の不正な形式の宣言"
                },
                "fullDescription": {
                  "text": "形式が不正で、JUnit テストフレームワークにより認識される可能性が低い JUnit テストメンバーの宣言を報告します。 このインスペクションでは、以下の問題が報告されます。 初期化できないテストクラス 間違った型を使用している、または必要な場合に static として宣言されていない '@RegisterExtension' アノテーションが付いたフィールド '@Nested' アノテーションが付いた static または private 内部クラス。 ソースなしで定義されているパラメーター化テスト '@MethodSource' が付いたパラメーター化テストで、不明、非 static、または引数なしのターゲットを持つもの パラメーター化テストのメソッドパラメーターと指定された '@ValueSource' または '@EnumSource' 値の型の不一致 '@Test'、'@ParameterizedTest' または '@RepeatedTest' のうち 2 つ以上のアノテーションが付いたテスト public でない、戻り値の型が void でない、または引数を取る 'setup()' または 'tearDown()' メソッド private、引数を取る、または static でない 'suite()' メソッド '@BeforeClass'、'@AfterClass'、'@BeforeAll' または '@AfterAll' アノテーションが付いたメソッドで、public でない、static でない、戻り値の型が void でない、または有効なパラメーターリストがないもの '@Before'、'@After'、'@BeforeEach' または '@AfterEach' アノテーションが付いたメソッドで、public でない、戻り値の型が void でない、または引数を取るもの '@BeforeAll' または '@AfterAll' メソッドに挿入されている 'RepetitionInfo' '@Test' アノテーションが付いたテストに使用されている '@BeforeEach'、または '@AfterEach' メソッドに挿入されている 'RepetitionInfo' '@DataPoint' または '@DataPoints' アノテーションが付いたフィールドおよびメソッドで、public でない、または static でないもの '@Rule' アノテーションが付いたフィールドおよびメソッドで、public でないか、'TestRule' または 'MethodRule' のサブタイプでないもの '@ClassRule' アノテーションが付いたフィールドおよびメソッドで、public でない、static でない、または 'TestRule' のサブタイプでないもの 'test' 接頭辞を持つ 'TestCase' のサブクラス内のメソッドで、pubic でない、戻り値の型が void でない、引数を取る、または static でないもの '@Test' アノテーションが付いたメソッドで、public でない、戻り値の型が void でない、引数を取る、または static でないもの Kotlin のサスペンド関数は引数と非 void の戻り値の型を持ちます。 そのため、JUnit テストランナーによって実行されることはありません。 このインスペクションはこの問題に関しても報告します。 形式が不正な '@Before' メソッドの例: '@Before private int foo(int arg) { }' クイックフィックス適用後: '@Before public void foo() { }' 欠落しているメソッドソースの例 (Kotlin): 'class Example {\n    @MethodSource(\"parameters\")\n    @ParameterizedTest\n    fun foo(param: String) { ... }\n  }' クイックフィックス適用後: 'class Example {\n    @MethodSource(\"parameters\")\n    @ParameterizedTest\n    fun foo(param: String) { ... }\n\n    companion object {\n      @JvmStatic\n      fun parameters(): Stream<Arguments> {\n        TODO(\"Not yet implemented\")\n      }\n    }\n  }' インスペクションのオプションを使用すると、アノテーションを指定できます。 ここで指定したアノテーションのいずれかが付いたパラメーターは報告されません。",
                  "markdown": "形式が不正で、JUnit テストフレームワークにより認識される可能性が低い JUnit テストメンバーの宣言を報告します。 このインスペクションでは、以下の問題が報告されます。\n\n* 初期化できないテストクラス\n* 間違った型を使用している、または必要な場合に static として宣言されていない `@RegisterExtension` アノテーションが付いたフィールド\n* `@Nested` アノテーションが付いた static または private 内部クラス。\n* ソースなしで定義されているパラメーター化テスト\n* `@MethodSource` が付いたパラメーター化テストで、不明、非 static、または引数なしのターゲットを持つもの\n* パラメーター化テストのメソッドパラメーターと指定された `@ValueSource` または `@EnumSource` 値の型の不一致\n* `@Test`、`@ParameterizedTest` または `@RepeatedTest` のうち 2 つ以上のアノテーションが付いたテスト\n* public でない、戻り値の型が void でない、または引数を取る `setup()` または `tearDown()` メソッド\n* private、引数を取る、または static でない `suite()` メソッド\n* `@BeforeClass`、`@AfterClass`、`@BeforeAll` または `@AfterAll` アノテーションが付いたメソッドで、public でない、static でない、戻り値の型が void でない、または有効なパラメーターリストがないもの\n* `@Before`、`@After`、`@BeforeEach` または `@AfterEach` アノテーションが付いたメソッドで、public でない、戻り値の型が void でない、または引数を取るもの\n* `@BeforeAll` または `@AfterAll` メソッドに挿入されている `RepetitionInfo`\n* `@Test` アノテーションが付いたテストに使用されている `@BeforeEach`、または `@AfterEach` メソッドに挿入されている `RepetitionInfo`\n* `@DataPoint` または `@DataPoints` アノテーションが付いたフィールドおよびメソッドで、public でない、または static でないもの\n* `@Rule` アノテーションが付いたフィールドおよびメソッドで、public でないか、`TestRule` または `MethodRule` のサブタイプでないもの\n* `@ClassRule` アノテーションが付いたフィールドおよびメソッドで、public でない、static でない、または `TestRule` のサブタイプでないもの\n* `test` 接頭辞を持つ `TestCase` のサブクラス内のメソッドで、pubic でない、戻り値の型が void でない、引数を取る、または static でないもの\n* `@Test` アノテーションが付いたメソッドで、public でない、戻り値の型が void でない、引数を取る、または static でないもの\n\nKotlin のサスペンド関数は引数と非 void の戻り値の型を持ちます。 そのため、JUnit テストランナーによって実行されることはありません。 このインスペクションはこの問題に関しても報告します。\n\n**形式が不正な `@Before` メソッドの例:**\n\n\n      @Before private int foo(int arg) { }\n\nクイックフィックス適用後:\n\n\n      @Before public void foo() { }\n\n**欠落しているメソッドソースの例 (Kotlin):**\n\n\n      class Example {\n        @MethodSource(\"parameters\")\n        @ParameterizedTest\n        fun foo(param: String) { ... }\n      }\n\nクイックフィックス適用後:\n\n\n      class Example {\n        @MethodSource(\"parameters\")\n        @ParameterizedTest\n        fun foo(param: String) { ... }\n\n        companion object {\n          @JvmStatic\n          fun parameters(): Stream<Arguments> {\n            TODO(\"Not yet implemented\")\n          }\n        }\n      }\n\nインスペクションのオプションを使用すると、アノテーションを指定できます。 ここで指定したアノテーションのいずれかが付いたパラメーターは報告されません。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JUnitMalformedDeclaration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertEqualsCalledOnArray",
                "shortDescription": {
                  "text": "配列に対する 'assertEquals()' 呼び出し"
                },
                "fullDescription": {
                  "text": "配列型の引数を使用して JUnit 'assertEquals()' 呼び出していることを報告します。 このようなメソッドは、配列の中身ではなく配列の識別子を比較しています。 配列の中身は、'assertArrayEquals()' メソッドで確認する必要があります。 例: '@Test\n  public void testSort() {\n    int[] actual = {248, 496, 0, 56};\n    Arrays.sort(actual);\n    Assert.assertEquals(new int[] {0, 56, 248, 496}, actual);\n  }' クイックフィックス適用後: '@Test\n  public void testSort() {\n    int[] actual = {248, 496, 0, 56};\n    Arrays.sort(actual);\n    Assert.assertArrayEquals(new int[] {0, 56, 248, 496}, actual);\n  }'",
                  "markdown": "配列型の引数を使用して JUnit `assertEquals()` 呼び出していることを報告します。 このようなメソッドは、配列の中身ではなく配列の識別子を比較しています。 配列の中身は、`assertArrayEquals()` メソッドで確認する必要があります。\n\n**例:**\n\n\n      @Test\n      public void testSort() {\n        int[] actual = {248, 496, 0, 56};\n        Arrays.sort(actual);\n        Assert.assertEquals(new int[] {0, 56, 248, 496}, actual);\n      }\n\nクイックフィックス適用後:\n\n\n      @Test\n      public void testSort() {\n        int[] actual = {248, 496, 0, 56};\n        Arrays.sort(actual);\n        Assert.assertArrayEquals(new int[] {0, 56, 248, 496}, actual);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertEqualsCalledOnArray",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JUnit5AssertionsConverter",
                "shortDescription": {
                  "text": "JUnit 5 の廃止されたアサーション"
                },
                "fullDescription": {
                  "text": "JUnit 5 テスト内の 'junit.framework.Assert'、'org.junit.Assert'、 'org.junit.Assume' クラスにあるメソッドの呼び出しを報告します。 このようなテストは適切に機能しますが、'org.junit.jupiter.api.Assertions'/'org.junit.jupiter.api.Assumptions' に移行すると、古い JUnit バージョンへの依存を避けることができます。 例: 'import org.junit.Assert;\n  import org.junit.jupiter.api.Test;\n\n  public class MyTest {\n    @Test\n    public void simpleTest() {\n      Assert.assertEquals(4, 2 + 2);\n    }\n  }' クイックフィックス適用後: 'import org.junit.jupiter.api.Assertions;\n  import org.junit.jupiter.api.Test;\n\n  public class MyTest {\n    @Test\n    public void simpleTest() {\n      Assertions.assertEquals(4, 2 + 2);\n    }\n  }'",
                  "markdown": "JUnit 5 テスト内の `junit.framework.Assert`、`org.junit.Assert`、 `org.junit.Assume` クラスにあるメソッドの呼び出しを報告します。\n\nこのようなテストは適切に機能しますが、`org.junit.jupiter.api.Assertions`/`org.junit.jupiter.api.Assumptions` に移行すると、古い JUnit バージョンへの依存を避けることができます。\n\n**例:**\n\n\n      import org.junit.Assert;\n      import org.junit.jupiter.api.Test;\n\n      public class MyTest {\n        @Test\n        public void simpleTest() {\n          Assert.assertEquals(4, 2 + 2);\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      import org.junit.jupiter.api.Assertions;\n      import org.junit.jupiter.api.Test;\n\n      public class MyTest {\n        @Test\n        public void simpleTest() {\n          Assertions.assertEquals(4, 2 + 2);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnit5AssertionsConverter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterizedParametersStaticCollection",
                "shortDescription": {
                  "text": "データ プロバイダーメソッドのないパラメーター化テストクラス"
                },
                "fullDescription": {
                  "text": "'@RunWith(Parameterized.class)' アノテーションが付いているものの、'@Parameterized.Parameters' アノテーションが付いたデータプロバイダーメソッドを含んでいないか、当該メソッドに正しいシグネチャーがない JUnit 4 パラメーター化テストクラスを報告します。 このようなテストクラスは実行できません。 データプロバイダーメソッドは 'public' で 'static'、かつ戻り値の型が 'Iterable' または 'Object[]' である必要があります。 空パラメーターのプロバイダーメソッドを作成するか、不正なデータプロバイダーメソッドのシグネチャーを変更することを提案します。 例: '@RunWith(Parameterized.class)\n  public class ImportantTest {\n    private int input;\n    private int expected;\n\n    ImportantTest(int input, int expected) {\n      this.input = input;\n      this.expected = expected;\n    }\n\n    // ... test cases\n  }' クイックフィックス適用後: '@RunWith(Parameterized.class)\n  public class ImportantTest {\n    private int input;\n    private int expected;\n\n    ImportantTest(int input, int expected) {\n      this.input = input;\n      this.expected = expected;\n    }\n\n    @Parameters\n    public static Iterable<Object[]> parameters() {\n      return null;\n    }\n\n    // ... test cases\n  }'",
                  "markdown": "`@RunWith(Parameterized.class)` アノテーションが付いているものの、`@Parameterized.Parameters` アノテーションが付いたデータプロバイダーメソッドを含んでいないか、当該メソッドに正しいシグネチャーがない JUnit 4 [パラメーター化テスト](https://github.com/junit-team/junit4/wiki/parameterized-tests)クラスを報告します。 このようなテストクラスは実行できません。 データプロバイダーメソッドは `public` で `static`、かつ戻り値の型が `Iterable` または `Object[]` である必要があります。\n\n空パラメーターのプロバイダーメソッドを作成するか、不正なデータプロバイダーメソッドのシグネチャーを変更することを提案します。\n\n**例:**\n\n\n\n      @RunWith(Parameterized.class)\n      public class ImportantTest {\n        private int input;\n        private int expected;\n\n        ImportantTest(int input, int expected) {\n          this.input = input;\n          this.expected = expected;\n        }\n\n        // ... test cases\n      }\n\nクイックフィックス適用後:\n\n\n      @RunWith(Parameterized.class)\n      public class ImportantTest {\n        private int input;\n        private int expected;\n\n        ImportantTest(int input, int expected) {\n          this.input = input;\n          this.expected = expected;\n        }\n\n        @Parameters\n        public static Iterable<Object[]> parameters() {\n          return null;\n        }\n\n        // ... test cases\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterizedParametersStaticCollection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Junit4RunWithInspection",
                "shortDescription": {
                  "text": "'@RunWith' アノテーションはすでに親クラスに存在します"
                },
                "fullDescription": {
                  "text": "JUnit テスト階層内の親クラスと子クラスに '@RunWith' アノテーションが付いている場合に報告します。 このような場合、予期しないテスト動作が発生する可能性があります。 例: '@RunWith(Suite.class)\n  @SuiteClasses(MySuiteClass.class)\n  public abstract Parent {\n  }\n\n  @RunWith(Parameterized.class)\n  public MyTest {\n  }' 2024.1 の新機能です",
                  "markdown": "JUnit テスト階層内の親クラスと子クラスに `@RunWith` アノテーションが付いている場合に報告します。 このような場合、予期しないテスト動作が発生する可能性があります。\n\n**例:**\n\n\n      @RunWith(Suite.class)\n      @SuiteClasses(MySuiteClass.class)\n      public abstract Parent {\n      }\n\n      @RunWith(Parameterized.class)\n      public MyTest {\n      }\n\n\n2024.1 の新機能です"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Junit4RunWithInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JUnit5Converter",
                "shortDescription": {
                  "text": "JUnit 5 にできる JUnit 4 テスト"
                },
                "fullDescription": {
                  "text": "JUnit 5 に自動的に移行可能な JUnit 4 テストを報告します。 デフォルトのテストランナーは自動的に変換可能ですが、カスタムランナーやメソッド / フィールドのルールはそうではなく、手動での変更が必要です。 例: 'import org.junit.Assert;\n  import org.junit.Test;\n\n  public class RelevantTest {\n    @Test\n    public void testIt() {\n      Assert.assertEquals(\"expected\", \"actual\");\n    }\n  }' クイックフィックス適用後: 'import org.junit.jupiter.api.Assertions;\n  import org.junit.jupiter.api.Test;\n\n  public class RelevantTest {\n    @Test\n    public void testIt() {\n      Assertions.assertEquals(\"expected\", \"actual\");\n    }\n  }' このインスペクションを使用するには、JUnit 5 ライブラリがクラスパスにあり、JDK 1.8 以降がプロジェクトに構成されている必要があります。",
                  "markdown": "JUnit 5 に自動的に移行可能な JUnit 4 テストを報告します。 デフォルトのテストランナーは自動的に変換可能ですが、カスタムランナーやメソッド / フィールドのルールはそうではなく、手動での変更が必要です。\n\n**例:**\n\n\n      import org.junit.Assert;\n      import org.junit.Test;\n\n      public class RelevantTest {\n        @Test\n        public void testIt() {\n          Assert.assertEquals(\"expected\", \"actual\");\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      import org.junit.jupiter.api.Assertions;\n      import org.junit.jupiter.api.Test;\n\n      public class RelevantTest {\n        @Test\n        public void testIt() {\n          Assertions.assertEquals(\"expected\", \"actual\");\n        }\n      }\n\nこのインスペクションを使用するには、JUnit 5 ライブラリがクラスパスにあり、JDK 1.8 以降がプロジェクトに構成されている必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnit5Converter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Junit4Converter",
                "shortDescription": {
                  "text": "JUnit 4 にできる JUnit 3 テスト"
                },
                "fullDescription": {
                  "text": "JUnit 4 テストクラスに変換できる JUnit 3 テストクラスを報告します。 例: 'public class MainTestCase extends junit.framework.TestCase {\n    public void test() {\n      Assert.assertTrue(true);\n    }\n  }' クイックフィックス適用後: 'public class MainTestCase {\n    @org.junit.Test\n    public void test() {\n      Assert.assertTrue(true);\n    }\n  }' このインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以上で、クラスパスに JUnit 4 がある場合にのみ報告します。",
                  "markdown": "JUnit 4 テストクラスに変換できる JUnit 3 テストクラスを報告します。\n\n**例:**\n\n\n      public class MainTestCase extends junit.framework.TestCase {\n        public void test() {\n          Assert.assertTrue(true);\n        }\n      }\n\nクイックフィックス適用後:\n\n\n      public class MainTestCase {\n        @org.junit.Test\n        public void test() {\n          Assert.assertTrue(true);\n        }\n      }\n\nこのインスペクションは、プロジェクトまたはモジュールの言語レベルが 5 以上で、クラスパスに JUnit 4 がある場合にのみ報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "Junit4Converter",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IgnoredJUnitTest",
                "shortDescription": {
                  "text": "'@Ignore' / '@Disabled' アノテーションが付いた JUnit テスト"
                },
                "fullDescription": {
                  "text": "JUnit 4 の '@Ignore' アノテーションまたは JUnit 5 の '@Disabled' アノテーションが使用されていることを報告します。 これらのアノテーションが長期にわたって付いているテスト、特に理由が指定されていないものはコードの臭いと見なされます。 例: '@Ignore\n  public class UrgentTest {\n\n    @Test\n    public void testIt() {\n      Assert.assertEquals(\"expected\", \"actual\");\n    }\n  }' インスペクションの構成: 理由がアノテーションの 'value' 属性に指定されていない場合のみ報告するには、「理由のないアノテーションのみを報告する」オプションを使用します。",
                  "markdown": "JUnit 4 の `@Ignore` アノテーションまたは JUnit 5 の `@Disabled` アノテーションが使用されていることを報告します。 これらのアノテーションが長期にわたって付いているテスト、特に理由が指定されていないものはコードの臭いと見なされます。\n\n**例:**\n\n\n      @Ignore\n      public class UrgentTest {\n\n        @Test\n        public void testIt() {\n          Assert.assertEquals(\"expected\", \"actual\");\n        }\n      }\n\n\nインスペクションの構成:\n\n* 理由がアノテーションの `value` 属性に指定されていない場合のみ報告するには、「**理由のないアノテーションのみを報告する**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IgnoredJUnitTest",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MigrateAssertToMatcherAssert",
                "shortDescription": {
                  "text": "'assertThat()' 呼び出しにできる JUnit アサーション"
                },
                "fullDescription": {
                  "text": "'Assert.assertEquals()' や 'Assert.assertTrue()' などのメソッドの呼び出しのうち、Hamcrest 宣言スタイルの 'Assert.assertThat()' の呼び出しに移行できるものを報告します。 例: 'public class SubstantialTest {\n    @Test\n    public void testContents(Collection<String> c, String s) {\n      Assert.assertTrue(c.contains(s));\n      Assert.assertEquals(c, s);\n      Assert.assertNotNull(c);\n      Assert.assertNull(c);\n      Assert.assertFalse(c.contains(s));\n    }\n  }' このような移行を実行するためのクイックフィックスが提供されています。 'public class SubstantialTest {\n    @Test\n    public void testContents(Collection<String> c, String s) {\n      assertThat(c, hasItem(o));\n      assertThat(o, is(c));\n      assertThat(c, notNullValue());\n      assertThat(c, nullValue());\n      assertThat(c, not(hasItem(o)));\n    }\n  }' このインスペクションを使用するには、クラスパスに Hamcrest ライブラリがある必要があります。 Hamcrest の Matcher メソッドを static インポートするクイックフィックスを実行するかどうかを指定するには、「Matcher のメソッドを static インポートする」オプションを使用します。",
                  "markdown": "`Assert.assertEquals()` や `Assert.assertTrue()` などのメソッドの呼び出しのうち、Hamcrest 宣言スタイルの `Assert.assertThat()` の呼び出しに移行できるものを報告します。\n\n例:\n\n\n      public class SubstantialTest {\n        @Test\n        public void testContents(Collection<String> c, String s) {\n          Assert.assertTrue(c.contains(s));\n          Assert.assertEquals(c, s);\n          Assert.assertNotNull(c);\n          Assert.assertNull(c);\n          Assert.assertFalse(c.contains(s));\n        }\n      }\n\nこのような移行を実行するためのクイックフィックスが提供されています。\n\n\n      public class SubstantialTest {\n        @Test\n        public void testContents(Collection<String> c, String s) {\n          assertThat(c, hasItem(o));\n          assertThat(o, is(c));\n          assertThat(c, notNullValue());\n          assertThat(c, nullValue());\n          assertThat(c, not(hasItem(o)));\n        }\n      }\n\nこのインスペクションを使用するには、クラスパスに Hamcrest ライブラリがある必要があります。\n\nHamcrest の Matcher メソッドを static インポートするクイックフィックスを実行するかどうかを指定するには、「**Matcher のメソッドを static インポートする**」オプションを使用します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MigrateAssertToMatcherAssert",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JUnit",
                      "index": 73,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.properties",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "UseEllipsisInPropertyInspection",
                "shortDescription": {
                  "text": "省略記号を 3 つのドット文字で代用"
                },
                "fullDescription": {
                  "text": "UTF-8 プロパティファイルで省略記号の代わりに使用されている 3 つの \"ドット\" 文字を報告します。",
                  "markdown": "UTF-8 プロパティファイルで省略記号の代わりに使用されている 3 つの \"ドット\" 文字を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseEllipsisInPropertyInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "プロパティファイル",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AlphaUnsortedPropertiesFile",
                "shortDescription": {
                  "text": "アルファベット順に並べ替えられていないプロパティファイルまたはリソースバンドル"
                },
                "fullDescription": {
                  "text": "アルファベット順に並べ替えられていないリソースバンドルまたは .properties ファイルを報告します。",
                  "markdown": "アルファベット順に並べ替えられていないリソースバンドルまたは .properties ファイルを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AlphaUnsortedPropertiesFile",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "プロパティファイル",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrailingSpacesInProperty",
                "shortDescription": {
                  "text": "プロパティの末尾スペース"
                },
                "fullDescription": {
                  "text": "キーまたは値が空白で終わっているプロパティを報告します。",
                  "markdown": "キーまたは値が空白で終わっているプロパティを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TrailingSpacesInProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "プロパティファイル",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedProperty",
                "shortDescription": {
                  "text": "未使用のプロパティ"
                },
                "fullDescription": {
                  "text": "含まれている .properties ファイルの外で参照されていないプロパティを報告します。",
                  "markdown": "含まれている .properties ファイルの外で参照されていないプロパティを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "プロパティファイル",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WrongPropertyKeyValueDelimiter",
                "shortDescription": {
                  "text": "プロパティのキーと値の区切り文字がコードスタイル設定と一致しません"
                },
                "fullDescription": {
                  "text": "キーまたは値の区切り文字がコードスタイルの設定と一致していないプロパティを報告します。",
                  "markdown": "キーまたは値の区切り文字がコードスタイルの設定と一致していないプロパティを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "WrongPropertyKeyValueDelimiter",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "プロパティファイル",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicatePropertyInspection",
                "shortDescription": {
                  "text": "プロパティが重複しています"
                },
                "fullDescription": {
                  "text": "異なる値を持つ重複したプロパティキー、重複したキー、重複したプロパティの値を報告します。 例: 'property1=value;\nproperty2=value;' オプションのリストを使用すると、このインスペクションが重複を検索する場所を選択できます。",
                  "markdown": "異なる値を持つ重複したプロパティキー、重複したキー、重複したプロパティの値を報告します。\n\n例:\n\n\n    property1=value;\n    property2=value;\n\n**オプション**のリストを使用すると、このインスペクションが重複を検索する場所を選択できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DuplicatePropertyInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "プロパティファイル",
                      "index": 32,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.plugins.javaFX",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "JavaFxEventHandler",
                "shortDescription": {
                  "text": "イベントハンドラーメソッドのシグネチャー問題"
                },
                "fullDescription": {
                  "text": "互換性のない引数の型、あいまいなイベントハンドラーメソッド、不正な戻り値の型など、イベントハンドラーに関する問題を報告します。",
                  "markdown": "互換性のない引数の型、あいまいなイベントハンドラーメソッド、不正な戻り値の型など、イベントハンドラーに関する問題を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaFxEventHandler",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaFX",
                      "index": 82,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaFxRedundantPropertyValue",
                "shortDescription": {
                  "text": "JavaFX の冗長なプロパティ値"
                },
                "fullDescription": {
                  "text": ".fxml ファイルのプロパティ (属性とタグの両方) で、デフォルト値があるために冗長となっているものを報告します。",
                  "markdown": ".fxml ファイルのプロパティ (属性とタグの両方) で、デフォルト値があるために冗長となっているものを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaFxRedundantPropertyValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaFX",
                      "index": 82,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaFxUnresolvedFxIdReference",
                "shortDescription": {
                  "text": "未解決の fx:id 属性参照"
                },
                "fullDescription": {
                  "text": "未解決の fx:id 参照を報告します。 クイックフィックスを使用すると、対応するフィールドが作成されます。",
                  "markdown": "未解決の fx:id 参照を報告します。 クイックフィックスを使用すると、対応するフィールドが作成されます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaFxUnresolvedFxIdReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaFX",
                      "index": 82,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaFxColorRgb",
                "shortDescription": {
                  "text": "範囲外の色成分"
                },
                "fullDescription": {
                  "text": "有効な範囲を外れている RGB 色成分を報告します。",
                  "markdown": "有効な範囲を外れている RGB 色成分を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaFxColorRgb",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaFX",
                      "index": 82,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaFxUnusedImports",
                "shortDescription": {
                  "text": "JavaFX の未使用インポート"
                },
                "fullDescription": {
                  "text": ".fxml にある未使用のインポートを報告します。",
                  "markdown": ".fxml にある未使用のインポートを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaFxUnusedImports",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaFX",
                      "index": 82,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaFxResourcePropertyValue",
                "shortDescription": {
                  "text": "プロパティファイルの値が属性の型と互換性がありません"
                },
                "fullDescription": {
                  "text": ".properties ファイルに定義されている属性値で、属性の型と一致していないものを報告します。",
                  "markdown": ".properties ファイルに定義されている属性値で、属性の型と一致していないものを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaFxResourcePropertyValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaFX",
                      "index": 82,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaFxDefaultTag",
                "shortDescription": {
                  "text": "不要なデフォルトタグ"
                },
                "fullDescription": {
                  "text": ".fxml ファイルにある冗長なタグを報告します。 このようなタグは @DefaultProperty クラスアノテーションで宣言されているクラスのプロパティに対応するため、省略できます。",
                  "markdown": ".fxml ファイルにある冗長なタグを報告します。 このようなタグは @DefaultProperty クラスアノテーションで宣言されているクラスのプロパティに対応するため、省略できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaFxDefaultTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaFX",
                      "index": 82,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.intellij.qodana",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "QodanaJavaSanity",
                "shortDescription": {
                  "text": "Java の健全性"
                },
                "fullDescription": {
                  "text": "Java コードに未解決の参照があることを報告します。",
                  "markdown": "Java コードに未解決の参照があることを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "QodanaJavaSanity",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "一般",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaAnnotator",
                "shortDescription": {
                  "text": "Java アノテーター"
                },
                "fullDescription": {
                  "text": "Java アノテーターによって報告される問題 (コンパイルの問題、IDEA で解決されない参照など) を表示できます。",
                  "markdown": "Java アノテーターによって報告される問題 (コンパイルの問題、IDEA で解決されない参照など) を表示できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JavaAnnotator",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "一般",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JvmCoverageInspection",
                "shortDescription": {
                  "text": "Kotlin および Java のソースコードカバレッジをチェック"
                },
                "fullDescription": {
                  "text": "カバレッジが一定のしきい値未満のメソッドおよびクラスを報告します。",
                  "markdown": "カバレッジが一定のしきい値未満のメソッドおよびクラスを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JvmCoverageInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "コードカバレッジ",
                      "index": 99,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "QodanaKotlinSanity",
                "shortDescription": {
                  "text": "Kotlin の健全性"
                },
                "fullDescription": {
                  "text": "Kotlin コードに未解決の参照があることを報告します。",
                  "markdown": "Kotlin コードに未解決の参照があることを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "QodanaKotlinSanity",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "一般",
                      "index": 44,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CyclomaticComplexityInspection",
                "shortDescription": {
                  "text": "コードメトリクス"
                },
                "fullDescription": {
                  "text": "サイクロマティック複雑度を計算します。",
                  "markdown": "サイクロマティック複雑度を計算します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CyclomaticComplexityInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Qodana",
                      "index": 126,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JvmLinesOfCodeInspection",
                "shortDescription": {
                  "text": "Kotlin および Java コードメトリクスの計算"
                },
                "fullDescription": {
                  "text": "コード行数をカウントします。",
                  "markdown": "コード行数をカウントします。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JvmLinesOfCodeInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "コードメトリクス",
                      "index": 127,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.intellij.plugins.markdown",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "MarkdownLinkDestinationWithSpaces",
                "shortDescription": {
                  "text": "リンクにスペースを含めることはできません"
                },
                "fullDescription": {
                  "text": "異なるツール間の一貫性を確保するため、ファイルリンクにスペースを含めることはできません。 例: '[Some file link](some file.md)' クイックフィックスを使用すると、スペースが URL エンコードされたものに置換されます。 '[Some file link](some%20file.md)'",
                  "markdown": "異なるツール間の一貫性を確保するため、ファイルリンクにスペースを含めることはできません。\n\n**例:**\n\n\n      [Some file link](some file.md)\n\nクイックフィックスを使用すると、スペースが URL エンコードされたものに置換されます。\n\n\n      [Some file link](some%20file.md)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownLinkDestinationWithSpaces",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 92,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownNoTableBorders",
                "shortDescription": {
                  "text": "テーブルに縦線がありません"
                },
                "fullDescription": {
                  "text": "テーブルに正しい縦線があるかどうかを確認します。 互換性の理由から、すべてのテーブル行には最初と最後に縦線 (パイプ文字) を記述する必要があります。",
                  "markdown": "テーブルに正しい縦線があるかどうかを確認します。 互換性の理由から、すべてのテーブル行には最初と最後に縦線 (パイプ文字) を記述する必要があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownNoTableBorders",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 92,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownOutdatedTableOfContents",
                "shortDescription": {
                  "text": "古い目次セクション"
                },
                "fullDescription": {
                  "text": "コンテンツ部分の特定のテーブルがドキュメントの実際の構造に対応しているかどうかを確認します。",
                  "markdown": "コンテンツ部分の特定のテーブルがドキュメントの実際の構造に対応しているかどうかを確認します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownOutdatedTableOfContents",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 92,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownUnresolvedLinkLabel",
                "shortDescription": {
                  "text": "未解決のリンクラベル"
                },
                "fullDescription": {
                  "text": "Markdown ファイルにある未解決のリンクラベルを報告します。",
                  "markdown": "Markdown ファイルにある未解決のリンクラベルを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownUnresolvedLinkLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 92,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownIncorrectTableFormatting",
                "shortDescription": {
                  "text": "不適切なテーブル書式"
                },
                "fullDescription": {
                  "text": "テーブルの書式が正しいかどうかを確認します。",
                  "markdown": "テーブルの書式が正しいかどうかを確認します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MarkdownIncorrectTableFormatting",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 92,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownIncorrectlyNumberedListItem",
                "shortDescription": {
                  "text": "間違って番号付けされたリスト項目"
                },
                "fullDescription": {
                  "text": "番号付きリスト項目には 1 から始まる連続した番号が期待されています。 なぜかというと、多くの Markdown プロセッサは番号付きリストの番号付けを無視しているためです。 プロセッサはそのようなリストに対して '<ol>' 要素を生成し、項目に 1 から連続的に番号を付けます。",
                  "markdown": "番号付きリスト項目には 1 から始まる連続した番号が期待されています。\n\nなぜかというと、多くの Markdown プロセッサは番号付きリストの番号付けを無視しているためです。 プロセッサはそのようなリストに対して `<ol>` 要素を生成し、項目に 1 から連続的に番号を付けます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownIncorrectlyNumberedListItem",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 92,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownUnresolvedFileReference",
                "shortDescription": {
                  "text": "未解決のファイル参照"
                },
                "fullDescription": {
                  "text": "Markdown ファイルの未解決のファイル参照を報告します。",
                  "markdown": "Markdown ファイルの未解決のファイル参照を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownUnresolvedFileReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 92,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownUnresolvedHeaderReference",
                "shortDescription": {
                  "text": "未解決のヘッダー参照"
                },
                "fullDescription": {
                  "text": "Markdown ファイルにある未解決のヘッダー参照を報告します。",
                  "markdown": "Markdown ファイルにある未解決のヘッダー参照を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownUnresolvedHeaderReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 92,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.security.package-checker",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "MaliciousLibrariesLocal",
                "shortDescription": {
                  "text": "悪意のある依存関係"
                },
                "fullDescription": {
                  "text": "プロジェクトで宣言されている NPM および PyPI の悪意のある依存関係を報告します。 報告された問題を解決することで、攻撃者によるソフトウェアのセキュリティ侵害を防ぐことができます。 悪意のあるパッケージを除去すると、問題を解決できます。",
                  "markdown": "プロジェクトで宣言されている NPM および PyPI の悪意のある依存関係を報告します。\n\n報告された問題を解決することで、攻撃者によるソフトウェアのセキュリティ侵害を防ぐことができます。\n\n悪意のあるパッケージを除去すると、問題を解決できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MaliciousLibrariesLocal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "セキュリティ",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VulnerableCodeUsages",
                "shortDescription": {
                  "text": "脆弱な API の使用"
                },
                "fullDescription": {
                  "text": "インポートされている依存関係の脆弱性のある API が使用されていることを報告します。 報告された問題を解決することで、攻撃者によるソフトウェアのセキュリティ侵害を防ぐことができます。 問題を解決するため、脆弱性が解決されたバージョン (提供されている場合) に更新するか、脆弱性がない依存関係に切り替えることができます。",
                  "markdown": "インポートされている依存関係の脆弱性のある API が使用されていることを報告します。\n\n報告された問題を解決することで、攻撃者によるソフトウェアのセキュリティ侵害を防ぐことができます。\n\n問題を解決するため、脆弱性が解決されたバージョン (提供されている場合) に更新するか、脆弱性がない依存関係に切り替えることができます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VulnerableCodeUsages",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "セキュリティ",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VulnerableLibrariesGlobal",
                "shortDescription": {
                  "text": "脆弱なインポート済みの依存関係"
                },
                "fullDescription": {
                  "text": "プロジェクトにインポートされている Gradle と Maven の依存関係の脆弱性を報告します。 Gradle と Maven の依存関係の完全なリストは、外部ライブラリにあるプロジェクトツールウィンドウに表示されています。 報告された問題を解決することで、攻撃者によるソフトウェアのセキュリティ侵害を防ぐことができます。 問題を解決するため、脆弱性が解決されたバージョン (提供されている場合) に更新するか、脆弱性がない依存関係に切り替えることができます。 提供されるクイックフィックスにより、安全なバージョンに更新するか、ウェブサイトにアクセスして特定の脆弱性に関する詳細を参照することを提案される場合があります。",
                  "markdown": "プロジェクトにインポートされている Gradle と Maven の依存関係の脆弱性を報告します。\nGradle と Maven の依存関係の完全なリストは、外部ライブラリにあるプロジェクトツールウィンドウに表示されています。\n\n報告された問題を解決することで、攻撃者によるソフトウェアのセキュリティ侵害を防ぐことができます。\n\n問題を解決するため、脆弱性が解決されたバージョン (提供されている場合) に更新するか、脆弱性がない依存関係に切り替えることができます。\n\n提供されるクイックフィックスにより、安全なバージョンに更新するか、ウェブサイトにアクセスして特定の脆弱性に関する詳細を参照することを提案される場合があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VulnerableLibrariesGlobal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "セキュリティ",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VulnerableLibrariesLocal",
                "shortDescription": {
                  "text": "脆弱な宣言済みの依存関係"
                },
                "fullDescription": {
                  "text": "プロジェクトで宣言されている Gradle、Maven、NPM、および PyPI の依存関係の脆弱性を報告します。 Gradle と Maven の依存関係の完全なリストは、外部ライブラリにあるプロジェクトツールウィンドウに表示されています。 報告された問題を解決することで、攻撃者によるソフトウェアのセキュリティ侵害を防ぐことができます。 問題を解決するため、脆弱性が解決されたバージョン (提供されている場合) に更新するか、脆弱性がない依存関係に切り替えることができます。 提供されるクイックフィックスにより、安全なバージョンに更新するか、ウェブサイトにアクセスして特定の脆弱性に関する詳細を参照することを提案される場合があります。",
                  "markdown": "プロジェクトで宣言されている Gradle、Maven、NPM、および PyPI の依存関係の脆弱性を報告します。\nGradle と Maven の依存関係の完全なリストは、外部ライブラリにあるプロジェクトツールウィンドウに表示されています。\n\n報告された問題を解決することで、攻撃者によるソフトウェアのセキュリティ侵害を防ぐことができます。\n\n問題を解決するため、脆弱性が解決されたバージョン (提供されている場合) に更新するか、脆弱性がない依存関係に切り替えることができます。\n\n提供されるクイックフィックスにより、安全なバージョンに更新するか、ウェブサイトにアクセスして特定の脆弱性に関する詳細を参照することを提案される場合があります。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VulnerableLibrariesLocal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "セキュリティ",
                      "index": 95,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.modules.json",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "Json5StandardCompliance",
                "shortDescription": {
                  "text": "JSON5 標準に準拠"
                },
                "fullDescription": {
                  "text": "JSON5 ファイルの言語仕様との矛盾を報告します。",
                  "markdown": "JSON5 ファイルの[言語仕様](http://json5.org)との矛盾を報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "Json5StandardCompliance",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON および JSON5",
                      "index": 106,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonSchemaCompliance",
                "shortDescription": {
                  "text": "JSON スキーマに準拠"
                },
                "fullDescription": {
                  "text": "JSON ファイルとそれに割り当てられている JSON スキーマの矛盾を報告します。",
                  "markdown": "JSON ファイルとそれに割り当てられている [JSON スキーマ](https://json-schema.org)の矛盾を報告します。  "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JsonSchemaCompliance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON および JSON5",
                      "index": 106,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonStandardCompliance",
                "shortDescription": {
                  "text": "JSON 標準に準拠"
                },
                "fullDescription": {
                  "text": "JSON ファイルにある、次のような言語仕様との矛盾を報告します。 行またはブロックコメント (構成可能) 複数のトップレベルの値 (JSON Lines ファイルを除き、構成可能) オブジェクトまたは配列にある末尾のコンマ (構成可能) シングルクォート文字列 プロパティキーがダブルクォート文字列でない 浮動小数点リテラルとしての NaN または Infinity/-Infinity の数値 (構成可能)",
                  "markdown": "JSON ファイルにある、次のような[言語仕様](https://tools.ietf.org/html/rfc7159)との矛盾を報告します。\n\n* 行またはブロックコメント (構成可能)\n* 複数のトップレベルの値 (JSON Lines ファイルを除き、構成可能)\n* オブジェクトまたは配列にある末尾のコンマ (構成可能)\n* シングルクォート文字列\n* プロパティキーがダブルクォート文字列でない\n* 浮動小数点リテラルとしての NaN または Infinity/-Infinity の数値 (構成可能)"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JsonStandardCompliance",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON および JSON5",
                      "index": 106,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonSchemaDeprecation",
                "shortDescription": {
                  "text": "非推奨の JSON プロパティ"
                },
                "fullDescription": {
                  "text": "JSON ファイルにある非推奨のプロパティを報告します。 非推奨の仕組みはまだ JSON スキーマの仕様で定義されていないため、このインスペクションには非標準の拡張機能「deprecationMessage」が使用されていることに注意してください。",
                  "markdown": "JSON ファイルにある非推奨のプロパティを報告します。  \n非推奨の仕組みはまだ JSON スキーマの仕様で定義されていないため、このインスペクションには非標準の拡張機能「deprecationMessage」が使用されていることに注意してください。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JsonSchemaDeprecation",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON および JSON5",
                      "index": 106,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonSchemaRefReference",
                "shortDescription": {
                  "text": "未解決の '$ref' および '$schema' 参照"
                },
                "fullDescription": {
                  "text": "JSON スキーマにある未解決の '$ref' または '$schema' パスを報告します。",
                  "markdown": "JSON スキーマにある未解決の `$ref` または `$schema` パスを報告します。  "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JsonSchemaRefReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON および JSON5",
                      "index": 106,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonDuplicatePropertyKeys",
                "shortDescription": {
                  "text": "オブジェクトリテラル内の重複キー"
                },
                "fullDescription": {
                  "text": "オブジェクトリテラル内の重複しているキーを報告します。",
                  "markdown": "オブジェクトリテラル内の重複しているキーを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JsonDuplicatePropertyKeys",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Reliability"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON および JSON5",
                      "index": 106,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "tanvd.grazi",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "LanguageDetectionInspection",
                "shortDescription": {
                  "text": "自然言語の検出"
                },
                "fullDescription": {
                  "text": "自然言語を検出し、対応する文法およびスペルチェックを有効化することを提案します。",
                  "markdown": "自然言語を検出し、対応する文法およびスペルチェックを有効化することを提案します。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LanguageDetectionInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "校正",
                      "index": 89,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "GrazieInspection",
                "shortDescription": {
                  "text": "文法"
                },
                "fullDescription": {
                  "text": "テキスト内の文法ミスを報告します。 このインスペクションは「設定 | エディター | 自然言語 | 文法とスタイル」で構成できます。",
                  "markdown": "テキスト内の文法ミスを報告します。 このインスペクションは「[設定 \\| エディター \\| 自然言語 \\| 文法とスタイル](settings://reference.settingsdialog.project.grazie)」で構成できます。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "GrazieInspection",
                    "ideaSeverity": "GRAMMAR_ERROR",
                    "qodanaSeverity": "Info",
                    "codeQualityCategory": "Code Style"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "校正",
                      "index": 89,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.toml.lang",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "TomlUnresolvedReference",
                "shortDescription": {
                  "text": "未解決の参照"
                },
                "fullDescription": {
                  "text": "TOML ファイルに未解決の参照があることを報告します。",
                  "markdown": "TOML ファイルに未解決の参照があることを報告します。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TomlUnresolvedReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Sanity"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "TOML",
                      "index": 115,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.android.tools.gradle.dcl",
            "version": "243.26053.27",
            "rules": [
              {
                "id": "DeclarativeUnresolvedReference",
                "shortDescription": {
                  "text": "未解決の参照があります"
                },
                "fullDescription": {
                  "text": "No description available",
                  "markdown": "No description available"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeclarativeUnresolvedReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High",
                    "codeQualityCategory": "Unspecified"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Declarative Gradle",
                      "index": 131,
                      "toolComponent": {
                        "name": "IC"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          }
        ]
      },
      "invocations": [
        {
          "startTimeUtc": "2025-04-02T08:03:51.9563568Z",
          "exitCode": 0,
          "executionSuccessful": true
        }
      ],
      "language": "en-US",
      "versionControlProvenance": [
        {
          "properties": {
            "repoUrl": "",
            "vcsType": "Git"
          }
        }
      ],
      "results": [],
      "automationDetails": {
        "id": "ForgeIntroduction1.21/qodana/2025-04-02",
        "guid": "ababe720-d9e6-4558-b04d-d886bd900f68",
        "properties": {
          "jobUrl": "",
          "analysisKind": "ide"
        }
      },
      "newlineSequences": [
        "\r\n",
        "\n"
      ],
      "properties": {
        "configProfile": "starter",
        "deviceId": "3103251de2a5302-8be7-45ba-9977-623365045218",
        "qodanaNewResultSummary": {
          "high": 21,
          "moderate": 1,
          "total": 22
        }
      }
    }
  ],
  "properties": {
    "runTimestamp": "1743581036180"
  }
}